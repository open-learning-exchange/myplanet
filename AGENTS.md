# Instructions

*   **Realm Model Primary Keys:** Realm model primary keys are directly named (e.g., `id`). This field should be used for item comparisons in `DiffUtil.ItemCallback`'s `areItemsTheSame` method.
*   **TeamPageConfig Registry:** The `TeamPageConfig` sealed class (`org.ole.planet.myplanet.ui.teams`) acts as the registry for Team module tabs, defining the mapping between tab types (e.g., 'PLAN', 'MISSION') and their corresponding Fragment instances via the `createFragment()` method.
*   **BaseDashboardFragment Hierarchy:** `BaseDashboardFragment` inherits from `BaseDashboardFragmentPlugin`, which in turn inherits from `BaseContainerFragment`.
*   **Naming Conventions:** Adapter, Fragment, and ViewHolder classes should use plural forms for the concepts they manage (e.g., `TeamsTasksAdapter`, `TeamsTasksFragment`, `TeamsPlanFragment`).
*   **Repository Injections:** Repositories may inject other repository interfaces into their implementation (e.g., `SubmissionsRepository` into `SurveysRepositoryImpl`) to reuse logic, provided no circular dependencies are introduced.
*   **Nullable Lateinit Listeners:** When dealing with nullable `lateinit` listeners that are passed to constructors (e.g., `OnHomeItemClickListener`), the constructor should accept a nullable type, and the listener should be invoked with a null-safe call (`?.let{...}`) to prevent crashes if it's not initialized at the time of use.
*   **CommunityPagerAdapter:** The `CommunityPagerAdapter` (`org.ole.planet.myplanet.ui.community`) manages fragments for the community section, including `VoicesFragment`, `CommunityServicesFragment`, `TeamCalendarFragment`, and `EnterprisesFinancesFragment`.
*   **Hilt Internal Injection:** When injecting an `internal` type (like a domain helper) into the constructor of a `public` class (like a Repository implementation) using Hilt, the constructor itself must be marked `internal` to avoid compilation errors regarding visibility exposure.
*   **Base Fragment Locations:** The base fragments `BaseDashboardFragment`, `BaseTeamFragment`, and `BaseVoicesFragment` are located in the `org.ole.planet.myplanet.ui.base` package.
*   **Hilt/Kapt Imports:** Hilt's annotation processor (`kapt`) requires explicit `import` statements for injected types. The build may fail with 'could not be resolved' errors if the import is missing, even if the Kotlin compiler can infer the type.
*   **View Visibility Logic:** In UI components like `RecyclerView.Adapter`, logic for setting a view's visibility should be co-located and consistent with the logic for setting its click listeners to avoid state mismatches.
*   **CoursesFragment Inheritance:** `CoursesFragment` inherits from `BaseRecyclerFragment<RealmMyCourse?>` and implements `OnCourseItemSelectedListener`, `OnTagClickListener`, and `RealtimeSyncMixin`.
*   **Targeted Compilation:** To verify compilation changes without running a full build (which often times out), use targeted commands like `./gradlew :app:compileLiteDebugKotlin`, `./gradlew :app:kspDefaultDebugKotlin`, or `./gradlew :app:compileDefaultDebugKotlin`. These check for syntax and annotation processing errors efficiently.
*   **Refactoring Static Utilities:** Static utility methods located in UI component companion objects (e.g., `Fragment.Companion`) should be refactored into instance methods on an injectable repository or service class.
*   **Realm Object Updates:** To update a Realm object in a repository, the method should accept the object's primary key. The implementation must then fetch the *managed* instance of the object within the Realm transaction before applying modifications.
*   **Hilt Base Class Injection:** When using Hilt, if a dependency is required by a base class and its subclasses, it should be injected (`@Inject`) only in the base class. Subclasses will inherit the dependency, and injecting it again in a subclass will cause a compilation error.
*   **Realm & Suspend Functions:** When invoking a `suspend` function that relies on data from Realm but performs operations (like network calls) independent of the transaction, fetch the necessary data within `databaseService.withRealm`, return it, and then invoke the `suspend` function outside the `withRealm` block within a `CoroutineScope`. This prevents suspension errors and avoids holding Realm transactions open unnecessarily.
*   **Adding Dependencies:** When a class is refactored to require a new constructor dependency (e.g., adding `DataService` to `ResourcesRepositoryImpl`'s constructor), Hilt must be taught how to provide this new dependency, typically by creating a new Hilt module with a `@Provides` function.
*   **Logging:** For logging, use the standard Android `Log` class (e.g., `Log.e(...)`). Do not assume custom logging methods exist in utility classes like `Utilities`.
*   **Listener Interfaces:** Listener interfaces (whether for Adapters, Fragments, or other components) must be extracted to standalone files in the `org.ole.planet.myplanet.callback` package (avoiding inner interfaces) and follow the naming convention `On[Event]Listener` (e.g., `OnFeedbackSubmittedListener`, `OnMemberActionListener`).
*   **Running Tests:** The command `./gradlew testDefaultDebugUnitTest` is used to run the debug unit tests.
*   **Hilt Verification:** Successful execution of the `ksp[Flavor]Kotlin` task (e.g., `kspDefaultDebugKotlin`) confirms that generated code for Hilt dependency injection and ViewBinding/DataBinding is valid. This serves as a quick verification step compared to full compilation.
*   **Frontend Verification:** The `frontend_verification_instructions` tool is designed for web applications (Playwright) and is not suitable for verifying Android UI changes in this repository.
*   **Activity Hierarchy:** `DashboardActivity` inherits from `DashboardElementActivity`, which inherits from `SyncActivity`, which in turn inherits from `ProcessUserDataActivity`. This hierarchy requires careful handling of Hilt injections.
*   **Repo to UI Threading:** To prevent `IllegalStateException` crashes when passing Realm objects from a repository (on a background thread) to a UI component (on the main thread), repository methods must return unmanaged copies of the objects using `realm.copyFromRealm()`.
*   **Coroutine Scopes:** Avoid creating unmanaged `CoroutineScope`s in classes with a lifecycle shorter than the application's (e.g., UI helpers). Instead, pass a lifecycle-aware scope (like a Fragment's `viewLifecycleOwner.lifecycleScope`) as a parameter to functions that need to launch coroutines to prevent memory leaks.
*   **Source Sets:** The `app/src` directory contains `main` and `lite` source sets but notably lacks standard `test` or `androidTest` directories, indicating unit tests may be missing or structured non-standardly in this repository.
*   **Launch Exception Handling:** When handling exceptions in a coroutine launched with `launch`, the `try-catch-finally` block must be placed *inside* the lambda passed to `launch`.
*   **Realm Relationships:** When creating a new Realm object that has a relationship with an existing object (e.g., a reply belonging to a user), the existing object must be a *managed* instance within the current Realm transaction. Passing a detached object (e.g., from `copyFromRealm` or the UI layer) will cause the relationship to fail to persist, often silently.
*   **RealmNews Model:** The `RealmNews` model is used to represent both original 'news' items and their 'replies'.
*   **Nullable Listeners:** In Kotlin, if a function parameter is nullable (e.g., `listener: OnSuccessListener?`) but has no default value, an argument must be passed explicitly. To pass no listener, use `functionName(null)`, not `functionName()`.
*   **Repository Collections:** Repository method signatures should accept standard Kotlin collection types (e.g., `List<String>`) instead of Realm-specific types like `RealmList<String>`. The calling layer (e.g., ViewModel or UI helper) is responsible for converting Realm-specific collections to standard collections (e.g., using `.toList()`) before passing them to the repository.
*   **Atomic Transactions:** When a single UI action requires updating multiple, distinct database objects, the repository method should accept all of these objects to ensure they are saved within a single, atomic transaction.
*   **Hilt Overrides:** When a subclass needs to override a Hilt-injected property from its superclass, the property in the superclass must be marked with the `open` keyword, and the property in the subclass must be marked with `override`.
*   **Git Merge Diffs:** When `replace_with_git_merge_diff` fails repeatedly due to incorrect search blocks, a reliable alternative is to read the file's content into a bash variable, perform a string replacement using `${VAR//search/replace}`, and then write the variable's content back to the file.
*   **Data Models:** Data models (e.g., `OnboardingItem`) should reside in the `org.ole.planet.myplanet.model` package. This package contains both Realm database entities (prefixed with `Realm`) and standard non-persisted data models.
*   **Lateinit Access:** To prevent `kotlin.UninitializedPropertyAccessException` in `lateinit` properties (e.g., RecyclerView adapters), ensure all view and property initializations are complete before attaching observers (like StateFlow collectors) that might access those properties.
*   **Utilities Package:** The package `org.ole.planet.myplanet.utilities` has been renamed to `org.ole.planet.myplanet.utils`. All utility classes (e.g., `Utilities.kt`, `Constants.kt`, `FileUtils.kt`) and `NotificationActionReceiver` are now located in this package.
*   **TeamPagerAdapter:** In `TeamPagerAdapter`, interaction listeners (e.g., `OnTeamUpdateListener`) are assigned to fragments explicitly within the adapter by checking the fragment's type (e.g., `if (fragment is TeamsPlanFragment)`).
*   **Renaming Components:** Renaming an Android component like a Fragment also requires renaming its corresponding XML layout file and updating all references, including the `tools:context` attribute in the layout file and any instantiation points in configuration files (e.g., `TeamPageConfig.kt`) or PagerAdapters.
*   **Implicit References:** When refactoring classes to a subpackage, existing code in the parent package that accessed them without imports will break. Tools like `grep` searching only for explicit import statements will fail to identify these files, so implicit references in the parent package must be manually verified.
*   **Data Flow:** Future data operations in the `ProcessUserDataActivity` flow must be routed through `UploadManager` or `UserRepository`, avoiding direct interactions with `DatabaseService`.
*   **Manifest Updates:** Modifications to the Android Manifest (e.g., updating package names for Receivers or Activities) must be applied to both `app/src/main/AndroidManifest.xml` and `app/src/lite/AndroidManifest.xml` to avoid build inconsistencies across flavors.
*   **Suspend Functions:** When refactoring a method to be a `suspend` function, verify that all call sites are within a `CoroutineScope`. Non-lifecycle-aware classes like `Application` cannot directly call `suspend` functions, so the method may need to remain a standard function using callbacks to maintain compatibility.
*   **Clean Build:** If a Gradle build fails with an unexpected error (like databinding issues) after code changes, running `./gradlew clean` before retrying the build can resolve the issue.
*   **XML Renaming:** When renaming an Android XML layout file (e.g., `fragment_old_name.xml` to `fragment_new_name.xml`), the associated auto-generated Data Binding class name also changes (e.g., `FragmentOldNameBinding` to `FragmentNewNameBinding`). Code referencing the old binding class must be updated to avoid compilation errors.
*   **Verification Strategy:** Due to frequent compilation timeouts in the environment (e.g., with `assembleLiteDebug`), verification of refactoring should rely on rigorous text search (like `grep` excluding build dirs) to ensure all references are updated.
*   **Viewer Package:** The package `org.ole.planet.myplanet.ui.reader` has been renamed to `org.ole.planet.myplanet.ui.viewer`. Content viewing activities (e.g., `PDFReaderActivity`, `VideoViewerActivity`, `ImageViewerActivity`, `AudioPlayerActivity`, `CSVViewerActivity`, `MarkdownViewerActivity`, `TextFileViewerActivity`, `WebViewActivity`) are now located in this package.
*   **Helper Refactoring:** Static helper classes or Kotlin `object`s that contain business or data logic (e.g., `VoicesActions`) should be refactored into injectable classes to improve testability and adhere to dependency injection principles.
*   **DataService Singleton:** The `DataService` class is configured as a Singleton in `DataServiceModule` (`@InstallIn(SingletonComponent::class)`), utilizing `@ApplicationContext`. This enables its injection into Repositories and other Singleton-scoped components.
*   **API Package:** `ApiClient`, `ApiInterface`, and `ChatApiService` are now located in the `org.ole.planet.myplanet.data.api` package.
*   **Exam Saving:** When saving data in `AddExaminationActivity`, the `isSaved` boolean must be set to `true` (e.g., via `finishActivity()`) to bypass the "Do you want to cancel?" dialog in `finish()`.
*   **User Encryption:** `UserRepository` exposes `initUserEncryptionKeys(userId: String)` to generate and save encryption parameters (Key and IV) for a user if they are null, within a Realm transaction.
*   **Health Repository:** `HealthRepository` manages `RealmHealthExamination` data, providing suspending functions to fetch detached objects via `copyFromRealm` and save data using `DatabaseService`.
*   **ListAdapter & Realm:** When using `ListAdapter` with Realm objects (as seen in `ResourcesAdapter`), the data must be detached using `copyFromRealm` before calling `submitList` to avoid `Realm access from incorrect thread` exceptions during background diff calculation.
*   **Nullable SAM:** In `ResourcesAdapter`, the nullable `onComplete` callback passed to `submitList` requires explicit wrapping as a `Runnable` (e.g., `Runnable { onComplete() }`) due to Kotlin's lack of automatic SAM conversion for nullable function types to nullable Java interfaces.
*   **Courses Adapter:** The `CoursesAdapter` (`org.ole.planet.myplanet.ui.courses`) extends `ListAdapter<RealmMyCourse, RecyclerView.ViewHolder>`. It handles external data updates (ratings/progress maps) by triggering `notifyItemRangeChanged` with payloads inside the `submitList` commit callback, avoiding wrapper classes.
*   **Type Safety:** `CoursesFragment` filters its Realm results using `filterIsInstance<RealmMyCourse>()` to ensure type safety and pass a non-nullable `List<RealmMyCourse>` to `CoursesAdapter.submitList`.
*   **Binding Position:** In `ListAdapter` implementations (like `CoursesAdapter`), `holder.bindingAdapterPosition` must be used in click listeners to ensure the correct list index is accessed, as the bound `position` parameter may become stale.
*   **LifeFragment Async:** In `LifeFragment`, asynchronous data refreshes (e.g., `refreshList`) use `viewLifecycleOwner.lifecycleScope` and include a `view == null` check to prevent execution if the view has been destroyed.
*   **LifeRepository Filtering:** `LifeRepository.getMyLifeByUserId` returns a list of detached `RealmMyLife` objects filtered by `isVisible = true` and sorted by `weight`.
*   **TeamCoursesAdapter:** `TeamCoursesAdapter` constructor accepts a `teamCreator` string instead of a `Realm` instance. `TeamCoursesFragment` obtains this value from the `RealmMyTeam` object provided by `BaseTeamFragment`.
*   **Courses Fetching:** `CoursesRepository` provides a `getByIds(courseIds: List<String>)` function to fetch a list of `RealmMyCourse` objects based on a list of IDs.
*   **Reactive Courses:** In `TeamCoursesFragment`, course data is fetched reactively by observing `BaseTeamFragment.teamFlow` and querying the `CoursesRepository` with the IDs found in `RealmMyTeam.courses`.
*   **CallbackFlow Safety:** In `RealmRepository`, `callbackFlow` implementations must wrap Realm operations in a `try-catch` block, check `!realm.isClosed` and `!realm.isInTransaction` inside listeners, and perform cleanup (listener removal then `realm.close()`) within `awaitClose`.
*   **Submissions Logic:** `SubmissionsRepository` includes `getSubmissionForExam` to retrieve pending submissions and `createSubmission` to handle the logic of creating new submissions (returning a detached object), including linking team information within a Realm transaction.
*   **Exam Refactoring:** When refactoring `ExamTakingFragment` to use `SubmissionsRepository.createSubmission`, the fragment must call `mRealm.refresh()` and re-fetch the submission by ID to obtain a managed `RealmSubmission` required for legacy view logic.
*   **Background Filtering:** When filtering Realm objects in background coroutines (e.g., in `CoursesFragment`), it is necessary to verify if the returned list contains managed objects (`RealmObject.isManaged`) and detach them using `realm.copyFromRealm` within the background context before passing them to the UI.
*   **Exam Async Save:** `ExamTakingFragment` orchestrates asynchronous answer saving by launching coroutines in `lifecycleScope` for navigation buttons (awaiting completion) and `onDestroyView` (fire-and-forget), while handling save errors via UI Toasts.
*   **Exam Save Function:** `ExamSubmissionUtils.saveAnswer` has been refactored to a `suspend` function returning `Result<Boolean>`, internally managing `Realm.getDefaultInstance()` on `Dispatchers.IO`, and takes IDs/primitives as arguments to avoid threading issues.
*   **Team Exams:** `TeamsRepository` includes `getTeamForExam(teamId)` to retrieve a `RealmMyTeam` object by its ID, specifically for use in exam contexts.
*   **Team Metadata:** `TeamsRepository` includes `getAllActiveTeams()` to retrieve active top-level teams, `getJoinedMembers(teamId)` to retrieve member lists, and `getTeamCreator(teamId)` to retrieve the creator's ID.
*   **Health Check:** `ConfigurationsRepository.checkHealth()` is a `suspend` function returning `Result<Boolean>`, utilizing `Dispatchers.IO` for network calls and replacing `OnSuccessListener`.
*   **Worker Injection:** `RepositoryEntryPoint` exposes `configurationsRepository()` to allow manual dependency injection in `AutoSyncWorker` via `EntryPointAccessors`.
*   **Health Service Removal:** The `healthAccess` method has been removed from `DataService`, consolidating health check logic into `ConfigurationsRepository`.
*   **Worker Async:** `AutoSyncWorker` uses `workerScope.launch` to asynchronously execute `checkHealth` and `uploadHealth` despite extending the synchronous `Worker` class, returning `Result.success()` immediately (fire-and-forget).
*   **Resource Open Check:** `ResourcesRepository.isResourceOpened(resourceId: String)` is a `suspend` function that queries `RealmResourceActivity` internally, removing the dependency on an external `Realm` instance.
*   **Survey DiffUtil:** `SurveyAdapter` (`org.ole.planet.myplanet.ui.surveys`) uses `DiffUtils.itemCallback` for its `ListAdapter` implementation and no longer contains the `SurveyDiffCallback` inner class.
*   **DiffUtils Helper:** The utility object `DiffUtils` (`org.ole.planet.myplanet.utilities`) provides an `itemCallback` helper function to generate `DiffUtil.ItemCallback` implementations using lambdas.
*   **Utilities Package Name:** The package `org.ole.planet.myplanet.utilities` contains utility classes like `DiffUtils`, `Utilities`, `Constants`, and `FileUtils`. This package has NOT been renamed to `utils`.
*   **Resource Activity User:** In `RealmResourceActivity`, the `user` field stores the user's name (String), not their unique ID (UUID). Filtering by user requires resolving the name from `RealmUserModel` first.
*   **Resource Observation:** `ResourcesRepository` now handles the retrieval and observation of opened resource IDs via `getOpenedResourceIds` and `observeOpenedResourceIds`, decoupling `ResourcesFragment` from direct `RealmResourceActivity` queries.
*   **ResourcesFragment Type Safety:** `ResourcesFragment` filters its Realm results using `filterIsInstance<RealmMyLibrary>()` to ensure a non-nullable `List<RealmMyLibrary>` is passed to `ResourcesAdapter.submitList`.
*   **ResourcesAdapter ListAdapter:** `ResourcesAdapter` has been refactored to extend `ListAdapter`, replacing manual diff calculation logic with `DiffUtil`. It requires `submitList` to receive data updates and no longer accepts an initial list in its constructor.
*   **User Existence Checks:** `UserRepository` provides `isEmpty()` (checks if the Realm file is empty) and `hasAnyUser()` (checks for existence of any `RealmUserModel`), which replace direct Realm checks in `SyncActivity`.
*   **Async Sync Check:** In `SyncActivity.onSyncComplete`, the `lifecycleScope.launch(Dispatchers.IO)` coroutine is used to asynchronously poll the `UserRepository.hasAnyUser()` method to check for user data presence.
*   **Sync Auth Blocking:** `SyncActivity.authenticateUser` uses `runBlocking` to invoke suspending `UserRepository` methods (like `getUserByName` and `isEmpty`) while satisfying the synchronous boolean return signature required by `AuthUtils.login`.
*   **Detached User:** The `UserRepository.getUserByName(name: String)` method returns a detached `RealmUserModel?` object, allowing `LoginActivity` (and other UI components) to perform login lookups directly within a coroutine without managing Realm instances.
*   **Auth Logic Move:** The `checkName` authentication logic (including Realm queries and password verification via `AndroidDecrypter`) has been moved from `SyncActivity` to `UserRepositoryImpl.authenticateUser`, which returns a detached `RealmUserModel` or null.
*   **Transaction Managers:** `TransactionSyncManager` methods (e.g., `syncAllHealthData`, `syncKeyIv`) create and manage their own local `Realm` instances using `Realm.getDefaultInstance()` and `executeTransactionAsync`, removing the requirement for callers to pass an open Realm instance.
*   **User Profile Access:** `UserRepository` provides `getUserProfile()` (returning a detached `RealmUserModel?`) and `getUserImageUrl()` (returning `String?`) to allow the UI layer to access user data without direct Realm interactions.
*   **Survey Lookup:** The `SurveysRepository` includes a `getSurveyByName(name: String)` method to fetch `RealmStepExam` objects by their `name` field.
*   **Dashboard Navigation:** In `DashboardActivity`, the navigation logic uses `SurveysRepository.getSurveyByName(surveyId)` to locate a survey. The `surveyId` parameter corresponds to the `name` field of `RealmStepExam`, not its primary key.
*   **Realm Threading Pattern:** To resolve threading conflicts when needing `suspend` calls (like those in `UserSessionManager`) based on Realm data, an effective pattern is to fetch and copy data into an intermediate structure (e.g., `IntermediateMemberData`) within a `withRealm` block, close the block, and then execute the suspend functions using the detached data.
*   **Activities Repository:** `ActivitiesRepository` is a new repository responsible for logging login/logout/resource-open events and retrieving activity data (e.g., `getOfflineVisits`, `getLastVisit`), effectively decoupling this logic from `UserSessionManager`.
*   **Async Member Details:** `VoicesActions.showMemberDetails` is a `suspend` function that accepts `UserSessionManager` to asynchronously fetch profile data (like offline visits) before instantiating the `MembersDetailFragment`.
*   **Async Reads:** Read operations in `UserSessionManager` (e.g., `getOfflineVisits`, `getLastVisit`) are now `suspend` functions. Callers (like ViewModels) must handle these asynchronously, typically using `StateFlow` and `viewModelScope`.
*   **Offline Visits:** `ActivitiesRepository` is the designated repository for accessing `RealmOfflineActivity` data, including calculating offline visit counts via `getOfflineVisitCount`.
*   **ViewModel Migration:** When migrating synchronous data access in `UserSessionManager` to asynchronous Repository calls, ViewModels (e.g., `UserProfileViewModel`) should expose the data via `StateFlow` and populate it using `viewModelScope.launch`.
*   **QueryList Helper:** The `RealmRepository` base class provides a `queryList` function that accepts a query builder lambda and returns a list of detached objects using `copyFromRealm`. This function is useful for returning safe copies to the UI thread.
*   **LifeFragment Location:** `LifeFragment` is located in `org.ole.planet.myplanet.ui.life` and manages the display of user life goals and activities.
*   **RealmOfflineActivity Fields:** The `RealmOfflineActivity` model contains both `userId` and `userName` fields; `ActivitiesRepository` utilizes `userId` for filtering offline visit counts.