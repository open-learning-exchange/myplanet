--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/AutoSyncWorker.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.app.ActivityManager
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import androidx.core.content.edit
import androidx.work.Worker
import androidx.work.WorkerParameters
import dagger.hilt.android.EntryPointAccessors
import java.util.Date
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.datamanager.Service.CheckVersionCallback
import org.ole.planet.myplanet.di.AutoSyncEntryPoint
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.ui.sync.LoginActivity
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DialogUtils.startDownloadUpdate
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities

class AutoSyncWorker(
    private val context: Context,
    workerParams: WorkerParameters
) : Worker(context, workerParams), SyncListener, CheckVersionCallback, SuccessListener {
    private lateinit var preferences: SharedPreferences
    private lateinit var syncManager: SyncManager
    private lateinit var uploadManager: UploadManager
    private lateinit var uploadToShelfService: UploadToShelfService
    private val backgroundExecutor: ExecutorService = Executors.newSingleThreadExecutor()

    override fun doWork(): Result {
        preferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

        val entryPoint = EntryPointAccessors.fromApplication(context, AutoSyncEntryPoint::class.java)
        syncManager = entryPoint.syncManager()
        uploadManager = entryPoint.uploadManager()
        uploadToShelfService = entryPoint.uploadToShelfService()
        val lastSync = preferences.getLong("LastSync", 0)
        val currentTime = System.currentTimeMillis()
        val syncInterval = preferences.getInt("autoSyncInterval", 60 * 60)
        if (currentTime - lastSync > syncInterval * 1000) {
            if (isAppInForeground(context)) {
                Utilities.toast(context, "Syncing started...")
            }
            Service(context).checkVersion(this, preferences)
        }
        return Result.success()
    }

    override fun onSyncStarted() {}

    override fun onSyncComplete() {}

    override fun onSyncFailed(msg: String?) {
        if (MainApplication.syncFailedCount > 3) {
            context.startActivity(Intent(context, LoginActivity::class.java)
                .putExtra("showWifiDialog", true)
                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK))
        }
    }

    override fun onUpdateAvailable(info: MyPlanet?, cancelable: Boolean) {
        startDownloadUpdate(context, UrlUtils.getApkUpdateUrl(info?.localapkpath), null)
    }

    override fun onCheckingVersion() {}
    override fun onError(msg: String, blockSync: Boolean) {
        if (!blockSync) {
            syncManager.start(this, "upload")
            uploadToShelfService.uploadUserData {
                Service(MainApplication.context).healthAccess {
                    uploadToShelfService.uploadHealth()
                }
            }
            if (!MainApplication.isSyncRunning) {
                MainApplication.isSyncRunning = true
                backgroundExecutor.execute {
                    uploadManager.uploadExamResult(this@AutoSyncWorker)
                    uploadManager.uploadFeedback(this@AutoSyncWorker)
                    uploadManager.uploadAchievement()
                    uploadManager.uploadResourceActivities("")
                    uploadManager.uploadUserActivities(this@AutoSyncWorker)
                    uploadManager.uploadCourseActivities()
                    uploadManager.uploadSearchActivity()
                    uploadManager.uploadRating()
                    uploadManager.uploadResource(this@AutoSyncWorker)
                    uploadManager.uploadNews()
                    uploadManager.uploadTeams()
                    uploadManager.uploadTeamTask()
                    uploadManager.uploadMeetups()
                    uploadManager.uploadCrashLog()
                    uploadManager.uploadSubmissions()
                    uploadManager.uploadActivities { MainApplication.isSyncRunning = false }
                }
            }
        }
    }

    override fun onSuccess(success: String?) {
        val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        settings.edit { putLong("lastUsageUploaded", Date().time) }
    }

    override fun onStopped() {
        super.onStopped()
        backgroundExecutor.shutdown()
    }

    private fun isAppInForeground(context: Context): Boolean {
        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val runningProcesses = activityManager.runningAppProcesses ?: return false

        for (processInfo in runningProcesses) {
            if (processInfo.processName == context.packageName &&
                processInfo.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
                return true
            }
        }
        return false
    }
}
=======
package org.ole.planet.myplanet.service


import android.app.ActivityManager
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import androidx.core.content.edit
import androidx.work.Worker
import androidx.work.WorkerParameters
import dagger.hilt.android.EntryPointAccessors
import java.util.Date
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.datamanager.Service.CheckVersionCallback
import org.ole.planet.myplanet.di.AutoSyncEntryPoint
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.ui.sync.LoginActivity
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DialogUtils.startDownloadUpdate
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities

class AutoSyncWorker(
    private val context: Context,
    workerParams: WorkerParameters
) : Worker(context, workerParams), SyncListener, CheckVersionCallback, SuccessListener {
    private lateinit var preferences: SharedPreferences
    private lateinit var syncManager: SyncManager
    private lateinit var uploadManager: UploadManager
    private lateinit var uploadToShelfService: UploadToShelfService
    private val backgroundExecutor: ExecutorService = Executors.newSingleThreadExecutor()

    override fun doWork(): Result {
        preferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

        val entryPoint = EntryPointAccessors.fromApplication(context, AutoSyncEntryPoint::class.java)
        syncManager = entryPoint.syncManager()
        uploadManager = entryPoint.uploadManager()
        uploadToShelfService = entryPoint.uploadToShelfService()
        val lastSync = preferences.getLong("LastSync", 0)
        val currentTime = System.currentTimeMillis()
        val syncInterval = preferences.getInt("autoSyncInterval", 60 * 60)
        if (currentTime - lastSync > syncInterval * 1000) {
            if (isAppInForeground(context)) {
                Utilities.toast(context, "Syncing started...")
            }
            Service(context).checkVersion(this, preferences)
        }
        return Result.success()
    }

    override fun onSyncStarted() {}

    override fun onSyncComplete() {}

    override fun onSyncFailed(msg: String?) {
        if (MainApplication.syncFailedCount > 3) {
            context.startActivity(Intent(context, LoginActivity::class.java)
                .putExtra("showWifiDialog", true)
                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK))
        }
    }

    override fun onUpdateAvailable(info: MyPlanet?, cancelable: Boolean) {
        startDownloadUpdate(context, UrlUtils.getApkUpdateUrl(info?.localapkpath), null)
    }

    override fun onCheckingVersion() {}
    override fun onError(msg: String, blockSync: Boolean) {
        if (!blockSync) {
            syncManager.start(this, "upload")
            uploadToShelfService.uploadUserData {
                Service(MainApplication.context).healthAccess {
                    uploadToShelfService.uploadHealth()
                }
            }
            if (!MainApplication.isSyncRunning) {
                MainApplication.isSyncRunning = true
                backgroundExecutor.execute {
                    uploadManager.uploadExamResult(this@AutoSyncWorker)
                    uploadManager.uploadFeedback(this@AutoSyncWorker)
                    uploadManager.uploadAchievement()
                    uploadManager.uploadResourceActivities("")
                    uploadManager.uploadUserActivities(this@AutoSyncWorker)
                    uploadManager.uploadCourseActivities()
                    uploadManager.uploadSearchActivity()
                    uploadManager.uploadRating()
                    uploadManager.uploadResource(this@AutoSyncWorker)
                    uploadManager.uploadNews()
                    uploadManager.uploadTeams()
                    uploadManager.uploadTeamTask()
                    uploadManager.uploadMeetups()
                    uploadManager.uploadCrashLog()
                    uploadManager.uploadSubmissions()
                    uploadManager.uploadActivities { MainApplication.isSyncRunning = false }
                }
            }
        }
    }

    override fun onSuccess(success: String?) {
        val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        settings.edit { putLong("lastUsageUploaded", Date().time) }
    }

    override fun onStopped() {
        super.onStopped()
        backgroundExecutor.shutdown()
    }

    private fun isAppInForeground(context: Context): Boolean {
        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val runningProcesses = activityManager.runningAppProcesses ?: return false

        for (processInfo in runningProcesses) {
            if (processInfo.processName == context.packageName &&
                processInfo.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
                return true
            }
        }
        return false
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/AudioRecorderService.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.Manifest
import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.media.MediaRecorder
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.provider.Settings
import androidx.activity.result.ActivityResultCaller
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.core.app.ActivityCompat.shouldShowRequestPermissionRationale
import androidx.core.content.ContextCompat
import java.io.File
import java.util.UUID
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.utilities.Utilities

class AudioRecorderService {
    private var outputFile: String? = null
    private var myAudioRecorder: MediaRecorder? = null
    private var audioRecordListener: AudioRecordListener? = null
    private var caller: ActivityResultCaller? = null
    private lateinit var permissionLauncher: ActivityResultLauncher<String>

    fun forceStop() {
        myAudioRecorder?.apply {
            stop()
            release()
        }
        myAudioRecorder = null
        audioRecordListener?.onError("Recording stopped")
    }

    fun setAudioRecordListener(audioRecordListener: AudioRecordListener): AudioRecorderService {
        this.audioRecordListener = audioRecordListener
        return this
    }

    @RequiresApi(Build.VERSION_CODES.S)
    fun startRecording() {
        outputFile = createAudioFile()
        myAudioRecorder = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            MediaRecorder(context)
        } else {
            @Suppress("DEPRECATION")
            MediaRecorder()
        }

        myAudioRecorder?.apply {
            setAudioSource(MediaRecorder.AudioSource.MIC)
            setOutputFormat(MediaRecorder.OutputFormat.AAC_ADTS)
            setAudioEncoder(MediaRecorder.AudioEncoder.AAC)
            setOutputFile(outputFile)
            try {
                prepare()
                start()
                audioRecordListener?.onRecordStarted()
            } catch (e: Exception) {
                myAudioRecorder = null
                audioRecordListener?.onError(e.message)
            }
        }
    }

    private fun createAudioFile(): String? {
        var audioFileName: String
        var audioFile: File
        var attempt = 0
        do {
            audioFileName = "${UUID.randomUUID()}.aac"
            audioFile = File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC), audioFileName)
            attempt++
        } while (audioFile.exists() && attempt < 100)
        if (attempt >= 100) {
            return null
        }
        return audioFile.absolutePath
    }

    fun isRecording(): Boolean {
        return myAudioRecorder != null
    }

    fun stopRecording() {
        myAudioRecorder?.let { recorder ->
            try {
                if (isRecording()) {
                    recorder.stop()
                    recorder.release()
                }
            } catch (e: RuntimeException) {
                MainApplication.handleUncaughtException(e)
            } finally {
                myAudioRecorder = null
                audioRecordListener?.onRecordStopped(outputFile)
            }
        }
    }

    fun setCaller(caller: ActivityResultCaller, context: Context){
        this.caller = caller
        permissionLauncher =
            caller.registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->
                if (granted){
                    toggleRecording()
                }
                else {
                    if (!shouldShowRequestPermissionRationale(context as Activity, Manifest.permission.RECORD_AUDIO)) {
                        AlertDialog.Builder(context, R.style.AlertDialogTheme)
                            .setTitle(R.string.permission_required)
                            .setMessage(R.string.microphone_permission_required)
                            .setPositiveButton(R.string.settings) { dialog, _ ->
                                dialog.dismiss()
                                val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                                val uri: Uri = Uri.fromParts("package", context.packageName, null)
                                intent.data = uri
                                context.startActivity(intent)
                            }
                            .setNegativeButton(R.string.cancel) { dialog, _ -> dialog.dismiss() }
                            .show()
                    } else {
                        Utilities.toast(context, "Microphone permission is required to record audio.")
                    }
                }
            }
    }

    fun onRecordClicked() {
        if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO)
            == PackageManager.PERMISSION_GRANTED) {
            toggleRecording()
        } else {
            permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
            println(permissionLauncher)
        }
    }

    private fun toggleRecording() {
        if (this.isRecording()) {
            this.stopRecording()
        } else {
            this.startRecording()
        }
    }

    interface AudioRecordListener {
        fun onRecordStarted()
        fun onRecordStopped(outputFile: String?)
        fun onError(error: String?)
    }
}
=======
package org.ole.planet.myplanet.service


import android.Manifest
import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.media.MediaRecorder
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.provider.Settings
import androidx.activity.result.ActivityResultCaller
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.core.app.ActivityCompat.shouldShowRequestPermissionRationale
import androidx.core.content.ContextCompat
import java.io.File
import java.util.UUID
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.utilities.Utilities

class AudioRecorderService {
    private var outputFile: String? = null
    private var myAudioRecorder: MediaRecorder? = null
    private var audioRecordListener: AudioRecordListener? = null
    private var caller: ActivityResultCaller? = null
    private lateinit var permissionLauncher: ActivityResultLauncher<String>

    fun forceStop() {
        myAudioRecorder?.apply {
            stop()
            release()
        }
        myAudioRecorder = null
        audioRecordListener?.onError("Recording stopped")
    }

    fun setAudioRecordListener(audioRecordListener: AudioRecordListener): AudioRecorderService {
        this.audioRecordListener = audioRecordListener
        return this
    }

    @RequiresApi(Build.VERSION_CODES.S)
    fun startRecording() {
        outputFile = createAudioFile()
        myAudioRecorder = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            MediaRecorder(context)
        } else {
            @Suppress("DEPRECATION")
            MediaRecorder()
        }

        myAudioRecorder?.apply {
            setAudioSource(MediaRecorder.AudioSource.MIC)
            setOutputFormat(MediaRecorder.OutputFormat.AAC_ADTS)
            setAudioEncoder(MediaRecorder.AudioEncoder.AAC)
            setOutputFile(outputFile)
            try {
                prepare()
                start()
                audioRecordListener?.onRecordStarted()
            } catch (e: Exception) {
                myAudioRecorder = null
                audioRecordListener?.onError(e.message)
            }
        }
    }

    private fun createAudioFile(): String? {
        var audioFileName: String
        var audioFile: File
        var attempt = 0
        do {
            audioFileName = "${UUID.randomUUID()}.aac"
            audioFile = File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC), audioFileName)
            attempt++
        } while (audioFile.exists() && attempt < 100)
        if (attempt >= 100) {
            return null
        }
        return audioFile.absolutePath
    }

    fun isRecording(): Boolean {
        return myAudioRecorder != null
    }

    fun stopRecording() {
        myAudioRecorder?.let { recorder ->
            try {
                if (isRecording()) {
                    recorder.stop()
                    recorder.release()
                }
            } catch (e: RuntimeException) {
                MainApplication.handleUncaughtException(e)
            } finally {
                myAudioRecorder = null
                audioRecordListener?.onRecordStopped(outputFile)
            }
        }
    }

    fun setCaller(caller: ActivityResultCaller, context: Context){
        this.caller = caller
        permissionLauncher =
            caller.registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->
                if (granted){
                    toggleRecording()
                }
                else {
                    if (!shouldShowRequestPermissionRationale(context as Activity, Manifest.permission.RECORD_AUDIO)) {
                        AlertDialog.Builder(context, R.style.AlertDialogTheme)
                            .setTitle(R.string.permission_required)
                            .setMessage(R.string.microphone_permission_required)
                            .setPositiveButton(R.string.settings) { dialog, _ ->
                                dialog.dismiss()
                                val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                                val uri: Uri = Uri.fromParts("package", context.packageName, null)
                                intent.data = uri
                                context.startActivity(intent)
                            }
                            .setNegativeButton(R.string.cancel) { dialog, _ -> dialog.dismiss() }
                            .show()
                    } else {
                        Utilities.toast(context, "Microphone permission is required to record audio.")
                    }
                }
            }
    }

    fun onRecordClicked() {
        if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO)
            == PackageManager.PERMISSION_GRANTED) {
            toggleRecording()
        } else {
            permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
            println(permissionLauncher)
        }
    }

    private fun toggleRecording() {
        if (this.isRecording()) {
            this.stopRecording()
        } else {
            this.startRecording()
        }
    }

    interface AudioRecordListener {
        fun onRecordStarted()
        fun onRecordStopped(outputFile: String?)
        fun onError(error: String?)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/TransactionSyncManager.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.content.Context
import android.content.SharedPreferences
import android.text.TextUtils
import android.util.Base64
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import java.io.IOException
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.model.DocumentResponse
import org.ole.planet.myplanet.model.RealmChatHistory.Companion.insert
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.saveConcatenatedLinksToPrefs
import org.ole.planet.myplanet.model.RealmStepExam.Companion.insertCourseStepsExams
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.model.RealmUserModel.Companion.populateUsersTable
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.JsonUtils.getJsonArray
import org.ole.planet.myplanet.utilities.JsonUtils.getJsonObject
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.SecurePrefs
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities
import retrofit2.Response

object TransactionSyncManager {
    fun authenticate(): Boolean {
        val apiInterface = client?.create(ApiInterface::class.java)
        try {
            val response: Response<DocumentResponse>? = apiInterface?.getDocuments(UrlUtils.header, "${UrlUtils.getUrl()}/tablet_users/_all_docs")?.execute()
            if (response != null) {
                return response.code() == 200
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
        return false
    }

    fun syncAllHealthData(mRealm: Realm, settings: SharedPreferences, listener: SyncListener) {
        listener.onSyncStarted()
        val userName = SecurePrefs.getUserName(MainApplication.context, settings) ?: ""
        val password = SecurePrefs.getPassword(MainApplication.context, settings) ?: ""
        val header = "Basic ${Base64.encodeToString("$userName:$password".toByteArray(), Base64.NO_WRAP)}"
        mRealm.executeTransactionAsync({ realm: Realm ->
            val users = realm.where(RealmUserModel::class.java).isNotEmpty("_id").findAll()
            for (userModel in users) {
                syncHealthData(userModel, header)
            }
        }, { listener.onSyncComplete() }) { error: Throwable ->
            error.message?.let { listener.onSyncFailed(it) }
        }
    }

    private fun syncHealthData(userModel: RealmUserModel?, header: String) {
        val table = "userdb-${userModel?.planetCode?.let { Utilities.toHex(it) }}-${userModel?.name?.let { Utilities.toHex(it) }}"
        val apiInterface = client?.create(ApiInterface::class.java)
        val response: Response<DocumentResponse>?
        try {
            response = apiInterface?.getDocuments(header, "${UrlUtils.getUrl()}/$table/_all_docs")?.execute()
            val ob = response?.body()
            if (ob != null && ob.rows?.isNotEmpty() == true) {
                val r = ob.rows?.firstOrNull()
                r?.id?.let { id ->
                    val jsonDoc = apiInterface.getJsonObject(header, "${UrlUtils.getUrl()}/$table/$id")
                        .execute().body()
                    userModel?.key = getString("key", jsonDoc)
                    userModel?.iv = getString("iv", jsonDoc)
                }
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    fun syncKeyIv(mRealm: Realm, settings: SharedPreferences, listener: SyncListener) {
        listener.onSyncStarted()
        val model = UserProfileDbHandler(MainApplication.context).userModel
        val userName = SecurePrefs.getUserName(MainApplication.context, settings) ?: ""
        val password = SecurePrefs.getPassword(MainApplication.context, settings) ?: ""
        val header = "Basic " + Base64.encodeToString("$userName:$password".toByteArray(), Base64.NO_WRAP)
        val id = model?.id
        mRealm.executeTransactionAsync({ realm: Realm ->
            val userModel = realm.where(RealmUserModel::class.java).equalTo("id", id).findFirst()
            syncHealthData(userModel, header)
        }, { listener.onSyncComplete() }) { error: Throwable ->
            error.message?.let { listener.onSyncFailed(it) }
        }
    }

    fun syncDb(realm: Realm, table: String) {
        realm.executeTransactionAsync { mRealm: Realm ->
            val apiInterface = client?.create(ApiInterface::class.java)
            val allDocs = apiInterface?.getJsonObject(UrlUtils.header, UrlUtils.getUrl() + "/" + table + "/_all_docs?include_doc=false")
            try {
                val all = allDocs?.execute()
                val rows = getJsonArray("rows", all?.body())
                val keys: MutableList<String> = ArrayList()
                for (i in 0 until rows.size()) {
                    val `object` = rows[i].asJsonObject
                    if (!TextUtils.isEmpty(getString("id", `object`))) keys.add(getString("key", `object`))
                    if (i == rows.size() - 1 || keys.size == 1000) {
                        val obj = JsonObject()
                        obj.add("keys", Gson().fromJson(Gson().toJson(keys), JsonArray::class.java))
                        val response = apiInterface?.findDocs(UrlUtils.header, "application/json", UrlUtils.getUrl() + "/" + table + "/_all_docs?include_docs=true", obj)?.execute()
                        if (response?.body() != null) {
                            val arr = getJsonArray("rows", response.body())
                            if (table == "chat_history") {
                                insertToChat(arr, mRealm)
                            }
                            insertDocs(arr, mRealm, table)
                        }
                        keys.clear()
                    }
                }
            } catch (e: IOException) {
                e.printStackTrace()
            }
        }
    }

    private fun insertToChat(arr: JsonArray, mRealm: Realm) {
        val chatHistoryList = mutableListOf<JsonObject>()
        for (j in arr) {
            var jsonDoc = j.asJsonObject
            jsonDoc = getJsonObject("doc", jsonDoc)
            chatHistoryList.add(jsonDoc)
        }

        chatHistoryList.forEach { jsonDoc ->
            insert(mRealm, jsonDoc)
        }
    }

    private fun insertDocs(arr: JsonArray, mRealm: Realm, table: String) {
        val documentList = mutableListOf<JsonObject>()

        for (j in arr) {
            var jsonDoc = j.asJsonObject
            jsonDoc = getJsonObject("doc", jsonDoc)
            val id = getString("_id", jsonDoc)
            if (!id.startsWith("_design")) {
                documentList.add(jsonDoc)
            }
        }

        documentList.forEach { jsonDoc ->
            continueInsert(mRealm, table, jsonDoc)
        }
    }

    private fun continueInsert(mRealm: Realm, table: String, jsonDoc: JsonObject) {
        val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        when (table) {
            "exams" -> {
                insertCourseStepsExams("", "", jsonDoc, mRealm)
            }
            "tablet_users" -> {
                populateUsersTable(jsonDoc, mRealm, settings)
            }
            else -> {
                callMethod(mRealm, jsonDoc, table)
            }
        }
        saveConcatenatedLinksToPrefs()
    }

    private fun callMethod(mRealm: Realm, jsonDoc: JsonObject, type: String) {
        try {
            val methods = Constants.classList[type]?.methods
            methods?.let {
                for (m in it) {
                    if ("insert" == m.name) {
                        m.invoke(null, mRealm, jsonDoc)
                        break
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}
=======
package org.ole.planet.myplanet.service


import android.content.Context
import android.content.SharedPreferences
import android.text.TextUtils
import android.util.Base64
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import java.io.IOException
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.model.DocumentResponse
import org.ole.planet.myplanet.model.RealmChatHistory.Companion.insert
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.saveConcatenatedLinksToPrefs
import org.ole.planet.myplanet.model.RealmStepExam.Companion.insertCourseStepsExams
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.model.RealmUserModel.Companion.populateUsersTable
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.JsonUtils.getJsonArray
import org.ole.planet.myplanet.utilities.JsonUtils.getJsonObject
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.SecurePrefs
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities
import retrofit2.Response

object TransactionSyncManager {
    fun authenticate(): Boolean {
        val apiInterface = client?.create(ApiInterface::class.java)
        try {
            val response: Response<DocumentResponse>? = apiInterface?.getDocuments(UrlUtils.header, "${UrlUtils.getUrl()}/tablet_users/_all_docs")?.execute()
            if (response != null) {
                return response.code() == 200
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
        return false
    }

    fun syncAllHealthData(mRealm: Realm, settings: SharedPreferences, listener: SyncListener) {
        listener.onSyncStarted()
        val userName = SecurePrefs.getUserName(MainApplication.context, settings) ?: ""
        val password = SecurePrefs.getPassword(MainApplication.context, settings) ?: ""
        val header = "Basic ${Base64.encodeToString("$userName:$password".toByteArray(), Base64.NO_WRAP)}"
        mRealm.executeTransactionAsync({ realm: Realm ->
            val users = realm.where(RealmUserModel::class.java).isNotEmpty("_id").findAll()
            for (userModel in users) {
                syncHealthData(userModel, header)
            }
        }, { listener.onSyncComplete() }) { error: Throwable ->
            error.message?.let { listener.onSyncFailed(it) }
        }
    }

    private fun syncHealthData(userModel: RealmUserModel?, header: String) {
        val table = "userdb-${userModel?.planetCode?.let { Utilities.toHex(it) }}-${userModel?.name?.let { Utilities.toHex(it) }}"
        val apiInterface = client?.create(ApiInterface::class.java)
        val response: Response<DocumentResponse>?
        try {
            response = apiInterface?.getDocuments(header, "${UrlUtils.getUrl()}/$table/_all_docs")?.execute()
            val ob = response?.body()
            if (ob != null && ob.rows?.isNotEmpty() == true) {
                val r = ob.rows?.firstOrNull()
                r?.id?.let { id ->
                    val jsonDoc = apiInterface.getJsonObject(header, "${UrlUtils.getUrl()}/$table/$id")
                        .execute().body()
                    userModel?.key = getString("key", jsonDoc)
                    userModel?.iv = getString("iv", jsonDoc)
                }
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    fun syncKeyIv(mRealm: Realm, settings: SharedPreferences, listener: SyncListener) {
        listener.onSyncStarted()
        val model = UserProfileDbHandler(MainApplication.context).userModel
        val userName = SecurePrefs.getUserName(MainApplication.context, settings) ?: ""
        val password = SecurePrefs.getPassword(MainApplication.context, settings) ?: ""
        val header = "Basic " + Base64.encodeToString("$userName:$password".toByteArray(), Base64.NO_WRAP)
        val id = model?.id
        mRealm.executeTransactionAsync({ realm: Realm ->
            val userModel = realm.where(RealmUserModel::class.java).equalTo("id", id).findFirst()
            syncHealthData(userModel, header)
        }, { listener.onSyncComplete() }) { error: Throwable ->
            error.message?.let { listener.onSyncFailed(it) }
        }
    }

    fun syncDb(realm: Realm, table: String) {
        realm.executeTransactionAsync { mRealm: Realm ->
            val apiInterface = client?.create(ApiInterface::class.java)
            val allDocs = apiInterface?.getJsonObject(UrlUtils.header, UrlUtils.getUrl() + "/" + table + "/_all_docs?include_doc=false")
            try {
                val all = allDocs?.execute()
                val rows = getJsonArray("rows", all?.body())
                val keys: MutableList<String> = ArrayList()
                for (i in 0 until rows.size()) {
                    val `object` = rows[i].asJsonObject
                    if (!TextUtils.isEmpty(getString("id", `object`))) keys.add(getString("key", `object`))
                    if (i == rows.size() - 1 || keys.size == 1000) {
                        val obj = JsonObject()
                        obj.add("keys", Gson().fromJson(Gson().toJson(keys), JsonArray::class.java))
                        val response = apiInterface?.findDocs(UrlUtils.header, "application/json", UrlUtils.getUrl() + "/" + table + "/_all_docs?include_docs=true", obj)?.execute()
                        if (response?.body() != null) {
                            val arr = getJsonArray("rows", response.body())
                            if (table == "chat_history") {
                                insertToChat(arr, mRealm)
                            }
                            insertDocs(arr, mRealm, table)
                        }
                        keys.clear()
                    }
                }
            } catch (e: IOException) {
                e.printStackTrace()
            }
        }
    }

    private fun insertToChat(arr: JsonArray, mRealm: Realm) {
        val chatHistoryList = mutableListOf<JsonObject>()
        for (j in arr) {
            var jsonDoc = j.asJsonObject
            jsonDoc = getJsonObject("doc", jsonDoc)
            chatHistoryList.add(jsonDoc)
        }

        chatHistoryList.forEach { jsonDoc ->
            insert(mRealm, jsonDoc)
        }
    }

    private fun insertDocs(arr: JsonArray, mRealm: Realm, table: String) {
        val documentList = mutableListOf<JsonObject>()

        for (j in arr) {
            var jsonDoc = j.asJsonObject
            jsonDoc = getJsonObject("doc", jsonDoc)
            val id = getString("_id", jsonDoc)
            if (!id.startsWith("_design")) {
                documentList.add(jsonDoc)
            }
        }

        documentList.forEach { jsonDoc ->
            continueInsert(mRealm, table, jsonDoc)
        }
    }

    private fun continueInsert(mRealm: Realm, table: String, jsonDoc: JsonObject) {
        val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        when (table) {
            "exams" -> {
                insertCourseStepsExams("", "", jsonDoc, mRealm)
            }
            "tablet_users" -> {
                populateUsersTable(jsonDoc, mRealm, settings)
            }
            else -> {
                callMethod(mRealm, jsonDoc, table)
            }
        }
        saveConcatenatedLinksToPrefs()
    }

    private fun callMethod(mRealm: Realm, jsonDoc: JsonObject, type: String) {
        try {
            val methods = Constants.classList[type]?.methods
            methods?.let {
                for (m in it) {
                    if ("insert" == m.name) {
                        m.invoke(null, mRealm, jsonDoc)
                        break
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/UploadToShelfService.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.content.Context
import android.content.SharedPreferences
import android.text.TextUtils
import android.util.Base64
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import dagger.hilt.android.qualifiers.ApplicationContext
import io.realm.Realm
import java.io.IOException
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.RealmMeetup.Companion.getMyMeetUpIds
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getMyCourseIds
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmMyHealthPojo.Companion.serialize
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getMyLibIds
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.removedIds
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateIv
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateKey
import org.ole.planet.myplanet.utilities.JsonUtils.getJsonArray
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.RetryUtils
import org.ole.planet.myplanet.utilities.SecurePrefs
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities
import retrofit2.Response

@Singleton
class UploadToShelfService @Inject constructor(
    @ApplicationContext private val context: Context,
    private val dbService: DatabaseService,
    @AppPreferences private val sharedPreferences: SharedPreferences
) {
    lateinit var mRealm: Realm

    fun uploadUserData(listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance
        mRealm.executeTransactionAsync({ realm: Realm ->
            val userModels: List<RealmUserModel> = realm.where(RealmUserModel::class.java)
                .isEmpty("_id").or().equalTo("isUpdated", true)
                .findAll()
                .take(100)
            if (userModels.isEmpty()) {
                return@executeTransactionAsync
            }
            val password = SecurePrefs.getPassword(context, sharedPreferences) ?: ""
            userModels.forEachIndexed { index, model ->
                try {
                    val header = "Basic ${Base64.encodeToString(("${model.name}:${password}").toByteArray(), Base64.NO_WRAP)}"
                    val userExists = checkIfUserExists(apiInterface, header, model)

                    if (!userExists) {
                        uploadNewUser(apiInterface, realm, model)
                    } else if (model.isUpdated) {
                        updateExistingUser(apiInterface, header, model)
                    }
                } catch (e: IOException) {
                    e.printStackTrace()
                }
            }
        }, {
            mRealm.close()
            uploadToShelf(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    listener.onSuccess(success)
                }
            })
        }) { error ->
            mRealm.close()
            listener.onSuccess("Error during user data sync: ${error.localizedMessage}")
        }
    }

    fun uploadSingleUserData(userName: String?, listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance

        mRealm.executeTransactionAsync({ realm: Realm ->
            val userModel = realm.where(RealmUserModel::class.java)
                .equalTo("name", userName)
                .findFirst()

            if (userModel != null) {
                try {
                    val password = SecurePrefs.getPassword(context, sharedPreferences) ?: ""
                    val header = "Basic ${Base64.encodeToString(("${userModel.name}:${password}").toByteArray(), Base64.NO_WRAP)}"

                    val userExists = checkIfUserExists(apiInterface, header, userModel)

                    if (!userExists) {
                        uploadNewUser(apiInterface, realm, userModel)
                    } else if (userModel.isUpdated) {
                        updateExistingUser(apiInterface, header, userModel)
                    }
                } catch (e: IOException) {
                    e.printStackTrace()
                }
            }
        }, {
            mRealm.close()
            uploadSingleUserToShelf(userName, listener)
        }) { error ->
            mRealm.close()
            listener.onSuccess("Error during user data sync: ${error.localizedMessage}")
        }
    }

    private fun checkIfUserExists(apiInterface: ApiInterface?, header: String, model: RealmUserModel): Boolean {
        try {
            val res = apiInterface?.getJsonObject(header, "${replacedUrl(model)}/_users/org.couchdb.user:${model.name}")?.execute()
            val exists = res?.body() != null
            return exists
        } catch (e: IOException) {
            e.printStackTrace()
            return false
        }
    }

    private fun uploadNewUser(apiInterface: ApiInterface?, realm: Realm, model: RealmUserModel) {
        try {
            val obj = model.serialize()
            val createResponse = apiInterface?.putDoc(null, "application/json", "${replacedUrl(model)}/_users/org.couchdb.user:${model.name}", obj)?.execute()

            if (createResponse?.isSuccessful == true) {
                val id = createResponse.body()?.get("id")?.asString
                val rev = createResponse.body()?.get("rev")?.asString
                model._id = id
                model._rev = rev
                processUserAfterCreation(apiInterface, realm, model, obj)
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private fun processUserAfterCreation(apiInterface: ApiInterface?, realm: Realm, model: RealmUserModel, obj: JsonObject) {
        try {
            val password = SecurePrefs.getPassword(context, sharedPreferences) ?: ""
            val header = "Basic ${Base64.encodeToString(("${model.name}:${password}").toByteArray(), Base64.NO_WRAP)}"
            val fetchDataResponse = apiInterface?.getJsonObject(header, "${replacedUrl(model)}/_users/${model._id}")?.execute()
            if (fetchDataResponse?.isSuccessful == true) {
                model.password_scheme = getString("password_scheme", fetchDataResponse.body())
                model.derived_key = getString("derived_key", fetchDataResponse.body())
                model.salt = getString("salt", fetchDataResponse.body())
                model.iterations = getString("iterations", fetchDataResponse.body())

                if (saveKeyIv(apiInterface, model, obj)) {
                    updateHealthData(realm, model)
                }
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private fun updateExistingUser(apiInterface: ApiInterface?, header: String, model: RealmUserModel) {
        try {
            val latestDocResponse = apiInterface?.getJsonObject(header, "${replacedUrl(model)}/_users/org.couchdb.user:${model.name}")?.execute()

            if (latestDocResponse?.isSuccessful == true) {
                val latestRev = latestDocResponse.body()?.get("_rev")?.asString
                val obj = model.serialize()
                val objMap = obj.entrySet().associate { (key, value) -> key to value }
                val mutableObj = mutableMapOf<String, Any>().apply { putAll(objMap) }
                latestRev?.let { rev -> mutableObj["_rev"] = rev as Any }

                val gson = Gson()
                val jsonElement = gson.toJsonTree(mutableObj)
                val jsonObject = jsonElement.asJsonObject

                val updateResponse = apiInterface.putDoc(header, "application/json", "${replacedUrl(model)}/_users/org.couchdb.user:${model.name}", jsonObject).execute()

                if (updateResponse.isSuccessful) {
                    val updatedRev = updateResponse.body()?.get("rev")?.asString
                    model._rev = updatedRev
                    model.isUpdated = false
                }
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private fun replacedUrl(model: RealmUserModel): String {
        val url = UrlUtils.getUrl()
        val password = SecurePrefs.getPassword(context, sharedPreferences) ?: ""
        val replacedUrl = url.replaceFirst("[^:]+:[^@]+@".toRegex(), "${model.name}:${password}@")
        val protocolIndex = url.indexOf("://")
        val protocol = url.substring(0, protocolIndex)
        return "$protocol://$replacedUrl"
    }

    private fun updateHealthData(realm: Realm, model: RealmUserModel) {
        val list: List<RealmMyHealthPojo> = realm.where(RealmMyHealthPojo::class.java).equalTo("_id", model.id).findAll()
        for (p in list) {
            p.userId = model._id
        }
    }

    @Throws(IOException::class)
    fun saveKeyIv(apiInterface: ApiInterface?, model: RealmUserModel, obj: JsonObject): Boolean {
        val table = "userdb-${Utilities.toHex(model.planetCode)}-${Utilities.toHex(model.name)}"
        val header = "Basic ${Base64.encodeToString(("${obj["name"].asString}:${obj["password"].asString}").toByteArray(), Base64.NO_WRAP)}"
        val ob = JsonObject()
        var keyString = generateKey()
        var iv: String? = generateIv()
        if (!TextUtils.isEmpty(model.iv)) {
            iv = model.iv
        }
        if (!TextUtils.isEmpty(model.key)) {
            keyString = model.key
        }
        ob.addProperty("key", keyString)
        ob.addProperty("iv", iv)
        ob.addProperty("createdOn", Date().time)
        val maxAttempts = 3
        val retryDelayMs = 2000L

        val response = runBlocking {
            RetryUtils.retry(
                maxAttempts = maxAttempts,
                delayMs = retryDelayMs,
                shouldRetry = { resp -> resp == null || !resp.isSuccessful || resp.body() == null }
            ) {
                apiInterface?.postDoc(header, "application/json", "${UrlUtils.getUrl()}/$table", ob)?.execute()
            }
        }

        if (response?.isSuccessful == true && response.body() != null) {
            model.key = keyString
            model.iv = iv
        } else {
            val errorMessage = "Failed to save key/IV after $maxAttempts attempts"
            throw IOException(errorMessage)
        }

        changeUserSecurity(model, obj)
        return true
    }

    fun uploadHealth() {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance

        mRealm.executeTransactionAsync({ realm: Realm ->
            val myHealths: List<RealmMyHealthPojo> = realm.where(RealmMyHealthPojo::class.java).equalTo("isUpdated", true).notEqualTo("userId", "").findAll()
            myHealths.forEachIndexed { index, pojo ->
                try {
                    val res = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/health", serialize(pojo))?.execute()

                    if (res?.body() != null && res.body()?.has("id") == true) {
                        pojo._rev = res.body()?.get("rev")?.asString
                        pojo.isUpdated = false
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }, {
            mRealm.close()
        }) { _ ->
            mRealm.close()
        }
    }

    fun uploadSingleUserHealth(userId: String?, listener: SuccessListener?) {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance

        mRealm.executeTransactionAsync({ realm: Realm ->
            if (userId.isNullOrEmpty()) {
                return@executeTransactionAsync
            }

            val myHealths: List<RealmMyHealthPojo> = realm.where(RealmMyHealthPojo::class.java)
                .equalTo("isUpdated", true)
                .equalTo("userId", userId)
                .findAll()

            myHealths.forEach { pojo ->
                try {
                    val res = apiInterface?.postDoc(
                        UrlUtils.header,
                        "application/json",
                        "${UrlUtils.getUrl()}/health",
                        serialize(pojo)
                    )?.execute()

                    if (res?.body() != null && res.body()?.has("id") == true) {
                        pojo._rev = res.body()?.get("rev")?.asString
                        pojo.isUpdated = false
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }, {
            mRealm.close()
            listener?.onSuccess("Health data for user $userId uploaded successfully")
        }) { error ->
            mRealm.close()
            listener?.onSuccess("Error uploading health data for user $userId: ${error.localizedMessage}")
        }
    }

    private fun uploadToShelf(listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance
        var unmanagedUsers: List<RealmUserModel> = emptyList()

        mRealm.executeTransactionAsync({ realm ->
            val users = realm.where(RealmUserModel::class.java).isNotEmpty("_id").findAll()
            unmanagedUsers = realm.copyFromRealm(users)
        }, {
            mRealm.close()
            if (unmanagedUsers.isEmpty()) {
                listener.onSuccess("Sync with server completed successfully")
                return@executeTransactionAsync
            }
            Thread {
                var backgroundRealm: Realm? = null
                try {
                    backgroundRealm = dbService.realmInstance
                    unmanagedUsers.forEach { model ->
                        try {
                            if (model.id?.startsWith("guest") == true) return@forEach
                            val jsonDoc = apiInterface?.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/shelf/${model._id}")?.execute()?.body()
                            val `object` = getShelfData(backgroundRealm, model.id, jsonDoc)
                            `object`.addProperty("_rev", getString("_rev", jsonDoc))
                            apiInterface?.putDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/shelf/${sharedPreferences.getString("userId", "")}", `object`)?.execute()
                        } catch (e: Exception) {
                            e.printStackTrace()
                        }
                    }
                    MainApplication.applicationScope.launch(Dispatchers.Main) {
                        listener.onSuccess("Sync with server completed successfully")
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                    MainApplication.applicationScope.launch(Dispatchers.Main) {
                        listener.onSuccess("Unable to update documents: ${e.localizedMessage}")
                    }
                } finally {
                    backgroundRealm?.close()
                }
            }.start()
        }, { error ->
            mRealm.close()
            listener.onSuccess("Unable to update documents: ${error.localizedMessage}")
        })
    }

    private fun uploadSingleUserToShelf(userName: String?, listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance

        mRealm.executeTransactionAsync({ realm: Realm ->
            val model = realm.where(RealmUserModel::class.java)
                .equalTo("name", userName)
                .isNotEmpty("_id")
                .findFirst()

            if (model != null) {
                try {
                    if (model.id?.startsWith("guest") == true) return@executeTransactionAsync

                    val shelfUrl = "${UrlUtils.getUrl()}/shelf/${model._id}"
                    val jsonDoc = apiInterface?.getJsonObject(UrlUtils.header, shelfUrl)?.execute()?.body()
                    val shelfObject = getShelfData(realm, model.id, jsonDoc)
                    shelfObject.addProperty("_rev", getString("_rev", jsonDoc))

                    val targetUrl = "${UrlUtils.getUrl()}/shelf/${sharedPreferences.getString("userId", "")}"
                    apiInterface?.putDoc(UrlUtils.header, "application/json", targetUrl, shelfObject)?.execute()?.body()
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }, {
            mRealm.close()
            listener.onSuccess("Single user shelf sync completed successfully")
        }) { error ->
            mRealm.close()
            listener.onSuccess("Unable to update document: ${error.localizedMessage}")
        }
    }

    private fun getShelfData(realm: Realm?, userId: String?, jsonDoc: JsonObject?): JsonObject {
        val myLibs = getMyLibIds(realm, userId)
        val myCourses = getMyCourseIds(realm, userId)
        val myMeetups = getMyMeetUpIds(realm, userId)
        val removedResources = listOf(*removedIds(realm, "resources", userId))
        val removedCourses = listOf(*removedIds(realm, "courses", userId))
        val mergedResourceIds = mergeJsonArray(myLibs, getJsonArray("resourceIds", jsonDoc), removedResources)
        val mergedCourseIds = mergeJsonArray(myCourses, getJsonArray("courseIds", jsonDoc), removedCourses)
        val `object` = JsonObject()
        `object`.addProperty("_id", sharedPreferences.getString("userId", ""))
        `object`.add("meetupIds", mergeJsonArray(myMeetups, getJsonArray("meetupIds", jsonDoc), removedResources))
        `object`.add("resourceIds", mergedResourceIds)
        `object`.add("courseIds", mergedCourseIds)
        return `object`
    }

    private fun mergeJsonArray(array1: JsonArray?, array2: JsonArray, removedIds: List<String>): JsonArray {
        val array = JsonArray()
        array.addAll(array1)
        for (e in array2) {
            if (!array.contains(e) && !removedIds.contains(e.asString)) {
                array.add(e)
            }
        }
        return array
    }

    companion object {
        private fun changeUserSecurity(model: RealmUserModel, obj: JsonObject) {
            val table = "userdb-${Utilities.toHex(model.planetCode)}-${Utilities.toHex(model.name)}"
            val header = "Basic ${Base64.encodeToString(("${obj["name"].asString}:${obj["password"].asString}").toByteArray(), Base64.NO_WRAP)}"
            val apiInterface = client?.create(ApiInterface::class.java)
            try {
                val response: Response<JsonObject?>? = apiInterface?.getJsonObject(header, "${UrlUtils.getUrl()}/${table}/_security")?.execute()
                if (response?.body() != null) {
                    val jsonObject = response.body()
                    val members = jsonObject?.getAsJsonObject("members")
                    val rolesArray: JsonArray = if (members?.has("roles") == true) {
                        members.getAsJsonArray("roles")
                    } else {
                        JsonArray()
                    }
                    rolesArray.add("health")
                    members?.add("roles", rolesArray)
                    jsonObject?.add("members", members)
                    apiInterface.putDoc(header, "application/json", "${UrlUtils.getUrl()}/${table}/_security", jsonObject).execute()
                }
            } catch (e: IOException) {
                e.printStackTrace()
            }
        }
    }
}
=======
package org.ole.planet.myplanet.service


import android.content.Context
import android.content.SharedPreferences
import android.text.TextUtils
import android.util.Base64
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import dagger.hilt.android.qualifiers.ApplicationContext
import io.realm.Realm
import java.io.IOException
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.RealmMeetup.Companion.getMyMeetUpIds
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getMyCourseIds
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmMyHealthPojo.Companion.serialize
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getMyLibIds
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.removedIds
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateIv
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateKey
import org.ole.planet.myplanet.utilities.JsonUtils.getJsonArray
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.RetryUtils
import org.ole.planet.myplanet.utilities.SecurePrefs
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities
import retrofit2.Response

@Singleton
class UploadToShelfService @Inject constructor(
    @ApplicationContext private val context: Context,
    private val dbService: DatabaseService,
    @AppPreferences private val sharedPreferences: SharedPreferences
) {
    lateinit var mRealm: Realm

    fun uploadUserData(listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance
        mRealm.executeTransactionAsync({ realm: Realm ->
            val userModels: List<RealmUserModel> = realm.where(RealmUserModel::class.java)
                .isEmpty("_id").or().equalTo("isUpdated", true)
                .findAll()
                .take(100)
            if (userModels.isEmpty()) {
                return@executeTransactionAsync
            }
            val password = SecurePrefs.getPassword(context, sharedPreferences) ?: ""
            userModels.forEachIndexed { index, model ->
                try {
                    val header = "Basic ${Base64.encodeToString(("${model.name}:${password}").toByteArray(), Base64.NO_WRAP)}"
                    val userExists = checkIfUserExists(apiInterface, header, model)

                    if (!userExists) {
                        uploadNewUser(apiInterface, realm, model)
                    } else if (model.isUpdated) {
                        updateExistingUser(apiInterface, header, model)
                    }
                } catch (e: IOException) {
                    e.printStackTrace()
                }
            }
        }, {
            mRealm.close()
            uploadToShelf(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    listener.onSuccess(success)
                }
            })
        }) { error ->
            mRealm.close()
            listener.onSuccess("Error during user data sync: ${error.localizedMessage}")
        }
    }

    fun uploadSingleUserData(userName: String?, listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance

        mRealm.executeTransactionAsync({ realm: Realm ->
            val userModel = realm.where(RealmUserModel::class.java)
                .equalTo("name", userName)
                .findFirst()

            if (userModel != null) {
                try {
                    val password = SecurePrefs.getPassword(context, sharedPreferences) ?: ""
                    val header = "Basic ${Base64.encodeToString(("${userModel.name}:${password}").toByteArray(), Base64.NO_WRAP)}"

                    val userExists = checkIfUserExists(apiInterface, header, userModel)

                    if (!userExists) {
                        uploadNewUser(apiInterface, realm, userModel)
                    } else if (userModel.isUpdated) {
                        updateExistingUser(apiInterface, header, userModel)
                    }
                } catch (e: IOException) {
                    e.printStackTrace()
                }
            }
        }, {
            mRealm.close()
            uploadSingleUserToShelf(userName, listener)
        }) { error ->
            mRealm.close()
            listener.onSuccess("Error during user data sync: ${error.localizedMessage}")
        }
    }

    private fun checkIfUserExists(apiInterface: ApiInterface?, header: String, model: RealmUserModel): Boolean {
        try {
            val res = apiInterface?.getJsonObject(header, "${replacedUrl(model)}/_users/org.couchdb.user:${model.name}")?.execute()
            val exists = res?.body() != null
            return exists
        } catch (e: IOException) {
            e.printStackTrace()
            return false
        }
    }

    private fun uploadNewUser(apiInterface: ApiInterface?, realm: Realm, model: RealmUserModel) {
        try {
            val obj = model.serialize()
            val createResponse = apiInterface?.putDoc(null, "application/json", "${replacedUrl(model)}/_users/org.couchdb.user:${model.name}", obj)?.execute()

            if (createResponse?.isSuccessful == true) {
                val id = createResponse.body()?.get("id")?.asString
                val rev = createResponse.body()?.get("rev")?.asString
                model._id = id
                model._rev = rev
                processUserAfterCreation(apiInterface, realm, model, obj)
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private fun processUserAfterCreation(apiInterface: ApiInterface?, realm: Realm, model: RealmUserModel, obj: JsonObject) {
        try {
            val password = SecurePrefs.getPassword(context, sharedPreferences) ?: ""
            val header = "Basic ${Base64.encodeToString(("${model.name}:${password}").toByteArray(), Base64.NO_WRAP)}"
            val fetchDataResponse = apiInterface?.getJsonObject(header, "${replacedUrl(model)}/_users/${model._id}")?.execute()
            if (fetchDataResponse?.isSuccessful == true) {
                model.password_scheme = getString("password_scheme", fetchDataResponse.body())
                model.derived_key = getString("derived_key", fetchDataResponse.body())
                model.salt = getString("salt", fetchDataResponse.body())
                model.iterations = getString("iterations", fetchDataResponse.body())

                if (saveKeyIv(apiInterface, model, obj)) {
                    updateHealthData(realm, model)
                }
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private fun updateExistingUser(apiInterface: ApiInterface?, header: String, model: RealmUserModel) {
        try {
            val latestDocResponse = apiInterface?.getJsonObject(header, "${replacedUrl(model)}/_users/org.couchdb.user:${model.name}")?.execute()

            if (latestDocResponse?.isSuccessful == true) {
                val latestRev = latestDocResponse.body()?.get("_rev")?.asString
                val obj = model.serialize()
                val objMap = obj.entrySet().associate { (key, value) -> key to value }
                val mutableObj = mutableMapOf<String, Any>().apply { putAll(objMap) }
                latestRev?.let { rev -> mutableObj["_rev"] = rev as Any }

                val gson = Gson()
                val jsonElement = gson.toJsonTree(mutableObj)
                val jsonObject = jsonElement.asJsonObject

                val updateResponse = apiInterface.putDoc(header, "application/json", "${replacedUrl(model)}/_users/org.couchdb.user:${model.name}", jsonObject).execute()

                if (updateResponse.isSuccessful) {
                    val updatedRev = updateResponse.body()?.get("rev")?.asString
                    model._rev = updatedRev
                    model.isUpdated = false
                }
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private fun replacedUrl(model: RealmUserModel): String {
        val url = UrlUtils.getUrl()
        val password = SecurePrefs.getPassword(context, sharedPreferences) ?: ""
        val replacedUrl = url.replaceFirst("[^:]+:[^@]+@".toRegex(), "${model.name}:${password}@")
        val protocolIndex = url.indexOf("://")
        val protocol = url.substring(0, protocolIndex)
        return "$protocol://$replacedUrl"
    }

    private fun updateHealthData(realm: Realm, model: RealmUserModel) {
        val list: List<RealmMyHealthPojo> = realm.where(RealmMyHealthPojo::class.java).equalTo("_id", model.id).findAll()
        for (p in list) {
            p.userId = model._id
        }
    }

    @Throws(IOException::class)
    fun saveKeyIv(apiInterface: ApiInterface?, model: RealmUserModel, obj: JsonObject): Boolean {
        val table = "userdb-${Utilities.toHex(model.planetCode)}-${Utilities.toHex(model.name)}"
        val header = "Basic ${Base64.encodeToString(("${obj["name"].asString}:${obj["password"].asString}").toByteArray(), Base64.NO_WRAP)}"
        val ob = JsonObject()
        var keyString = generateKey()
        var iv: String? = generateIv()
        if (!TextUtils.isEmpty(model.iv)) {
            iv = model.iv
        }
        if (!TextUtils.isEmpty(model.key)) {
            keyString = model.key
        }
        ob.addProperty("key", keyString)
        ob.addProperty("iv", iv)
        ob.addProperty("createdOn", Date().time)
        val maxAttempts = 3
        val retryDelayMs = 2000L

        val response = runBlocking {
            RetryUtils.retry(
                maxAttempts = maxAttempts,
                delayMs = retryDelayMs,
                shouldRetry = { resp -> resp == null || !resp.isSuccessful || resp.body() == null }
            ) {
                apiInterface?.postDoc(header, "application/json", "${UrlUtils.getUrl()}/$table", ob)?.execute()
            }
        }

        if (response?.isSuccessful == true && response.body() != null) {
            model.key = keyString
            model.iv = iv
        } else {
            val errorMessage = "Failed to save key/IV after $maxAttempts attempts"
            throw IOException(errorMessage)
        }

        changeUserSecurity(model, obj)
        return true
    }

    fun uploadHealth() {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance

        mRealm.executeTransactionAsync({ realm: Realm ->
            val myHealths: List<RealmMyHealthPojo> = realm.where(RealmMyHealthPojo::class.java).equalTo("isUpdated", true).notEqualTo("userId", "").findAll()
            myHealths.forEachIndexed { index, pojo ->
                try {
                    val res = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/health", serialize(pojo))?.execute()

                    if (res?.body() != null && res.body()?.has("id") == true) {
                        pojo._rev = res.body()?.get("rev")?.asString
                        pojo.isUpdated = false
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }, {
            mRealm.close()
        }) { _ ->
            mRealm.close()
        }
    }

    fun uploadSingleUserHealth(userId: String?, listener: SuccessListener?) {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance

        mRealm.executeTransactionAsync({ realm: Realm ->
            if (userId.isNullOrEmpty()) {
                return@executeTransactionAsync
            }

            val myHealths: List<RealmMyHealthPojo> = realm.where(RealmMyHealthPojo::class.java)
                .equalTo("isUpdated", true)
                .equalTo("userId", userId)
                .findAll()

            myHealths.forEach { pojo ->
                try {
                    val res = apiInterface?.postDoc(
                        UrlUtils.header,
                        "application/json",
                        "${UrlUtils.getUrl()}/health",
                        serialize(pojo)
                    )?.execute()

                    if (res?.body() != null && res.body()?.has("id") == true) {
                        pojo._rev = res.body()?.get("rev")?.asString
                        pojo.isUpdated = false
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }, {
            mRealm.close()
            listener?.onSuccess("Health data for user $userId uploaded successfully")
        }) { error ->
            mRealm.close()
            listener?.onSuccess("Error uploading health data for user $userId: ${error.localizedMessage}")
        }
    }

    private fun uploadToShelf(listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance
        var unmanagedUsers: List<RealmUserModel> = emptyList()

        mRealm.executeTransactionAsync({ realm ->
            val users = realm.where(RealmUserModel::class.java).isNotEmpty("_id").findAll()
            unmanagedUsers = realm.copyFromRealm(users)
        }, {
            mRealm.close()
            if (unmanagedUsers.isEmpty()) {
                listener.onSuccess("Sync with server completed successfully")
                return@executeTransactionAsync
            }
            Thread {
                var backgroundRealm: Realm? = null
                try {
                    backgroundRealm = dbService.realmInstance
                    unmanagedUsers.forEach { model ->
                        try {
                            if (model.id?.startsWith("guest") == true) return@forEach
                            val jsonDoc = apiInterface?.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/shelf/${model._id}")?.execute()?.body()
                            val `object` = getShelfData(backgroundRealm, model.id, jsonDoc)
                            `object`.addProperty("_rev", getString("_rev", jsonDoc))
                            apiInterface?.putDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/shelf/${sharedPreferences.getString("userId", "")}", `object`)?.execute()
                        } catch (e: Exception) {
                            e.printStackTrace()
                        }
                    }
                    MainApplication.applicationScope.launch(Dispatchers.Main) {
                        listener.onSuccess("Sync with server completed successfully")
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                    MainApplication.applicationScope.launch(Dispatchers.Main) {
                        listener.onSuccess("Unable to update documents: ${e.localizedMessage}")
                    }
                } finally {
                    backgroundRealm?.close()
                }
            }.start()
        }, { error ->
            mRealm.close()
            listener.onSuccess("Unable to update documents: ${error.localizedMessage}")
        })
    }

    private fun uploadSingleUserToShelf(userName: String?, listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)
        mRealm = dbService.realmInstance

        mRealm.executeTransactionAsync({ realm: Realm ->
            val model = realm.where(RealmUserModel::class.java)
                .equalTo("name", userName)
                .isNotEmpty("_id")
                .findFirst()

            if (model != null) {
                try {
                    if (model.id?.startsWith("guest") == true) return@executeTransactionAsync

                    val shelfUrl = "${UrlUtils.getUrl()}/shelf/${model._id}"
                    val jsonDoc = apiInterface?.getJsonObject(UrlUtils.header, shelfUrl)?.execute()?.body()
                    val shelfObject = getShelfData(realm, model.id, jsonDoc)
                    shelfObject.addProperty("_rev", getString("_rev", jsonDoc))

                    val targetUrl = "${UrlUtils.getUrl()}/shelf/${sharedPreferences.getString("userId", "")}"
                    apiInterface?.putDoc(UrlUtils.header, "application/json", targetUrl, shelfObject)?.execute()?.body()
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }, {
            mRealm.close()
            listener.onSuccess("Single user shelf sync completed successfully")
        }) { error ->
            mRealm.close()
            listener.onSuccess("Unable to update document: ${error.localizedMessage}")
        }
    }

    private fun getShelfData(realm: Realm?, userId: String?, jsonDoc: JsonObject?): JsonObject {
        val myLibs = getMyLibIds(realm, userId)
        val myCourses = getMyCourseIds(realm, userId)
        val myMeetups = getMyMeetUpIds(realm, userId)
        val removedResources = listOf(*removedIds(realm, "resources", userId))
        val removedCourses = listOf(*removedIds(realm, "courses", userId))
        val mergedResourceIds = mergeJsonArray(myLibs, getJsonArray("resourceIds", jsonDoc), removedResources)
        val mergedCourseIds = mergeJsonArray(myCourses, getJsonArray("courseIds", jsonDoc), removedCourses)
        val `object` = JsonObject()
        `object`.addProperty("_id", sharedPreferences.getString("userId", ""))
        `object`.add("meetupIds", mergeJsonArray(myMeetups, getJsonArray("meetupIds", jsonDoc), removedResources))
        `object`.add("resourceIds", mergedResourceIds)
        `object`.add("courseIds", mergedCourseIds)
        return `object`
    }

    private fun mergeJsonArray(array1: JsonArray?, array2: JsonArray, removedIds: List<String>): JsonArray {
        val array = JsonArray()
        array.addAll(array1)
        for (e in array2) {
            if (!array.contains(e) && !removedIds.contains(e.asString)) {
                array.add(e)
            }
        }
        return array
    }

    companion object {
        private fun changeUserSecurity(model: RealmUserModel, obj: JsonObject) {
            val table = "userdb-${Utilities.toHex(model.planetCode)}-${Utilities.toHex(model.name)}"
            val header = "Basic ${Base64.encodeToString(("${obj["name"].asString}:${obj["password"].asString}").toByteArray(), Base64.NO_WRAP)}"
            val apiInterface = client?.create(ApiInterface::class.java)
            try {
                val response: Response<JsonObject?>? = apiInterface?.getJsonObject(header, "${UrlUtils.getUrl()}/${table}/_security")?.execute()
                if (response?.body() != null) {
                    val jsonObject = response.body()
                    val members = jsonObject?.getAsJsonObject("members")
                    val rolesArray: JsonArray = if (members?.has("roles") == true) {
                        members.getAsJsonArray("roles")
                    } else {
                        JsonArray()
                    }
                    rolesArray.add("health")
                    members?.add("roles", rolesArray)
                    jsonObject?.add("members", members)
                    apiInterface.putDoc(header, "application/json", "${UrlUtils.getUrl()}/${table}/_security", jsonObject).execute()
                }
            } catch (e: IOException) {
                e.printStackTrace()
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/SyncManager.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.content.Context
import android.content.SharedPreferences
import android.net.wifi.SupplicantState
import android.net.wifi.WifiManager
import androidx.core.content.edit
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonNull
import com.google.gson.JsonObject
import dagger.Lazy
import dagger.hilt.android.qualifiers.ApplicationContext
import io.realm.Realm
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.cancel
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.MainApplication.Companion.createLog
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.ApiClient
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.ManagerSync
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.di.ApplicationScope
import org.ole.planet.myplanet.model.RealmMeetup.Companion.insert
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.insertMyCourses
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.saveConcatenatedLinksToPrefs
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.insertMyLibrary
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.removeDeletedResource
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.save
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.insertMyTeams
import org.ole.planet.myplanet.model.RealmResourceActivity.Companion.onSynced
import org.ole.planet.myplanet.model.Rows
import org.ole.planet.myplanet.service.sync.SyncMode
import org.ole.planet.myplanet.service.sync.ThreadSafeRealmHelper
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.JsonUtils.getJsonArray
import org.ole.planet.myplanet.utilities.JsonUtils.getJsonObject
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.NotificationUtils.cancel
import org.ole.planet.myplanet.utilities.NotificationUtils.create
import org.ole.planet.myplanet.utilities.SyncTimeLogger
import org.ole.planet.myplanet.utilities.UrlUtils

@Singleton
class SyncManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val databaseService: DatabaseService,
    @AppPreferences private val settings: SharedPreferences,
    private val apiInterface: ApiInterface,
    private val improvedSyncManager: Lazy<ImprovedSyncManager>,
    @ApplicationScope private val syncScope: CoroutineScope
) {
    private var td: Thread? = null
    lateinit var mRealm: Realm
    private var isSyncing = false
    private val stringArray = arrayOfNulls<String>(4)
    private var listener: SyncListener? = null
    private var backgroundSync: Job? = null
    private var betaSync = false
    private val initializationJob: Job by lazy {
        syncScope.launch {
            improvedSyncManager.get().initialize()
        }
    }

    fun start(listener: SyncListener?, type: String, syncTables: List<String>? = null) {
        this.listener = listener
        if (!isSyncing) {
            settings.edit { remove("concatenated_links") }
            listener?.onSyncStarted()

            // Use improved sync manager if beta sync is enabled
            val useImproved = settings.getBoolean("useImprovedSync", false)
            val isSyncRequest = type.equals("sync", ignoreCase = true)
            if (useImproved && isSyncRequest) {
                initializeAndStartImprovedSync(listener, syncTables)
            } else {
                if (useImproved && !isSyncRequest) {
                    createLog("sync_manager_route", "legacy|reason=$type")
                } else if (!useImproved) {
                    createLog("sync_manager_route", "legacy")
                }
                authenticateAndSync(type, syncTables)
            }
        }
    }

    private fun initializeAndStartImprovedSync(listener: SyncListener?, syncTables: List<String>?) {
        syncScope.launch {
            try {
                initializationJob.join()

                val manager = improvedSyncManager.get()
                val syncMode = if (settings.getBoolean("fastSync", false)) {
                    SyncMode.Fast
                } else {
                    SyncMode.Standard
                }
                createLog("sync_manager_route", "improved|mode=${syncMode.javaClass.simpleName}")
                manager.start(listener, syncMode, syncTables)
            } catch (e: Exception) {
                listener?.onSyncFailed(e.message)
            }
        }
    }

    private fun destroy() {
        if (betaSync) {
            syncScope.cancel()
            ThreadSafeRealmHelper.closeThreadRealm()
        }
        cancelBackgroundSync()
        cancel(context, 111)
        isSyncing = false
        settings.edit { putLong("LastSync", Date().time) }
        listener?.onSyncComplete()
        try {
            if (!betaSync) {
                if (::mRealm.isInitialized && !mRealm.isClosed) {
                    mRealm.close()
                    td?.interrupt()
                }
            } else {
                td?.interrupt()
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun authenticateAndSync(type: String, syncTables: List<String>?) {
        td = Thread {
            if (TransactionSyncManager.authenticate()) {
                runBlocking {
                    startSync(type, syncTables)
                }
            } else {
                handleException(context.getString(R.string.invalid_configuration))
                cleanupMainSync()
            }
        }
        td?.start()
    }

    private suspend fun startSync(type: String, syncTables: List<String>?) {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (!isFastSync || type == "upload") {
            startFullSync()
        } else {
            startFastSync(syncTables)
        }
    }

    private suspend fun startFullSync() {
        try {
            val logger = SyncTimeLogger
            logger.startLogging()

            initializeSync()
            coroutineScope {
                val syncJobs = listOf(
                    async {
                        logger.startProcess("tablet_users_sync")
                        TransactionSyncManager.syncDb(mRealm, "tablet_users")
                        logger.endProcess("tablet_users_sync")
                    },
                    async {
                        logger.startProcess("library_sync")
                        myLibraryTransactionSync()
                        logger.endProcess("library_sync")
                    },
                    async { logger.startProcess("courses_sync")
                        TransactionSyncManager.syncDb(mRealm, "courses")
                        logger.endProcess("courses_sync")
                    },
                    async { logger.startProcess("exams_sync")
                        TransactionSyncManager.syncDb(mRealm, "exams")
                        logger.endProcess("exams_sync")
                    },
                    async { logger.startProcess("ratings_sync")
                        TransactionSyncManager.syncDb(mRealm, "ratings")
                        logger.endProcess("ratings_sync")
                    },
                    async { logger.startProcess("courses_progress_sync")
                        TransactionSyncManager.syncDb(mRealm, "courses_progress")
                        logger.endProcess("courses_progress_sync")
                    },
                    async { logger.startProcess("achievements_sync")
                        TransactionSyncManager.syncDb(mRealm, "achievements")
                        logger.endProcess("achievements_sync")
                    },
                    async { logger.startProcess("tags_sync")
                        TransactionSyncManager.syncDb(mRealm, "tags")
                        logger.endProcess("tags_sync")
                    },
                    async { logger.startProcess("submissions_sync")
                        TransactionSyncManager.syncDb(mRealm, "submissions")
                        logger.endProcess("submissions_sync")
                    },
                    async { logger.startProcess("news_sync")
                        TransactionSyncManager.syncDb(mRealm, "news")
                        logger.endProcess("news_sync")
                    },
                    async { logger.startProcess("feedback_sync")
                        TransactionSyncManager.syncDb(mRealm, "feedback")
                        logger.endProcess("feedback_sync")
                    },
                    async { logger.startProcess("teams_sync")
                        TransactionSyncManager.syncDb(mRealm, "teams")
                        logger.endProcess("teams_sync")
                    },
                    async { logger.startProcess("tasks_sync")
                        TransactionSyncManager.syncDb(mRealm, "tasks")
                        logger.endProcess("tasks_sync")
                    },
                    async { logger.startProcess("login_activities_sync")
                        TransactionSyncManager.syncDb(mRealm, "login_activities")
                        logger.endProcess("login_activities_sync")
                    },
                    async { logger.startProcess("meetups_sync")
                        TransactionSyncManager.syncDb(mRealm, "meetups")
                        logger.endProcess("meetups_sync")
                    },
                    async { logger.startProcess("health_sync")
                        TransactionSyncManager.syncDb(mRealm, "health")
                        logger.endProcess("health_sync")
                    },
                    async { logger.startProcess("certifications_sync")
                        TransactionSyncManager.syncDb(mRealm, "certifications")
                        logger.endProcess("certifications_sync")
                    },
                    async { logger.startProcess("team_activities_sync")
                        TransactionSyncManager.syncDb(mRealm, "team_activities")
                        logger.endProcess("team_activities_sync")
                    },
                    async { logger.startProcess("chat_history_sync")
                        TransactionSyncManager.syncDb(mRealm, "chat_history")
                        logger.endProcess("chat_history_sync")
                    }
                )
                syncJobs.awaitAll()
            }

            logger.startProcess("admin_sync")
            ManagerSync.instance.syncAdmin()
            logger.endProcess("admin_sync")

            logger.startProcess("resource_sync")
            resourceTransactionSync()
            logger.endProcess("resource_sync")

            logger.startProcess("on_synced")
            onSynced(mRealm, settings)
            logger.endProcess("on_synced")
            mRealm.close()

            logger.stopLogging()
        } catch (err: Exception) {
            err.printStackTrace()
            handleException(err.message)
        } finally {
            destroy()
        }
    }

    private suspend fun startFastSync(syncTables: List<String>? = null) {
        try {
            val logger = SyncTimeLogger
            logger.startLogging()

            initializeSync()
            coroutineScope {
                val syncJobs = mutableListOf<Deferred<Unit>>()
                if (syncTables?.contains("tablet_users") != false) {
                    syncJobs.add(
                        async {
                            logger.startProcess("tablet_users_sync")
                            TransactionSyncManager.syncDb(mRealm, "tablet_users")
                            logger.endProcess("tablet_users_sync")
                        })

                    syncJobs.add(
                        async { logger.startProcess("login_activities_sync")
                            TransactionSyncManager.syncDb(mRealm, "login_activities")
                            logger.endProcess("login_activities_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("tags_sync")
                            TransactionSyncManager.syncDb(mRealm, "tags")
                            logger.endProcess("tags_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("teams_sync")
                            TransactionSyncManager.syncDb(mRealm, "teams")
                            logger.endProcess("teams_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("news_sync")
                            TransactionSyncManager.syncDb(mRealm, "news")
                            logger.endProcess("news_sync")
                        })
                }

                if (syncTables?.contains("resources") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("library_sync")
                            myLibraryTransactionSync()
                            logger.endProcess("library_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("resource_sync")
                            resourceTransactionSync()
                            logger.endProcess("resource_sync")
                        })
                }

                if (syncTables?.contains("courses") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("library_sync")
                            myLibraryTransactionSync()
                            logger.endProcess("library_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("courses_sync")
                            TransactionSyncManager.syncDb(mRealm, "courses")
                            logger.endProcess("courses_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("courses_progress_sync")
                            TransactionSyncManager.syncDb(mRealm, "courses_progress")
                            logger.endProcess("courses_progress_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("ratings_sync")
                            TransactionSyncManager.syncDb(mRealm, "ratings")
                            logger.endProcess("ratings_sync")
                        })
                }

                if (syncTables?.contains("tasks") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("tasks_sync")
                            TransactionSyncManager.syncDb(mRealm, "tasks")
                            logger.endProcess("tasks_sync")
                        })
                }

                if (syncTables?.contains("meetups") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("meetups_sync")
                            TransactionSyncManager.syncDb(mRealm, "meetups")
                            logger.endProcess("meetups_sync")
                        })
                }

                if (syncTables?.contains("team_activities") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("team_activities_sync")
                            TransactionSyncManager.syncDb(mRealm, "team_activities")
                            logger.endProcess("team_activities_sync")
                        })
                }

                if (syncTables?.contains("chat_history") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("chat_history_sync")
                            TransactionSyncManager.syncDb(mRealm, "chat_history")
                            logger.endProcess("chat_history_sync")
                        })
                }

                if (syncTables?.contains("feedback") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("feedback_sync")
                            TransactionSyncManager.syncDb(mRealm, "feedback")
                            logger.endProcess("feedback_sync")
                        })
                }

                if (syncTables?.contains("achievements") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("achievements_sync")
                            TransactionSyncManager.syncDb(mRealm, "achievements")
                            logger.endProcess("achievements_sync")
                        })
                }

                if (syncTables?.contains("health") == true) {
                    syncJobs.add(
                        async { logger.startProcess("health_sync")
                            TransactionSyncManager.syncDb(mRealm, "health")
                            logger.endProcess("health_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("certifications_sync")
                            TransactionSyncManager.syncDb(mRealm, "certifications")
                            logger.endProcess("certifications_sync")
                        })
                }

                if (syncTables?.contains("courses") == true || syncTables?.contains("exams") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("exams_sync")
                            TransactionSyncManager.syncDb(mRealm, "exams")
                            logger.endProcess("exams_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("submissions_sync")
                            TransactionSyncManager.syncDb(mRealm, "submissions")
                            logger.endProcess("submissions_sync")
                        })
                }

                syncJobs.awaitAll()
            }

            logger.startProcess("admin_sync")
            ManagerSync.instance.syncAdmin()
            logger.endProcess("admin_sync")

            logger.startProcess("on_synced")
            onSynced(mRealm, settings)
            logger.endProcess("on_synced")
            mRealm.close()

            logger.stopLogging()
        } catch (err: Exception) {
            err.printStackTrace()
            handleException(err.message)
        } finally {
            destroy()
        }
    }

    private fun cleanupMainSync() {
        cancel(context, 111)
        isSyncing = false
        if (!betaSync) {
            try {
                if (::mRealm.isInitialized) {
                    mRealm.close()
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
            td?.interrupt()
        } else {
            td?.interrupt()
        }
    }

    private fun initializeSync() {
        val wifiManager = context.applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
        val wifiInfo = wifiManager.connectionInfo
        if (wifiInfo.supplicantState == SupplicantState.COMPLETED) {
            settings.edit { putString("LastWifiSSID", wifiInfo.ssid) }
        }
        isSyncing = true
        create(context, R.mipmap.ic_launcher, "Syncing data", "Please wait...")
        mRealm = databaseService.realmInstance
    }

    fun cancelBackgroundSync() {
        backgroundSync?.cancel()
        backgroundSync = null
    }

    private suspend fun resourceTransactionSync(backgroundRealm: Realm? = null) {
        val logger = SyncTimeLogger
        logger.startProcess("resource_sync")
        var processedItems = 0

        try {
            val realmInstance = backgroundRealm ?: mRealm
            val newIds: MutableList<String?> = ArrayList()
            var totalRows = 0
            ApiClient.executeWithRetryAndWrap {
                apiInterface.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/resources/_all_docs?limit=0").execute()
            }?.let { response ->
                response.body()?.let { body ->
                    if (body.has("total_rows")) {
                        totalRows = body.get("total_rows").asInt
                    }
                }
            }

            val batchSize = 50
            var skip = 0
            var batchCount = 0

            while (skip < totalRows || (totalRows == 0 && skip == 0)) {
                batchCount++

                try {
                    var response: JsonObject? = null
                    ApiClient.executeWithRetryAndWrap {
                        apiInterface.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/resources/_all_docs?include_docs=true&limit=$batchSize&skip=$skip").execute()
                    }?.let {
                        response = it.body()
                    }

                    if (response == null) {
                        skip += batchSize
                        continue
                    }

                    val rows = getJsonArray("rows", response)

                    if (rows.size() == 0) {
                        break
                    }

                    val batchDocuments = JsonArray()
                    val validDocuments = mutableListOf<Pair<JsonObject, String>>()

                    for (i in 0 until rows.size()) {
                        val rowObj = rows[i].asJsonObject
                        if (rowObj.has("doc")) {
                            val doc = getJsonObject("doc", rowObj)
                            val id = getString("_id", doc)

                            if (!id.startsWith("_design") && id.isNotBlank()) {
                                batchDocuments.add(doc)
                                validDocuments.add(Pair(doc, id))
                            }
                        }
                    }

                    if (validDocuments.isNotEmpty()) {
                        try {
                            val chunkSize = 10
                            val chunks = validDocuments.chunked(chunkSize)
                            val idsWeAreProcessing = validDocuments.map { it.second }

                            val savedIds = mutableListOf<String>()
                            for ((_, chunk) in chunks.withIndex()) {
                                realmInstance.executeTransaction { realm ->
                                    val chunkDocuments = JsonArray()
                                    chunk.forEach { (doc, _) -> chunkDocuments.add(doc) }

                                    val chunkIds = save(chunkDocuments, realm)
                                    savedIds.addAll(chunkIds)
                                }
                            }

                            if (savedIds.isNotEmpty()) {
                                val validIds = savedIds.filter { it.isNotBlank() }
                                if (validIds.isNotEmpty()) {
                                    newIds.addAll(validIds)
                                    processedItems += validIds.size
                                } else {
                                    newIds.addAll(idsWeAreProcessing)
                                    processedItems += idsWeAreProcessing.size
                                }
                            } else {
                                newIds.addAll(idsWeAreProcessing)
                                processedItems += idsWeAreProcessing.size
                            }
                        } catch (e: Exception) {
                            e.printStackTrace()

                            for ((doc, _) in validDocuments) {
                                try {
                                    realmInstance.executeTransaction { realm ->
                                        val singleDocArray = JsonArray()
                                        singleDocArray.add(doc)
                                        val singleIds = save(singleDocArray, realm)
                                        if (singleIds.isNotEmpty()) {
                                            newIds.addAll(singleIds)
                                            processedItems++
                                        }
                                    }
                                } catch (e2: Exception) {
                                    e2.printStackTrace()
                                }
                            }
                        }
                    }

                    skip += rows.size()
                    if (batchCount % 10 == 0) {
                        val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
                        settings.edit {
                            putLong("ResourceLastSyncTime", System.currentTimeMillis())
                            putInt("ResourceSyncPosition", skip)
                        }
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                    skip += batchSize
                }
            }

            try {
                val validNewIds = newIds.filter { !it.isNullOrBlank() }
                if (validNewIds.isNotEmpty() && validNewIds.size == newIds.size) {
                    removeDeletedResource(validNewIds, realmInstance)
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
            logger.endProcess("resource_sync", processedItems)
        } catch (e: Exception) {
            e.printStackTrace()
            logger.endProcess("resource_sync", processedItems)
        }
    }

    private fun handleException(message: String?) {
        if (listener != null) {
            isSyncing = false
            MainApplication.syncFailedCount++
            listener?.onSyncFailed(message)
        }
    }

    private suspend fun getShelvesWithDataBatchOptimized(): List<String> {
        val shelvesWithData = mutableListOf<String>()
        val cachedShelves = getCachedShelvesWithData()
        if (cachedShelves.isNotEmpty()) {
            return cachedShelves
        }

        val allShelves = ApiClient.executeWithRetryAndWrap {
            apiInterface.getDocuments(UrlUtils.header, "${UrlUtils.getUrl()}/shelf/_all_docs").execute()
        }?.body()?.rows ?: return emptyList()

        coroutineScope {
            val semaphore = Semaphore(8)
            val checkJobs = allShelves.chunked(25).map { shelfBatch ->
                async(Dispatchers.IO) {
                    semaphore.withPermit {
                        checkShelfBatchForDataOptimized(shelfBatch, apiInterface)
                    }
                }
            }

            checkJobs.awaitAll().flatten().let { validShelves ->
                shelvesWithData.addAll(validShelves)
            }
        }

        cacheShelvesWithData(shelvesWithData)
        return shelvesWithData
    }

    private suspend fun checkShelfBatchForDataOptimized(shelfBatch: List<Rows>, apiInterface: ApiInterface): List<String> {
        val shelvesWithData = mutableListOf<String>()
        val shelfIds = shelfBatch.map { it.id }
        val keysObject = JsonObject().apply {
            add("keys", Gson().fromJson(Gson().toJson(shelfIds), JsonArray::class.java))
        }

        val response = ApiClient.executeWithRetryAndWrap {
            apiInterface.findDocs(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/shelf/_all_docs?include_docs=true", keysObject).execute()
        }?.body()

        response?.let { responseBody ->
            val rows = getJsonArray("rows", responseBody)
            for (i in 0 until rows.size()) {
                val row = rows[i].asJsonObject
                if (row.has("doc")) {
                    val doc = getJsonObject("doc", row)
                    val shelfId = getString("_id", doc)

                    if (hasShelfDataUltraFast(doc)) {
                        shelvesWithData.add(shelfId)
                    }
                }
            }
        }
        return shelvesWithData
    }

    private fun hasShelfDataUltraFast(shelfDoc: JsonObject): Boolean {
        return listOf("resourceIds", "courseIds", "meetupIds", "teamIds").any { key ->
            shelfDoc.has(key) && shelfDoc.get(key).let { element ->
                element.isJsonArray && element.asJsonArray.size() > 0
            }
        }
    }

    private fun getCachedShelvesWithData(): List<String> {
        val cacheKey = "shelves_with_data"
        val cacheTimeKey = "shelves_cache_time"
        val cacheValidityHours = 6

        val cacheTime = settings.getLong(cacheTimeKey, 0)
        val now = System.currentTimeMillis()

        if (now - cacheTime < cacheValidityHours * 60 * 60 * 1000) {
            val cachedData = settings.getString(cacheKey, "") ?: ""
            if (cachedData.isNotEmpty()) {
                return cachedData.split(",").filter { it.isNotBlank() }
            }
        }
        return emptyList()
    }

    private fun cacheShelvesWithData(shelves: List<String>) {
        val cacheKey = "shelves_with_data"
        val cacheTimeKey = "shelves_cache_time"

        settings.edit {
            putString(cacheKey, shelves.joinToString(","))
            putLong(cacheTimeKey, System.currentTimeMillis())
        }
    }

    private suspend fun myLibraryTransactionSync() {
        val logger = SyncTimeLogger
        logger.startProcess("library_sync")
        var processedItems = 0

        try {
            val shelvesWithData = getShelvesWithDataBatchOptimized()

            if (shelvesWithData.isEmpty()) {
                return
            }

            coroutineScope {
                val semaphore = Semaphore(3)
                val shelfJobs = shelvesWithData.map { shelfId ->
                    async(Dispatchers.IO) {
                        semaphore.withPermit {
                            processShelfParallel(shelfId, apiInterface)
                        }
                    }
                }

                processedItems = shelfJobs.awaitAll().sum()
            }
            saveConcatenatedLinksToPrefs()
            logger.endProcess("library_sync", processedItems)
        } catch (e: Exception) {
            e.printStackTrace()
            logger.endProcess("library_sync", processedItems)
        }
    }

    private suspend fun processShelfParallel(shelfId: String, apiInterface: ApiInterface): Int {
        var processedItems = 0

        try {
            var shelfDoc: JsonObject? = null
            ApiClient.executeWithRetryAndWrap {
                apiInterface.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/shelf/$shelfId").execute()
            }?.let {
                shelfDoc = it.body()
            }

            if (shelfDoc == null) {
                return 0
            }

            coroutineScope {
                val dataJobs = Constants.shelfDataList.mapNotNull { shelfData ->
                    val array = getJsonArray(shelfData.key, shelfDoc)
                    if (array.size() > 0) {
                        async(Dispatchers.IO) {
                            processShelfDataOptimizedSync(shelfId, shelfData, shelfDoc, apiInterface)
                        }
                    } else null
                }

                processedItems = dataJobs.awaitAll().sum()
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }

        return processedItems
    }

    private suspend fun processShelfDataOptimizedSync(shelfId: String?, shelfData: Constants.ShelfData, shelfDoc: JsonObject?, apiInterface: ApiInterface): Int {
        var processedCount = 0

        try {
            val array = getJsonArray(shelfData.key, shelfDoc)
            if (array.size() == 0) return 0

            stringArray[0] = shelfId
            stringArray[1] = shelfData.categoryKey
            stringArray[2] = shelfData.type

            val validIds = mutableListOf<String>()
            for (i in 0 until array.size()) {
                if (array[i] !is JsonNull) {
                    validIds.add(array[i].asString)
                }
            }

            if (validIds.isEmpty()) return 0

            val batchSize = 25

            for (i in 0 until validIds.size step batchSize) {
                val end = minOf(i + batchSize, validIds.size)
                val batch = validIds.subList(i, end)

                val keysObject = JsonObject()
                keysObject.add("keys", Gson().fromJson(Gson().toJson(batch), JsonArray::class.java))

                var response: JsonObject? = null
                ApiClient.executeWithRetryAndWrap {
                    apiInterface.findDocs(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/${shelfData.type}/_all_docs?include_docs=true", keysObject).execute()
                }?.let {
                    response = it.body()
                }

                if (response == null) continue

                val responseRows = getJsonArray("rows", response)
                if (responseRows.size() == 0) continue

                val documentsToProcess = mutableListOf<JsonObject>()
                for (j in 0 until responseRows.size()) {
                    val rowObj = responseRows[j].asJsonObject
                    if (rowObj.has("doc")) {
                        val doc = getJsonObject("doc", rowObj)
                        documentsToProcess.add(doc)
                    }
                }

                if (documentsToProcess.isNotEmpty()) {
                    safeRealmOperation { realm ->
                        realm.executeTransaction { realmTx ->
                            documentsToProcess.forEach { doc ->
                                try {
                                    when (shelfData.type) {
                                        "resources" -> insertMyLibrary(shelfId, doc, realmTx)
                                        "meetups" -> insert(realmTx, doc)
                                        "courses" -> insertMyCourses(shelfId, doc, realmTx)
                                        "teams" -> insertMyTeams(doc, realmTx)
                                    }
                                    processedCount++
                                } catch (e: Exception) {
                                    e.printStackTrace()
                                }
                            }
                        }
                    }
                }
            }

        } catch (e: Exception) {
            e.printStackTrace()
        }
        return processedCount
    }

    private fun <T> safeRealmOperation(operation: (Realm) -> T): T? {
        return ThreadSafeRealmHelper.withRealm(databaseService, operation)
    }

}
=======
package org.ole.planet.myplanet.service


import android.content.Context
import android.content.SharedPreferences
import android.net.wifi.SupplicantState
import android.net.wifi.WifiManager
import androidx.core.content.edit
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonNull
import com.google.gson.JsonObject
import dagger.Lazy
import dagger.hilt.android.qualifiers.ApplicationContext
import io.realm.Realm
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.cancel
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.MainApplication.Companion.createLog
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.ApiClient
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.ManagerSync
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.di.ApplicationScope
import org.ole.planet.myplanet.model.RealmMeetup.Companion.insert
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.insertMyCourses
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.saveConcatenatedLinksToPrefs
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.insertMyLibrary
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.removeDeletedResource
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.save
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.insertMyTeams
import org.ole.planet.myplanet.model.RealmResourceActivity.Companion.onSynced
import org.ole.planet.myplanet.model.Rows
import org.ole.planet.myplanet.service.sync.SyncMode
import org.ole.planet.myplanet.service.sync.ThreadSafeRealmHelper
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.JsonUtils.getJsonArray
import org.ole.planet.myplanet.utilities.JsonUtils.getJsonObject
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.NotificationUtils.cancel
import org.ole.planet.myplanet.utilities.NotificationUtils.create
import org.ole.planet.myplanet.utilities.SyncTimeLogger
import org.ole.planet.myplanet.utilities.UrlUtils

@Singleton
class SyncManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val databaseService: DatabaseService,
    @AppPreferences private val settings: SharedPreferences,
    private val apiInterface: ApiInterface,
    private val improvedSyncManager: Lazy<ImprovedSyncManager>,
    @ApplicationScope private val syncScope: CoroutineScope
) {
    private var td: Thread? = null
    lateinit var mRealm: Realm
    private var isSyncing = false
    private val stringArray = arrayOfNulls<String>(4)
    private var listener: SyncListener? = null
    private var backgroundSync: Job? = null
    private var betaSync = false
    private val initializationJob: Job by lazy {
        syncScope.launch {
            improvedSyncManager.get().initialize()
        }
    }

    fun start(listener: SyncListener?, type: String, syncTables: List<String>? = null) {
        this.listener = listener
        if (!isSyncing) {
            settings.edit { remove("concatenated_links") }
            listener?.onSyncStarted()

            // Use improved sync manager if beta sync is enabled
            val useImproved = settings.getBoolean("useImprovedSync", false)
            val isSyncRequest = type.equals("sync", ignoreCase = true)
            if (useImproved && isSyncRequest) {
                initializeAndStartImprovedSync(listener, syncTables)
            } else {
                if (useImproved && !isSyncRequest) {
                    createLog("sync_manager_route", "legacy|reason=$type")
                } else if (!useImproved) {
                    createLog("sync_manager_route", "legacy")
                }
                authenticateAndSync(type, syncTables)
            }
        }
    }

    private fun initializeAndStartImprovedSync(listener: SyncListener?, syncTables: List<String>?) {
        syncScope.launch {
            try {
                initializationJob.join()

                val manager = improvedSyncManager.get()
                val syncMode = if (settings.getBoolean("fastSync", false)) {
                    SyncMode.Fast
                } else {
                    SyncMode.Standard
                }
                createLog("sync_manager_route", "improved|mode=${syncMode.javaClass.simpleName}")
                manager.start(listener, syncMode, syncTables)
            } catch (e: Exception) {
                listener?.onSyncFailed(e.message)
            }
        }
    }

    private fun destroy() {
        if (betaSync) {
            syncScope.cancel()
            ThreadSafeRealmHelper.closeThreadRealm()
        }
        cancelBackgroundSync()
        cancel(context, 111)
        isSyncing = false
        settings.edit { putLong("LastSync", Date().time) }
        listener?.onSyncComplete()
        try {
            if (!betaSync) {
                if (::mRealm.isInitialized && !mRealm.isClosed) {
                    mRealm.close()
                    td?.interrupt()
                }
            } else {
                td?.interrupt()
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun authenticateAndSync(type: String, syncTables: List<String>?) {
        td = Thread {
            if (TransactionSyncManager.authenticate()) {
                runBlocking {
                    startSync(type, syncTables)
                }
            } else {
                handleException(context.getString(R.string.invalid_configuration))
                cleanupMainSync()
            }
        }
        td?.start()
    }

    private suspend fun startSync(type: String, syncTables: List<String>?) {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (!isFastSync || type == "upload") {
            startFullSync()
        } else {
            startFastSync(syncTables)
        }
    }

    private suspend fun startFullSync() {
        try {
            val logger = SyncTimeLogger
            logger.startLogging()

            initializeSync()
            coroutineScope {
                val syncJobs = listOf(
                    async {
                        logger.startProcess("tablet_users_sync")
                        TransactionSyncManager.syncDb(mRealm, "tablet_users")
                        logger.endProcess("tablet_users_sync")
                    },
                    async {
                        logger.startProcess("library_sync")
                        myLibraryTransactionSync()
                        logger.endProcess("library_sync")
                    },
                    async { logger.startProcess("courses_sync")
                        TransactionSyncManager.syncDb(mRealm, "courses")
                        logger.endProcess("courses_sync")
                    },
                    async { logger.startProcess("exams_sync")
                        TransactionSyncManager.syncDb(mRealm, "exams")
                        logger.endProcess("exams_sync")
                    },
                    async { logger.startProcess("ratings_sync")
                        TransactionSyncManager.syncDb(mRealm, "ratings")
                        logger.endProcess("ratings_sync")
                    },
                    async { logger.startProcess("courses_progress_sync")
                        TransactionSyncManager.syncDb(mRealm, "courses_progress")
                        logger.endProcess("courses_progress_sync")
                    },
                    async { logger.startProcess("achievements_sync")
                        TransactionSyncManager.syncDb(mRealm, "achievements")
                        logger.endProcess("achievements_sync")
                    },
                    async { logger.startProcess("tags_sync")
                        TransactionSyncManager.syncDb(mRealm, "tags")
                        logger.endProcess("tags_sync")
                    },
                    async { logger.startProcess("submissions_sync")
                        TransactionSyncManager.syncDb(mRealm, "submissions")
                        logger.endProcess("submissions_sync")
                    },
                    async { logger.startProcess("news_sync")
                        TransactionSyncManager.syncDb(mRealm, "news")
                        logger.endProcess("news_sync")
                    },
                    async { logger.startProcess("feedback_sync")
                        TransactionSyncManager.syncDb(mRealm, "feedback")
                        logger.endProcess("feedback_sync")
                    },
                    async { logger.startProcess("teams_sync")
                        TransactionSyncManager.syncDb(mRealm, "teams")
                        logger.endProcess("teams_sync")
                    },
                    async { logger.startProcess("tasks_sync")
                        TransactionSyncManager.syncDb(mRealm, "tasks")
                        logger.endProcess("tasks_sync")
                    },
                    async { logger.startProcess("login_activities_sync")
                        TransactionSyncManager.syncDb(mRealm, "login_activities")
                        logger.endProcess("login_activities_sync")
                    },
                    async { logger.startProcess("meetups_sync")
                        TransactionSyncManager.syncDb(mRealm, "meetups")
                        logger.endProcess("meetups_sync")
                    },
                    async { logger.startProcess("health_sync")
                        TransactionSyncManager.syncDb(mRealm, "health")
                        logger.endProcess("health_sync")
                    },
                    async { logger.startProcess("certifications_sync")
                        TransactionSyncManager.syncDb(mRealm, "certifications")
                        logger.endProcess("certifications_sync")
                    },
                    async { logger.startProcess("team_activities_sync")
                        TransactionSyncManager.syncDb(mRealm, "team_activities")
                        logger.endProcess("team_activities_sync")
                    },
                    async { logger.startProcess("chat_history_sync")
                        TransactionSyncManager.syncDb(mRealm, "chat_history")
                        logger.endProcess("chat_history_sync")
                    }
                )
                syncJobs.awaitAll()
            }

            logger.startProcess("admin_sync")
            ManagerSync.instance.syncAdmin()
            logger.endProcess("admin_sync")

            logger.startProcess("resource_sync")
            resourceTransactionSync()
            logger.endProcess("resource_sync")

            logger.startProcess("on_synced")
            onSynced(mRealm, settings)
            logger.endProcess("on_synced")
            mRealm.close()

            logger.stopLogging()
        } catch (err: Exception) {
            err.printStackTrace()
            handleException(err.message)
        } finally {
            destroy()
        }
    }

    private suspend fun startFastSync(syncTables: List<String>? = null) {
        try {
            val logger = SyncTimeLogger
            logger.startLogging()

            initializeSync()
            coroutineScope {
                val syncJobs = mutableListOf<Deferred<Unit>>()
                if (syncTables?.contains("tablet_users") != false) {
                    syncJobs.add(
                        async {
                            logger.startProcess("tablet_users_sync")
                            TransactionSyncManager.syncDb(mRealm, "tablet_users")
                            logger.endProcess("tablet_users_sync")
                        })

                    syncJobs.add(
                        async { logger.startProcess("login_activities_sync")
                            TransactionSyncManager.syncDb(mRealm, "login_activities")
                            logger.endProcess("login_activities_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("tags_sync")
                            TransactionSyncManager.syncDb(mRealm, "tags")
                            logger.endProcess("tags_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("teams_sync")
                            TransactionSyncManager.syncDb(mRealm, "teams")
                            logger.endProcess("teams_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("news_sync")
                            TransactionSyncManager.syncDb(mRealm, "news")
                            logger.endProcess("news_sync")
                        })
                }

                if (syncTables?.contains("resources") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("library_sync")
                            myLibraryTransactionSync()
                            logger.endProcess("library_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("resource_sync")
                            resourceTransactionSync()
                            logger.endProcess("resource_sync")
                        })
                }

                if (syncTables?.contains("courses") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("library_sync")
                            myLibraryTransactionSync()
                            logger.endProcess("library_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("courses_sync")
                            TransactionSyncManager.syncDb(mRealm, "courses")
                            logger.endProcess("courses_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("courses_progress_sync")
                            TransactionSyncManager.syncDb(mRealm, "courses_progress")
                            logger.endProcess("courses_progress_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("ratings_sync")
                            TransactionSyncManager.syncDb(mRealm, "ratings")
                            logger.endProcess("ratings_sync")
                        })
                }

                if (syncTables?.contains("tasks") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("tasks_sync")
                            TransactionSyncManager.syncDb(mRealm, "tasks")
                            logger.endProcess("tasks_sync")
                        })
                }

                if (syncTables?.contains("meetups") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("meetups_sync")
                            TransactionSyncManager.syncDb(mRealm, "meetups")
                            logger.endProcess("meetups_sync")
                        })
                }

                if (syncTables?.contains("team_activities") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("team_activities_sync")
                            TransactionSyncManager.syncDb(mRealm, "team_activities")
                            logger.endProcess("team_activities_sync")
                        })
                }

                if (syncTables?.contains("chat_history") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("chat_history_sync")
                            TransactionSyncManager.syncDb(mRealm, "chat_history")
                            logger.endProcess("chat_history_sync")
                        })
                }

                if (syncTables?.contains("feedback") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("feedback_sync")
                            TransactionSyncManager.syncDb(mRealm, "feedback")
                            logger.endProcess("feedback_sync")
                        })
                }

                if (syncTables?.contains("achievements") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("achievements_sync")
                            TransactionSyncManager.syncDb(mRealm, "achievements")
                            logger.endProcess("achievements_sync")
                        })
                }

                if (syncTables?.contains("health") == true) {
                    syncJobs.add(
                        async { logger.startProcess("health_sync")
                            TransactionSyncManager.syncDb(mRealm, "health")
                            logger.endProcess("health_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("certifications_sync")
                            TransactionSyncManager.syncDb(mRealm, "certifications")
                            logger.endProcess("certifications_sync")
                        })
                }

                if (syncTables?.contains("courses") == true || syncTables?.contains("exams") == true) {
                    syncJobs.add(
                        async {
                            logger.startProcess("exams_sync")
                            TransactionSyncManager.syncDb(mRealm, "exams")
                            logger.endProcess("exams_sync")
                        })

                    syncJobs.add(
                        async {
                            logger.startProcess("submissions_sync")
                            TransactionSyncManager.syncDb(mRealm, "submissions")
                            logger.endProcess("submissions_sync")
                        })
                }

                syncJobs.awaitAll()
            }

            logger.startProcess("admin_sync")
            ManagerSync.instance.syncAdmin()
            logger.endProcess("admin_sync")

            logger.startProcess("on_synced")
            onSynced(mRealm, settings)
            logger.endProcess("on_synced")
            mRealm.close()

            logger.stopLogging()
        } catch (err: Exception) {
            err.printStackTrace()
            handleException(err.message)
        } finally {
            destroy()
        }
    }

    private fun cleanupMainSync() {
        cancel(context, 111)
        isSyncing = false
        if (!betaSync) {
            try {
                if (::mRealm.isInitialized) {
                    mRealm.close()
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
            td?.interrupt()
        } else {
            td?.interrupt()
        }
    }

    private fun initializeSync() {
        val wifiManager = context.applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
        val wifiInfo = wifiManager.connectionInfo
        if (wifiInfo.supplicantState == SupplicantState.COMPLETED) {
            settings.edit { putString("LastWifiSSID", wifiInfo.ssid) }
        }
        isSyncing = true
        create(context, R.mipmap.ic_launcher, "Syncing data", "Please wait...")
        mRealm = databaseService.realmInstance
    }

    fun cancelBackgroundSync() {
        backgroundSync?.cancel()
        backgroundSync = null
    }

    private suspend fun resourceTransactionSync(backgroundRealm: Realm? = null) {
        val logger = SyncTimeLogger
        logger.startProcess("resource_sync")
        var processedItems = 0

        try {
            val realmInstance = backgroundRealm ?: mRealm
            val newIds: MutableList<String?> = ArrayList()
            var totalRows = 0
            ApiClient.executeWithRetryAndWrap {
                apiInterface.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/resources/_all_docs?limit=0").execute()
            }?.let { response ->
                response.body()?.let { body ->
                    if (body.has("total_rows")) {
                        totalRows = body.get("total_rows").asInt
                    }
                }
            }

            val batchSize = 50
            var skip = 0
            var batchCount = 0

            while (skip < totalRows || (totalRows == 0 && skip == 0)) {
                batchCount++

                try {
                    var response: JsonObject? = null
                    ApiClient.executeWithRetryAndWrap {
                        apiInterface.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/resources/_all_docs?include_docs=true&limit=$batchSize&skip=$skip").execute()
                    }?.let {
                        response = it.body()
                    }

                    if (response == null) {
                        skip += batchSize
                        continue
                    }

                    val rows = getJsonArray("rows", response)

                    if (rows.size() == 0) {
                        break
                    }

                    val batchDocuments = JsonArray()
                    val validDocuments = mutableListOf<Pair<JsonObject, String>>()

                    for (i in 0 until rows.size()) {
                        val rowObj = rows[i].asJsonObject
                        if (rowObj.has("doc")) {
                            val doc = getJsonObject("doc", rowObj)
                            val id = getString("_id", doc)

                            if (!id.startsWith("_design") && id.isNotBlank()) {
                                batchDocuments.add(doc)
                                validDocuments.add(Pair(doc, id))
                            }
                        }
                    }

                    if (validDocuments.isNotEmpty()) {
                        try {
                            val chunkSize = 10
                            val chunks = validDocuments.chunked(chunkSize)
                            val idsWeAreProcessing = validDocuments.map { it.second }

                            val savedIds = mutableListOf<String>()
                            for ((_, chunk) in chunks.withIndex()) {
                                realmInstance.executeTransaction { realm ->
                                    val chunkDocuments = JsonArray()
                                    chunk.forEach { (doc, _) -> chunkDocuments.add(doc) }

                                    val chunkIds = save(chunkDocuments, realm)
                                    savedIds.addAll(chunkIds)
                                }
                            }

                            if (savedIds.isNotEmpty()) {
                                val validIds = savedIds.filter { it.isNotBlank() }
                                if (validIds.isNotEmpty()) {
                                    newIds.addAll(validIds)
                                    processedItems += validIds.size
                                } else {
                                    newIds.addAll(idsWeAreProcessing)
                                    processedItems += idsWeAreProcessing.size
                                }
                            } else {
                                newIds.addAll(idsWeAreProcessing)
                                processedItems += idsWeAreProcessing.size
                            }
                        } catch (e: Exception) {
                            e.printStackTrace()

                            for ((doc, _) in validDocuments) {
                                try {
                                    realmInstance.executeTransaction { realm ->
                                        val singleDocArray = JsonArray()
                                        singleDocArray.add(doc)
                                        val singleIds = save(singleDocArray, realm)
                                        if (singleIds.isNotEmpty()) {
                                            newIds.addAll(singleIds)
                                            processedItems++
                                        }
                                    }
                                } catch (e2: Exception) {
                                    e2.printStackTrace()
                                }
                            }
                        }
                    }

                    skip += rows.size()
                    if (batchCount % 10 == 0) {
                        val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
                        settings.edit {
                            putLong("ResourceLastSyncTime", System.currentTimeMillis())
                            putInt("ResourceSyncPosition", skip)
                        }
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                    skip += batchSize
                }
            }

            try {
                val validNewIds = newIds.filter { !it.isNullOrBlank() }
                if (validNewIds.isNotEmpty() && validNewIds.size == newIds.size) {
                    removeDeletedResource(validNewIds, realmInstance)
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
            logger.endProcess("resource_sync", processedItems)
        } catch (e: Exception) {
            e.printStackTrace()
            logger.endProcess("resource_sync", processedItems)
        }
    }

    private fun handleException(message: String?) {
        if (listener != null) {
            isSyncing = false
            MainApplication.syncFailedCount++
            listener?.onSyncFailed(message)
        }
    }

    private suspend fun getShelvesWithDataBatchOptimized(): List<String> {
        val shelvesWithData = mutableListOf<String>()
        val cachedShelves = getCachedShelvesWithData()
        if (cachedShelves.isNotEmpty()) {
            return cachedShelves
        }

        val allShelves = ApiClient.executeWithRetryAndWrap {
            apiInterface.getDocuments(UrlUtils.header, "${UrlUtils.getUrl()}/shelf/_all_docs").execute()
        }?.body()?.rows ?: return emptyList()

        coroutineScope {
            val semaphore = Semaphore(8)
            val checkJobs = allShelves.chunked(25).map { shelfBatch ->
                async(Dispatchers.IO) {
                    semaphore.withPermit {
                        checkShelfBatchForDataOptimized(shelfBatch, apiInterface)
                    }
                }
            }

            checkJobs.awaitAll().flatten().let { validShelves ->
                shelvesWithData.addAll(validShelves)
            }
        }

        cacheShelvesWithData(shelvesWithData)
        return shelvesWithData
    }

    private suspend fun checkShelfBatchForDataOptimized(shelfBatch: List<Rows>, apiInterface: ApiInterface): List<String> {
        val shelvesWithData = mutableListOf<String>()
        val shelfIds = shelfBatch.map { it.id }
        val keysObject = JsonObject().apply {
            add("keys", Gson().fromJson(Gson().toJson(shelfIds), JsonArray::class.java))
        }

        val response = ApiClient.executeWithRetryAndWrap {
            apiInterface.findDocs(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/shelf/_all_docs?include_docs=true", keysObject).execute()
        }?.body()

        response?.let { responseBody ->
            val rows = getJsonArray("rows", responseBody)
            for (i in 0 until rows.size()) {
                val row = rows[i].asJsonObject
                if (row.has("doc")) {
                    val doc = getJsonObject("doc", row)
                    val shelfId = getString("_id", doc)

                    if (hasShelfDataUltraFast(doc)) {
                        shelvesWithData.add(shelfId)
                    }
                }
            }
        }
        return shelvesWithData
    }

    private fun hasShelfDataUltraFast(shelfDoc: JsonObject): Boolean {
        return listOf("resourceIds", "courseIds", "meetupIds", "teamIds").any { key ->
            shelfDoc.has(key) && shelfDoc.get(key).let { element ->
                element.isJsonArray && element.asJsonArray.size() > 0
            }
        }
    }

    private fun getCachedShelvesWithData(): List<String> {
        val cacheKey = "shelves_with_data"
        val cacheTimeKey = "shelves_cache_time"
        val cacheValidityHours = 6

        val cacheTime = settings.getLong(cacheTimeKey, 0)
        val now = System.currentTimeMillis()

        if (now - cacheTime < cacheValidityHours * 60 * 60 * 1000) {
            val cachedData = settings.getString(cacheKey, "") ?: ""
            if (cachedData.isNotEmpty()) {
                return cachedData.split(",").filter { it.isNotBlank() }
            }
        }
        return emptyList()
    }

    private fun cacheShelvesWithData(shelves: List<String>) {
        val cacheKey = "shelves_with_data"
        val cacheTimeKey = "shelves_cache_time"

        settings.edit {
            putString(cacheKey, shelves.joinToString(","))
            putLong(cacheTimeKey, System.currentTimeMillis())
        }
    }

    private suspend fun myLibraryTransactionSync() {
        val logger = SyncTimeLogger
        logger.startProcess("library_sync")
        var processedItems = 0

        try {
            val shelvesWithData = getShelvesWithDataBatchOptimized()

            if (shelvesWithData.isEmpty()) {
                return
            }

            coroutineScope {
                val semaphore = Semaphore(3)
                val shelfJobs = shelvesWithData.map { shelfId ->
                    async(Dispatchers.IO) {
                        semaphore.withPermit {
                            processShelfParallel(shelfId, apiInterface)
                        }
                    }
                }

                processedItems = shelfJobs.awaitAll().sum()
            }
            saveConcatenatedLinksToPrefs()
            logger.endProcess("library_sync", processedItems)
        } catch (e: Exception) {
            e.printStackTrace()
            logger.endProcess("library_sync", processedItems)
        }
    }

    private suspend fun processShelfParallel(shelfId: String, apiInterface: ApiInterface): Int {
        var processedItems = 0

        try {
            var shelfDoc: JsonObject? = null
            ApiClient.executeWithRetryAndWrap {
                apiInterface.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/shelf/$shelfId").execute()
            }?.let {
                shelfDoc = it.body()
            }

            if (shelfDoc == null) {
                return 0
            }

            coroutineScope {
                val dataJobs = Constants.shelfDataList.mapNotNull { shelfData ->
                    val array = getJsonArray(shelfData.key, shelfDoc)
                    if (array.size() > 0) {
                        async(Dispatchers.IO) {
                            processShelfDataOptimizedSync(shelfId, shelfData, shelfDoc, apiInterface)
                        }
                    } else null
                }

                processedItems = dataJobs.awaitAll().sum()
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }

        return processedItems
    }

    private suspend fun processShelfDataOptimizedSync(shelfId: String?, shelfData: Constants.ShelfData, shelfDoc: JsonObject?, apiInterface: ApiInterface): Int {
        var processedCount = 0

        try {
            val array = getJsonArray(shelfData.key, shelfDoc)
            if (array.size() == 0) return 0

            stringArray[0] = shelfId
            stringArray[1] = shelfData.categoryKey
            stringArray[2] = shelfData.type

            val validIds = mutableListOf<String>()
            for (i in 0 until array.size()) {
                if (array[i] !is JsonNull) {
                    validIds.add(array[i].asString)
                }
            }

            if (validIds.isEmpty()) return 0

            val batchSize = 25

            for (i in 0 until validIds.size step batchSize) {
                val end = minOf(i + batchSize, validIds.size)
                val batch = validIds.subList(i, end)

                val keysObject = JsonObject()
                keysObject.add("keys", Gson().fromJson(Gson().toJson(batch), JsonArray::class.java))

                var response: JsonObject? = null
                ApiClient.executeWithRetryAndWrap {
                    apiInterface.findDocs(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/${shelfData.type}/_all_docs?include_docs=true", keysObject).execute()
                }?.let {
                    response = it.body()
                }

                if (response == null) continue

                val responseRows = getJsonArray("rows", response)
                if (responseRows.size() == 0) continue

                val documentsToProcess = mutableListOf<JsonObject>()
                for (j in 0 until responseRows.size()) {
                    val rowObj = responseRows[j].asJsonObject
                    if (rowObj.has("doc")) {
                        val doc = getJsonObject("doc", rowObj)
                        documentsToProcess.add(doc)
                    }
                }

                if (documentsToProcess.isNotEmpty()) {
                    safeRealmOperation { realm ->
                        realm.executeTransaction { realmTx ->
                            documentsToProcess.forEach { doc ->
                                try {
                                    when (shelfData.type) {
                                        "resources" -> insertMyLibrary(shelfId, doc, realmTx)
                                        "meetups" -> insert(realmTx, doc)
                                        "courses" -> insertMyCourses(shelfId, doc, realmTx)
                                        "teams" -> insertMyTeams(doc, realmTx)
                                    }
                                    processedCount++
                                } catch (e: Exception) {
                                    e.printStackTrace()
                                }
                            }
                        }
                    }
                }
            }

        } catch (e: Exception) {
            e.printStackTrace()
        }
        return processedCount
    }

    private fun <T> safeRealmOperation(operation: (Realm) -> T): T? {
        return ThreadSafeRealmHelper.withRealm(databaseService, operation)
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/UserProfileDbHandler.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.content.Context
import android.content.SharedPreferences
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.android.qualifiers.ApplicationContext
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.di.ApplicationScope
import org.ole.planet.myplanet.di.ServiceEntryPoint
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmOfflineActivity
import org.ole.planet.myplanet.model.RealmResourceActivity
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Utilities

class UserProfileDbHandler @Inject constructor(
    @ApplicationContext private val context: Context,
    private val realmService: DatabaseService,
    @AppPreferences private val settings: SharedPreferences,
    @ApplicationScope private val applicationScope: CoroutineScope
) {
    private val fullName: String

    constructor(context: Context) : this(
        context,
        DatabaseService(context),
        context.getSharedPreferences(Constants.PREFS_NAME, Context.MODE_PRIVATE),
        EntryPointAccessors.fromApplication(
            context.applicationContext, ServiceEntryPoint::class.java
        ).applicationScope()
    )

    init {
        try {
            fullName = Utilities.getUserName(settings)
        } catch (e: IllegalArgumentException) {
            throw e
        }
    }

    val userModel: RealmUserModel? get() = getUserModelCopy()

    fun getUserModelCopy(): RealmUserModel? {
        val userId = settings.getString("userId", null)?.takeUnless { it.isBlank() } ?: return null
        return realmService.withRealm { realm ->
            realm.where(RealmUserModel::class.java)
                .equalTo("id", userId)
                .or()
                .equalTo("_id", userId)
                .findFirst()
                ?.let { realm.copyFromRealm(it) }
        }
    }

    fun onLogin() {
        onLoginAsync()
    }

    fun onLoginAsync(callback: (() -> Unit)? = null, onError: ((Throwable) -> Unit)? = null) {
        applicationScope.launch(Dispatchers.IO) {
            try {
                val model = getUserModelCopy()
                val userId = model?.id
                val userName = model?.name
                val parentCode = model?.parentCode
                val planetCode = model?.planetCode

                realmService.executeTransactionAsync { realm ->
                    val offlineActivities = realm.createObject(RealmOfflineActivity::class.java, UUID.randomUUID().toString())
                    offlineActivities.userId = userId
                    offlineActivities.userName = userName
                    offlineActivities.parentCode = parentCode
                    offlineActivities.createdOn = planetCode
                    offlineActivities.type = KEY_LOGIN
                    offlineActivities._rev = null
                    offlineActivities._id = null
                    offlineActivities.description = "Member login on offline application"
                    offlineActivities.loginTime = Date().time
                }
                withContext(Dispatchers.Main) {
                    callback?.invoke()
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    onError?.invoke(e)
                }
            }
        }
    }

    fun logoutAsync() {
        applicationScope.launch(Dispatchers.IO) {
            try {
                realmService.executeTransactionAsync { realm ->
                    RealmOfflineActivity.getRecentLogin(realm)
                        ?.logoutTime = Date().time
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }


    val lastVisit: Long? get() = realmService.withRealm { realm ->
        realm.where(RealmOfflineActivity::class.java).max("loginTime") as Long?
    }
    val offlineVisits: Int get() = getOfflineVisits(userModel)

    fun getOfflineVisits(m: RealmUserModel?): Int {
        return realmService.withRealm { realm ->
            val dbUsers = realm.where(RealmOfflineActivity::class.java)
                .equalTo("userName", m?.name)
                .equalTo("type", KEY_LOGIN)
                .findAll()
            if (!dbUsers.isEmpty()) {
                dbUsers.size
            } else {
                0
            }
        }
    }

    fun getLastVisit(m: RealmUserModel): String {
        return realmService.withRealm { realm ->
            val lastLogoutTimestamp = realm.where(RealmOfflineActivity::class.java)
                .equalTo("userName", m.name)
                .max("loginTime") as Long?
            if (lastLogoutTimestamp != null) {
                val date = Date(lastLogoutTimestamp)
                SimpleDateFormat("MMMM dd, yyyy hh:mm a", Locale.getDefault()).format(date)
            } else {
                "No logout record found"
            }
        }
    }

    fun setResourceOpenCount(item: RealmMyLibrary) {
        setResourceOpenCount(item, KEY_RESOURCE_OPEN)
    }

    fun setResourceOpenCount(item: RealmMyLibrary, type: String?) {
        val itemTitle = item.title
        val itemResourceId = item.resourceId

        applicationScope.launch(Dispatchers.IO) {
            try {
                val model = getUserModelCopy()
                if (model?.id?.startsWith("guest") == true) {
                    return@launch
                }

                val userName = model?.name
                val parentCode = model?.parentCode
                val planetCode = model?.planetCode

                realmService.executeTransactionAsync { realm ->
                    val offlineActivities = realm.createObject(RealmResourceActivity::class.java, "${UUID.randomUUID()}")
                    offlineActivities.user = userName
                    offlineActivities.parentCode = parentCode
                    offlineActivities.createdOn = planetCode
                    offlineActivities.type = type
                    offlineActivities.title = itemTitle
                    offlineActivities.resourceId = itemResourceId
                    offlineActivities.time = Date().time
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    val numberOfResourceOpen: String
        get() = realmService.withRealm { realm ->
            val count = realm.where(RealmResourceActivity::class.java)
                .equalTo("user", fullName)
                .equalTo("type", KEY_RESOURCE_OPEN)
                .count()
            if (count == 0L) "" else "Resource opened $count times."
        }

    val maxOpenedResource: String
        get() = realmService.withRealm { realm ->
            val result = realm.where(RealmResourceActivity::class.java)
                .equalTo("user", fullName)
                .equalTo("type", KEY_RESOURCE_OPEN)
                .findAll()
                .where()
                .distinct("resourceId")
                .findAll()

            var maxCount = 0L
            var maxOpenedResource = ""

            for (realmResourceActivities in result) {
                val count = realm.where(RealmResourceActivity::class.java)
                    .equalTo("user", fullName)
                    .equalTo("type", KEY_RESOURCE_OPEN)
                    .equalTo("resourceId", realmResourceActivities.resourceId)
                    .count()

                if (count > maxCount) {
                    maxCount = count
                    maxOpenedResource = "${realmResourceActivities.title}"
                }
            }

            if (maxCount == 0L) "" else "$maxOpenedResource opened $maxCount times"
        }

    companion object {
        const val KEY_LOGIN = "login"
        const val KEY_RESOURCE_OPEN = "visit"
        const val KEY_RESOURCE_DOWNLOAD = "download"
    }
}
=======
package org.ole.planet.myplanet.service


import android.content.Context
import android.content.SharedPreferences
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.android.qualifiers.ApplicationContext
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.di.ApplicationScope
import org.ole.planet.myplanet.di.ServiceEntryPoint
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmOfflineActivity
import org.ole.planet.myplanet.model.RealmResourceActivity
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Utilities

class UserProfileDbHandler @Inject constructor(
    @ApplicationContext private val context: Context,
    private val realmService: DatabaseService,
    @AppPreferences private val settings: SharedPreferences,
    @ApplicationScope private val applicationScope: CoroutineScope
) {
    private val fullName: String

    constructor(context: Context) : this(
        context,
        DatabaseService(context),
        context.getSharedPreferences(Constants.PREFS_NAME, Context.MODE_PRIVATE),
        EntryPointAccessors.fromApplication(
            context.applicationContext, ServiceEntryPoint::class.java
        ).applicationScope()
    )

    init {
        try {
            fullName = Utilities.getUserName(settings)
        } catch (e: IllegalArgumentException) {
            throw e
        }
    }

    val userModel: RealmUserModel? get() = getUserModelCopy()

    fun getUserModelCopy(): RealmUserModel? {
        val userId = settings.getString("userId", null)?.takeUnless { it.isBlank() } ?: return null
        return realmService.withRealm { realm ->
            realm.where(RealmUserModel::class.java)
                .equalTo("id", userId)
                .or()
                .equalTo("_id", userId)
                .findFirst()
                ?.let { realm.copyFromRealm(it) }
        }
    }

    fun onLogin() {
        onLoginAsync()
    }

    fun onLoginAsync(callback: (() -> Unit)? = null, onError: ((Throwable) -> Unit)? = null) {
        applicationScope.launch(Dispatchers.IO) {
            try {
                val model = getUserModelCopy()
                val userId = model?.id
                val userName = model?.name
                val parentCode = model?.parentCode
                val planetCode = model?.planetCode

                realmService.executeTransactionAsync { realm ->
                    val offlineActivities = realm.createObject(RealmOfflineActivity::class.java, UUID.randomUUID().toString())
                    offlineActivities.userId = userId
                    offlineActivities.userName = userName
                    offlineActivities.parentCode = parentCode
                    offlineActivities.createdOn = planetCode
                    offlineActivities.type = KEY_LOGIN
                    offlineActivities._rev = null
                    offlineActivities._id = null
                    offlineActivities.description = "Member login on offline application"
                    offlineActivities.loginTime = Date().time
                }
                withContext(Dispatchers.Main) {
                    callback?.invoke()
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    onError?.invoke(e)
                }
            }
        }
    }

    fun logoutAsync() {
        applicationScope.launch(Dispatchers.IO) {
            try {
                realmService.executeTransactionAsync { realm ->
                    RealmOfflineActivity.getRecentLogin(realm)
                        ?.logoutTime = Date().time
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }


    val lastVisit: Long? get() = realmService.withRealm { realm ->
        realm.where(RealmOfflineActivity::class.java).max("loginTime") as Long?
    }
    val offlineVisits: Int get() = getOfflineVisits(userModel)

    fun getOfflineVisits(m: RealmUserModel?): Int {
        return realmService.withRealm { realm ->
            val dbUsers = realm.where(RealmOfflineActivity::class.java)
                .equalTo("userName", m?.name)
                .equalTo("type", KEY_LOGIN)
                .findAll()
            if (!dbUsers.isEmpty()) {
                dbUsers.size
            } else {
                0
            }
        }
    }

    fun getLastVisit(m: RealmUserModel): String {
        return realmService.withRealm { realm ->
            val lastLogoutTimestamp = realm.where(RealmOfflineActivity::class.java)
                .equalTo("userName", m.name)
                .max("loginTime") as Long?
            if (lastLogoutTimestamp != null) {
                val date = Date(lastLogoutTimestamp)
                SimpleDateFormat("MMMM dd, yyyy hh:mm a", Locale.getDefault()).format(date)
            } else {
                "No logout record found"
            }
        }
    }

    fun setResourceOpenCount(item: RealmMyLibrary) {
        setResourceOpenCount(item, KEY_RESOURCE_OPEN)
    }

    fun setResourceOpenCount(item: RealmMyLibrary, type: String?) {
        val itemTitle = item.title
        val itemResourceId = item.resourceId

        applicationScope.launch(Dispatchers.IO) {
            try {
                val model = getUserModelCopy()
                if (model?.id?.startsWith("guest") == true) {
                    return@launch
                }

                val userName = model?.name
                val parentCode = model?.parentCode
                val planetCode = model?.planetCode

                realmService.executeTransactionAsync { realm ->
                    val offlineActivities = realm.createObject(RealmResourceActivity::class.java, "${UUID.randomUUID()}")
                    offlineActivities.user = userName
                    offlineActivities.parentCode = parentCode
                    offlineActivities.createdOn = planetCode
                    offlineActivities.type = type
                    offlineActivities.title = itemTitle
                    offlineActivities.resourceId = itemResourceId
                    offlineActivities.time = Date().time
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    val numberOfResourceOpen: String
        get() = realmService.withRealm { realm ->
            val count = realm.where(RealmResourceActivity::class.java)
                .equalTo("user", fullName)
                .equalTo("type", KEY_RESOURCE_OPEN)
                .count()
            if (count == 0L) "" else "Resource opened $count times."
        }

    val maxOpenedResource: String
        get() = realmService.withRealm { realm ->
            val result = realm.where(RealmResourceActivity::class.java)
                .equalTo("user", fullName)
                .equalTo("type", KEY_RESOURCE_OPEN)
                .findAll()
                .where()
                .distinct("resourceId")
                .findAll()

            var maxCount = 0L
            var maxOpenedResource = ""

            for (realmResourceActivities in result) {
                val count = realm.where(RealmResourceActivity::class.java)
                    .equalTo("user", fullName)
                    .equalTo("type", KEY_RESOURCE_OPEN)
                    .equalTo("resourceId", realmResourceActivities.resourceId)
                    .count()

                if (count > maxCount) {
                    maxCount = count
                    maxOpenedResource = "${realmResourceActivities.title}"
                }
            }

            if (maxCount == 0L) "" else "$maxOpenedResource opened $maxCount times"
        }

    companion object {
        const val KEY_LOGIN = "login"
        const val KEY_RESOURCE_OPEN = "visit"
        const val KEY_RESOURCE_DOWNLOAD = "download"
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/BroadcastService.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.content.Intent
import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.asSharedFlow

@Singleton
class BroadcastService @Inject constructor() {
    private val _events = MutableSharedFlow<Intent>()
    val events = _events.asSharedFlow()

    suspend fun sendBroadcast(intent: Intent) {
        _events.emit(intent)
    }
}
=======
package org.ole.planet.myplanet.service


import android.content.Intent
import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.asSharedFlow

@Singleton
class BroadcastService @Inject constructor() {
    private val _events = MutableSharedFlow<Intent>()
    val events = _events.asSharedFlow()

    suspend fun sendBroadcast(intent: Intent) {
        _events.emit(intent)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/sync/ThreadSafeRealmHelper.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service.sync

import io.realm.Realm
import org.ole.planet.myplanet.datamanager.DatabaseService

object ThreadSafeRealmHelper {

    private val threadLocalRealm = ThreadLocal<Realm?>()

    fun <T> withRealm(databaseService: DatabaseService, operation: (Realm) -> T): T? {
        return try {
            // Get or create Realm instance for current thread
            val realm = threadLocalRealm.get() ?: run {
                val newRealm = databaseService.realmInstance
                threadLocalRealm.set(newRealm)
                newRealm
            }

            if (realm.isClosed) {
                // If realm is closed, create a new one
                val newRealm = databaseService.realmInstance
                threadLocalRealm.set(newRealm)
                operation(newRealm)
            } else {
                operation(realm)
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    fun closeThreadRealm() {
        try {
            val realm = threadLocalRealm.get()
            if (realm != null && !realm.isClosed) {
                realm.close()
            }
        } catch (e: Exception) {
            // Ignore close errors
        } finally {
            threadLocalRealm.remove()
        }
    }

}
=======
package org.ole.planet.myplanet.service.sync


import io.realm.Realm
import org.ole.planet.myplanet.datamanager.DatabaseService

object ThreadSafeRealmHelper {

    private val threadLocalRealm = ThreadLocal<Realm?>()

    fun <T> withRealm(databaseService: DatabaseService, operation: (Realm) -> T): T? {
        return try {
            // Get or create Realm instance for current thread
            val realm = threadLocalRealm.get() ?: run {
                val newRealm = databaseService.realmInstance
                threadLocalRealm.set(newRealm)
                newRealm
            }

            if (realm.isClosed) {
                // If realm is closed, create a new one
                val newRealm = databaseService.realmInstance
                threadLocalRealm.set(newRealm)
                operation(newRealm)
            } else {
                operation(realm)
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    fun closeThreadRealm() {
        try {
            val realm = threadLocalRealm.get()
            if (realm != null && !realm.isClosed) {
                realm.close()
            }
        } catch (e: Exception) {
            // Ignore close errors
        } finally {
            threadLocalRealm.remove()
        }
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/sync/StandardSyncStrategy.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service.sync

import io.realm.Realm
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import org.ole.planet.myplanet.service.TransactionSyncManager

class StandardSyncStrategy : SyncStrategy {

    override suspend fun syncTable(
        table: String,
        realm: Realm,
        config: SyncConfig
    ): Flow<SyncResult> = flow {
        val startTime = System.currentTimeMillis()

        try {
            // Use the existing TransactionSyncManager for standard sync
            TransactionSyncManager.syncDb(realm, table)

            val endTime = System.currentTimeMillis()
            emit(
                SyncResult(
                    table = table,
                    processedItems = -1, // TransactionSyncManager doesn't return count
                    success = true,
                    duration = endTime - startTime,
                    strategy = getStrategyName()
                )
            )
        } catch (e: Exception) {
            val endTime = System.currentTimeMillis()
            emit(
                SyncResult(
                    table = table,
                    processedItems = 0,
                    success = false,
                    errorMessage = e.message,
                    duration = endTime - startTime,
                    strategy = getStrategyName()
                )
            )
        }
    }

    override fun getStrategyName(): String = "standard"

    override fun isSupported(table: String): Boolean = true
}
=======
package org.ole.planet.myplanet.service.sync


import io.realm.Realm
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import org.ole.planet.myplanet.service.TransactionSyncManager

class StandardSyncStrategy : SyncStrategy {

    override suspend fun syncTable(
        table: String,
        realm: Realm,
        config: SyncConfig
    ): Flow<SyncResult> = flow {
        val startTime = System.currentTimeMillis()

        try {
            // Use the existing TransactionSyncManager for standard sync
            TransactionSyncManager.syncDb(realm, table)

            val endTime = System.currentTimeMillis()
            emit(
                SyncResult(
                    table = table,
                    processedItems = -1, // TransactionSyncManager doesn't return count
                    success = true,
                    duration = endTime - startTime,
                    strategy = getStrategyName()
                )
            )
        } catch (e: Exception) {
            val endTime = System.currentTimeMillis()
            emit(
                SyncResult(
                    table = table,
                    processedItems = 0,
                    success = false,
                    errorMessage = e.message,
                    duration = endTime - startTime,
                    strategy = getStrategyName()
                )
            )
        }
    }

    override fun getStrategyName(): String = "standard"

    override fun isSupported(table: String): Boolean = true
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/sync/SyncStrategy.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service.sync

import io.realm.Realm
import kotlinx.coroutines.flow.Flow

data class SyncConfig(
    val batchSize: Int = 50,
    val concurrencyLevel: Int = 3,
    val retryAttempts: Int = 3,
    val timeoutMs: Long = 30000,
    val enableOptimizations: Boolean = true,
    val fallbackToStandard: Boolean = true
)

data class SyncResult(
    val table: String,
    val processedItems: Int,
    val success: Boolean,
    val errorMessage: String? = null,
    val duration: Long,
    val strategy: String
)

interface SyncStrategy {
    suspend fun syncTable(
        table: String,
        realm: Realm,
        config: SyncConfig
    ): Flow<SyncResult>

    fun getStrategyName(): String
    fun isSupported(table: String): Boolean
}

sealed class SyncMode {
    object Standard : SyncMode()
    object Fast : SyncMode()
    object Optimized : SyncMode()
}
=======
package org.ole.planet.myplanet.service.sync


import io.realm.Realm
import kotlinx.coroutines.flow.Flow

data class SyncConfig(
    val batchSize: Int = 50,
    val concurrencyLevel: Int = 3,
    val retryAttempts: Int = 3,
    val timeoutMs: Long = 30000,
    val enableOptimizations: Boolean = true,
    val fallbackToStandard: Boolean = true
)

data class SyncResult(
    val table: String,
    val processedItems: Int,
    val success: Boolean,
    val errorMessage: String? = null,
    val duration: Long,
    val strategy: String
)

interface SyncStrategy {
    suspend fun syncTable(
        table: String,
        realm: Realm,
        config: SyncConfig
    ): Flow<SyncResult>

    fun getStrategyName(): String
    fun isSupported(table: String): Boolean
}

sealed class SyncMode {
    object Standard : SyncMode()
    object Fast : SyncMode()
    object Optimized : SyncMode()
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/sync/AdaptiveBatchProcessor.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service.sync

import android.app.ActivityManager
import android.content.Context
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import android.os.Build
import kotlin.math.max
import kotlin.math.min

data class SystemCapabilities(
    val availableMemoryMB: Long,
    val cpuCores: Int,
    val networkSpeed: NetworkSpeed,
    val isLowMemoryDevice: Boolean
)

enum class NetworkSpeed {
    SLOW, MEDIUM, FAST, UNKNOWN
}

class AdaptiveBatchProcessor(private val context: Context) {

    private val baseConfig = SyncConfig()
    private var cachedCapabilities: SystemCapabilities? = null
    private var lastCapabilityCheck = 0L
    private val cacheValidityMs = 30000L // 30 seconds

    fun getOptimalConfig(table: String): SyncConfig {
        val capabilities = getSystemCapabilities()
        return when (table) {
            "resources" -> getResourceSyncConfig(capabilities)
            "courses", "exams", "submissions" -> getCourseSyncConfig(capabilities)
            "library", "shelf" -> getLibrarySyncConfig(capabilities)
            else -> getStandardSyncConfig(capabilities)
        }
    }

    private fun getSystemCapabilities(): SystemCapabilities {
        val now = System.currentTimeMillis()
        if (cachedCapabilities != null && (now - lastCapabilityCheck) < cacheValidityMs) {
            return cachedCapabilities!!
        }

        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val memInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(memInfo)

        val capabilities = SystemCapabilities(
            availableMemoryMB = memInfo.availMem / (1024 * 1024),
            cpuCores = Runtime.getRuntime().availableProcessors(),
            networkSpeed = detectNetworkSpeed(),
            isLowMemoryDevice = activityManager.isLowRamDevice
        )

        cachedCapabilities = capabilities
        lastCapabilityCheck = now
        return capabilities
    }

    private fun detectNetworkSpeed(): NetworkSpeed {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = connectivityManager.activeNetwork ?: return NetworkSpeed.UNKNOWN
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return NetworkSpeed.UNKNOWN

        return when {
            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) -> {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    val linkDownstreamBandwidth = capabilities.linkDownstreamBandwidthKbps
                    when {
                        linkDownstreamBandwidth > 50000 -> NetworkSpeed.FAST
                        linkDownstreamBandwidth > 10000 -> NetworkSpeed.MEDIUM
                        else -> NetworkSpeed.SLOW
                    }
                } else NetworkSpeed.MEDIUM
            }
            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) -> {
                if (capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
                    NetworkSpeed.MEDIUM
                } else NetworkSpeed.SLOW
            }
            else -> NetworkSpeed.SLOW
        }
    }

    private fun getResourceSyncConfig(capabilities: SystemCapabilities): SyncConfig {
        val baseBatchSize = when (capabilities.networkSpeed) {
            NetworkSpeed.FAST -> 1000
            NetworkSpeed.MEDIUM -> 500
            NetworkSpeed.SLOW -> 100
            NetworkSpeed.UNKNOWN -> 250
        }

        val memoryAdjustedBatchSize = if (capabilities.isLowMemoryDevice) {
            baseBatchSize / 2
        } else {
            min(baseBatchSize, (capabilities.availableMemoryMB / 10).toInt())
        }

        val concurrency = calculateOptimalConcurrency(capabilities)

        return baseConfig.copy(
            batchSize = max(50, memoryAdjustedBatchSize),
            concurrencyLevel = concurrency,
            enableOptimizations = !capabilities.isLowMemoryDevice,
            timeoutMs = when (capabilities.networkSpeed) {
                NetworkSpeed.FAST -> 15000
                NetworkSpeed.MEDIUM -> 30000
                NetworkSpeed.SLOW -> 60000
                NetworkSpeed.UNKNOWN -> 45000
            }
        )
    }

    private fun getCourseSyncConfig(capabilities: SystemCapabilities): SyncConfig {
        return getResourceSyncConfig(capabilities).copy(
            batchSize = getResourceSyncConfig(capabilities).batchSize / 2,
            concurrencyLevel = max(1, getResourceSyncConfig(capabilities).concurrencyLevel - 1)
        )
    }

    private fun getLibrarySyncConfig(capabilities: SystemCapabilities): SyncConfig {
        return baseConfig.copy(
            batchSize = when (capabilities.networkSpeed) {
                NetworkSpeed.FAST -> 25
                NetworkSpeed.MEDIUM -> 15
                NetworkSpeed.SLOW -> 5
                NetworkSpeed.UNKNOWN -> 10
            },
            concurrencyLevel = calculateOptimalConcurrency(capabilities),
            enableOptimizations = true
        )
    }

    private fun getStandardSyncConfig(capabilities: SystemCapabilities): SyncConfig {
        return baseConfig.copy(
            batchSize = 50,
            concurrencyLevel = max(1, capabilities.cpuCores / 2),
            enableOptimizations = !capabilities.isLowMemoryDevice
        )
    }

    private fun calculateOptimalConcurrency(capabilities: SystemCapabilities): Int {
        val baseConcurrency = when {
            capabilities.isLowMemoryDevice -> 1
            capabilities.availableMemoryMB < 512 -> 2
            capabilities.availableMemoryMB < 1024 -> 3
            else -> min(5, capabilities.cpuCores)
        }

        return when (capabilities.networkSpeed) {
            NetworkSpeed.FAST -> baseConcurrency
            NetworkSpeed.MEDIUM -> max(1, baseConcurrency - 1)
            NetworkSpeed.SLOW -> max(1, baseConcurrency - 2)
            NetworkSpeed.UNKNOWN -> max(1, baseConcurrency - 1)
        }
    }

}
=======
package org.ole.planet.myplanet.service.sync


import android.app.ActivityManager
import android.content.Context
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import android.os.Build
import kotlin.math.max
import kotlin.math.min

data class SystemCapabilities(
    val availableMemoryMB: Long,
    val cpuCores: Int,
    val networkSpeed: NetworkSpeed,
    val isLowMemoryDevice: Boolean
)

enum class NetworkSpeed {
    SLOW, MEDIUM, FAST, UNKNOWN
}

class AdaptiveBatchProcessor(private val context: Context) {

    private val baseConfig = SyncConfig()
    private var cachedCapabilities: SystemCapabilities? = null
    private var lastCapabilityCheck = 0L
    private val cacheValidityMs = 30000L // 30 seconds

    fun getOptimalConfig(table: String): SyncConfig {
        val capabilities = getSystemCapabilities()
        return when (table) {
            "resources" -> getResourceSyncConfig(capabilities)
            "courses", "exams", "submissions" -> getCourseSyncConfig(capabilities)
            "library", "shelf" -> getLibrarySyncConfig(capabilities)
            else -> getStandardSyncConfig(capabilities)
        }
    }

    private fun getSystemCapabilities(): SystemCapabilities {
        val now = System.currentTimeMillis()
        if (cachedCapabilities != null && (now - lastCapabilityCheck) < cacheValidityMs) {
            return cachedCapabilities!!
        }

        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val memInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(memInfo)

        val capabilities = SystemCapabilities(
            availableMemoryMB = memInfo.availMem / (1024 * 1024),
            cpuCores = Runtime.getRuntime().availableProcessors(),
            networkSpeed = detectNetworkSpeed(),
            isLowMemoryDevice = activityManager.isLowRamDevice
        )

        cachedCapabilities = capabilities
        lastCapabilityCheck = now
        return capabilities
    }

    private fun detectNetworkSpeed(): NetworkSpeed {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = connectivityManager.activeNetwork ?: return NetworkSpeed.UNKNOWN
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return NetworkSpeed.UNKNOWN

        return when {
            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) -> {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    val linkDownstreamBandwidth = capabilities.linkDownstreamBandwidthKbps
                    when {
                        linkDownstreamBandwidth > 50000 -> NetworkSpeed.FAST
                        linkDownstreamBandwidth > 10000 -> NetworkSpeed.MEDIUM
                        else -> NetworkSpeed.SLOW
                    }
                } else NetworkSpeed.MEDIUM
            }
            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) -> {
                if (capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
                    NetworkSpeed.MEDIUM
                } else NetworkSpeed.SLOW
            }
            else -> NetworkSpeed.SLOW
        }
    }

    private fun getResourceSyncConfig(capabilities: SystemCapabilities): SyncConfig {
        val baseBatchSize = when (capabilities.networkSpeed) {
            NetworkSpeed.FAST -> 1000
            NetworkSpeed.MEDIUM -> 500
            NetworkSpeed.SLOW -> 100
            NetworkSpeed.UNKNOWN -> 250
        }

        val memoryAdjustedBatchSize = if (capabilities.isLowMemoryDevice) {
            baseBatchSize / 2
        } else {
            min(baseBatchSize, (capabilities.availableMemoryMB / 10).toInt())
        }

        val concurrency = calculateOptimalConcurrency(capabilities)

        return baseConfig.copy(
            batchSize = max(50, memoryAdjustedBatchSize),
            concurrencyLevel = concurrency,
            enableOptimizations = !capabilities.isLowMemoryDevice,
            timeoutMs = when (capabilities.networkSpeed) {
                NetworkSpeed.FAST -> 15000
                NetworkSpeed.MEDIUM -> 30000
                NetworkSpeed.SLOW -> 60000
                NetworkSpeed.UNKNOWN -> 45000
            }
        )
    }

    private fun getCourseSyncConfig(capabilities: SystemCapabilities): SyncConfig {
        return getResourceSyncConfig(capabilities).copy(
            batchSize = getResourceSyncConfig(capabilities).batchSize / 2,
            concurrencyLevel = max(1, getResourceSyncConfig(capabilities).concurrencyLevel - 1)
        )
    }

    private fun getLibrarySyncConfig(capabilities: SystemCapabilities): SyncConfig {
        return baseConfig.copy(
            batchSize = when (capabilities.networkSpeed) {
                NetworkSpeed.FAST -> 25
                NetworkSpeed.MEDIUM -> 15
                NetworkSpeed.SLOW -> 5
                NetworkSpeed.UNKNOWN -> 10
            },
            concurrencyLevel = calculateOptimalConcurrency(capabilities),
            enableOptimizations = true
        )
    }

    private fun getStandardSyncConfig(capabilities: SystemCapabilities): SyncConfig {
        return baseConfig.copy(
            batchSize = 50,
            concurrencyLevel = max(1, capabilities.cpuCores / 2),
            enableOptimizations = !capabilities.isLowMemoryDevice
        )
    }

    private fun calculateOptimalConcurrency(capabilities: SystemCapabilities): Int {
        val baseConcurrency = when {
            capabilities.isLowMemoryDevice -> 1
            capabilities.availableMemoryMB < 512 -> 2
            capabilities.availableMemoryMB < 1024 -> 3
            else -> min(5, capabilities.cpuCores)
        }

        return when (capabilities.networkSpeed) {
            NetworkSpeed.FAST -> baseConcurrency
            NetworkSpeed.MEDIUM -> max(1, baseConcurrency - 1)
            NetworkSpeed.SLOW -> max(1, baseConcurrency - 2)
            NetworkSpeed.UNKNOWN -> max(1, baseConcurrency - 1)
        }
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/sync/RealmConnectionPool.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service.sync

import android.content.Context
import io.realm.Realm
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.atomic.AtomicInteger
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.sync.withPermit
import org.ole.planet.myplanet.datamanager.DatabaseService

data class RealmPoolConfig(
    val maxConnections: Int = 5,
    val connectionTimeoutMs: Long = 30000,
    val idleTimeoutMs: Long = 300000, // 5 minutes
    val validationIntervalMs: Long = 60000, // 1 minute
    val enableConnectionValidation: Boolean = true
)

private data class PooledRealm(
    val realm: Realm,
    val createdAt: Long,
    val lastUsedAt: Long,
    var isInUse: Boolean = false,
    val id: String = java.util.UUID.randomUUID().toString()
)

class RealmConnectionPool(
    private val context: Context,
    private val databaseService: DatabaseService,
    private val config: RealmPoolConfig = RealmPoolConfig()
) {
    private val threadLocalConnections = ThreadLocal<Realm?>()
    private val availableConnections = ConcurrentLinkedQueue<PooledRealm>()
    private val allConnections = mutableMapOf<String, PooledRealm>()
    private val activeConnections = AtomicInteger(0)
    private val connectionSemaphore = Semaphore(config.maxConnections)
    private val poolMutex = Mutex()

    private var lastValidationTime = 0L
    suspend fun <T> useRealm(operation: suspend (Realm) -> T): T {
        // Check if current thread already has a realm instance
        val existingRealm = threadLocalConnections.get()
        if (existingRealm != null && !existingRealm.isClosed) {
            return operation(existingRealm)
        }

        return connectionSemaphore.withPermit {
            val pooledRealm = acquireConnection()
            threadLocalConnections.set(pooledRealm.realm)
            try {
                operation(pooledRealm.realm)
            } finally {
                threadLocalConnections.remove()
                releaseConnection(pooledRealm)
            }
        }
    }

    private suspend fun acquireConnection(): PooledRealm = poolMutex.withLock {
        validateConnectionsIfNeeded()

        // Try to get an available connection
        var pooledRealm = availableConnections.poll()

        if (pooledRealm != null) {
            // Validate the connection before use
            if (isConnectionValid(pooledRealm)) {
                pooledRealm = pooledRealm.copy(
                    lastUsedAt = System.currentTimeMillis(),
                    isInUse = true
                )
                allConnections[pooledRealm.id] = pooledRealm
                return pooledRealm
            } else {
                // Connection is invalid, close it and remove from pool
                closeConnection(pooledRealm)
            }
        }

        // Create a new connection if under the limit
        if (allConnections.size < config.maxConnections) {
            pooledRealm = createNewConnection()
            allConnections[pooledRealm.id] = pooledRealm
            activeConnections.incrementAndGet()
            return pooledRealm
        }

        throw IllegalStateException("Connection pool exhausted and cannot create new connections")
    }

    private suspend fun releaseConnection(pooledRealm: PooledRealm) = poolMutex.withLock {
        if (isConnectionValid(pooledRealm)) {
            val updatedConnection = pooledRealm.copy(
                lastUsedAt = System.currentTimeMillis(),
                isInUse = false
            )
            allConnections[pooledRealm.id] = updatedConnection
            availableConnections.offer(updatedConnection)
        } else {
            closeConnection(pooledRealm)
        }
    }

    private fun createNewConnection(): PooledRealm {
        val realm = databaseService.realmInstance
        return PooledRealm(
            realm = realm,
            createdAt = System.currentTimeMillis(),
            lastUsedAt = System.currentTimeMillis(),
            isInUse = true
        )
    }

    private fun isConnectionValid(pooledRealm: PooledRealm): Boolean {
        if (!config.enableConnectionValidation) return true

        return try {
            !pooledRealm.realm.isClosed &&
            pooledRealm.realm.isInTransaction.not() &&
            (System.currentTimeMillis() - pooledRealm.lastUsedAt) < config.idleTimeoutMs
        } catch (e: Exception) {
            false
        }
    }

    private fun closeConnection(pooledRealm: PooledRealm) {
        try {
            if (!pooledRealm.realm.isClosed) {
                pooledRealm.realm.close()
            }
        } catch (e: Exception) {
            // Log error but continue cleanup
        } finally {
            allConnections.remove(pooledRealm.id)
            activeConnections.decrementAndGet()
        }
    }

    private fun validateConnectionsIfNeeded() {
        val now = System.currentTimeMillis()
        if (now - lastValidationTime > config.validationIntervalMs) {
            lastValidationTime = now

            // Remove expired connections
            val expiredConnections = allConnections.values.filter {
                !it.isInUse && (now - it.lastUsedAt) > config.idleTimeoutMs
            }

            expiredConnections.forEach { closeConnection(it) }

            // Remove expired connections from available queue
            val validConnections = availableConnections.filter { pooledRealm ->
                allConnections.containsKey(pooledRealm.id) && isConnectionValid(pooledRealm)
            }
            availableConnections.clear()
            availableConnections.addAll(validConnections)
        }
    }
}

class RealmPoolManager private constructor() {
    companion object {
        @Volatile
        private var INSTANCE: RealmPoolManager? = null

        fun getInstance(): RealmPoolManager {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: RealmPoolManager().also { INSTANCE = it }
            }
        }
    }

    private var connectionPool: RealmConnectionPool? = null
    private val mutex = Mutex()

    suspend fun initializePool(
        context: Context,
        databaseService: DatabaseService,
        config: RealmPoolConfig = RealmPoolConfig()
    ) = mutex.withLock {
        if (connectionPool == null) {
            connectionPool = RealmConnectionPool(context, databaseService, config)
        }
    }

    suspend fun <T> useRealm(operation: suspend (Realm) -> T): T {
        val pool = connectionPool ?: throw IllegalStateException("Pool not initialized")
        return pool.useRealm(operation)
    }

}
=======
package org.ole.planet.myplanet.service.sync


import android.content.Context
import io.realm.Realm
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.atomic.AtomicInteger
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.sync.withPermit
import org.ole.planet.myplanet.datamanager.DatabaseService

data class RealmPoolConfig(
    val maxConnections: Int = 5,
    val connectionTimeoutMs: Long = 30000,
    val idleTimeoutMs: Long = 300000, // 5 minutes
    val validationIntervalMs: Long = 60000, // 1 minute
    val enableConnectionValidation: Boolean = true
)

private data class PooledRealm(
    val realm: Realm,
    val createdAt: Long,
    val lastUsedAt: Long,
    var isInUse: Boolean = false,
    val id: String = java.util.UUID.randomUUID().toString()
)

class RealmConnectionPool(
    private val context: Context,
    private val databaseService: DatabaseService,
    private val config: RealmPoolConfig = RealmPoolConfig()
) {
    private val threadLocalConnections = ThreadLocal<Realm?>()
    private val availableConnections = ConcurrentLinkedQueue<PooledRealm>()
    private val allConnections = mutableMapOf<String, PooledRealm>()
    private val activeConnections = AtomicInteger(0)
    private val connectionSemaphore = Semaphore(config.maxConnections)
    private val poolMutex = Mutex()

    private var lastValidationTime = 0L
    suspend fun <T> useRealm(operation: suspend (Realm) -> T): T {
        // Check if current thread already has a realm instance
        val existingRealm = threadLocalConnections.get()
        if (existingRealm != null && !existingRealm.isClosed) {
            return operation(existingRealm)
        }

        return connectionSemaphore.withPermit {
            val pooledRealm = acquireConnection()
            threadLocalConnections.set(pooledRealm.realm)
            try {
                operation(pooledRealm.realm)
            } finally {
                threadLocalConnections.remove()
                releaseConnection(pooledRealm)
            }
        }
    }

    private suspend fun acquireConnection(): PooledRealm = poolMutex.withLock {
        validateConnectionsIfNeeded()

        // Try to get an available connection
        var pooledRealm = availableConnections.poll()

        if (pooledRealm != null) {
            // Validate the connection before use
            if (isConnectionValid(pooledRealm)) {
                pooledRealm = pooledRealm.copy(
                    lastUsedAt = System.currentTimeMillis(),
                    isInUse = true
                )
                allConnections[pooledRealm.id] = pooledRealm
                return pooledRealm
            } else {
                // Connection is invalid, close it and remove from pool
                closeConnection(pooledRealm)
            }
        }

        // Create a new connection if under the limit
        if (allConnections.size < config.maxConnections) {
            pooledRealm = createNewConnection()
            allConnections[pooledRealm.id] = pooledRealm
            activeConnections.incrementAndGet()
            return pooledRealm
        }

        throw IllegalStateException("Connection pool exhausted and cannot create new connections")
    }

    private suspend fun releaseConnection(pooledRealm: PooledRealm) = poolMutex.withLock {
        if (isConnectionValid(pooledRealm)) {
            val updatedConnection = pooledRealm.copy(
                lastUsedAt = System.currentTimeMillis(),
                isInUse = false
            )
            allConnections[pooledRealm.id] = updatedConnection
            availableConnections.offer(updatedConnection)
        } else {
            closeConnection(pooledRealm)
        }
    }

    private fun createNewConnection(): PooledRealm {
        val realm = databaseService.realmInstance
        return PooledRealm(
            realm = realm,
            createdAt = System.currentTimeMillis(),
            lastUsedAt = System.currentTimeMillis(),
            isInUse = true
        )
    }

    private fun isConnectionValid(pooledRealm: PooledRealm): Boolean {
        if (!config.enableConnectionValidation) return true

        return try {
            !pooledRealm.realm.isClosed &&
            pooledRealm.realm.isInTransaction.not() &&
            (System.currentTimeMillis() - pooledRealm.lastUsedAt) < config.idleTimeoutMs
        } catch (e: Exception) {
            false
        }
    }

    private fun closeConnection(pooledRealm: PooledRealm) {
        try {
            if (!pooledRealm.realm.isClosed) {
                pooledRealm.realm.close()
            }
        } catch (e: Exception) {
            // Log error but continue cleanup
        } finally {
            allConnections.remove(pooledRealm.id)
            activeConnections.decrementAndGet()
        }
    }

    private fun validateConnectionsIfNeeded() {
        val now = System.currentTimeMillis()
        if (now - lastValidationTime > config.validationIntervalMs) {
            lastValidationTime = now

            // Remove expired connections
            val expiredConnections = allConnections.values.filter {
                !it.isInUse && (now - it.lastUsedAt) > config.idleTimeoutMs
            }

            expiredConnections.forEach { closeConnection(it) }

            // Remove expired connections from available queue
            val validConnections = availableConnections.filter { pooledRealm ->
                allConnections.containsKey(pooledRealm.id) && isConnectionValid(pooledRealm)
            }
            availableConnections.clear()
            availableConnections.addAll(validConnections)
        }
    }
}

class RealmPoolManager private constructor() {
    companion object {
        @Volatile
        private var INSTANCE: RealmPoolManager? = null

        fun getInstance(): RealmPoolManager {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: RealmPoolManager().also { INSTANCE = it }
            }
        }
    }

    private var connectionPool: RealmConnectionPool? = null
    private val mutex = Mutex()

    suspend fun initializePool(
        context: Context,
        databaseService: DatabaseService,
        config: RealmPoolConfig = RealmPoolConfig()
    ) = mutex.withLock {
        if (connectionPool == null) {
            connectionPool = RealmConnectionPool(context, databaseService, config)
        }
    }

    suspend fun <T> useRealm(operation: suspend (Realm) -> T): T {
        val pool = connectionPool ?: throw IllegalStateException("Pool not initialized")
        return pool.useRealm(operation)
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/sync/RealtimeSyncCoordinator.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service.sync

import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.asSharedFlow
import org.ole.planet.myplanet.callback.RealtimeSyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate

class RealtimeSyncCoordinator {

    companion object {
        @Volatile
        private var INSTANCE: RealtimeSyncCoordinator? = null

        fun getInstance(): RealtimeSyncCoordinator {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: RealtimeSyncCoordinator().also { INSTANCE = it }
            }
        }
    }

    private val listeners = mutableSetOf<RealtimeSyncListener>()
    private val _dataUpdateFlow = MutableSharedFlow<TableDataUpdate>()
    val dataUpdateFlow: SharedFlow<TableDataUpdate> = _dataUpdateFlow.asSharedFlow()

    fun addListener(listener: RealtimeSyncListener) {
        synchronized(listeners) {
            listeners.add(listener)
        }
    }

    fun removeListener(listener: RealtimeSyncListener) {
        synchronized(listeners) {
            listeners.remove(listener)
        }
    }

}
=======
package org.ole.planet.myplanet.service.sync


import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.asSharedFlow
import org.ole.planet.myplanet.callback.RealtimeSyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate

class RealtimeSyncCoordinator {

    companion object {
        @Volatile
        private var INSTANCE: RealtimeSyncCoordinator? = null

        fun getInstance(): RealtimeSyncCoordinator {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: RealtimeSyncCoordinator().also { INSTANCE = it }
            }
        }
    }

    private val listeners = mutableSetOf<RealtimeSyncListener>()
    private val _dataUpdateFlow = MutableSharedFlow<TableDataUpdate>()
    val dataUpdateFlow: SharedFlow<TableDataUpdate> = _dataUpdateFlow.asSharedFlow()

    fun addListener(listener: RealtimeSyncListener) {
        synchronized(listeners) {
            listeners.add(listener)
        }
    }

    fun removeListener(listener: RealtimeSyncListener) {
        synchronized(listeners) {
            listeners.remove(listener)
        }
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/BroadcastServiceEntryPoint.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.content.Context
import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.components.SingletonComponent

@EntryPoint
@InstallIn(SingletonComponent::class)
interface BroadcastServiceEntryPoint {
    fun broadcastService(): BroadcastService
}

fun getBroadcastService(context: Context): BroadcastService {
    val hiltEntryPoint = EntryPointAccessors.fromApplication(
        context.applicationContext,
        BroadcastServiceEntryPoint::class.java
    )
    return hiltEntryPoint.broadcastService()
}
=======
package org.ole.planet.myplanet.service


import android.content.Context
import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.components.SingletonComponent

@EntryPoint
@InstallIn(SingletonComponent::class)
interface BroadcastServiceEntryPoint {
    fun broadcastService(): BroadcastService
}

fun getBroadcastService(context: Context): BroadcastService {
    val hiltEntryPoint = EntryPointAccessors.fromApplication(
        context.applicationContext,
        BroadcastServiceEntryPoint::class.java
    )
    return hiltEntryPoint.broadcastService()
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/ImprovedSyncManager.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.content.Context
import android.content.SharedPreferences
import androidx.core.content.edit
import dagger.hilt.android.qualifiers.ApplicationContext
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication.Companion.createLog
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.ManagerSync
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.service.sync.AdaptiveBatchProcessor
import org.ole.planet.myplanet.service.sync.RealmPoolManager
import org.ole.planet.myplanet.service.sync.StandardSyncStrategy
import org.ole.planet.myplanet.service.sync.SyncMode
import org.ole.planet.myplanet.service.sync.SyncStrategy
import org.ole.planet.myplanet.utilities.NotificationUtils
import org.ole.planet.myplanet.utilities.SyncTimeLogger

@Singleton
class ImprovedSyncManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val databaseService: DatabaseService,
    @AppPreferences private val settings: SharedPreferences
) {

    private val batchProcessor = AdaptiveBatchProcessor(context)
    private val poolManager = RealmPoolManager.getInstance()

    private val standardStrategy = StandardSyncStrategy()

    private var isSyncing = false
    private var listener: SyncListener? = null
    private val syncScope = CoroutineScope(Dispatchers.IO + SupervisorJob())

    // Table sync order for dependencies
    private val syncOrder = listOf(
        "tablet_users",
        "tags",
        "teams",
        "news",
        "library",
        "resources",
        "courses",
        "exams",
        "ratings",
        "courses_progress",
        "achievements",
        "submissions",
        "tasks",
        "login_activities",
        "meetups",
        "health",
        "certifications",
        "team_activities",
        "chat_history",
        "feedback"
    )

    suspend fun initialize() {
        poolManager.initializePool(context, databaseService)
    }

    fun start(
        listener: SyncListener?,
        syncMode: SyncMode = SyncMode.Standard,
        syncTables: List<String>? = null
    ) {
        this.listener = listener
        if (!isSyncing) {
            settings.edit { remove("concatenated_links") }
            listener?.onSyncStarted()
            createLog(
                "improved_sync_start",
                "mode=${syncMode.describe()}|tables=${syncTables?.joinToString() ?: "default"}"
            )
            startSyncProcess(syncMode, syncTables)
        }
    }

    private fun startSyncProcess(syncMode: SyncMode, syncTables: List<String>?) {
        syncScope.launch {
            try {
                if (TransactionSyncManager.authenticate()) {
                    performSync(syncMode, syncTables)
                } else {
                    handleException("Authentication failed")
                }
            } catch (e: Exception) {
                handleException(e.message ?: "Unknown error")
            } finally {
                cleanup()
            }
        }
    }

    private suspend fun performSync(syncMode: SyncMode, syncTables: List<String>?) {
        val logger = SyncTimeLogger
        logger.startLogging()

        initializeSync()

        val tablesToSync = syncTables ?: syncOrder
        val strategy = getStrategy(syncMode)

        coroutineScope {
            val syncJobs = tablesToSync.map { table ->
                async {
                    syncTable(table, strategy, logger)
                }
            }

            syncJobs.awaitAll()
        }

        // Post-sync operations
        logger.startProcess("admin_sync")
        ManagerSync.instance.syncAdmin()
        logger.endProcess("admin_sync")

        poolManager.useRealm { realm ->
            logger.startProcess("on_synced")
            org.ole.planet.myplanet.model.RealmResourceActivity.onSynced(realm, settings)
            logger.endProcess("on_synced")
        }

        logger.stopLogging()
    }

    private suspend fun syncTable(table: String, strategy: SyncStrategy, logger: SyncTimeLogger) {
        val config = batchProcessor.getOptimalConfig(table)

        try {
            logger.startProcess("${table}_sync")

            if (strategy.isSupported(table)) {
                poolManager.useRealm { realm ->
                    strategy.syncTable(table, realm, config).collect()
                }
            } else {
                // Fallback to standard sync
                poolManager.useRealm { realm ->
                    TransactionSyncManager.syncDb(realm, table)
                }
            }

            logger.endProcess("${table}_sync")

        } catch (e: Exception) {
            logger.endProcess("${table}_sync")

            throw e
        }
    }

    private fun getStrategy(syncMode: SyncMode): SyncStrategy {
        return when (syncMode) {
            SyncMode.Standard -> standardStrategy
            SyncMode.Fast, SyncMode.Optimized -> standardStrategy
        }
    }

    private fun initializeSync() {
        isSyncing = true
        NotificationUtils.create(
            context,
            org.ole.planet.myplanet.R.mipmap.ic_launcher,
            "Syncing data",
            "Please wait..."
        )
    }

    private fun cleanup() {
        isSyncing = false
        settings.edit { putLong("LastSync", Date().time) }
        NotificationUtils.cancel(context, 111)
        listener?.onSyncComplete()
    }

    private fun SyncMode.describe(): String {
        return when (this) {
            SyncMode.Standard -> "Standard"
            SyncMode.Fast -> "Fast"
            SyncMode.Optimized -> "Optimized"
        }
    }

    private fun handleException(message: String) {
        if (listener != null) {
            isSyncing = false
            org.ole.planet.myplanet.MainApplication.syncFailedCount++
            listener?.onSyncFailed(message)
        }
    }

}
=======
package org.ole.planet.myplanet.service


import android.content.Context
import android.content.SharedPreferences
import androidx.core.content.edit
import dagger.hilt.android.qualifiers.ApplicationContext
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication.Companion.createLog
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.ManagerSync
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.service.sync.AdaptiveBatchProcessor
import org.ole.planet.myplanet.service.sync.RealmPoolManager
import org.ole.planet.myplanet.service.sync.StandardSyncStrategy
import org.ole.planet.myplanet.service.sync.SyncMode
import org.ole.planet.myplanet.service.sync.SyncStrategy
import org.ole.planet.myplanet.utilities.NotificationUtils
import org.ole.planet.myplanet.utilities.SyncTimeLogger

@Singleton
class ImprovedSyncManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val databaseService: DatabaseService,
    @AppPreferences private val settings: SharedPreferences
) {

    private val batchProcessor = AdaptiveBatchProcessor(context)
    private val poolManager = RealmPoolManager.getInstance()

    private val standardStrategy = StandardSyncStrategy()

    private var isSyncing = false
    private var listener: SyncListener? = null
    private val syncScope = CoroutineScope(Dispatchers.IO + SupervisorJob())

    // Table sync order for dependencies
    private val syncOrder = listOf(
        "tablet_users",
        "tags",
        "teams",
        "news",
        "library",
        "resources",
        "courses",
        "exams",
        "ratings",
        "courses_progress",
        "achievements",
        "submissions",
        "tasks",
        "login_activities",
        "meetups",
        "health",
        "certifications",
        "team_activities",
        "chat_history",
        "feedback"
    )

    suspend fun initialize() {
        poolManager.initializePool(context, databaseService)
    }

    fun start(
        listener: SyncListener?,
        syncMode: SyncMode = SyncMode.Standard,
        syncTables: List<String>? = null
    ) {
        this.listener = listener
        if (!isSyncing) {
            settings.edit { remove("concatenated_links") }
            listener?.onSyncStarted()
            createLog(
                "improved_sync_start",
                "mode=${syncMode.describe()}|tables=${syncTables?.joinToString() ?: "default"}"
            )
            startSyncProcess(syncMode, syncTables)
        }
    }

    private fun startSyncProcess(syncMode: SyncMode, syncTables: List<String>?) {
        syncScope.launch {
            try {
                if (TransactionSyncManager.authenticate()) {
                    performSync(syncMode, syncTables)
                } else {
                    handleException("Authentication failed")
                }
            } catch (e: Exception) {
                handleException(e.message ?: "Unknown error")
            } finally {
                cleanup()
            }
        }
    }

    private suspend fun performSync(syncMode: SyncMode, syncTables: List<String>?) {
        val logger = SyncTimeLogger
        logger.startLogging()

        initializeSync()

        val tablesToSync = syncTables ?: syncOrder
        val strategy = getStrategy(syncMode)

        coroutineScope {
            val syncJobs = tablesToSync.map { table ->
                async {
                    syncTable(table, strategy, logger)
                }
            }

            syncJobs.awaitAll()
        }

        // Post-sync operations
        logger.startProcess("admin_sync")
        ManagerSync.instance.syncAdmin()
        logger.endProcess("admin_sync")

        poolManager.useRealm { realm ->
            logger.startProcess("on_synced")
            org.ole.planet.myplanet.model.RealmResourceActivity.onSynced(realm, settings)
            logger.endProcess("on_synced")
        }

        logger.stopLogging()
    }

    private suspend fun syncTable(table: String, strategy: SyncStrategy, logger: SyncTimeLogger) {
        val config = batchProcessor.getOptimalConfig(table)

        try {
            logger.startProcess("${table}_sync")

            if (strategy.isSupported(table)) {
                poolManager.useRealm { realm ->
                    strategy.syncTable(table, realm, config).collect()
                }
            } else {
                // Fallback to standard sync
                poolManager.useRealm { realm ->
                    TransactionSyncManager.syncDb(realm, table)
                }
            }

            logger.endProcess("${table}_sync")

        } catch (e: Exception) {
            logger.endProcess("${table}_sync")

            throw e
        }
    }

    private fun getStrategy(syncMode: SyncMode): SyncStrategy {
        return when (syncMode) {
            SyncMode.Standard -> standardStrategy
            SyncMode.Fast, SyncMode.Optimized -> standardStrategy
        }
    }

    private fun initializeSync() {
        isSyncing = true
        NotificationUtils.create(
            context,
            org.ole.planet.myplanet.R.mipmap.ic_launcher,
            "Syncing data",
            "Please wait..."
        )
    }

    private fun cleanup() {
        isSyncing = false
        settings.edit { putLong("LastSync", Date().time) }
        NotificationUtils.cancel(context, 111)
        listener?.onSyncComplete()
    }

    private fun SyncMode.describe(): String {
        return when (this) {
            SyncMode.Standard -> "Standard"
            SyncMode.Fast -> "Fast"
            SyncMode.Optimized -> "Optimized"
        }
    }

    private fun handleException(message: String) {
        if (listener != null) {
            isSyncing = false
            org.ole.planet.myplanet.MainApplication.syncFailedCount++
            listener?.onSyncFailed(message)
        }
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/ServerReachabilityWorker.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Build
import androidx.core.app.NotificationCompat
import androidx.core.content.edit
import androidx.core.net.toUri
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import dagger.hilt.android.EntryPointAccessors
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeoutOrNull
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.di.WorkerDependenciesEntryPoint
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper

class ServerReachabilityWorker(context: Context, workerParams: WorkerParameters) : CoroutineWorker(context, workerParams) {
    private val workerEntryPoint = EntryPointAccessors.fromApplication(
        context.applicationContext,
        WorkerDependenciesEntryPoint::class.java
    )
    private val uploadManager = workerEntryPoint.uploadManager()
    private val submissionRepository = workerEntryPoint.submissionRepository()
    companion object {
        private const val NOTIFICATION_ID = 1001
        private const val CHANNEL_ID = "server_reachability_channel"
        private const val CHANNEL_NAME = "Server Connectivity"
        private const val LAST_NOTIFICATION_TIME_KEY = "last_server_notification_time"
        private const val NOTIFICATION_COOLDOWN_MS = 30 * 60 * 1000L
        private const val NETWORK_RECONNECTION_KEY = "network_reconnection_trigger"
    }

    override suspend fun doWork(): Result {
        return try {
            if (!NetworkUtils.isNetworkConnected) {
                return Result.success()
            }

            val isNetworkReconnection = inputData.getBoolean(NETWORK_RECONNECTION_KEY, false)
            val preferences = applicationContext.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            val serverUrl = preferences.getString("serverURL", "") ?: ""

            if (serverUrl.isEmpty()) {
                return Result.success()
            }

            val isReachable = withContext(Dispatchers.IO) {
                isServerReachable(serverUrl)
            }

            if (!isReachable) {
                tryServerSwitch(serverUrl, preferences, isNetworkReconnection)
            }

            if (isReachable && isNetworkReconnection) {
                val lastNotificationTime = preferences.getLong(LAST_NOTIFICATION_TIME_KEY, 0)
                val currentTime = System.currentTimeMillis()
                val timeSinceLastNotification = currentTime - lastNotificationTime
                if (timeSinceLastNotification > NOTIFICATION_COOLDOWN_MS) {
                    showServerNotification(preferences)
                    preferences.edit {
                        putLong(LAST_NOTIFICATION_TIME_KEY, currentTime)
                    }
                }
                checkAvailableServerAndUpload(preferences)
            }

            Result.success()
        } catch (e: Exception) {
            e.printStackTrace()
            Result.retry()
        }
    }

    private suspend fun tryServerSwitch(serverUrl: String, preferences: SharedPreferences, isNetworkReconnection: Boolean) {
        try {
            val serverUrlMapper = ServerUrlMapper()
            val mapping = serverUrlMapper.processUrl(serverUrl)

            if (mapping.alternativeUrl != null) {
                val alternativeReachable = withContext(Dispatchers.IO) {
                    isServerReachable(mapping.alternativeUrl)
                }

                if (alternativeReachable) {
                    serverUrlMapper.updateServerIfNecessary(mapping, preferences) { url ->
                        isServerReachable(url)
                    }

                    if (isNetworkReconnection) {
                        val lastNotificationTime = preferences.getLong(LAST_NOTIFICATION_TIME_KEY, 0)
                        val currentTime = System.currentTimeMillis()
                        val timeSinceLastNotification = currentTime - lastNotificationTime
                        if (timeSinceLastNotification > NOTIFICATION_COOLDOWN_MS) {
                            showServerNotification(preferences)
                            preferences.edit {
                                putLong(LAST_NOTIFICATION_TIME_KEY, currentTime)
                            }
                        }
                        checkAvailableServerAndUpload(preferences)
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun showServerNotification(preferences: SharedPreferences) {
        val notificationManager = applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        createNotificationChannel(notificationManager)

        val intent = Intent(applicationContext, DashboardActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
        }

        val pendingIntent = PendingIntent.getActivity(
            applicationContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val appName = applicationContext.getString(R.string.app_project_name)
        val serverName = getServerDisplayName(preferences)

        val notification = NotificationCompat.Builder(applicationContext, CHANNEL_ID)
            .setSmallIcon(R.drawable.ole_logo)
            .setContentTitle(appName)
            .setContentText(applicationContext.getString(R.string.is_available, serverName))
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .build()

        try {
            notificationManager.notify(NOTIFICATION_ID, notification)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private suspend fun checkAvailableServerAndUpload(settings: SharedPreferences) {
        val updateUrl = "${settings.getString("serverURL", "")}"
        val serverUrlMapper = ServerUrlMapper()
        val mapping = serverUrlMapper.processUrl(updateUrl)

        try {
            val primaryAvailable = withTimeoutOrNull(15000) {
                isServerReachable(mapping.primaryUrl)
            } ?: false

            val alternativeAvailable = if (mapping.alternativeUrl != null) {
                withTimeoutOrNull(15000) {
                    isServerReachable(mapping.alternativeUrl)
                } ?: false
            } else {
                false
            }

            if (!primaryAvailable && alternativeAvailable) {
                mapping.alternativeUrl?.let { alternativeUrl ->
                    val uri = updateUrl.toUri()
                    val editor = settings.edit()
                    serverUrlMapper.updateUrlPreferences(editor, uri, alternativeUrl, mapping.primaryUrl, settings)
                }
            }
            uploadSubmissions()
        } catch (e: Exception) {
            e.printStackTrace()
            uploadSubmissions()
        }
    }

    private suspend fun uploadSubmissions() {
        try {
            if (submissionRepository.hasPendingOfflineSubmissions()) {
                withContext(Dispatchers.IO) {
                    uploadManager.uploadSubmissions()
                }
            }
            uploadExamResultWrapper()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private suspend fun uploadExamResultWrapper() {
        if (!submissionRepository.hasPendingExamResults()) {
            return
        }

        try {
            val successListener = object : SuccessListener {
                override fun onSuccess(success: String?) {
                    // No UI updates required for background sync completion.
                }
            }

            withContext(Dispatchers.IO) {
                uploadManager.uploadExamResult(successListener)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun createNotificationChannel(notificationManager: NotificationManager) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT
            ).apply {
                description = "Notifications for server connectivity status"
            }
            notificationManager.createNotificationChannel(channel)
        }
    }

    private fun getServerDisplayName(preferences: SharedPreferences): String {
        return try {
            val communityName = preferences.getString("communityName", "") ?: ""
            val planetString = applicationContext.getString(R.string.planet)

            if (communityName.isNotEmpty()) {
                "$planetString $communityName"
            } else {
                planetString
            }
        } catch (e: Exception) {
            e.printStackTrace()
            "Server"
        }
    }
}
=======
package org.ole.planet.myplanet.service


import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Build
import androidx.core.app.NotificationCompat
import androidx.core.content.edit
import androidx.core.net.toUri
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import dagger.hilt.android.EntryPointAccessors
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeoutOrNull
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.di.WorkerDependenciesEntryPoint
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper

class ServerReachabilityWorker(context: Context, workerParams: WorkerParameters) : CoroutineWorker(context, workerParams) {
    private val workerEntryPoint = EntryPointAccessors.fromApplication(
        context.applicationContext,
        WorkerDependenciesEntryPoint::class.java
    )
    private val uploadManager = workerEntryPoint.uploadManager()
    private val submissionRepository = workerEntryPoint.submissionRepository()
    companion object {
        private const val NOTIFICATION_ID = 1001
        private const val CHANNEL_ID = "server_reachability_channel"
        private const val CHANNEL_NAME = "Server Connectivity"
        private const val LAST_NOTIFICATION_TIME_KEY = "last_server_notification_time"
        private const val NOTIFICATION_COOLDOWN_MS = 30 * 60 * 1000L
        private const val NETWORK_RECONNECTION_KEY = "network_reconnection_trigger"
    }

    override suspend fun doWork(): Result {
        return try {
            if (!NetworkUtils.isNetworkConnected) {
                return Result.success()
            }

            val isNetworkReconnection = inputData.getBoolean(NETWORK_RECONNECTION_KEY, false)
            val preferences = applicationContext.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            val serverUrl = preferences.getString("serverURL", "") ?: ""

            if (serverUrl.isEmpty()) {
                return Result.success()
            }

            val isReachable = withContext(Dispatchers.IO) {
                isServerReachable(serverUrl)
            }

            if (!isReachable) {
                tryServerSwitch(serverUrl, preferences, isNetworkReconnection)
            }

            if (isReachable && isNetworkReconnection) {
                val lastNotificationTime = preferences.getLong(LAST_NOTIFICATION_TIME_KEY, 0)
                val currentTime = System.currentTimeMillis()
                val timeSinceLastNotification = currentTime - lastNotificationTime
                if (timeSinceLastNotification > NOTIFICATION_COOLDOWN_MS) {
                    showServerNotification(preferences)
                    preferences.edit {
                        putLong(LAST_NOTIFICATION_TIME_KEY, currentTime)
                    }
                }
                checkAvailableServerAndUpload(preferences)
            }

            Result.success()
        } catch (e: Exception) {
            e.printStackTrace()
            Result.retry()
        }
    }

    private suspend fun tryServerSwitch(serverUrl: String, preferences: SharedPreferences, isNetworkReconnection: Boolean) {
        try {
            val serverUrlMapper = ServerUrlMapper()
            val mapping = serverUrlMapper.processUrl(serverUrl)

            if (mapping.alternativeUrl != null) {
                val alternativeReachable = withContext(Dispatchers.IO) {
                    isServerReachable(mapping.alternativeUrl)
                }

                if (alternativeReachable) {
                    serverUrlMapper.updateServerIfNecessary(mapping, preferences) { url ->
                        isServerReachable(url)
                    }

                    if (isNetworkReconnection) {
                        val lastNotificationTime = preferences.getLong(LAST_NOTIFICATION_TIME_KEY, 0)
                        val currentTime = System.currentTimeMillis()
                        val timeSinceLastNotification = currentTime - lastNotificationTime
                        if (timeSinceLastNotification > NOTIFICATION_COOLDOWN_MS) {
                            showServerNotification(preferences)
                            preferences.edit {
                                putLong(LAST_NOTIFICATION_TIME_KEY, currentTime)
                            }
                        }
                        checkAvailableServerAndUpload(preferences)
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun showServerNotification(preferences: SharedPreferences) {
        val notificationManager = applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        createNotificationChannel(notificationManager)

        val intent = Intent(applicationContext, DashboardActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
        }

        val pendingIntent = PendingIntent.getActivity(
            applicationContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val appName = applicationContext.getString(R.string.app_project_name)
        val serverName = getServerDisplayName(preferences)

        val notification = NotificationCompat.Builder(applicationContext, CHANNEL_ID)
            .setSmallIcon(R.drawable.ole_logo)
            .setContentTitle(appName)
            .setContentText(applicationContext.getString(R.string.is_available, serverName))
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .build()

        try {
            notificationManager.notify(NOTIFICATION_ID, notification)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private suspend fun checkAvailableServerAndUpload(settings: SharedPreferences) {
        val updateUrl = "${settings.getString("serverURL", "")}"
        val serverUrlMapper = ServerUrlMapper()
        val mapping = serverUrlMapper.processUrl(updateUrl)

        try {
            val primaryAvailable = withTimeoutOrNull(15000) {
                isServerReachable(mapping.primaryUrl)
            } ?: false

            val alternativeAvailable = if (mapping.alternativeUrl != null) {
                withTimeoutOrNull(15000) {
                    isServerReachable(mapping.alternativeUrl)
                } ?: false
            } else {
                false
            }

            if (!primaryAvailable && alternativeAvailable) {
                mapping.alternativeUrl?.let { alternativeUrl ->
                    val uri = updateUrl.toUri()
                    val editor = settings.edit()
                    serverUrlMapper.updateUrlPreferences(editor, uri, alternativeUrl, mapping.primaryUrl, settings)
                }
            }
            uploadSubmissions()
        } catch (e: Exception) {
            e.printStackTrace()
            uploadSubmissions()
        }
    }

    private suspend fun uploadSubmissions() {
        try {
            if (submissionRepository.hasPendingOfflineSubmissions()) {
                withContext(Dispatchers.IO) {
                    uploadManager.uploadSubmissions()
                }
            }
            uploadExamResultWrapper()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private suspend fun uploadExamResultWrapper() {
        if (!submissionRepository.hasPendingExamResults()) {
            return
        }

        try {
            val successListener = object : SuccessListener {
                override fun onSuccess(success: String?) {
                    // No UI updates required for background sync completion.
                }
            }

            withContext(Dispatchers.IO) {
                uploadManager.uploadExamResult(successListener)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun createNotificationChannel(notificationManager: NotificationManager) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT
            ).apply {
                description = "Notifications for server connectivity status"
            }
            notificationManager.createNotificationChannel(channel)
        }
    }

    private fun getServerDisplayName(preferences: SharedPreferences): String {
        return try {
            val communityName = preferences.getString("communityName", "") ?: ""
            val planetString = applicationContext.getString(R.string.planet)

            if (communityName.isNotEmpty()) {
                "$planetString $communityName"
            } else {
                planetString
            }
        } catch (e: Exception) {
            e.printStackTrace()
            "Server"
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/StayOnlineWorker.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.content.Context
import android.content.Intent
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.utilities.Constants.isBetaWifiFeatureEnabled
import org.ole.planet.myplanet.utilities.NetworkUtils.isWifiConnected

class StayOnlineWorker(private val context: Context, workerParams: WorkerParameters) : CoroutineWorker(context, workerParams) {
    override suspend fun doWork(): Result {
        if (isBetaWifiFeatureEnabled(context)) {
            if (isWifiConnected()) {
                withContext(Dispatchers.IO) {
                    val broadcastService = getBroadcastService(context)
                    broadcastService.sendBroadcast(Intent("SHOW_WIFI_ALERT"))
                }
            }
        }
        return Result.success()
    }
}
=======
package org.ole.planet.myplanet.service


import android.content.Context
import android.content.Intent
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.utilities.Constants.isBetaWifiFeatureEnabled
import org.ole.planet.myplanet.utilities.NetworkUtils.isWifiConnected

class StayOnlineWorker(private val context: Context, workerParams: WorkerParameters) : CoroutineWorker(context, workerParams) {
    override suspend fun doWork(): Result {
        if (isBetaWifiFeatureEnabled(context)) {
            if (isWifiConnected()) {
                withContext(Dispatchers.IO) {
                    val broadcastService = getBroadcastService(context)
                    broadcastService.sendBroadcast(Intent("SHOW_WIFI_ALERT"))
                }
            }
        }
        return Result.success()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/UploadManager.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.content.Context
import android.content.SharedPreferences
import android.os.Looper
import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.qualifiers.ApplicationContext
import io.realm.Realm
import io.realm.RealmResults
import java.io.File
import java.io.IOException
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.FileUploadService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.model.RealmAchievement
import org.ole.planet.myplanet.model.RealmApkLog
import org.ole.planet.myplanet.model.RealmCourseActivity
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyPersonal
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmNewsLog
import org.ole.planet.myplanet.model.RealmOfflineActivity
import org.ole.planet.myplanet.model.RealmRating
import org.ole.planet.myplanet.model.RealmResourceActivity
import org.ole.planet.myplanet.model.RealmSearchActivity
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmitPhotos
import org.ole.planet.myplanet.model.RealmTeamLog
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.VersionUtils.getAndroidId
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

private const val BATCH_SIZE = 50

private inline fun <T> Iterable<T>.processInBatches(action: (T) -> Unit) {
    chunked(BATCH_SIZE).forEach { chunk ->
        chunk.forEach { item ->
            action(item)
        }
    }
}

@Singleton
class UploadManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val databaseService: DatabaseService,
    @AppPreferences private val pref: SharedPreferences,
    private val gson: Gson
) : FileUploadService() {

    private fun uploadNewsActivities() {
        val apiInterface = client?.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val newsLog: List<RealmNewsLog> = transactionRealm.where(RealmNewsLog::class.java)
                    .isNull("_id").or().isEmpty("_id")
                    .findAll()

                newsLog.processInBatches { news ->
                        try {
                            val `object` = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/myplanet_activities", RealmNewsLog.serialize(news))?.execute()?.body()

                            if (`object` != null) {
                                news._id = getString("id", `object`)
                                news._rev = getString("rev", `object`)
                            }
                        } catch (e: IOException) {
                            e.printStackTrace()
                        }
                }
            }
        }

    }

    fun uploadActivities(listener: SuccessListener?) {
        val apiInterface = client?.create(ApiInterface::class.java)
        val model = databaseService.withRealm { realm ->
            realm.where(RealmUserModel::class.java)
                .equalTo("id", pref.getString("userId", ""))
                .findFirst()
                ?.let { realm.copyFromRealm(it) }
        } ?: run {
            listener?.onSuccess("Cannot upload activities: user model is null")
            return
        }

        if (model.isManager()) {
            listener?.onSuccess("Skipping activities upload for manager")
            return
        }

        try {
            apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/myplanet_activities", MyPlanet.getNormalMyPlanetActivities(MainApplication.context, pref, model))?.enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {}

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {}
            })

            apiInterface?.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/myplanet_activities/${getAndroidId(MainApplication.context)}@${NetworkUtils.getUniqueIdentifier()}")?.enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    var `object` = response.body()

                    if (`object` != null) {
                        val usages = `object`.getAsJsonArray("usages")
                        usages.addAll(MyPlanet.getTabletUsages(context))
                        `object`.add("usages", usages)
                    } else {
                        `object` = MyPlanet.getMyPlanetActivities(context, pref, model)
                    }

                    apiInterface.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/myplanet_activities", `object`).enqueue(object : Callback<JsonObject?> {
                        override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                            listener?.onSuccess("My planet activities uploaded successfully")
                        }

                        override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                            listener?.onSuccess("Failed to upload activities: ${t.message}")
                        }
                    })
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    val `object` = MyPlanet.getMyPlanetActivities(context, pref, model)
                    apiInterface.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/myplanet_activities", `object`).enqueue(object : Callback<JsonObject?> {
                        override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                            listener?.onSuccess("My planet activities uploaded successfully")
                        }

                        override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                            listener?.onSuccess("Failed to upload activities: ${t.message}")
                        }
                    })
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
            listener?.onSuccess("Failed to upload activities: ${e.message}")
        }
    }

    fun uploadExamResult(listener: SuccessListener) {
        val apiInterface = client.create(ApiInterface::class.java)
        try {
            val submissionIds = databaseService.withRealm { realm ->
                realm.where(RealmSubmission::class.java).findAll()
                    .filter { (it.answers?.size ?: 0) > 0 && it.userId?.startsWith("guest") != true }
                    .mapNotNull { it.id }
            }

            var processedCount = 0
            var errorCount = 0

            submissionIds.chunked(BATCH_SIZE).forEach { batchIds ->
                val submissionsToUpload = databaseService.withRealm { realm ->
                    realm.where(RealmSubmission::class.java)
                        .`in`("id", batchIds.toTypedArray())
                        .findAll()
                        .map { sub ->
                            val serialized = RealmSubmission.serializeExamResult(realm, sub, context)
                            Triple(sub.id, serialized, sub._id)
                        }
                }

                for ((id, serialized, _id) in submissionsToUpload) {
                    try {
                        val response: JsonObject? = if (TextUtils.isEmpty(_id)) {
                            apiInterface.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/submissions", serialized).execute().body()
                        } else {
                            apiInterface.putDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/submissions/$_id", serialized).execute().body()
                        }

                        if (response != null && id != null) {
                            databaseService.withRealm { realm ->
                                realm.executeTransaction { transactionRealm ->
                                    transactionRealm.where(RealmSubmission::class.java).equalTo("id", id).findFirst()?.let { sub ->
                                        sub._id = getString("id", response)
                                        sub._rev = getString("rev", response)
                                    }
                                }
                            }
                            processedCount++
                        } else {
                            errorCount++
                        }
                    } catch (e: IOException) {
                        errorCount++
                        e.printStackTrace()
                    } catch (e: Exception) {
                        errorCount++
                        e.printStackTrace()
                    }
                }
            }

            uploadCourseProgress()
            listener.onSuccess("Result sync completed successfully ($processedCount processed, $errorCount errors)")
        } catch (e: Exception) {
            e.printStackTrace()
            listener.onSuccess("Error during result sync: ${e.message}")
        }
    }

    private fun createImage(user: RealmUserModel?, imgObject: JsonObject?): JsonObject {
        val `object` = JsonObject()
        `object`.addProperty("title", getString("fileName", imgObject))
        `object`.addProperty("createdDate", Date().time)
        `object`.addProperty("filename", getString("fileName", imgObject))
        `object`.addProperty("private", true)
        user?.id?.let { `object`.addProperty("addedBy", it) }
        user?.parentCode?.let { `object`.addProperty("resideOn", it) }
        user?.planetCode?.let { `object`.addProperty("sourcePlanet", it) }
        val object1 = JsonObject()
        `object`.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
        `object`.addProperty("deviceName", NetworkUtils.getDeviceName())
        `object`.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(MainApplication.context))
        `object`.add("privateFor", object1)
        `object`.addProperty("mediaType", "image")
        return `object`
    }

    fun uploadAchievement() {
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val list: List<RealmAchievement> =
                    transactionRealm.where(RealmAchievement::class.java).findAll()
                list.processInBatches { sub ->
                    try {
                        if (sub._id?.startsWith("guest") == true) {
                            return@processInBatches
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
                }
            }
        }

    }

    private fun uploadCourseProgress() {
        val apiInterface = client.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val data: List<RealmCourseProgress> =
                    transactionRealm.where(RealmCourseProgress::class.java).isNull("_id").findAll()
                var successCount = 0
                var skipCount = 0
                var errorCount = 0

                data.processInBatches { sub ->
                    try {
                        if (sub.userId?.startsWith("guest") == true) {
                            skipCount++
                            return@processInBatches
                        }

                        val `object` = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/courses_progress",
                            RealmCourseProgress.serializeProgress(sub)
                        )?.execute()?.body()
                        if (`object` != null) {
                            sub._id = getString("id", `object`)
                            sub._rev = getString("rev", `object`)
                            successCount++
                        } else {
                            errorCount++
                        }
                    } catch (e: IOException) {
                        errorCount++
                        e.printStackTrace()
                    }
                }
            }
        }
    }

    fun uploadFeedback(listener: SuccessListener) {
        val apiInterface = client.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync(Realm.Transaction { transactionRealm: Realm ->
                val feedbacks: List<RealmFeedback> =
                    transactionRealm.where(RealmFeedback::class.java).findAll()

                if (feedbacks.isEmpty()) {
                    return@Transaction
                }

                var successCount = 0
                var errorCount = 0

                feedbacks.processInBatches { feedback ->
                    try {
                        val res: Response<JsonObject>? = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/feedback",
                            RealmFeedback.serializeFeedback(feedback)
                        )?.execute()

                        val r = res?.body()
                        if (r != null) {
                            val revElement = r["rev"]
                            val idElement = r["id"]
                            if (revElement != null && idElement != null) {
                                feedback._rev = revElement.asString
                                feedback._id = idElement.asString
                                successCount++
                            } else {
                                errorCount++
                            }
                        } else {
                            errorCount++
                        }
                    } catch (e: IOException) {
                        errorCount++
                        e.printStackTrace()
                    }
                }
            }, {
                listener.onSuccess("Feedback sync completed successfully")
            }, { error ->
                listener.onSuccess("Feedback sync failed: ${error.message}")
                error.printStackTrace()
            })
        }
    }

    fun uploadSubmitPhotos(listener: SuccessListener?) {
        val apiInterface = client.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val data: List<RealmSubmitPhotos> =
                    transactionRealm.where(RealmSubmitPhotos::class.java).equalTo("uploaded", false).findAll()
                data.processInBatches { sub ->
                    try {
                        val `object` = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/submissions",
                            RealmSubmitPhotos.serializeRealmSubmitPhotos(sub)
                        )?.execute()?.body()
                        if (`object` != null) {
                            val rev = getString("rev", `object`)
                            val id = getString("id", `object`)
                            sub.uploaded = true
                            sub._rev = rev
                            sub._id = id
                            listener?.let { uploadAttachment(id, rev, sub, it) }
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
                if (data.isEmpty()) {
                    listener?.onSuccess("No photos to upload")
                }
            }
        }
    }

    fun uploadResource(listener: SuccessListener?) {
        val apiInterface = client?.create(ApiInterface::class.java)

        databaseService.withRealm { realm ->
            realm.executeTransactionAsync({ transactionRealm: Realm ->
                val user = transactionRealm.where(RealmUserModel::class.java)
                    .equalTo("id", pref.getString("userId", ""))
                    .findFirst()

                val data: List<RealmMyLibrary> = transactionRealm.where(RealmMyLibrary::class.java)
                    .isNull("_rev")
                    .findAll()

                if (data.isEmpty()) {
                    return@executeTransactionAsync
                }

                data.processInBatches { sub ->
                    try {
                        val `object` = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/resources",
                            RealmMyLibrary.serialize(sub, user)
                        )?.execute()?.body()

                        if (`object` != null) {
                            val rev = getString("rev", `object`)
                            val id = getString("id", `object`)
                            sub._rev = rev
                            sub._id = id
                            listener?.let { uploadAttachment(id, rev, sub, it) }
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }, {
                listener?.onSuccess("No resources to upload")
            }) { error ->
                listener?.onSuccess("Resource upload failed: ${error.message}")
            }
        }
    }

    fun uploadMyPersonal(personal: RealmMyPersonal, listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)

        if (!personal.isUploaded) {
            apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/resources", RealmMyPersonal.serialize(personal, context))?.enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    val `object` = response.body()
                    if (`object` != null) {
                        val rev = getString("rev", `object`)
                        val id = getString("id", `object`)
                        databaseService.withRealm { updateRealm ->
                            updateRealm.executeTransactionAsync({ transactionRealm ->
                                val managedPersonal = personal.id?.takeIf { it.isNotEmpty() }?.let { personalId ->
                                    transactionRealm.where(RealmMyPersonal::class.java)
                                        .equalTo("id", personalId)
                                        .findFirst()
                                } ?: personal._id?.takeIf { it.isNotEmpty() }?.let { existingId ->
                                    transactionRealm.where(RealmMyPersonal::class.java)
                                        .equalTo("_id", existingId)
                                        .findFirst()
                                }

                                managedPersonal?.let { realmPersonal ->
                                    realmPersonal.isUploaded = true
                                    realmPersonal._rev = rev
                                    realmPersonal._id = id
                                } ?: throw IllegalStateException("Personal resource not found")
                            }, {
                                uploadAttachment(id, rev, personal, listener)
                            }) { error ->
                                listener.onSuccess(
                                    "Error updating personal resource: ${error.message ?: "Unknown error"}"
                                )
                            }
                        }
                    } else {
                        listener.onSuccess("Failed to upload personal resource: No response")
                    }
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    listener.onSuccess("Unable to upload resource: ${t.message}")
                }
            })
        } else {
            listener.onSuccess("Resource already uploaded")
        }
    }

    fun uploadTeamTask() {
        val apiInterface = client?.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val list: List<RealmTeamTask> = transactionRealm.where(RealmTeamTask::class.java).findAll()
                val tasksToUpload = list.filter { task ->
                    TextUtils.isEmpty(task._id) || task.isUpdated
                }

                tasksToUpload.processInBatches { task ->
                    try {
                        val `object` = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/tasks",
                            RealmTeamTask.serialize(transactionRealm, task)
                        )?.execute()?.body()

                        if (`object` != null) {
                            val rev = getString("rev", `object`)
                            val id = getString("id", `object`)
                            task._rev = rev
                            task._id = id
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
                }
            }
        }
    }

    fun uploadSubmissions() {
        val apiInterface = client?.create(ApiInterface::class.java)

        try {
            val hasLooper = Looper.myLooper() != null

            databaseService.withRealm { realm ->
                if (hasLooper) {
                    realm.executeTransactionAsync { transactionRealm: Realm ->
                        val list: List<RealmSubmission> = transactionRealm.where(RealmSubmission::class.java)
                            .equalTo("isUpdated", true).or().isEmpty("_id").findAll()

                        list.processInBatches { submission ->
                            try {
                                val requestJson = RealmSubmission.serialize(transactionRealm, submission)
                                val response = apiInterface?.postDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/submissions",
                                    requestJson
                                )?.execute()

                                val jsonObject = response?.body()
                                if (jsonObject != null) {
                                    val rev = getString("rev", jsonObject)
                                    val id = getString("id", jsonObject)
                                    submission._rev = rev
                                    submission._id = id
                                    submission.isUpdated = false
                                }
                            } catch (e: IOException) {
                                e.printStackTrace()
                            }
                        }
                    }
                } else {
                    realm.executeTransaction { transactionRealm: Realm ->
                        val list: List<RealmSubmission> = transactionRealm.where(RealmSubmission::class.java)
                            .equalTo("isUpdated", true).or().isEmpty("_id").findAll()

                        list.processInBatches { submission ->
                            try {
                                val requestJson = RealmSubmission.serialize(transactionRealm, submission)
                                val response = apiInterface?.postDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/submissions",
                                    requestJson
                                )?.execute()

                                val jsonObject = response?.body()
                                if (jsonObject != null) {
                                    val rev = getString("rev", jsonObject)
                                    val id = getString("id", jsonObject)
                                    submission._rev = rev
                                    submission._id = id
                                    submission.isUpdated = false
                                }
                            } catch (e: IOException) {
                                e.printStackTrace()
                            }
                        }
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    fun uploadTeams() {
        val apiInterface = client?.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val teams: List<RealmMyTeam> =
                    transactionRealm.where(RealmMyTeam::class.java).equalTo("updated", true).findAll()
                teams.processInBatches { team ->
                    try {
                        val `object` = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/teams",
                            RealmMyTeam.serialize(team)
                        )?.execute()?.body()
                        if (`object` != null) {
                            team._rev = getString("rev", `object`)
                            team.updated = false
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
                }
            }
        }
    }

    fun uploadUserActivities(listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)
        val model = databaseService.withRealm { realm ->
            realm.where(RealmUserModel::class.java)
                .equalTo("id", pref.getString("userId", ""))
                .findFirst()
                ?.let { realm.copyFromRealm(it) }
        } ?: run {
            listener.onSuccess("Cannot upload user activities: user model is null")
            return
        }

        if (model.isManager()) {
            listener.onSuccess("Skipping user activities upload for manager")
            return
        }

        try {
            val hasLooper = Looper.myLooper() != null

            databaseService.withRealm { realm ->
                if (hasLooper) {
                    realm.executeTransactionAsync({ transactionRealm: Realm ->
                        val activities = transactionRealm.where(RealmOfflineActivity::class.java)
                            .isNull("_rev")
                            .equalTo("type", "login")
                            .findAll()

                        activities.processInBatches { act ->
                            try {
                                if (act.userId?.startsWith("guest") == true) {
                                    return@processInBatches
                                }

                                val `object` = apiInterface?.postDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/login_activities",
                                    RealmOfflineActivity.serializeLoginActivities(act, context)
                                )?.execute()?.body()
                                act.changeRev(`object`)
                            } catch (e: IOException) {
                                e.printStackTrace()
                            }
                        }
                        uploadTeamActivities(transactionRealm, apiInterface)
                    }, {
                        listener.onSuccess("User activities sync completed successfully")
                    }) { e: Throwable ->
                        e.printStackTrace()
                        listener.onSuccess(e.message)
                    }
                } else {
                    realm.executeTransaction { transactionRealm: Realm ->
                        val activities = transactionRealm.where(RealmOfflineActivity::class.java)
                            .isNull("_rev")
                            .equalTo("type", "login")
                            .findAll()

                        activities.processInBatches { act ->
                            try {
                                if (act.userId?.startsWith("guest") == true) {
                                    return@processInBatches
                                }

                                val `object` = apiInterface?.postDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/login_activities",
                                    RealmOfflineActivity.serializeLoginActivities(act, context)
                                )?.execute()?.body()
                                act.changeRev(`object`)
                            } catch (e: IOException) {
                                e.printStackTrace()
                            }
                        }
                        uploadTeamActivities(transactionRealm, apiInterface)
                    }
                    listener.onSuccess("User activities sync completed successfully")
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
            listener.onSuccess("Failed to upload user activities: ${e.message}")
        }
    }

    fun uploadTeamActivities(realm: Realm, apiInterface: ApiInterface?) {
        val logs = realm.where(RealmTeamLog::class.java).isNull("_rev").findAll()
        logs.processInBatches { log ->
                try {
                    val `object` = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/team_activities", RealmTeamLog.serializeTeamActivities(log, context))?.execute()?.body()
                    if (`object` != null) {
                        log._id = getString("id", `object`)
                        log._rev = getString("rev", `object`)
                    }
                } catch (e: IOException) {
                    e.printStackTrace()
                }
        }
    }

    fun uploadRating() {
        val apiInterface = client?.create(ApiInterface::class.java)

        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val activities = transactionRealm.where(RealmRating::class.java).equalTo("isUpdated", true).findAll()
                activities.processInBatches { act ->
                    try {
                        if (act.userId?.startsWith("guest") == true) {
                            return@processInBatches
                        }

                        val `object`: Response<JsonObject>? =
                            if (TextUtils.isEmpty(act._id)) {
                                apiInterface?.postDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/ratings",
                                    RealmRating.serializeRating(act)
                                )?.execute()
                            } else {
                                apiInterface?.putDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/ratings/" + act._id,
                                    RealmRating.serializeRating(act)
                                )?.execute()
                            }
                        if (`object`?.body() != null) {
                            act._id = getString("id", `object`.body())
                            act._rev = getString("rev", `object`.body())
                            act.isUpdated = false
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
        }
    }

    fun uploadNews() {
        val apiInterface = client?.create(ApiInterface::class.java)

        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
            val activities = transactionRealm.where(RealmNews::class.java).findAll()
            activities.processInBatches { act ->
                    try {
                        if (act.userId?.startsWith("guest") == true) {
                            return@processInBatches
                        }

                        val `object` = RealmNews.serializeNews(act)
                        val image = act.imagesArray
                        val user = transactionRealm.where(RealmUserModel::class.java).equalTo("id", pref.getString("userId", "")).findFirst()

                        if (act.imageUrls != null && act.imageUrls?.isNotEmpty() == true) {
                            act.imageUrls?.chunked(5)?.forEach { imageChunk ->
                                imageChunk.forEach { imageObject ->
                                    val imgObject = gson.fromJson(imageObject, JsonObject::class.java)
                                    val ob = createImage(user, imgObject)
                                    val response = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/resources", ob)?.execute()?.body()

                                    val rev = getString("rev", response)
                                    val id = getString("id", response)
                                    val f = File(getString("imageUrl", imgObject))
                                    val name = FileUtils.getFileNameFromUrl(getString("imageUrl", imgObject))
                                    val format = "%s/resources/%s/%s"
                                    val connection = f.toURI().toURL().openConnection()
                                    val mimeType = connection.contentType
                                    val body = FileUtils.fullyReadFileToBytes(f)
                                        .toRequestBody("application/octet-stream".toMediaTypeOrNull())
                                    val url = String.format(format, UrlUtils.getUrl(), id, name)

                                    val res = apiInterface?.uploadResource(getHeaderMap(mimeType, rev), url, body)?.execute()
                                    val attachment = res?.body()

                                    val resourceObject = JsonObject()
                                    resourceObject.addProperty("resourceId", getString("id", attachment))
                                    resourceObject.addProperty("filename", getString("fileName", imgObject))
                                    val markdown = "![](resources/" + getString("id", attachment) + "/" + getString("fileName", imgObject) + ")"
                                    resourceObject.addProperty("markdown", markdown)

                                    var msg = getString("message", `object`)
                                    msg += """

                                    $markdown
                                    """.trimIndent()
                                    `object`.addProperty("message", msg)
                                    image.add(resourceObject)
                                }
                            }
                        }

                        act.images = gson.toJson(image)
                        `object`.add("images", image)

                        val newsUploadResponse: Response<JsonObject>? =
                            if (TextUtils.isEmpty(act._id)) {
                                apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/news", `object`)?.execute()
                            } else {
                                apiInterface?.putDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/news/" + act._id, `object`)?.execute()
                            }
                        if (newsUploadResponse?.body() != null) {
                            act.imageUrls?.clear()
                            act._id = getString("id", newsUploadResponse.body())
                            act._rev = getString("rev", newsUploadResponse.body())
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
        }
        uploadNewsActivities()
    }

    fun uploadCrashLog() {
        val apiInterface = client?.create(ApiInterface::class.java)

        try {
            val hasLooper = Looper.myLooper() != null

            databaseService.withRealm { realm ->
                if (hasLooper) {
                    realm.executeTransactionAsync { transactionRealm: Realm ->
                        uploadCrashLogData(transactionRealm, apiInterface)
                    }
                } else {
                    realm.executeTransaction { transactionRealm: Realm ->
                        uploadCrashLogData(transactionRealm, apiInterface)
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun uploadCrashLogData(realm: Realm, apiInterface: ApiInterface?) {
        val logs: RealmResults<RealmApkLog> = realm.where(RealmApkLog::class.java).isNull("_rev").findAll()

        logs.processInBatches { act ->
                try {
                    val o = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/apk_logs", RealmApkLog.serialize(act, context))?.execute()?.body()

                    if (o != null) {
                        act._rev = getString("rev", o)
                    }
                } catch (e: IOException) {
                    e.printStackTrace()
                }
        }
    }

    fun uploadSearchActivity() {
        val apiInterface = client?.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
            val logs: RealmResults<RealmSearchActivity> = transactionRealm.where(RealmSearchActivity::class.java).isEmpty("_rev").findAll()
            logs.processInBatches { act ->
                    try {
                        val o = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/search_activities", act.serialize())?.execute()?.body()
                        if (o != null) {
                            act._rev = getString("rev", o)
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
            }
            }
        }

    }

    fun uploadResourceActivities(type: String) {
        val apiInterface = client?.create(ApiInterface::class.java)

        val db = if (type == "sync") {
            "admin_activities"
        } else {
            "resource_activities"
        }

        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
            val activities: RealmResults<RealmResourceActivity> =
                if (type == "sync") {
                    transactionRealm.where(RealmResourceActivity::class.java).isNull("_rev").equalTo("type", "sync").findAll()
                } else {
                    transactionRealm.where(RealmResourceActivity::class.java).isNull("_rev").notEqualTo("type", "sync").findAll()
                }
            activities.processInBatches { act ->
                    try {
                        val `object` = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/" + db, RealmResourceActivity.serializeResourceActivities(act))?.execute()?.body()

                        if (`object` != null) {
                            act._rev = getString("rev", `object`)
                            act._id = getString("id", `object`)
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
            }
            }
        }
    }

    fun uploadCourseActivities() {
        val apiInterface = client?.create(ApiInterface::class.java)

        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
            val activities: RealmResults<RealmCourseActivity> = transactionRealm.where(RealmCourseActivity::class.java).isNull("_rev").notEqualTo("type", "sync").findAll()
            activities.processInBatches { act ->
                    try {
                        val `object` = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/course_activities", RealmCourseActivity.serializeSerialize(act))?.execute()?.body()

                        if (`object` != null) {
                            act._rev = getString("rev", `object`)
                            act._id = getString("id", `object`)
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
            }
            }
        }
    }

    fun uploadMeetups() {
        val apiInterface = client?.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
            val meetups: List<RealmMeetup> = transactionRealm.where(RealmMeetup::class.java).findAll()
            meetups.processInBatches { meetup ->
                    try {
                        val meetupJson = RealmMeetup.serialize(meetup)
                        val `object` = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/meetups", meetupJson)?.execute()?.body()

                        if (`object` != null) {
                            meetup.meetupId = getString("id", `object`)
                            meetup.meetupIdRev = getString("rev", `object`)
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
            }
            }
        }
    }
}
=======
package org.ole.planet.myplanet.service


import android.content.Context
import android.content.SharedPreferences
import android.os.Looper
import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.qualifiers.ApplicationContext
import io.realm.Realm
import io.realm.RealmResults
import java.io.File
import java.io.IOException
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.FileUploadService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.model.RealmAchievement
import org.ole.planet.myplanet.model.RealmApkLog
import org.ole.planet.myplanet.model.RealmCourseActivity
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyPersonal
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmNewsLog
import org.ole.planet.myplanet.model.RealmOfflineActivity
import org.ole.planet.myplanet.model.RealmRating
import org.ole.planet.myplanet.model.RealmResourceActivity
import org.ole.planet.myplanet.model.RealmSearchActivity
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmitPhotos
import org.ole.planet.myplanet.model.RealmTeamLog
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.VersionUtils.getAndroidId
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

private const val BATCH_SIZE = 50

private inline fun <T> Iterable<T>.processInBatches(action: (T) -> Unit) {
    chunked(BATCH_SIZE).forEach { chunk ->
        chunk.forEach { item ->
            action(item)
        }
    }
}

@Singleton
class UploadManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val databaseService: DatabaseService,
    @AppPreferences private val pref: SharedPreferences,
    private val gson: Gson
) : FileUploadService() {

    private fun uploadNewsActivities() {
        val apiInterface = client?.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val newsLog: List<RealmNewsLog> = transactionRealm.where(RealmNewsLog::class.java)
                    .isNull("_id").or().isEmpty("_id")
                    .findAll()

                newsLog.processInBatches { news ->
                        try {
                            val `object` = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/myplanet_activities", RealmNewsLog.serialize(news))?.execute()?.body()

                            if (`object` != null) {
                                news._id = getString("id", `object`)
                                news._rev = getString("rev", `object`)
                            }
                        } catch (e: IOException) {
                            e.printStackTrace()
                        }
                }
            }
        }

    }

    fun uploadActivities(listener: SuccessListener?) {
        val apiInterface = client?.create(ApiInterface::class.java)
        val model = databaseService.withRealm { realm ->
            realm.where(RealmUserModel::class.java)
                .equalTo("id", pref.getString("userId", ""))
                .findFirst()
                ?.let { realm.copyFromRealm(it) }
        } ?: run {
            listener?.onSuccess("Cannot upload activities: user model is null")
            return
        }

        if (model.isManager()) {
            listener?.onSuccess("Skipping activities upload for manager")
            return
        }

        try {
            apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/myplanet_activities", MyPlanet.getNormalMyPlanetActivities(MainApplication.context, pref, model))?.enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {}

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {}
            })

            apiInterface?.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/myplanet_activities/${getAndroidId(MainApplication.context)}@${NetworkUtils.getUniqueIdentifier()}")?.enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    var `object` = response.body()

                    if (`object` != null) {
                        val usages = `object`.getAsJsonArray("usages")
                        usages.addAll(MyPlanet.getTabletUsages(context))
                        `object`.add("usages", usages)
                    } else {
                        `object` = MyPlanet.getMyPlanetActivities(context, pref, model)
                    }

                    apiInterface.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/myplanet_activities", `object`).enqueue(object : Callback<JsonObject?> {
                        override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                            listener?.onSuccess("My planet activities uploaded successfully")
                        }

                        override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                            listener?.onSuccess("Failed to upload activities: ${t.message}")
                        }
                    })
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    val `object` = MyPlanet.getMyPlanetActivities(context, pref, model)
                    apiInterface.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/myplanet_activities", `object`).enqueue(object : Callback<JsonObject?> {
                        override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                            listener?.onSuccess("My planet activities uploaded successfully")
                        }

                        override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                            listener?.onSuccess("Failed to upload activities: ${t.message}")
                        }
                    })
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
            listener?.onSuccess("Failed to upload activities: ${e.message}")
        }
    }

    fun uploadExamResult(listener: SuccessListener) {
        val apiInterface = client.create(ApiInterface::class.java)
        try {
            val submissionIds = databaseService.withRealm { realm ->
                realm.where(RealmSubmission::class.java).findAll()
                    .filter { (it.answers?.size ?: 0) > 0 && it.userId?.startsWith("guest") != true }
                    .mapNotNull { it.id }
            }

            var processedCount = 0
            var errorCount = 0

            submissionIds.chunked(BATCH_SIZE).forEach { batchIds ->
                val submissionsToUpload = databaseService.withRealm { realm ->
                    realm.where(RealmSubmission::class.java)
                        .`in`("id", batchIds.toTypedArray())
                        .findAll()
                        .map { sub ->
                            val serialized = RealmSubmission.serializeExamResult(realm, sub, context)
                            Triple(sub.id, serialized, sub._id)
                        }
                }

                for ((id, serialized, _id) in submissionsToUpload) {
                    try {
                        val response: JsonObject? = if (TextUtils.isEmpty(_id)) {
                            apiInterface.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/submissions", serialized).execute().body()
                        } else {
                            apiInterface.putDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/submissions/$_id", serialized).execute().body()
                        }

                        if (response != null && id != null) {
                            databaseService.withRealm { realm ->
                                realm.executeTransaction { transactionRealm ->
                                    transactionRealm.where(RealmSubmission::class.java).equalTo("id", id).findFirst()?.let { sub ->
                                        sub._id = getString("id", response)
                                        sub._rev = getString("rev", response)
                                    }
                                }
                            }
                            processedCount++
                        } else {
                            errorCount++
                        }
                    } catch (e: IOException) {
                        errorCount++
                        e.printStackTrace()
                    } catch (e: Exception) {
                        errorCount++
                        e.printStackTrace()
                    }
                }
            }

            uploadCourseProgress()
            listener.onSuccess("Result sync completed successfully ($processedCount processed, $errorCount errors)")
        } catch (e: Exception) {
            e.printStackTrace()
            listener.onSuccess("Error during result sync: ${e.message}")
        }
    }

    private fun createImage(user: RealmUserModel?, imgObject: JsonObject?): JsonObject {
        val `object` = JsonObject()
        `object`.addProperty("title", getString("fileName", imgObject))
        `object`.addProperty("createdDate", Date().time)
        `object`.addProperty("filename", getString("fileName", imgObject))
        `object`.addProperty("private", true)
        user?.id?.let { `object`.addProperty("addedBy", it) }
        user?.parentCode?.let { `object`.addProperty("resideOn", it) }
        user?.planetCode?.let { `object`.addProperty("sourcePlanet", it) }
        val object1 = JsonObject()
        `object`.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
        `object`.addProperty("deviceName", NetworkUtils.getDeviceName())
        `object`.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(MainApplication.context))
        `object`.add("privateFor", object1)
        `object`.addProperty("mediaType", "image")
        return `object`
    }

    fun uploadAchievement() {
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val list: List<RealmAchievement> =
                    transactionRealm.where(RealmAchievement::class.java).findAll()
                list.processInBatches { sub ->
                    try {
                        if (sub._id?.startsWith("guest") == true) {
                            return@processInBatches
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
                }
            }
        }

    }

    private fun uploadCourseProgress() {
        val apiInterface = client.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val data: List<RealmCourseProgress> =
                    transactionRealm.where(RealmCourseProgress::class.java).isNull("_id").findAll()
                var successCount = 0
                var skipCount = 0
                var errorCount = 0

                data.processInBatches { sub ->
                    try {
                        if (sub.userId?.startsWith("guest") == true) {
                            skipCount++
                            return@processInBatches
                        }

                        val `object` = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/courses_progress",
                            RealmCourseProgress.serializeProgress(sub)
                        )?.execute()?.body()
                        if (`object` != null) {
                            sub._id = getString("id", `object`)
                            sub._rev = getString("rev", `object`)
                            successCount++
                        } else {
                            errorCount++
                        }
                    } catch (e: IOException) {
                        errorCount++
                        e.printStackTrace()
                    }
                }
            }
        }
    }

    fun uploadFeedback(listener: SuccessListener) {
        val apiInterface = client.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync(Realm.Transaction { transactionRealm: Realm ->
                val feedbacks: List<RealmFeedback> =
                    transactionRealm.where(RealmFeedback::class.java).findAll()

                if (feedbacks.isEmpty()) {
                    return@Transaction
                }

                var successCount = 0
                var errorCount = 0

                feedbacks.processInBatches { feedback ->
                    try {
                        val res: Response<JsonObject>? = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/feedback",
                            RealmFeedback.serializeFeedback(feedback)
                        )?.execute()

                        val r = res?.body()
                        if (r != null) {
                            val revElement = r["rev"]
                            val idElement = r["id"]
                            if (revElement != null && idElement != null) {
                                feedback._rev = revElement.asString
                                feedback._id = idElement.asString
                                successCount++
                            } else {
                                errorCount++
                            }
                        } else {
                            errorCount++
                        }
                    } catch (e: IOException) {
                        errorCount++
                        e.printStackTrace()
                    }
                }
            }, {
                listener.onSuccess("Feedback sync completed successfully")
            }, { error ->
                listener.onSuccess("Feedback sync failed: ${error.message}")
                error.printStackTrace()
            })
        }
    }

    fun uploadSubmitPhotos(listener: SuccessListener?) {
        val apiInterface = client.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val data: List<RealmSubmitPhotos> =
                    transactionRealm.where(RealmSubmitPhotos::class.java).equalTo("uploaded", false).findAll()
                data.processInBatches { sub ->
                    try {
                        val `object` = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/submissions",
                            RealmSubmitPhotos.serializeRealmSubmitPhotos(sub)
                        )?.execute()?.body()
                        if (`object` != null) {
                            val rev = getString("rev", `object`)
                            val id = getString("id", `object`)
                            sub.uploaded = true
                            sub._rev = rev
                            sub._id = id
                            listener?.let { uploadAttachment(id, rev, sub, it) }
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
                if (data.isEmpty()) {
                    listener?.onSuccess("No photos to upload")
                }
            }
        }
    }

    fun uploadResource(listener: SuccessListener?) {
        val apiInterface = client?.create(ApiInterface::class.java)

        databaseService.withRealm { realm ->
            realm.executeTransactionAsync({ transactionRealm: Realm ->
                val user = transactionRealm.where(RealmUserModel::class.java)
                    .equalTo("id", pref.getString("userId", ""))
                    .findFirst()

                val data: List<RealmMyLibrary> = transactionRealm.where(RealmMyLibrary::class.java)
                    .isNull("_rev")
                    .findAll()

                if (data.isEmpty()) {
                    return@executeTransactionAsync
                }

                data.processInBatches { sub ->
                    try {
                        val `object` = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/resources",
                            RealmMyLibrary.serialize(sub, user)
                        )?.execute()?.body()

                        if (`object` != null) {
                            val rev = getString("rev", `object`)
                            val id = getString("id", `object`)
                            sub._rev = rev
                            sub._id = id
                            listener?.let { uploadAttachment(id, rev, sub, it) }
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }, {
                listener?.onSuccess("No resources to upload")
            }) { error ->
                listener?.onSuccess("Resource upload failed: ${error.message}")
            }
        }
    }

    fun uploadMyPersonal(personal: RealmMyPersonal, listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)

        if (!personal.isUploaded) {
            apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/resources", RealmMyPersonal.serialize(personal, context))?.enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    val `object` = response.body()
                    if (`object` != null) {
                        val rev = getString("rev", `object`)
                        val id = getString("id", `object`)
                        databaseService.withRealm { updateRealm ->
                            updateRealm.executeTransactionAsync({ transactionRealm ->
                                val managedPersonal = personal.id?.takeIf { it.isNotEmpty() }?.let { personalId ->
                                    transactionRealm.where(RealmMyPersonal::class.java)
                                        .equalTo("id", personalId)
                                        .findFirst()
                                } ?: personal._id?.takeIf { it.isNotEmpty() }?.let { existingId ->
                                    transactionRealm.where(RealmMyPersonal::class.java)
                                        .equalTo("_id", existingId)
                                        .findFirst()
                                }

                                managedPersonal?.let { realmPersonal ->
                                    realmPersonal.isUploaded = true
                                    realmPersonal._rev = rev
                                    realmPersonal._id = id
                                } ?: throw IllegalStateException("Personal resource not found")
                            }, {
                                uploadAttachment(id, rev, personal, listener)
                            }) { error ->
                                listener.onSuccess(
                                    "Error updating personal resource: ${error.message ?: "Unknown error"}"
                                )
                            }
                        }
                    } else {
                        listener.onSuccess("Failed to upload personal resource: No response")
                    }
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    listener.onSuccess("Unable to upload resource: ${t.message}")
                }
            })
        } else {
            listener.onSuccess("Resource already uploaded")
        }
    }

    fun uploadTeamTask() {
        val apiInterface = client?.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val list: List<RealmTeamTask> = transactionRealm.where(RealmTeamTask::class.java).findAll()
                val tasksToUpload = list.filter { task ->
                    TextUtils.isEmpty(task._id) || task.isUpdated
                }

                tasksToUpload.processInBatches { task ->
                    try {
                        val `object` = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/tasks",
                            RealmTeamTask.serialize(transactionRealm, task)
                        )?.execute()?.body()

                        if (`object` != null) {
                            val rev = getString("rev", `object`)
                            val id = getString("id", `object`)
                            task._rev = rev
                            task._id = id
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
                }
            }
        }
    }

    fun uploadSubmissions() {
        val apiInterface = client?.create(ApiInterface::class.java)

        try {
            val hasLooper = Looper.myLooper() != null

            databaseService.withRealm { realm ->
                if (hasLooper) {
                    realm.executeTransactionAsync { transactionRealm: Realm ->
                        val list: List<RealmSubmission> = transactionRealm.where(RealmSubmission::class.java)
                            .equalTo("isUpdated", true).or().isEmpty("_id").findAll()

                        list.processInBatches { submission ->
                            try {
                                val requestJson = RealmSubmission.serialize(transactionRealm, submission)
                                val response = apiInterface?.postDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/submissions",
                                    requestJson
                                )?.execute()

                                val jsonObject = response?.body()
                                if (jsonObject != null) {
                                    val rev = getString("rev", jsonObject)
                                    val id = getString("id", jsonObject)
                                    submission._rev = rev
                                    submission._id = id
                                    submission.isUpdated = false
                                }
                            } catch (e: IOException) {
                                e.printStackTrace()
                            }
                        }
                    }
                } else {
                    realm.executeTransaction { transactionRealm: Realm ->
                        val list: List<RealmSubmission> = transactionRealm.where(RealmSubmission::class.java)
                            .equalTo("isUpdated", true).or().isEmpty("_id").findAll()

                        list.processInBatches { submission ->
                            try {
                                val requestJson = RealmSubmission.serialize(transactionRealm, submission)
                                val response = apiInterface?.postDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/submissions",
                                    requestJson
                                )?.execute()

                                val jsonObject = response?.body()
                                if (jsonObject != null) {
                                    val rev = getString("rev", jsonObject)
                                    val id = getString("id", jsonObject)
                                    submission._rev = rev
                                    submission._id = id
                                    submission.isUpdated = false
                                }
                            } catch (e: IOException) {
                                e.printStackTrace()
                            }
                        }
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    fun uploadTeams() {
        val apiInterface = client?.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val teams: List<RealmMyTeam> =
                    transactionRealm.where(RealmMyTeam::class.java).equalTo("updated", true).findAll()
                teams.processInBatches { team ->
                    try {
                        val `object` = apiInterface?.postDoc(
                            UrlUtils.header,
                            "application/json",
                            "${UrlUtils.getUrl()}/teams",
                            RealmMyTeam.serialize(team)
                        )?.execute()?.body()
                        if (`object` != null) {
                            team._rev = getString("rev", `object`)
                            team.updated = false
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
                }
            }
        }
    }

    fun uploadUserActivities(listener: SuccessListener) {
        val apiInterface = client?.create(ApiInterface::class.java)
        val model = databaseService.withRealm { realm ->
            realm.where(RealmUserModel::class.java)
                .equalTo("id", pref.getString("userId", ""))
                .findFirst()
                ?.let { realm.copyFromRealm(it) }
        } ?: run {
            listener.onSuccess("Cannot upload user activities: user model is null")
            return
        }

        if (model.isManager()) {
            listener.onSuccess("Skipping user activities upload for manager")
            return
        }

        try {
            val hasLooper = Looper.myLooper() != null

            databaseService.withRealm { realm ->
                if (hasLooper) {
                    realm.executeTransactionAsync({ transactionRealm: Realm ->
                        val activities = transactionRealm.where(RealmOfflineActivity::class.java)
                            .isNull("_rev")
                            .equalTo("type", "login")
                            .findAll()

                        activities.processInBatches { act ->
                            try {
                                if (act.userId?.startsWith("guest") == true) {
                                    return@processInBatches
                                }

                                val `object` = apiInterface?.postDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/login_activities",
                                    RealmOfflineActivity.serializeLoginActivities(act, context)
                                )?.execute()?.body()
                                act.changeRev(`object`)
                            } catch (e: IOException) {
                                e.printStackTrace()
                            }
                        }
                        uploadTeamActivities(transactionRealm, apiInterface)
                    }, {
                        listener.onSuccess("User activities sync completed successfully")
                    }) { e: Throwable ->
                        e.printStackTrace()
                        listener.onSuccess(e.message)
                    }
                } else {
                    realm.executeTransaction { transactionRealm: Realm ->
                        val activities = transactionRealm.where(RealmOfflineActivity::class.java)
                            .isNull("_rev")
                            .equalTo("type", "login")
                            .findAll()

                        activities.processInBatches { act ->
                            try {
                                if (act.userId?.startsWith("guest") == true) {
                                    return@processInBatches
                                }

                                val `object` = apiInterface?.postDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/login_activities",
                                    RealmOfflineActivity.serializeLoginActivities(act, context)
                                )?.execute()?.body()
                                act.changeRev(`object`)
                            } catch (e: IOException) {
                                e.printStackTrace()
                            }
                        }
                        uploadTeamActivities(transactionRealm, apiInterface)
                    }
                    listener.onSuccess("User activities sync completed successfully")
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
            listener.onSuccess("Failed to upload user activities: ${e.message}")
        }
    }

    fun uploadTeamActivities(realm: Realm, apiInterface: ApiInterface?) {
        val logs = realm.where(RealmTeamLog::class.java).isNull("_rev").findAll()
        logs.processInBatches { log ->
                try {
                    val `object` = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/team_activities", RealmTeamLog.serializeTeamActivities(log, context))?.execute()?.body()
                    if (`object` != null) {
                        log._id = getString("id", `object`)
                        log._rev = getString("rev", `object`)
                    }
                } catch (e: IOException) {
                    e.printStackTrace()
                }
        }
    }

    fun uploadRating() {
        val apiInterface = client?.create(ApiInterface::class.java)

        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
                val activities = transactionRealm.where(RealmRating::class.java).equalTo("isUpdated", true).findAll()
                activities.processInBatches { act ->
                    try {
                        if (act.userId?.startsWith("guest") == true) {
                            return@processInBatches
                        }

                        val `object`: Response<JsonObject>? =
                            if (TextUtils.isEmpty(act._id)) {
                                apiInterface?.postDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/ratings",
                                    RealmRating.serializeRating(act)
                                )?.execute()
                            } else {
                                apiInterface?.putDoc(
                                    UrlUtils.header,
                                    "application/json",
                                    "${UrlUtils.getUrl()}/ratings/" + act._id,
                                    RealmRating.serializeRating(act)
                                )?.execute()
                            }
                        if (`object`?.body() != null) {
                            act._id = getString("id", `object`.body())
                            act._rev = getString("rev", `object`.body())
                            act.isUpdated = false
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
        }
    }

    fun uploadNews() {
        val apiInterface = client?.create(ApiInterface::class.java)

        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
            val activities = transactionRealm.where(RealmNews::class.java).findAll()
            activities.processInBatches { act ->
                    try {
                        if (act.userId?.startsWith("guest") == true) {
                            return@processInBatches
                        }

                        val `object` = RealmNews.serializeNews(act)
                        val image = act.imagesArray
                        val user = transactionRealm.where(RealmUserModel::class.java).equalTo("id", pref.getString("userId", "")).findFirst()

                        if (act.imageUrls != null && act.imageUrls?.isNotEmpty() == true) {
                            act.imageUrls?.chunked(5)?.forEach { imageChunk ->
                                imageChunk.forEach { imageObject ->
                                    val imgObject = gson.fromJson(imageObject, JsonObject::class.java)
                                    val ob = createImage(user, imgObject)
                                    val response = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/resources", ob)?.execute()?.body()

                                    val rev = getString("rev", response)
                                    val id = getString("id", response)
                                    val f = File(getString("imageUrl", imgObject))
                                    val name = FileUtils.getFileNameFromUrl(getString("imageUrl", imgObject))
                                    val format = "%s/resources/%s/%s"
                                    val connection = f.toURI().toURL().openConnection()
                                    val mimeType = connection.contentType
                                    val body = FileUtils.fullyReadFileToBytes(f)
                                        .toRequestBody("application/octet-stream".toMediaTypeOrNull())
                                    val url = String.format(format, UrlUtils.getUrl(), id, name)

                                    val res = apiInterface?.uploadResource(getHeaderMap(mimeType, rev), url, body)?.execute()
                                    val attachment = res?.body()

                                    val resourceObject = JsonObject()
                                    resourceObject.addProperty("resourceId", getString("id", attachment))
                                    resourceObject.addProperty("filename", getString("fileName", imgObject))
                                    val markdown = "![](resources/" + getString("id", attachment) + "/" + getString("fileName", imgObject) + ")"
                                    resourceObject.addProperty("markdown", markdown)

                                    var msg = getString("message", `object`)
                                    msg += """

                                    $markdown
                                    """.trimIndent()
                                    `object`.addProperty("message", msg)
                                    image.add(resourceObject)
                                }
                            }
                        }

                        act.images = gson.toJson(image)
                        `object`.add("images", image)

                        val newsUploadResponse: Response<JsonObject>? =
                            if (TextUtils.isEmpty(act._id)) {
                                apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/news", `object`)?.execute()
                            } else {
                                apiInterface?.putDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/news/" + act._id, `object`)?.execute()
                            }
                        if (newsUploadResponse?.body() != null) {
                            act.imageUrls?.clear()
                            act._id = getString("id", newsUploadResponse.body())
                            act._rev = getString("rev", newsUploadResponse.body())
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
        }
        uploadNewsActivities()
    }

    fun uploadCrashLog() {
        val apiInterface = client?.create(ApiInterface::class.java)

        try {
            val hasLooper = Looper.myLooper() != null

            databaseService.withRealm { realm ->
                if (hasLooper) {
                    realm.executeTransactionAsync { transactionRealm: Realm ->
                        uploadCrashLogData(transactionRealm, apiInterface)
                    }
                } else {
                    realm.executeTransaction { transactionRealm: Realm ->
                        uploadCrashLogData(transactionRealm, apiInterface)
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun uploadCrashLogData(realm: Realm, apiInterface: ApiInterface?) {
        val logs: RealmResults<RealmApkLog> = realm.where(RealmApkLog::class.java).isNull("_rev").findAll()

        logs.processInBatches { act ->
                try {
                    val o = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/apk_logs", RealmApkLog.serialize(act, context))?.execute()?.body()

                    if (o != null) {
                        act._rev = getString("rev", o)
                    }
                } catch (e: IOException) {
                    e.printStackTrace()
                }
        }
    }

    fun uploadSearchActivity() {
        val apiInterface = client?.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
            val logs: RealmResults<RealmSearchActivity> = transactionRealm.where(RealmSearchActivity::class.java).isEmpty("_rev").findAll()
            logs.processInBatches { act ->
                    try {
                        val o = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/search_activities", act.serialize())?.execute()?.body()
                        if (o != null) {
                            act._rev = getString("rev", o)
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
            }
            }
        }

    }

    fun uploadResourceActivities(type: String) {
        val apiInterface = client?.create(ApiInterface::class.java)

        val db = if (type == "sync") {
            "admin_activities"
        } else {
            "resource_activities"
        }

        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
            val activities: RealmResults<RealmResourceActivity> =
                if (type == "sync") {
                    transactionRealm.where(RealmResourceActivity::class.java).isNull("_rev").equalTo("type", "sync").findAll()
                } else {
                    transactionRealm.where(RealmResourceActivity::class.java).isNull("_rev").notEqualTo("type", "sync").findAll()
                }
            activities.processInBatches { act ->
                    try {
                        val `object` = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/" + db, RealmResourceActivity.serializeResourceActivities(act))?.execute()?.body()

                        if (`object` != null) {
                            act._rev = getString("rev", `object`)
                            act._id = getString("id", `object`)
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
            }
            }
        }
    }

    fun uploadCourseActivities() {
        val apiInterface = client?.create(ApiInterface::class.java)

        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
            val activities: RealmResults<RealmCourseActivity> = transactionRealm.where(RealmCourseActivity::class.java).isNull("_rev").notEqualTo("type", "sync").findAll()
            activities.processInBatches { act ->
                    try {
                        val `object` = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/course_activities", RealmCourseActivity.serializeSerialize(act))?.execute()?.body()

                        if (`object` != null) {
                            act._rev = getString("rev", `object`)
                            act._id = getString("id", `object`)
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
            }
            }
        }
    }

    fun uploadMeetups() {
        val apiInterface = client?.create(ApiInterface::class.java)
        databaseService.withRealm { realm ->
            realm.executeTransactionAsync { transactionRealm: Realm ->
            val meetups: List<RealmMeetup> = transactionRealm.where(RealmMeetup::class.java).findAll()
            meetups.processInBatches { meetup ->
                    try {
                        val meetupJson = RealmMeetup.serialize(meetup)
                        val `object` = apiInterface?.postDoc(UrlUtils.header, "application/json", "${UrlUtils.getUrl()}/meetups", meetupJson)?.execute()?.body()

                        if (`object` != null) {
                            meetup.meetupId = getString("id", `object`)
                            meetup.meetupIdRev = getString("rev", `object`)
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
            }
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/TaskNotificationWorker.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.content.Context
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import dagger.hilt.android.EntryPointAccessors
import java.util.Calendar
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.di.WorkerDependenciesEntryPoint
import org.ole.planet.myplanet.utilities.NotificationUtils.create
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate

class TaskNotificationWorker(appContext: Context, workerParams: WorkerParameters) :
    CoroutineWorker(appContext, workerParams) {

    override suspend fun doWork(): Result {
        val current = Calendar.getInstance().timeInMillis
        val tomorrow = Calendar.getInstance()
        tomorrow.add(Calendar.DAY_OF_YEAR, 1)

        val entryPoint = EntryPointAccessors.fromApplication(
            applicationContext,
            WorkerDependenciesEntryPoint::class.java
        )
        val userProfileDbHandler = entryPoint.userProfileDbHandler()
        val teamRepository = entryPoint.teamRepository()

        val user = userProfileDbHandler.userModel
        val userId = user?.id
        if (!userId.isNullOrBlank()) {
            val tasks = runCatching {
                teamRepository.getPendingTasksForUser(userId, current, tomorrow.timeInMillis)
            }.getOrElse { emptyList() }

            if (tasks.isNotEmpty()) {
                tasks.forEach { task ->
                    create(
                        applicationContext,
                        R.drawable.ole_logo,
                        task.title,
                        "Task expires on " + formatDate(task.deadline, ""),
                    )
                }

                val taskIds = tasks.mapNotNull { it.id }.filter { it.isNotBlank() }
                if (taskIds.isNotEmpty()) {
                    runCatching { teamRepository.markTasksNotified(taskIds) }
                }
            }
        }
        return Result.success()
    }
}
=======
package org.ole.planet.myplanet.service


import android.content.Context
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import dagger.hilt.android.EntryPointAccessors
import java.util.Calendar
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.di.WorkerDependenciesEntryPoint
import org.ole.planet.myplanet.utilities.NotificationUtils.create
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate

class TaskNotificationWorker(appContext: Context, workerParams: WorkerParameters) :
    CoroutineWorker(appContext, workerParams) {

    override suspend fun doWork(): Result {
        val current = Calendar.getInstance().timeInMillis
        val tomorrow = Calendar.getInstance()
        tomorrow.add(Calendar.DAY_OF_YEAR, 1)

        val entryPoint = EntryPointAccessors.fromApplication(
            applicationContext,
            WorkerDependenciesEntryPoint::class.java
        )
        val userProfileDbHandler = entryPoint.userProfileDbHandler()
        val teamRepository = entryPoint.teamRepository()

        val user = userProfileDbHandler.userModel
        val userId = user?.id
        if (!userId.isNullOrBlank()) {
            val tasks = runCatching {
                teamRepository.getPendingTasksForUser(userId, current, tomorrow.timeInMillis)
            }.getOrElse { emptyList() }

            if (tasks.isNotEmpty()) {
                tasks.forEach { task ->
                    create(
                        applicationContext,
                        R.drawable.ole_logo,
                        task.title,
                        "Task expires on " + formatDate(task.deadline, ""),
                    )
                }

                val taskIds = tasks.mapNotNull { it.id }.filter { it.isNotBlank() }
                if (taskIds.isNotEmpty()) {
                    runCatching { teamRepository.markTasksNotified(taskIds) }
                }
            }
        }
        return Result.success()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/service/NetworkMonitorWorker.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.service

import android.content.Context
import androidx.work.CoroutineWorker
import androidx.work.Data
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import java.util.concurrent.TimeUnit
import org.ole.planet.myplanet.utilities.NetworkUtils

class NetworkMonitorWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    companion object {
        private const val WORK_TAG = "network_monitor_work"
        private const val SERVER_REACHABILITY_WORK_TAG = "server_reachability_work"
        private const val UPLOAD_DELAY_SECONDS = 30L

        fun start(context: Context) {
            val workRequest = OneTimeWorkRequestBuilder<NetworkMonitorWorker>()
                .addTag(WORK_TAG)
                .build()

            WorkManager.getInstance(context)
                .enqueueUniqueWork(WORK_TAG, ExistingWorkPolicy.KEEP, workRequest)
        }
    }

    override suspend fun doWork(): Result {
        return try {
            var wasConnected = false
            NetworkUtils.isNetworkConnectedFlow.collect { isConnected ->
                if (isConnected && !wasConnected) {
                    scheduleServerReachabilityCheck()
                }
                wasConnected = isConnected
            }

            Result.success()
        } catch (e: Exception) {
            Result.retry()
        }
    }

    private fun scheduleServerReachabilityCheck() {
        val inputData = Data.Builder()
            .putBoolean("network_reconnection_trigger", true)
            .build()

        val workRequest = OneTimeWorkRequestBuilder<ServerReachabilityWorker>()
            .addTag(SERVER_REACHABILITY_WORK_TAG)
            .setInputData(inputData)
            .setInitialDelay(UPLOAD_DELAY_SECONDS, TimeUnit.SECONDS)
            .build()

        WorkManager.getInstance(applicationContext)
            .enqueueUniqueWork(
                SERVER_REACHABILITY_WORK_TAG,
                ExistingWorkPolicy.REPLACE,
                workRequest
            )
    }
}
=======
package org.ole.planet.myplanet.service


import android.content.Context
import androidx.work.CoroutineWorker
import androidx.work.Data
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import java.util.concurrent.TimeUnit
import org.ole.planet.myplanet.utilities.NetworkUtils

class NetworkMonitorWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    companion object {
        private const val WORK_TAG = "network_monitor_work"
        private const val SERVER_REACHABILITY_WORK_TAG = "server_reachability_work"
        private const val UPLOAD_DELAY_SECONDS = 30L

        fun start(context: Context) {
            val workRequest = OneTimeWorkRequestBuilder<NetworkMonitorWorker>()
                .addTag(WORK_TAG)
                .build()

            WorkManager.getInstance(context)
                .enqueueUniqueWork(WORK_TAG, ExistingWorkPolicy.KEEP, workRequest)
        }
    }

    override suspend fun doWork(): Result {
        return try {
            var wasConnected = false
            NetworkUtils.isNetworkConnectedFlow.collect { isConnected ->
                if (isConnected && !wasConnected) {
                    scheduleServerReachabilityCheck()
                }
                wasConnected = isConnected
            }

            Result.success()
        } catch (e: Exception) {
            Result.retry()
        }
    }

    private fun scheduleServerReachabilityCheck() {
        val inputData = Data.Builder()
            .putBoolean("network_reconnection_trigger", true)
            .build()

        val workRequest = OneTimeWorkRequestBuilder<ServerReachabilityWorker>()
            .addTag(SERVER_REACHABILITY_WORK_TAG)
            .setInputData(inputData)
            .setInitialDelay(UPLOAD_DELAY_SECONDS, TimeUnit.SECONDS)
            .build()

        WorkManager.getInstance(applicationContext)
            .enqueueUniqueWork(
                SERVER_REACHABILITY_WORK_TAG,
                ExistingWorkPolicy.REPLACE,
                workRequest
            )
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/community/CommunityPagerAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.community

import android.content.SharedPreferences
import android.os.Bundle
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.viewpager2.adapter.FragmentStateAdapter
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.ui.enterprises.FinanceFragment
import org.ole.planet.myplanet.ui.enterprises.ReportsFragment
import org.ole.planet.myplanet.ui.news.NewsFragment
import org.ole.planet.myplanet.ui.team.TeamCalendarFragment

class CommunityPagerAdapter(private val fm: FragmentActivity, private val id: String, private var fromLogin: Boolean, val settings: SharedPreferences) : FragmentStateAdapter(fm) {
    override fun createFragment(position: Int): Fragment {
        val fragment: Fragment = when (position) {
            0 -> {
                NewsFragment()
            }
            1 -> {
                LeadersFragment()
            }
            2 -> {
                TeamCalendarFragment()
            }
            3 -> {
                ServicesFragment()
            }
            4 -> {
                FinanceFragment()
            }
            else -> {
                ReportsFragment()
            }
        }
        val b = Bundle()
        b.putString("id", id)
        b.putBoolean("fromLogin", fromLogin)
        b.putBoolean("fromCommunity", true)
        fragment.arguments = b
        return fragment
    }

    override fun getItemCount(): Int {
        return if (fromLogin) 3 else 6
    }

    fun getPageTitle(position: Int): CharSequence {
        val leaders = if (settings.getString("planetType", "") == "community") {
            fm.getString(R.string.community_leaders)
        } else {
            fm.getString(R.string.nation_leaders)
        }
        return when (position) {
            0 -> fm.getString(R.string.our_voices)
            1 -> leaders
            2 -> fm.getString(R.string.calendar)
            3 -> if (!fromLogin) fm.getString(R.string.services) else ""
            4 -> if (!fromLogin) fm.getString(R.string.finances) else ""
            5 -> if (!fromLogin) fm.getString(R.string.reports) else ""
            else -> ""
        }
    }
}
=======
package org.ole.planet.myplanet.ui.community


import android.content.SharedPreferences
import android.os.Bundle
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.viewpager2.adapter.FragmentStateAdapter
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.ui.enterprises.FinanceFragment
import org.ole.planet.myplanet.ui.enterprises.ReportsFragment
import org.ole.planet.myplanet.ui.news.NewsFragment
import org.ole.planet.myplanet.ui.team.TeamCalendarFragment

class CommunityPagerAdapter(private val fm: FragmentActivity, private val id: String, private var fromLogin: Boolean, val settings: SharedPreferences) : FragmentStateAdapter(fm) {
    override fun createFragment(position: Int): Fragment {
        val fragment: Fragment = when (position) {
            0 -> {
                NewsFragment()
            }
            1 -> {
                LeadersFragment()
            }
            2 -> {
                TeamCalendarFragment()
            }
            3 -> {
                ServicesFragment()
            }
            4 -> {
                FinanceFragment()
            }
            else -> {
                ReportsFragment()
            }
        }
        val b = Bundle()
        b.putString("id", id)
        b.putBoolean("fromLogin", fromLogin)
        b.putBoolean("fromCommunity", true)
        fragment.arguments = b
        return fragment
    }

    override fun getItemCount(): Int {
        return if (fromLogin) 3 else 6
    }

    fun getPageTitle(position: Int): CharSequence {
        val leaders = if (settings.getString("planetType", "") == "community") {
            fm.getString(R.string.community_leaders)
        } else {
            fm.getString(R.string.nation_leaders)
        }
        return when (position) {
            0 -> fm.getString(R.string.our_voices)
            1 -> leaders
            2 -> fm.getString(R.string.calendar)
            3 -> if (!fromLogin) fm.getString(R.string.services) else ""
            4 -> if (!fromLogin) fm.getString(R.string.finances) else ""
            5 -> if (!fromLogin) fm.getString(R.string.reports) else ""
            else -> ""
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/community/AdapterLeader.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.community

import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.FragmentActivity
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowJoinedUserBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.team.teamMember.MemberDetailFragment
import org.ole.planet.myplanet.utilities.DiffUtils

internal class AdapterLeader(var context: Context) :
    ListAdapter<RealmUserModel, AdapterLeader.ViewHolderLeader>(
        DiffUtils.itemCallback(
            areItemsTheSame = { oldItem, newItem -> oldItem.name == newItem.name },
            areContentsTheSame = { oldItem, newItem ->
                oldItem.firstName == newItem.firstName &&
                    oldItem.lastName == newItem.lastName &&
                    oldItem.email == newItem.email
            }
        )
    ) {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderLeader {
        val rowJoinedUserBinding =
            RowJoinedUserBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderLeader(rowJoinedUserBinding)
    }

    override fun onBindViewHolder(holder: ViewHolderLeader, position: Int) {
        val leader = getItem(position)
        if (leader.firstName == null) {
            holder.title.text = leader.name
        } else {
            holder.title.text = context.getString(R.string.message_placeholder, leader)
        }
        holder.tvDescription.text = leader.email

        holder.itemView.setOnClickListener {
            showLeaderDetails(leader)
        }
    }

    private fun showLeaderDetails(leader: RealmUserModel) {
        val activity = context as? FragmentActivity
        if (activity?.findViewById<View>(R.id.fragment_container) != null) {
            val fragment = MemberDetailFragment.newInstance(
                name = leader.name ?: "",
                email = leader.email ?: "",
                dob = leader.dob ?: "",
                language = leader.language ?: "",
                phone = leader.phoneNumber ?: "",
                visits = "",
                lastLogin = "",
                username = leader.name ?: "",
                memberLevel = leader.level ?: "",
                imageUrl = null
            )
            NavigationHelper.replaceFragment(
                activity.supportFragmentManager,
                R.id.fragment_container,
                fragment,
                addToBackStack = true
            )
        }
    }

    internal inner class ViewHolderLeader(rowJoinedUserBinding: RowJoinedUserBinding) : RecyclerView.ViewHolder(rowJoinedUserBinding.root) {
        var title = rowJoinedUserBinding.tvTitle
        var tvDescription = rowJoinedUserBinding.tvDescription
        var icon = rowJoinedUserBinding.icMore
    }
}
=======
package org.ole.planet.myplanet.ui.community


import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.FragmentActivity
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowJoinedUserBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.team.teamMember.MemberDetailFragment
import org.ole.planet.myplanet.utilities.DiffUtils

internal class AdapterLeader(var context: Context) :
    ListAdapter<RealmUserModel, AdapterLeader.ViewHolderLeader>(
        DiffUtils.itemCallback(
            areItemsTheSame = { oldItem, newItem -> oldItem.name == newItem.name },
            areContentsTheSame = { oldItem, newItem ->
                oldItem.firstName == newItem.firstName &&
                    oldItem.lastName == newItem.lastName &&
                    oldItem.email == newItem.email
            }
        )
    ) {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderLeader {
        val rowJoinedUserBinding =
            RowJoinedUserBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderLeader(rowJoinedUserBinding)
    }

    override fun onBindViewHolder(holder: ViewHolderLeader, position: Int) {
        val leader = getItem(position)
        if (leader.firstName == null) {
            holder.title.text = leader.name
        } else {
            holder.title.text = context.getString(R.string.message_placeholder, leader)
        }
        holder.tvDescription.text = leader.email

        holder.itemView.setOnClickListener {
            showLeaderDetails(leader)
        }
    }

    private fun showLeaderDetails(leader: RealmUserModel) {
        val activity = context as? FragmentActivity
        if (activity?.findViewById<View>(R.id.fragment_container) != null) {
            val fragment = MemberDetailFragment.newInstance(
                name = leader.name ?: "",
                email = leader.email ?: "",
                dob = leader.dob ?: "",
                language = leader.language ?: "",
                phone = leader.phoneNumber ?: "",
                visits = "",
                lastLogin = "",
                username = leader.name ?: "",
                memberLevel = leader.level ?: "",
                imageUrl = null
            )
            NavigationHelper.replaceFragment(
                activity.supportFragmentManager,
                R.id.fragment_container,
                fragment,
                addToBackStack = true
            )
        }
    }

    internal inner class ViewHolderLeader(rowJoinedUserBinding: RowJoinedUserBinding) : RecyclerView.ViewHolder(rowJoinedUserBinding.root) {
        var title = rowJoinedUserBinding.tvTitle
        var tvDescription = rowJoinedUserBinding.tvDescription
        var icon = rowJoinedUserBinding.icMore
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/community/LeadersFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.community

import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.GridLayoutManager
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentMembersBinding
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.RealmUserModel

@AndroidEntryPoint
class LeadersFragment : Fragment() {
    private var binding: FragmentMembersBinding? = null
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        binding = FragmentMembersBinding.inflate(inflater, container, false)
        return binding!!.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val leaders = settings.getString("communityLeaders", "")
        if (leaders.isNullOrEmpty()) {
            binding?.tvNodata?.let { it.text = getString(R.string.no_data_available) }
        } else {
            val leadersList = RealmUserModel.parseLeadersJson(leaders)
            binding?.rvMember?.layoutManager = GridLayoutManager(activity, 2)
            val adapter = AdapterLeader(requireActivity())
            binding?.rvMember?.adapter = adapter
            adapter.submitList(leadersList)
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        binding = null
    }
}
=======
package org.ole.planet.myplanet.ui.community


import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.GridLayoutManager
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentMembersBinding
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.RealmUserModel

@AndroidEntryPoint
class LeadersFragment : Fragment() {
    private var binding: FragmentMembersBinding? = null
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        binding = FragmentMembersBinding.inflate(inflater, container, false)
        return binding!!.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val leaders = settings.getString("communityLeaders", "")
        if (leaders.isNullOrEmpty()) {
            binding?.tvNodata?.let { it.text = getString(R.string.no_data_available) }
        } else {
            val leadersList = RealmUserModel.parseLeadersJson(leaders)
            binding?.rvMember?.layoutManager = GridLayoutManager(activity, 2)
            val adapter = AdapterLeader(requireActivity())
            binding?.rvMember?.adapter = adapter
            adapter.submitList(leadersList)
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        binding = null
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/community/ServicesFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.community

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentServicesBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.ui.navigation.NavigationHelper.replaceFragment
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.ui.team.TeamDetailFragment
import org.ole.planet.myplanet.utilities.Markdown.prependBaseUrlToImages
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText

class ServicesFragment : BaseTeamFragment() {
    private var binding: FragmentServicesBinding? = null

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        binding = FragmentServicesBinding.inflate(inflater, container, false)
        return binding!!.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        binding = null
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {

        super.onViewCreated(view, savedInstanceState)

        val description = team?.description ?: ""
        if (description.isEmpty()) {
            binding?.tvDescription?.visibility = View.GONE
            binding?.tvNoDescription?.visibility = View.VISIBLE
        } else {
            binding?.tvDescription?.visibility = View.VISIBLE
            binding?.tvNoDescription?.visibility = View.GONE
        }
        val basePath = requireContext().getExternalFilesDir(null)?.let { externalDir ->
            "file://${externalDir.absolutePath}/ole/"
        }.orEmpty()
        val markdownContentWithLocalPaths = prependBaseUrlToImages(
            description,
            basePath,
            600,
            350
        )
        binding?.let { setMarkdownText(it.tvDescription, markdownContentWithLocalPaths) }

        viewLifecycleOwner.lifecycleScope.launch {
            val links = teamRepository.getTeamLinks()
            val currentBinding = binding ?: return@launch
            if (links.isEmpty()) {
                currentBinding.llServices.visibility = View.GONE
                currentBinding.tvNoLinks.visibility = View.VISIBLE
            } else {
                currentBinding.llServices.visibility = View.VISIBLE
                currentBinding.tvNoLinks.visibility = View.GONE
            }
            setRecyclerView(links)
        }
    }

    override fun onNewsItemClick(news: RealmNews?) {}

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun setRecyclerView(links: List<RealmMyTeam>) {
        val parent = binding?.llServices ?: return
        parent.removeAllViews()
        links.forEach { team ->
            val b: TextView = LayoutInflater.from(activity).inflate(R.layout.button_single, parent, false) as TextView
            b.setPadding(8, 8, 8, 8)
            b.text = team.title
            b.setOnClickListener {
                val route = team.route?.split("/")
                if (route != null && route.size >= 4) {
                    val teamId = route[3]
                    viewLifecycleOwner.lifecycleScope.launch {
                        val isMyTeam = teamRepository.isMember(user?.id, teamId)

                        val f = TeamDetailFragment()
                        val args = Bundle().apply {
                            putString("id", teamId)
                            putBoolean("isMyTeam", isMyTeam)
                        }
                        f.arguments = args

                        val activity = requireActivity()
                        replaceFragment(
                            activity.supportFragmentManager,
                            R.id.fragment_container,
                            f,
                            addToBackStack = true,
                            tag = ""
                        )
                    }
                }
            }
            parent.addView(b)
        }
    }
}
=======
package org.ole.planet.myplanet.ui.community


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentServicesBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.ui.navigation.NavigationHelper.replaceFragment
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.ui.team.TeamDetailFragment
import org.ole.planet.myplanet.utilities.Markdown.prependBaseUrlToImages
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText

class ServicesFragment : BaseTeamFragment() {
    private var binding: FragmentServicesBinding? = null

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        binding = FragmentServicesBinding.inflate(inflater, container, false)
        return binding!!.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        binding = null
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {

        super.onViewCreated(view, savedInstanceState)

        val description = team?.description ?: ""
        if (description.isEmpty()) {
            binding?.tvDescription?.visibility = View.GONE
            binding?.tvNoDescription?.visibility = View.VISIBLE
        } else {
            binding?.tvDescription?.visibility = View.VISIBLE
            binding?.tvNoDescription?.visibility = View.GONE
        }
        val basePath = requireContext().getExternalFilesDir(null)?.let { externalDir ->
            "file://${externalDir.absolutePath}/ole/"
        }.orEmpty()
        val markdownContentWithLocalPaths = prependBaseUrlToImages(
            description,
            basePath,
            600,
            350
        )
        binding?.let { setMarkdownText(it.tvDescription, markdownContentWithLocalPaths) }

        viewLifecycleOwner.lifecycleScope.launch {
            val links = teamRepository.getTeamLinks()
            val currentBinding = binding ?: return@launch
            if (links.isEmpty()) {
                currentBinding.llServices.visibility = View.GONE
                currentBinding.tvNoLinks.visibility = View.VISIBLE
            } else {
                currentBinding.llServices.visibility = View.VISIBLE
                currentBinding.tvNoLinks.visibility = View.GONE
            }
            setRecyclerView(links)
        }
    }

    override fun onNewsItemClick(news: RealmNews?) {}

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun setRecyclerView(links: List<RealmMyTeam>) {
        val parent = binding?.llServices ?: return
        parent.removeAllViews()
        links.forEach { team ->
            val b: TextView = LayoutInflater.from(activity).inflate(R.layout.button_single, parent, false) as TextView
            b.setPadding(8, 8, 8, 8)
            b.text = team.title
            b.setOnClickListener {
                val route = team.route?.split("/")
                if (route != null && route.size >= 4) {
                    val teamId = route[3]
                    viewLifecycleOwner.lifecycleScope.launch {
                        val isMyTeam = teamRepository.isMember(user?.id, teamId)

                        val f = TeamDetailFragment()
                        val args = Bundle().apply {
                            putString("id", teamId)
                            putBoolean("isMyTeam", isMyTeam)
                        }
                        f.arguments = args

                        val activity = requireActivity()
                        replaceFragment(
                            activity.supportFragmentManager,
                            R.id.fragment_container,
                            f,
                            addToBackStack = true,
                            tag = ""
                        )
                    }
                }
            }
            parent.addView(b)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/community/CommunityTabFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.community

import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import com.google.android.material.tabs.TabLayoutMediator
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import org.ole.planet.myplanet.databinding.FragmentTeamDetailBinding
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.service.UserProfileDbHandler

@AndroidEntryPoint
class CommunityTabFragment : Fragment() {
    private var _binding: FragmentTeamDetailBinding? = null
    private val binding get() = _binding!!
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamDetailBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val parentCode = settings.getString("parentCode", "").orEmpty()
        val communityName = settings.getString("communityName", "").orEmpty()
        val user = userProfileDbHandler.userModel
        val planetCode = user?.planetCode.orEmpty()
        binding.viewPager2.adapter = CommunityPagerAdapter(requireActivity(), "$planetCode@$parentCode", false, settings)
        TabLayoutMediator(binding.tabLayout, binding.viewPager2) { tab, position ->
            tab.text = (binding.viewPager2.adapter as CommunityPagerAdapter).getPageTitle(position)
        }.attach()
        binding.title.text = if (planetCode.isEmpty()) communityName else planetCode
        binding.subtitle.text = settings.getString("planetType", "")
        binding.llActionButtons.visibility = View.GONE
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
=======
package org.ole.planet.myplanet.ui.community


import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import com.google.android.material.tabs.TabLayoutMediator
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import org.ole.planet.myplanet.databinding.FragmentTeamDetailBinding
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.service.UserProfileDbHandler

@AndroidEntryPoint
class CommunityTabFragment : Fragment() {
    private var _binding: FragmentTeamDetailBinding? = null
    private val binding get() = _binding!!
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamDetailBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val parentCode = settings.getString("parentCode", "").orEmpty()
        val communityName = settings.getString("communityName", "").orEmpty()
        val user = userProfileDbHandler.userModel
        val planetCode = user?.planetCode.orEmpty()
        binding.viewPager2.adapter = CommunityPagerAdapter(requireActivity(), "$planetCode@$parentCode", false, settings)
        TabLayoutMediator(binding.tabLayout, binding.viewPager2) { tab, position ->
            tab.text = (binding.viewPager2.adapter as CommunityPagerAdapter).getPageTitle(position)
        }.attach()
        binding.title.text = if (planetCode.isEmpty()) communityName else planetCode
        binding.subtitle.text = settings.getString("planetType", "")
        binding.llActionButtons.visibility = View.GONE
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/community/HomeCommunityDialogFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.community

import android.content.Context.MODE_PRIVATE
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.lifecycle.Lifecycle
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.google.android.material.tabs.TabLayoutMediator
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentTeamDetailBinding
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

class HomeCommunityDialogFragment : BottomSheetDialogFragment() {
    private var _binding: FragmentTeamDetailBinding? = null
    private val binding get() = _binding!!
    private var bottomSheetBehavior: BottomSheetBehavior<View>? = null

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamDetailBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        view.post {
            val parent = view.parent as View
            bottomSheetBehavior = BottomSheetBehavior.from(parent)

            bottomSheetBehavior?.isFitToContents = false
            bottomSheetBehavior?.peekHeight = resources.displayMetrics.heightPixels / 7

            bottomSheetBehavior?.state = BottomSheetBehavior.STATE_COLLAPSED
            bottomSheetBehavior?.addBottomSheetCallback(object : BottomSheetBehavior.BottomSheetCallback() {
                override fun onStateChanged(bottomSheet: View, newState: Int) {
                    when (newState) {
                        BottomSheetBehavior.STATE_HIDDEN -> {
                            if (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) {
                                dismiss()
                            }
                        }
                    }
                }

                override fun onSlide(bottomSheet: View, slideOffset: Float) {
                    val screenHeight = resources.displayMetrics.heightPixels
                    val newHeight = (screenHeight * (0.25f + (0.75f * slideOffset))).toInt()

                    bottomSheet.layoutParams.height = newHeight
                    bottomSheet.requestLayout()

                    when {
                        slideOffset > 0.5f -> bottomSheetBehavior?.state = BottomSheetBehavior.STATE_EXPANDED
                        slideOffset > 0.2f -> bottomSheetBehavior?.state = BottomSheetBehavior.STATE_HALF_EXPANDED
                        slideOffset < -0.3f -> bottomSheetBehavior?.state = BottomSheetBehavior.STATE_HIDDEN
                    }
                }
            })
        }

        initCommunityTab()
    }

    override fun onStart() {
        super.onStart()
        dialog?.let { d ->
            val bottomSheet = d.findViewById<View>(com.google.android.material.R.id.design_bottom_sheet)
            bottomSheet?.let {
                it.layoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT
                it.requestLayout()
            }
        }
    }

    private fun initCommunityTab() {
        binding.llActionButtons.visibility = View.GONE
        val settings = requireActivity().getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        val sParentcode = settings.getString("parentCode", "")
        val communityName = settings.getString("communityName", "")
        binding.viewPager2.adapter = CommunityPagerAdapter(requireActivity(), "$communityName@$sParentcode", true, settings)
        TabLayoutMediator(binding.tabLayout, binding.viewPager2) { tab, position ->
            tab.text = (binding.viewPager2.adapter as CommunityPagerAdapter).getPageTitle(position)
        }.attach()
        binding.title.text = communityName
        binding.title.setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
        binding.subtitle.setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
        binding.subtitle.text = settings.getString("planetType", "")
        binding.appBar.setBackgroundColor(ContextCompat.getColor(requireContext(), R.color.secondary_bg))
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
=======
package org.ole.planet.myplanet.ui.community


import android.content.Context.MODE_PRIVATE
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.lifecycle.Lifecycle
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.google.android.material.tabs.TabLayoutMediator
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentTeamDetailBinding
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

class HomeCommunityDialogFragment : BottomSheetDialogFragment() {
    private var _binding: FragmentTeamDetailBinding? = null
    private val binding get() = _binding!!
    private var bottomSheetBehavior: BottomSheetBehavior<View>? = null

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamDetailBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        view.post {
            val parent = view.parent as View
            bottomSheetBehavior = BottomSheetBehavior.from(parent)

            bottomSheetBehavior?.isFitToContents = false
            bottomSheetBehavior?.peekHeight = resources.displayMetrics.heightPixels / 7

            bottomSheetBehavior?.state = BottomSheetBehavior.STATE_COLLAPSED
            bottomSheetBehavior?.addBottomSheetCallback(object : BottomSheetBehavior.BottomSheetCallback() {
                override fun onStateChanged(bottomSheet: View, newState: Int) {
                    when (newState) {
                        BottomSheetBehavior.STATE_HIDDEN -> {
                            if (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) {
                                dismiss()
                            }
                        }
                    }
                }

                override fun onSlide(bottomSheet: View, slideOffset: Float) {
                    val screenHeight = resources.displayMetrics.heightPixels
                    val newHeight = (screenHeight * (0.25f + (0.75f * slideOffset))).toInt()

                    bottomSheet.layoutParams.height = newHeight
                    bottomSheet.requestLayout()

                    when {
                        slideOffset > 0.5f -> bottomSheetBehavior?.state = BottomSheetBehavior.STATE_EXPANDED
                        slideOffset > 0.2f -> bottomSheetBehavior?.state = BottomSheetBehavior.STATE_HALF_EXPANDED
                        slideOffset < -0.3f -> bottomSheetBehavior?.state = BottomSheetBehavior.STATE_HIDDEN
                    }
                }
            })
        }

        initCommunityTab()
    }

    override fun onStart() {
        super.onStart()
        dialog?.let { d ->
            val bottomSheet = d.findViewById<View>(com.google.android.material.R.id.design_bottom_sheet)
            bottomSheet?.let {
                it.layoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT
                it.requestLayout()
            }
        }
    }

    private fun initCommunityTab() {
        binding.llActionButtons.visibility = View.GONE
        val settings = requireActivity().getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        val sParentcode = settings.getString("parentCode", "")
        val communityName = settings.getString("communityName", "")
        binding.viewPager2.adapter = CommunityPagerAdapter(requireActivity(), "$communityName@$sParentcode", true, settings)
        TabLayoutMediator(binding.tabLayout, binding.viewPager2) { tab, position ->
            tab.text = (binding.viewPager2.adapter as CommunityPagerAdapter).getPageTitle(position)
        }.attach()
        binding.title.text = communityName
        binding.title.setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
        binding.subtitle.setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
        binding.subtitle.text = settings.getString("planetType", "")
        binding.appBar.setBackgroundColor(ContextCompat.getColor(requireContext(), R.color.secondary_bg))
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/rating/RatingFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.rating

import android.content.Context
import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.RatingBar
import android.widget.RatingBar.OnRatingBarChangeListener
import androidx.core.view.isVisible
import androidx.fragment.app.DialogFragment
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.FragmentRatingBinding
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class RatingFragment : DialogFragment() {
    private var _binding: FragmentRatingBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var viewModel: RatingViewModel
    var id: String? = ""
    var type: String? = ""
    var title: String? = ""
    lateinit var settings: SharedPreferences
    private var ratingListener: OnRatingChangeListener? = null
    private var isUserReady = false
    private var currentSubmitState: RatingViewModel.SubmitState = RatingViewModel.SubmitState.Idle
    fun setListener(listener: OnRatingChangeListener?) {
        this.ratingListener = listener
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NO_TITLE, R.style.AppTheme_Dialog_NoActionBar_MinWidth)
        if (arguments != null) {
            id = requireArguments().getString("id")
            type = requireArguments().getString("type")
            title = requireArguments().getString("title")
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentRatingBinding.inflate(inflater, container, false)
        settings = requireActivity().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupUI()
        observeViewModel()
        loadRatingData()
    }

    private fun setupUI() {
        binding.ratingBar.onRatingBarChangeListener =
            OnRatingBarChangeListener { _: RatingBar?, _: Float, fromUser: Boolean ->
                if (fromUser) {
                    binding.ratingError.visibility = View.GONE
                }
            }
        binding.btnCancel.setOnClickListener { dismiss() }
        binding.userStatusText.text = getString(R.string.loading_user_profile)
        binding.userStatusContainer.isVisible = true
        updateSubmitButtonState()
        binding.btnSubmit.setOnClickListener {
            if (binding.ratingBar.rating.toDouble() == 0.0) {
                binding.ratingError.visibility = View.VISIBLE
                binding.ratingError.text = getString(R.string.kindly_give_a_rating)
            } else {
                submitRating()
            }
        }
    }

    private fun observeViewModel() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.ratingState.collect { state ->
                    when (state) {
                        is RatingViewModel.RatingUiState.Loading -> {}
                        is RatingViewModel.RatingUiState.Success -> {
                            state.existingRating?.let { rating ->
                                binding.ratingBar.rating = rating.rate.toFloat()
                                binding.etComment.setText(rating.comment)
                            }
                        }
                        is RatingViewModel.RatingUiState.Error -> {
                            Utilities.toast(activity, state.message)
                        }
                    }
                }
            }
        }

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.userState.collect { user ->
                    isUserReady = user != null
                    binding.userStatusContainer.isVisible = !isUserReady
                    updateSubmitButtonState()
                }
            }
        }

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.submitState.collect { state ->
                    currentSubmitState = state
                    when (state) {
                        is RatingViewModel.SubmitState.Success -> {
                            Utilities.toast(activity, "Thank you, your rating is submitted.")
                            ratingListener?.onRatingChanged()
                            dismiss()
                        }
                        is RatingViewModel.SubmitState.Error -> {
                            Utilities.toast(activity, state.message)
                        }
                        RatingViewModel.SubmitState.Submitting,
                        RatingViewModel.SubmitState.Idle -> Unit
                    }
                    updateSubmitButtonState()
                }
            }
        }
    }

    private fun loadRatingData() {
        val userId = settings.getString("userId", "") ?: ""
        if (type != null && id != null && userId.isNotEmpty()) {
            viewModel.loadRatingData(type!!, id!!, userId)
        }
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }

    private fun submitRating() {
        val comment = binding.etComment.text.toString()
        val rating = binding.ratingBar.rating
        val userId = settings.getString("userId", "") ?: ""

        if (type != null && id != null && title != null && userId.isNotEmpty()) {
            viewModel.submitRating(
                type = type!!,
                itemId = id!!,
                title = title!!,
                userId = userId,
                rating = rating,
                comment = comment
            )
        }
    }

    private fun updateSubmitButtonState() {
        val isSubmitting = currentSubmitState is RatingViewModel.SubmitState.Submitting
        binding.btnSubmit.isEnabled = isUserReady && !isSubmitting
        binding.submitProgress.isVisible = isSubmitting
    }

    companion object {
        @JvmStatic
        fun newInstance(type: String?, id: String?, title: String?): RatingFragment {
            val fragment = RatingFragment()
            val b = Bundle()
            b.putString("id", id)
            b.putString("title", title)
            b.putString("type", type)
            fragment.arguments = b
            return fragment
        }
    }
}
=======
package org.ole.planet.myplanet.ui.rating


import android.content.Context
import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.RatingBar
import android.widget.RatingBar.OnRatingBarChangeListener
import androidx.core.view.isVisible
import androidx.fragment.app.DialogFragment
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.FragmentRatingBinding
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class RatingFragment : DialogFragment() {
    private var _binding: FragmentRatingBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var viewModel: RatingViewModel
    var id: String? = ""
    var type: String? = ""
    var title: String? = ""
    lateinit var settings: SharedPreferences
    private var ratingListener: OnRatingChangeListener? = null
    private var isUserReady = false
    private var currentSubmitState: RatingViewModel.SubmitState = RatingViewModel.SubmitState.Idle
    fun setListener(listener: OnRatingChangeListener?) {
        this.ratingListener = listener
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NO_TITLE, R.style.AppTheme_Dialog_NoActionBar_MinWidth)
        if (arguments != null) {
            id = requireArguments().getString("id")
            type = requireArguments().getString("type")
            title = requireArguments().getString("title")
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentRatingBinding.inflate(inflater, container, false)
        settings = requireActivity().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupUI()
        observeViewModel()
        loadRatingData()
    }

    private fun setupUI() {
        binding.ratingBar.onRatingBarChangeListener =
            OnRatingBarChangeListener { _: RatingBar?, _: Float, fromUser: Boolean ->
                if (fromUser) {
                    binding.ratingError.visibility = View.GONE
                }
            }
        binding.btnCancel.setOnClickListener { dismiss() }
        binding.userStatusText.text = getString(R.string.loading_user_profile)
        binding.userStatusContainer.isVisible = true
        updateSubmitButtonState()
        binding.btnSubmit.setOnClickListener {
            if (binding.ratingBar.rating.toDouble() == 0.0) {
                binding.ratingError.visibility = View.VISIBLE
                binding.ratingError.text = getString(R.string.kindly_give_a_rating)
            } else {
                submitRating()
            }
        }
    }

    private fun observeViewModel() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.ratingState.collect { state ->
                    when (state) {
                        is RatingViewModel.RatingUiState.Loading -> {}
                        is RatingViewModel.RatingUiState.Success -> {
                            state.existingRating?.let { rating ->
                                binding.ratingBar.rating = rating.rate.toFloat()
                                binding.etComment.setText(rating.comment)
                            }
                        }
                        is RatingViewModel.RatingUiState.Error -> {
                            Utilities.toast(activity, state.message)
                        }
                    }
                }
            }
        }

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.userState.collect { user ->
                    isUserReady = user != null
                    binding.userStatusContainer.isVisible = !isUserReady
                    updateSubmitButtonState()
                }
            }
        }

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.submitState.collect { state ->
                    currentSubmitState = state
                    when (state) {
                        is RatingViewModel.SubmitState.Success -> {
                            Utilities.toast(activity, "Thank you, your rating is submitted.")
                            ratingListener?.onRatingChanged()
                            dismiss()
                        }
                        is RatingViewModel.SubmitState.Error -> {
                            Utilities.toast(activity, state.message)
                        }
                        RatingViewModel.SubmitState.Submitting,
                        RatingViewModel.SubmitState.Idle -> Unit
                    }
                    updateSubmitButtonState()
                }
            }
        }
    }

    private fun loadRatingData() {
        val userId = settings.getString("userId", "") ?: ""
        if (type != null && id != null && userId.isNotEmpty()) {
            viewModel.loadRatingData(type!!, id!!, userId)
        }
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }

    private fun submitRating() {
        val comment = binding.etComment.text.toString()
        val rating = binding.ratingBar.rating
        val userId = settings.getString("userId", "") ?: ""

        if (type != null && id != null && title != null && userId.isNotEmpty()) {
            viewModel.submitRating(
                type = type!!,
                itemId = id!!,
                title = title!!,
                userId = userId,
                rating = rating,
                comment = comment
            )
        }
    }

    private fun updateSubmitButtonState() {
        val isSubmitting = currentSubmitState is RatingViewModel.SubmitState.Submitting
        binding.btnSubmit.isEnabled = isUserReady && !isSubmitting
        binding.submitProgress.isVisible = isSubmitting
    }

    companion object {
        @JvmStatic
        fun newInstance(type: String?, id: String?, title: String?): RatingFragment {
            val fragment = RatingFragment()
            val b = Bundle()
            b.putString("id", id)
            b.putString("title", title)
            b.putString("type", type)
            fragment.arguments = b
            return fragment
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/rating/RatingViewModel.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.rating

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.RatingEntry
import org.ole.planet.myplanet.repository.RatingRepository
import org.ole.planet.myplanet.repository.RatingSummary
import org.ole.planet.myplanet.repository.UserRepository

class RatingViewModel @Inject constructor(
    private val ratingRepository: RatingRepository,
    private val userRepository: UserRepository
) : ViewModel() {

    private val _ratingState = MutableStateFlow<RatingUiState>(RatingUiState.Loading)
    val ratingState: StateFlow<RatingUiState> = _ratingState.asStateFlow()

    private val _submitState = MutableStateFlow<SubmitState>(SubmitState.Idle)
    val submitState: StateFlow<SubmitState> = _submitState.asStateFlow()

    private val _userState = MutableStateFlow<RealmUserModel?>(null)
    val userState: StateFlow<RealmUserModel?> = _userState.asStateFlow()

    sealed class RatingUiState {
        object Loading : RatingUiState()
        data class Success(
            val existingRating: RatingEntry?,
            val averageRating: Float,
            val totalRatings: Int,
            val userRating: Int?
        ) : RatingUiState()
        data class Error(val message: String) : RatingUiState()
    }

    sealed class SubmitState {
        object Idle : SubmitState()
        object Submitting : SubmitState()
        object Success : SubmitState()
        data class Error(val message: String) : SubmitState()
    }

    fun loadRatingData(type: String, itemId: String, userId: String) {
        viewModelScope.launch {
            try {
                _ratingState.value = RatingUiState.Loading

                _userState.value = userRepository.getUserById(userId)

                val summary = ratingRepository.getRatingSummary(type, itemId, userId)
                _ratingState.value = summary.toUiState()
            } catch (e: Exception) {
                _userState.value = null
                _ratingState.value = RatingUiState.Error(e.message ?: "Failed to load rating data")
            }
        }
    }

    fun submitRating(
        type: String,
        itemId: String,
        title: String,
        userId: String,
        rating: Float,
        comment: String
    ) {
        viewModelScope.launch {
            try {
                _submitState.value = SubmitState.Submitting

                val user = _userState.value ?: userRepository.getUserById(userId)

                if (user == null) {
                    _submitState.value = SubmitState.Error("User not found")
                    return@launch
                }

                _userState.value = user

                val summary = ratingRepository.submitRating(
                    type = type,
                    itemId = itemId,
                    title = title,
                    userId = user.id?.takeIf { it.isNotBlank() } ?: user._id ?: userId,
                    rating = rating,
                    comment = comment
                )

                _ratingState.value = summary.toUiState()
                _submitState.value = SubmitState.Success
            } catch (e: Exception) {
                _submitState.value = SubmitState.Error(e.message ?: "Failed to submit rating")
            } finally {
                _submitState.value = SubmitState.Idle
            }
        }
    }

    private fun RatingSummary.toUiState(): RatingUiState.Success =
        RatingUiState.Success(
            existingRating = existingRating,
            averageRating = averageRating,
            totalRatings = totalRatings,
            userRating = userRating
        )
}
=======
package org.ole.planet.myplanet.ui.rating


import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.RatingEntry
import org.ole.planet.myplanet.repository.RatingRepository
import org.ole.planet.myplanet.repository.RatingSummary
import org.ole.planet.myplanet.repository.UserRepository

class RatingViewModel @Inject constructor(
    private val ratingRepository: RatingRepository,
    private val userRepository: UserRepository
) : ViewModel() {

    private val _ratingState = MutableStateFlow<RatingUiState>(RatingUiState.Loading)
    val ratingState: StateFlow<RatingUiState> = _ratingState.asStateFlow()

    private val _submitState = MutableStateFlow<SubmitState>(SubmitState.Idle)
    val submitState: StateFlow<SubmitState> = _submitState.asStateFlow()

    private val _userState = MutableStateFlow<RealmUserModel?>(null)
    val userState: StateFlow<RealmUserModel?> = _userState.asStateFlow()

    sealed class RatingUiState {
        object Loading : RatingUiState()
        data class Success(
            val existingRating: RatingEntry?,
            val averageRating: Float,
            val totalRatings: Int,
            val userRating: Int?
        ) : RatingUiState()
        data class Error(val message: String) : RatingUiState()
    }

    sealed class SubmitState {
        object Idle : SubmitState()
        object Submitting : SubmitState()
        object Success : SubmitState()
        data class Error(val message: String) : SubmitState()
    }

    fun loadRatingData(type: String, itemId: String, userId: String) {
        viewModelScope.launch {
            try {
                _ratingState.value = RatingUiState.Loading

                _userState.value = userRepository.getUserById(userId)

                val summary = ratingRepository.getRatingSummary(type, itemId, userId)
                _ratingState.value = summary.toUiState()
            } catch (e: Exception) {
                _userState.value = null
                _ratingState.value = RatingUiState.Error(e.message ?: "Failed to load rating data")
            }
        }
    }

    fun submitRating(
        type: String,
        itemId: String,
        title: String,
        userId: String,
        rating: Float,
        comment: String
    ) {
        viewModelScope.launch {
            try {
                _submitState.value = SubmitState.Submitting

                val user = _userState.value ?: userRepository.getUserById(userId)

                if (user == null) {
                    _submitState.value = SubmitState.Error("User not found")
                    return@launch
                }

                _userState.value = user

                val summary = ratingRepository.submitRating(
                    type = type,
                    itemId = itemId,
                    title = title,
                    userId = user.id?.takeIf { it.isNotBlank() } ?: user._id ?: userId,
                    rating = rating,
                    comment = comment
                )

                _ratingState.value = summary.toUiState()
                _submitState.value = SubmitState.Success
            } catch (e: Exception) {
                _submitState.value = SubmitState.Error(e.message ?: "Failed to submit rating")
            } finally {
                _submitState.value = SubmitState.Idle
            }
        }
    }

    private fun RatingSummary.toUiState(): RatingUiState.Success =
        RatingUiState.Success(
            existingRating = existingRating,
            averageRating = averageRating,
            totalRatings = totalRatings,
            userRating = userRating
        )
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/navigation/NavigationHelper.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.navigation

import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager

/**
 * Utility object that centralizes fragment navigation.
 * Use [replaceFragment] instead of direct fragment transactions to ensure
 * consistent navigation behavior across the app.
 */
object NavigationHelper {
    /**
     * Replaces a fragment in the specified container.
     *
     * @param fragmentManager manager used to execute the transaction
     * @param containerId id of the container where the fragment will be placed
     * @param fragment fragment instance to display
     * @param addToBackStack whether the transaction should be added to the back stack
     * @param tag optional tag for the fragment and back stack entry
     * @param allowStateLoss whether to allow committing state loss
     */
    fun replaceFragment(
        fragmentManager: FragmentManager,
        containerId: Int,
        fragment: Fragment,
        addToBackStack: Boolean = false,
        tag: String? = null,
        allowStateLoss: Boolean = false
    ) {
        fragmentManager.beginTransaction().apply {
            replace(containerId, fragment, tag)
            if (addToBackStack) {
                addToBackStack(tag)
            }
            if (allowStateLoss) {
                commitAllowingStateLoss()
            } else {
                commit()
            }
        }
    }

    /**
     * Pops the back stack of the provided [fragmentManager] if there are entries.
     *
     * @param fragmentManager manager whose back stack will be popped
     * @param tag optional tag identifying the entry to pop to
     * @param flags optional flags to control popping behavior
     */
    fun popBackStack(
        fragmentManager: FragmentManager,
        tag: String? = null,
        flags: Int = 0
    ) {
        if (fragmentManager.backStackEntryCount > 0) {
            if (tag == null && flags == 0) {
                fragmentManager.popBackStack()
            } else {
                fragmentManager.popBackStack(tag, flags)
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.navigation


import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager

/**
 * Utility object that centralizes fragment navigation.
 * Use [replaceFragment] instead of direct fragment transactions to ensure
 * consistent navigation behavior across the app.
 */
object NavigationHelper {
    /**
     * Replaces a fragment in the specified container.
     *
     * @param fragmentManager manager used to execute the transaction
     * @param containerId id of the container where the fragment will be placed
     * @param fragment fragment instance to display
     * @param addToBackStack whether the transaction should be added to the back stack
     * @param tag optional tag for the fragment and back stack entry
     * @param allowStateLoss whether to allow committing state loss
     */
    fun replaceFragment(
        fragmentManager: FragmentManager,
        containerId: Int,
        fragment: Fragment,
        addToBackStack: Boolean = false,
        tag: String? = null,
        allowStateLoss: Boolean = false
    ) {
        fragmentManager.beginTransaction().apply {
            replace(containerId, fragment, tag)
            if (addToBackStack) {
                addToBackStack(tag)
            }
            if (allowStateLoss) {
                commitAllowingStateLoss()
            } else {
                commit()
            }
        }
    }

    /**
     * Pops the back stack of the provided [fragmentManager] if there are entries.
     *
     * @param fragmentManager manager whose back stack will be popped
     * @param tag optional tag identifying the entry to pop to
     * @param flags optional flags to control popping behavior
     */
    fun popBackStack(
        fragmentManager: FragmentManager,
        tag: String? = null,
        flags: Int = 0
    ) {
        if (fragmentManager.backStackEntryCount > 0) {
            if (tag == null && flags == 0) {
                fragmentManager.popBackStack()
            } else {
                fragmentManager.popBackStack(tag, flags)
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/calendar/CalendarFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.calendar

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import com.applandeo.materialcalendarview.CalendarDay
import com.applandeo.materialcalendarview.listeners.OnCalendarDayClickListener
import java.util.Calendar
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.FragmentCalendarBinding

class CalendarFragment : Fragment() {
    private var _binding: FragmentCalendarBinding? = null
    private val binding get() = _binding!!
    var listener: OnHomeItemClickListener? = null

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) listener = context
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentCalendarBinding.inflate(inflater, container, false)
        binding.calendarView.setOnCalendarDayClickListener(object : OnCalendarDayClickListener {
            override fun onClick(calendarDay: CalendarDay) {
            }
        })
        val calendar = Calendar.getInstance()
        binding.calendarView.setDate(calendar.time)
        return binding.root
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.calendar


import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import com.applandeo.materialcalendarview.CalendarDay
import com.applandeo.materialcalendarview.listeners.OnCalendarDayClickListener
import java.util.Calendar
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.FragmentCalendarBinding

class CalendarFragment : Fragment() {
    private var _binding: FragmentCalendarBinding? = null
    private val binding get() = _binding!!
    var listener: OnHomeItemClickListener? = null

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) listener = context
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentCalendarBinding.inflate(inflater, container, false)
        binding.calendarView.setOnCalendarDayClickListener(object : OnCalendarDayClickListener {
            override fun onClick(calendarDay: CalendarDay) {
            }
        })
        val calendar = Calendar.getInstance()
        binding.calendarView.setDate(calendar.time)
        return binding.root
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/onboarding/OnBoardingActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.onboarding

import android.content.Intent
import android.os.Bundle
import android.view.View
import android.widget.ImageView
import android.widget.LinearLayout
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import androidx.viewpager.widget.ViewPager
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityOnBoardingBinding
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.sync.LoginActivity
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.MapTileUtils.copyAssets
import org.ole.planet.myplanet.utilities.SecurePrefs
import org.ole.planet.myplanet.utilities.SharedPrefManager

class OnBoardingActivity : AppCompatActivity() {
    private lateinit var binding: ActivityOnBoardingBinding
    private lateinit var mAdapter: OnBoardingAdapter
    private val onBoardItems = ArrayList<OnBoardItem>()
    private var dotsCount = 0
    private lateinit var dots: Array<ImageView?>
    lateinit var prefData: SharedPrefManager

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityOnBoardingBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        prefData = SharedPrefManager(this)

        copyAssets(this)
        val settings = getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        val savedUser = SecurePrefs.getUserName(this, settings)
        val savedPass = SecurePrefs.getPassword(this, settings)
        if (!savedUser.isNullOrEmpty() && !savedPass.isNullOrEmpty() && !settings.getBoolean(Constants.KEY_LOGIN, false)) {
            settings.edit { putBoolean(Constants.KEY_LOGIN, true) }
        }
        if (settings.getBoolean(Constants.KEY_LOGIN, false) && !Constants.autoSynFeature(Constants.KEY_AUTOSYNC_, applicationContext)) {
            val dashboard = Intent(applicationContext, DashboardActivity::class.java)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
                .putExtra("from_login", true)
            startActivity(dashboard)
            finish()
            return
        }

        if (prefData.getFirstLaunch()) {
            startActivity(Intent(this, LoginActivity::class.java))
            finish()
        }

        loadData()
        mAdapter = OnBoardingAdapter(this, onBoardItems)
        binding.pagerIntroduction.adapter = mAdapter
        binding.pagerIntroduction.currentItem = 0
        binding.pagerIntroduction.addOnPageChangeListener(object : ViewPager.OnPageChangeListener {
            override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {}

            override fun onPageSelected(position: Int) {
                for (i in 0 until dotsCount) {
                    dots[i]?.setImageDrawable(ContextCompat.getDrawable(this@OnBoardingActivity, R.drawable.non_selected_item_dot))
                }
                dots[position]?.setImageDrawable(ContextCompat.getDrawable(this@OnBoardingActivity, R.drawable.selected_item_dot))

                if (position == mAdapter.count - 1) {
                    binding.skip.visibility = View.GONE
                    binding.next.setText(R.string.get_started)
                } else {
                    binding.skip.visibility = View.VISIBLE
                    binding.next.setText(R.string.next)
                }
            }

            override fun onPageScrollStateChanged(state: Int) {}
        })

        binding.skip.setOnClickListener{
            finishTutorial()
        }

        binding.next.setOnClickListener {
            val currentPosition = binding.pagerIntroduction.currentItem
            if (currentPosition < mAdapter.count - 1) {
                binding.pagerIntroduction.setCurrentItem(currentPosition + 1, true)
            } else {
                finishTutorial()
            }
        }

        setUiPageViewController()
    }

    private fun loadData() {
        val descriptionResourceLists = listOf(
            listOf(R.string.ob_desc1),
            listOf(R.string.ob_desc2_1, R.string.ob_desc2_2),
            listOf(R.string.ob_desc3_1, R.string.ob_desc3_2),
            listOf(R.string.ob_desc4_1, R.string.ob_desc4_2, R.string.ob_desc4_3, R.string.ob_desc4_4, R.string.ob_desc4_5)
        )
        val headers = listOf(
            R.string.welcome_to_myPlanet,
            R.string.learn_offline,
            R.string.open_learning,
            R.string.unleash_learning_power
        )
        val imageIds = listOf(R.drawable.ole_logo, R.drawable.o_a, R.drawable.b_b, R.drawable.c_c)

        val items = imageIds.zip(headers).mapIndexed { index, (imageRes, headerRes) ->
            val descResourceArray = descriptionResourceLists.getOrNull(index).orEmpty()
            val description = descResourceArray
                .map { getString(it) }
                .joinToString(separator = "\n")
                .let { if (it.isEmpty()) it else "$it\n" }

            OnBoardItem().apply {
                imageID = imageRes
                title = getString(headerRes)
                this.description = description
            }
        }

        onBoardItems.clear()
        onBoardItems.addAll(items)
    }

    private fun setUiPageViewController() {
        dotsCount = mAdapter.count
        dots = arrayOfNulls(dotsCount)

        for (i in 0 until dotsCount) {
            dots[i] = ImageView(this)
            dots[i]?.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.non_selected_item_dot))

            val params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )

            params.setMargins(6, 0, 6, 0)
            binding.viewPagerCountDots.addView(dots[i], params)
        }
        dots[0]?.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.selected_item_dot))
    }

    private fun finishTutorial() {
        prefData.setFirstLaunch(true)
        startActivity(Intent(this, LoginActivity::class.java))
    }
}
=======
package org.ole.planet.myplanet.ui.onboarding


import android.content.Intent
import android.os.Bundle
import android.view.View
import android.widget.ImageView
import android.widget.LinearLayout
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import androidx.viewpager.widget.ViewPager
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityOnBoardingBinding
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.sync.LoginActivity
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.MapTileUtils.copyAssets
import org.ole.planet.myplanet.utilities.SecurePrefs
import org.ole.planet.myplanet.utilities.SharedPrefManager

class OnBoardingActivity : AppCompatActivity() {
    private lateinit var binding: ActivityOnBoardingBinding
    private lateinit var mAdapter: OnBoardingAdapter
    private val onBoardItems = ArrayList<OnBoardItem>()
    private var dotsCount = 0
    private lateinit var dots: Array<ImageView?>
    lateinit var prefData: SharedPrefManager

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityOnBoardingBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        prefData = SharedPrefManager(this)

        copyAssets(this)
        val settings = getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        val savedUser = SecurePrefs.getUserName(this, settings)
        val savedPass = SecurePrefs.getPassword(this, settings)
        if (!savedUser.isNullOrEmpty() && !savedPass.isNullOrEmpty() && !settings.getBoolean(Constants.KEY_LOGIN, false)) {
            settings.edit { putBoolean(Constants.KEY_LOGIN, true) }
        }
        if (settings.getBoolean(Constants.KEY_LOGIN, false) && !Constants.autoSynFeature(Constants.KEY_AUTOSYNC_, applicationContext)) {
            val dashboard = Intent(applicationContext, DashboardActivity::class.java)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
                .putExtra("from_login", true)
            startActivity(dashboard)
            finish()
            return
        }

        if (prefData.getFirstLaunch()) {
            startActivity(Intent(this, LoginActivity::class.java))
            finish()
        }

        loadData()
        mAdapter = OnBoardingAdapter(this, onBoardItems)
        binding.pagerIntroduction.adapter = mAdapter
        binding.pagerIntroduction.currentItem = 0
        binding.pagerIntroduction.addOnPageChangeListener(object : ViewPager.OnPageChangeListener {
            override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {}

            override fun onPageSelected(position: Int) {
                for (i in 0 until dotsCount) {
                    dots[i]?.setImageDrawable(ContextCompat.getDrawable(this@OnBoardingActivity, R.drawable.non_selected_item_dot))
                }
                dots[position]?.setImageDrawable(ContextCompat.getDrawable(this@OnBoardingActivity, R.drawable.selected_item_dot))

                if (position == mAdapter.count - 1) {
                    binding.skip.visibility = View.GONE
                    binding.next.setText(R.string.get_started)
                } else {
                    binding.skip.visibility = View.VISIBLE
                    binding.next.setText(R.string.next)
                }
            }

            override fun onPageScrollStateChanged(state: Int) {}
        })

        binding.skip.setOnClickListener{
            finishTutorial()
        }

        binding.next.setOnClickListener {
            val currentPosition = binding.pagerIntroduction.currentItem
            if (currentPosition < mAdapter.count - 1) {
                binding.pagerIntroduction.setCurrentItem(currentPosition + 1, true)
            } else {
                finishTutorial()
            }
        }

        setUiPageViewController()
    }

    private fun loadData() {
        val descriptionResourceLists = listOf(
            listOf(R.string.ob_desc1),
            listOf(R.string.ob_desc2_1, R.string.ob_desc2_2),
            listOf(R.string.ob_desc3_1, R.string.ob_desc3_2),
            listOf(R.string.ob_desc4_1, R.string.ob_desc4_2, R.string.ob_desc4_3, R.string.ob_desc4_4, R.string.ob_desc4_5)
        )
        val headers = listOf(
            R.string.welcome_to_myPlanet,
            R.string.learn_offline,
            R.string.open_learning,
            R.string.unleash_learning_power
        )
        val imageIds = listOf(R.drawable.ole_logo, R.drawable.o_a, R.drawable.b_b, R.drawable.c_c)

        val items = imageIds.zip(headers).mapIndexed { index, (imageRes, headerRes) ->
            val descResourceArray = descriptionResourceLists.getOrNull(index).orEmpty()
            val description = descResourceArray
                .map { getString(it) }
                .joinToString(separator = "\n")
                .let { if (it.isEmpty()) it else "$it\n" }

            OnBoardItem().apply {
                imageID = imageRes
                title = getString(headerRes)
                this.description = description
            }
        }

        onBoardItems.clear()
        onBoardItems.addAll(items)
    }

    private fun setUiPageViewController() {
        dotsCount = mAdapter.count
        dots = arrayOfNulls(dotsCount)

        for (i in 0 until dotsCount) {
            dots[i] = ImageView(this)
            dots[i]?.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.non_selected_item_dot))

            val params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )

            params.setMargins(6, 0, 6, 0)
            binding.viewPagerCountDots.addView(dots[i], params)
        }
        dots[0]?.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.selected_item_dot))
    }

    private fun finishTutorial() {
        prefData.setFirstLaunch(true)
        startActivity(Intent(this, LoginActivity::class.java))
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/onboarding/OnBoardingAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.onboarding

import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.viewpager.widget.PagerAdapter
import org.ole.planet.myplanet.R

class OnBoardingAdapter(private val mContext: Context, private val onBoardItems: ArrayList<OnBoardItem>) : PagerAdapter() {

    override fun getCount(): Int {
        return onBoardItems.size
    }

    override fun isViewFromObject(view: View, `object`: Any): Boolean {
        return view == `object`
    }

    override fun instantiateItem(container: ViewGroup, position: Int): Any {
        val itemView = LayoutInflater.from(mContext).inflate(R.layout.onboard_item, container, false)

        val item = onBoardItems[position]
        val imageView = itemView.findViewById<ImageView>(R.id.iv_onboard)
        imageView.setImageResource(item.imageID)
        val tvTitle = itemView.findViewById<TextView>(R.id.tv_header)
        tvTitle.text = item.title
        tvTitle.setTextColor(mContext.getColor(R.color.daynight_textColor))
        val tvContent = itemView.findViewById<TextView>(R.id.tv_desc)
        tvContent.text = item.description
        tvContent.setTextColor(mContext.getColor(R.color.daynight_textColor))
        container.addView(itemView)

        return itemView
    }

    override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) {
        container.removeView(`object` as View)
    }
}
=======
package org.ole.planet.myplanet.ui.onboarding


import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.viewpager.widget.PagerAdapter
import org.ole.planet.myplanet.R

class OnBoardingAdapter(private val mContext: Context, private val onBoardItems: ArrayList<OnBoardItem>) : PagerAdapter() {

    override fun getCount(): Int {
        return onBoardItems.size
    }

    override fun isViewFromObject(view: View, `object`: Any): Boolean {
        return view == `object`
    }

    override fun instantiateItem(container: ViewGroup, position: Int): Any {
        val itemView = LayoutInflater.from(mContext).inflate(R.layout.onboard_item, container, false)

        val item = onBoardItems[position]
        val imageView = itemView.findViewById<ImageView>(R.id.iv_onboard)
        imageView.setImageResource(item.imageID)
        val tvTitle = itemView.findViewById<TextView>(R.id.tv_header)
        tvTitle.text = item.title
        tvTitle.setTextColor(mContext.getColor(R.color.daynight_textColor))
        val tvContent = itemView.findViewById<TextView>(R.id.tv_desc)
        tvContent.text = item.description
        tvContent.setTextColor(mContext.getColor(R.color.daynight_textColor))
        container.addView(itemView)

        return itemView
    }

    override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) {
        container.removeView(`object` as View)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/AdapterTeamList.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team

import android.content.Context
import android.content.DialogInterface
import android.graphics.PorterDuff
import android.graphics.Typeface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.graphics.toColorInt
import androidx.fragment.app.FragmentManager
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.async
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ItemTeamListBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.ui.feedback.FeedbackFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.TimeUtils

class AdapterTeamList(
    private val context: Context,
    private val list: List<RealmMyTeam>,
    private val fragmentManager: FragmentManager,
    private val teamRepository: TeamRepository,
    private val currentUser: RealmUserModel?,
    private val scope: CoroutineScope,
) : RecyclerView.Adapter<AdapterTeamList.ViewHolderTeam>() {
    private var type: String? = ""
    private var teamListener: OnClickTeamItem? = null
    private var updateCompleteListener: OnUpdateCompleteListener? = null
    private var filteredList: List<RealmMyTeam> = emptyList()
    private lateinit var prefData: SharedPrefManager
    private val teamStatusCache = mutableMapOf<String, TeamStatus>()
    private val visitCountsCache = mutableMapOf<String, Long>()
    private var visitCounts: Map<String, Long> = emptyMap()
    private var updateListJob: Job? = null

    data class TeamStatus(
        val isMember: Boolean,
        val isLeader: Boolean,
        val hasPendingRequest: Boolean
    )

    private data class TeamData(
        val _id: String?,
        val name: String?,
        val teamType: String?,
        val createdDate: Long?,
        val type: String?,
        val status: String?,
        val visitCount: Long,
        val teamStatus: TeamStatus?
    )

    interface OnClickTeamItem {
        fun onEditTeam(team: RealmMyTeam?)
    }

    interface OnUpdateCompleteListener {
        fun onUpdateComplete(itemCount: Int)
    }

    fun setTeamListener(teamListener: OnClickTeamItem?) {
        this.teamListener = teamListener
    }

    fun setUpdateCompleteListener(listener: OnUpdateCompleteListener?) {
        this.updateCompleteListener = listener
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderTeam {
        val binding = ItemTeamListBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        prefData = SharedPrefManager(context)
        return ViewHolderTeam(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderTeam, position: Int) {
        val team = filteredList[position]
        val user: RealmUserModel? = currentUser

        with(holder.binding) {
            created.text = TimeUtils.getFormattedDate(team.createdDate)
            type.text = team.teamType
            type.visibility = if (team.teamType == null) View.GONE else View.VISIBLE
            name.text = team.name
            val visitCount = visitCounts[team._id.orEmpty()] ?: 0L
            noOfVisits.text = context.getString(R.string.number_placeholder, visitCount)

            val teamId = team._id.orEmpty()
            val userId = user?.id
            val cacheKey = "${teamId}_${userId}"
            val teamStatus = teamStatusCache[cacheKey] ?: TeamStatus(
                isMember = false,
                isLeader = false,
                hasPendingRequest = false
            )

            showActionButton(teamStatus.isMember, teamStatus.isLeader, teamStatus.hasPendingRequest, team, user)

            root.setOnClickListener {
                val activity = context as? AppCompatActivity ?: return@setOnClickListener
                val fragment = TeamDetailFragment.newInstance(
                    teamId = "${team._id}",
                    teamName = "${team.name}",
                    teamType = "${team.type}",
                    isMyTeam = teamStatus.isMember
                )
                NavigationHelper.replaceFragment(
                    activity.supportFragmentManager,
                    R.id.fragment_container,
                    fragment,
                    addToBackStack = true,
                    tag = "TeamDetailFragment"
                )
                prefData.setTeamName(team.name)
            }

            btnFeedback.setOnClickListener {
                val feedbackFragment = FeedbackFragment()
                feedbackFragment.show(fragmentManager, "")
                feedbackFragment.arguments = getBundle(team)
            }

            joinLeave.setOnClickListener {
                handleJoinLeaveClick(team, user)
            }
        }
    }

    private fun ItemTeamListBinding.showActionButton(
        isMyTeam: Boolean,
        isTeamLeader: Boolean,
        hasPendingRequest: Boolean,
        team: RealmMyTeam,
        user: RealmUserModel?,
    ) {
        if (isMyTeam) {
            name.setTypeface(null, Typeface.BOLD)
        } else {
            name.setTypeface(null, Typeface.NORMAL)
        }
        when {
            user?.isGuest() == true -> joinLeave.visibility = View.GONE

            isTeamLeader -> {
                joinLeave.apply {
                    isEnabled = true
                    contentDescription = "${context.getString(R.string.edit)} ${team.name}"
                    visibility = View.VISIBLE
                    setImageResource(R.drawable.ic_edit)
                    clearColorFilter()
                }
            }

            isMyTeam && !isTeamLeader -> {
                joinLeave.apply {
                    isEnabled = true
                    contentDescription = "${context.getString(R.string.leave)} ${team.name}"
                    visibility = View.VISIBLE
                    setImageResource(R.drawable.logout)
                    clearColorFilter()
                }
            }

            !isMyTeam && hasPendingRequest -> {
                joinLeave.apply {
                    isEnabled = false
                    contentDescription = "${context.getString(R.string.requested)} ${team.name}"
                    visibility = View.VISIBLE
                    setImageResource(R.drawable.baseline_hourglass_top_24)
                    setColorFilter("#9fa0a4".toColorInt(), PorterDuff.Mode.SRC_IN)
                }
            }

            !isMyTeam -> {
                joinLeave.apply {
                    isEnabled = true
                    contentDescription = "${context.getString(R.string.request_to_join)} ${team.name}"
                    visibility = View.VISIBLE
                    setImageResource(R.drawable.ic_join_request)
                    clearColorFilter()
                }
            }

            else -> joinLeave.visibility = View.GONE
        }
    }

    private fun handleJoinLeaveClick(team: RealmMyTeam, user: RealmUserModel?) {
        val teamId = team._id.orEmpty()
        val userId = user?.id
        val cacheKey = "${teamId}_${userId}"
        val teamStatus = teamStatusCache[cacheKey] ?: TeamStatus(
            isMember = false,
            isLeader = false,
            hasPendingRequest = false
        )

        if (teamStatus.isMember) {
            if (teamStatus.isLeader) {
                teamListener?.onEditTeam(team)
            } else {
                AlertDialog.Builder(context, R.style.CustomAlertDialog).setMessage(R.string.confirm_exit)
                    .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                        leaveTeam(team, userId)
                    }.setNegativeButton(R.string.no, null).show()
            }
        } else {
            requestToJoin(team, user)
        }
        syncTeamActivities()
    }

    fun updateList() {
        val user: RealmUserModel? = currentUser
        val userId = user?.id

        updateListJob?.cancel()
        updateListJob = scope.launch {
            val oldList = filteredList.map { team ->
                val teamId = team._id.orEmpty()
                val cacheKey = "${teamId}_${userId}"
                TeamData(
                    _id = team._id,
                    name = team.name,
                    teamType = team.teamType,
                    createdDate = team.createdDate,
                    type = team.type,
                    status = team.status,
                    visitCount = visitCounts[teamId] ?: 0L,
                    teamStatus = teamStatusCache[cacheKey]
                )
            }

            val validTeams = list.filter { it.status?.isNotEmpty() == true }

            if (validTeams.isEmpty()) {
                val diffResult = withContext(Dispatchers.Default) {
                    DiffUtils.calculateDiff(
                        oldList,
                        emptyList(),
                        areItemsTheSame = { old, new -> old._id == new._id },
                        areContentsTheSame = { old, new -> old == new }
                    )
                }
                visitCounts = emptyMap()
                filteredList = emptyList()
                diffResult.dispatchUpdatesTo(this@AdapterTeamList)
                updateCompleteListener?.onUpdateComplete(filteredList.size)
                return@launch
            }

            val teamIds = validTeams.mapNotNull { it._id?.takeIf { id -> id.isNotBlank() } }
            val (cachedVisitIds, nonCachedVisitIds) = teamIds.partition { it in visitCountsCache }
            val visitCountsDeferred = if (nonCachedVisitIds.isNotEmpty()) {
                async(Dispatchers.IO) {
                    teamRepository.getRecentVisitCounts(nonCachedVisitIds)
                }
            } else {
                async { emptyMap<String, Long>() }
            }

            val statusResults = mutableMapOf<String, TeamStatus>()
            val idsToFetch = linkedSetOf<String>()
            validTeams.forEach { team ->
                val teamId = team._id.orEmpty()
                if (teamId.isBlank()) return@forEach
                val cacheKey = "${teamId}_${userId}"
                val cachedStatus = teamStatusCache[cacheKey]
                if (cachedStatus != null) {
                    statusResults[teamId] = cachedStatus
                } else {
                    idsToFetch += teamId
                }
            }

            if (idsToFetch.isNotEmpty()) {
                val batchStatuses = withContext(Dispatchers.IO) {
                    teamRepository.getTeamMemberStatuses(userId, idsToFetch)
                }

                batchStatuses.forEach { (teamId, memberStatus) ->
                    val status = TeamStatus(
                        isMember = memberStatus.isMember,
                        isLeader = memberStatus.isLeader,
                        hasPendingRequest = memberStatus.hasPendingRequest
                    )
                    val cacheKey = "${teamId}_${userId}"
                    teamStatusCache[cacheKey] = status
                    statusResults[teamId] = status
                }
            }

            val newVisitCounts = visitCountsDeferred.await()
            newVisitCounts.forEach { (id, count) -> visitCountsCache[id] = count }
            val allVisitCounts = cachedVisitIds.associateWith { visitCountsCache[it]!! } + newVisitCounts
            val sortedTeams = validTeams.sortedWith(
                compareByDescending<RealmMyTeam> { team ->
                    val teamId = team._id.orEmpty()
                    val status = statusResults[teamId] ?: TeamStatus(false, false, false)
                    when {
                        status.isLeader -> 3
                        status.isMember -> 2
                        else -> 1
                    }
                }.thenByDescending { team ->
                    allVisitCounts[team._id.orEmpty()] ?: 0L
                }
            )

            val newList = sortedTeams.map { team ->
                val teamId = team._id.orEmpty()
                val cacheKey = "${teamId}_${userId}"
                TeamData(
                    _id = team._id,
                    name = team.name,
                    teamType = team.teamType,
                    createdDate = team.createdDate,
                    type = team.type,
                    status = team.status,
                    visitCount = allVisitCounts[teamId] ?: 0L,
                    teamStatus = teamStatusCache[cacheKey]
                )
            }

            val diffResult = withContext(Dispatchers.Default) {
                DiffUtils.calculateDiff(
                    oldList,
                    newList,
                    areItemsTheSame = { old, new -> old._id == new._id },
                    areContentsTheSame = { old, new -> old == new }
                )
            }

            visitCounts = allVisitCounts
            filteredList = sortedTeams
            diffResult.dispatchUpdatesTo(this@AdapterTeamList)
            updateCompleteListener?.onUpdateComplete(filteredList.size)
        }
    }

    private fun requestToJoin(team: RealmMyTeam, user: RealmUserModel?) {
        val teamId = team._id ?: return
        val teamType = team.teamType
        val userId = user?.id
        val userPlanetCode = user?.planetCode
        val cacheKey = "${teamId}_${userId}"
        val position = filteredList.indexOfFirst { it._id == teamId }

        teamStatusCache[cacheKey] = TeamStatus(
            isMember = false,
            isLeader = false,
            hasPendingRequest = true
        )

        if (position >= 0) {
            notifyItemChanged(position)
        }

        scope.launch(Dispatchers.IO) {
            teamRepository.requestToJoin(teamId, userId, userPlanetCode, teamType)
            withContext(Dispatchers.Main) {
                teamStatusCache.remove(cacheKey)
                updateList()
            }
        }
    }

    private fun leaveTeam(team: RealmMyTeam, userId: String?) {
        val teamId = team._id ?: return
        val cacheKey = "${teamId}_${userId}"
        teamStatusCache.remove(cacheKey)

        scope.launch(Dispatchers.IO) {
            teamRepository.leaveTeam(teamId, userId)
            withContext(Dispatchers.Main) {
                updateList()
            }
        }
    }

    private fun syncTeamActivities() {
        MainApplication.applicationScope.launch {
            teamRepository.syncTeamActivities()
        }
    }

    private fun getBundle(team: RealmMyTeam): Bundle {
        return Bundle().apply {
            putString("state", if (team.type?.isEmpty() == true) "teams" else "${team.type}s")
            putString("item", team._id)
            putString("parentCode", "dev")
        }
    }

    fun setType(type: String?) {
        this.type = type
    }

    fun cleanup() {
        scope.cancel()
        teamStatusCache.clear()
        visitCountsCache.clear()
    }

    override fun getItemCount(): Int = filteredList.size

    class ViewHolderTeam(val binding: ItemTeamListBinding) : RecyclerView.ViewHolder(binding.root)
}
=======
package org.ole.planet.myplanet.ui.team


import android.content.Context
import android.content.DialogInterface
import android.graphics.PorterDuff
import android.graphics.Typeface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.graphics.toColorInt
import androidx.fragment.app.FragmentManager
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.async
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ItemTeamListBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.ui.feedback.FeedbackFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.TimeUtils

class AdapterTeamList(
    private val context: Context,
    private val list: List<RealmMyTeam>,
    private val fragmentManager: FragmentManager,
    private val teamRepository: TeamRepository,
    private val currentUser: RealmUserModel?,
    private val scope: CoroutineScope,
) : RecyclerView.Adapter<AdapterTeamList.ViewHolderTeam>() {
    private var type: String? = ""
    private var teamListener: OnClickTeamItem? = null
    private var updateCompleteListener: OnUpdateCompleteListener? = null
    private var filteredList: List<RealmMyTeam> = emptyList()
    private lateinit var prefData: SharedPrefManager
    private val teamStatusCache = mutableMapOf<String, TeamStatus>()
    private val visitCountsCache = mutableMapOf<String, Long>()
    private var visitCounts: Map<String, Long> = emptyMap()
    private var updateListJob: Job? = null

    data class TeamStatus(
        val isMember: Boolean,
        val isLeader: Boolean,
        val hasPendingRequest: Boolean
    )

    private data class TeamData(
        val _id: String?,
        val name: String?,
        val teamType: String?,
        val createdDate: Long?,
        val type: String?,
        val status: String?,
        val visitCount: Long,
        val teamStatus: TeamStatus?
    )

    interface OnClickTeamItem {
        fun onEditTeam(team: RealmMyTeam?)
    }

    interface OnUpdateCompleteListener {
        fun onUpdateComplete(itemCount: Int)
    }

    fun setTeamListener(teamListener: OnClickTeamItem?) {
        this.teamListener = teamListener
    }

    fun setUpdateCompleteListener(listener: OnUpdateCompleteListener?) {
        this.updateCompleteListener = listener
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderTeam {
        val binding = ItemTeamListBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        prefData = SharedPrefManager(context)
        return ViewHolderTeam(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderTeam, position: Int) {
        val team = filteredList[position]
        val user: RealmUserModel? = currentUser

        with(holder.binding) {
            created.text = TimeUtils.getFormattedDate(team.createdDate)
            type.text = team.teamType
            type.visibility = if (team.teamType == null) View.GONE else View.VISIBLE
            name.text = team.name
            val visitCount = visitCounts[team._id.orEmpty()] ?: 0L
            noOfVisits.text = context.getString(R.string.number_placeholder, visitCount)

            val teamId = team._id.orEmpty()
            val userId = user?.id
            val cacheKey = "${teamId}_${userId}"
            val teamStatus = teamStatusCache[cacheKey] ?: TeamStatus(
                isMember = false,
                isLeader = false,
                hasPendingRequest = false
            )

            showActionButton(teamStatus.isMember, teamStatus.isLeader, teamStatus.hasPendingRequest, team, user)

            root.setOnClickListener {
                val activity = context as? AppCompatActivity ?: return@setOnClickListener
                val fragment = TeamDetailFragment.newInstance(
                    teamId = "${team._id}",
                    teamName = "${team.name}",
                    teamType = "${team.type}",
                    isMyTeam = teamStatus.isMember
                )
                NavigationHelper.replaceFragment(
                    activity.supportFragmentManager,
                    R.id.fragment_container,
                    fragment,
                    addToBackStack = true,
                    tag = "TeamDetailFragment"
                )
                prefData.setTeamName(team.name)
            }

            btnFeedback.setOnClickListener {
                val feedbackFragment = FeedbackFragment()
                feedbackFragment.show(fragmentManager, "")
                feedbackFragment.arguments = getBundle(team)
            }

            joinLeave.setOnClickListener {
                handleJoinLeaveClick(team, user)
            }
        }
    }

    private fun ItemTeamListBinding.showActionButton(
        isMyTeam: Boolean,
        isTeamLeader: Boolean,
        hasPendingRequest: Boolean,
        team: RealmMyTeam,
        user: RealmUserModel?,
    ) {
        if (isMyTeam) {
            name.setTypeface(null, Typeface.BOLD)
        } else {
            name.setTypeface(null, Typeface.NORMAL)
        }
        when {
            user?.isGuest() == true -> joinLeave.visibility = View.GONE

            isTeamLeader -> {
                joinLeave.apply {
                    isEnabled = true
                    contentDescription = "${context.getString(R.string.edit)} ${team.name}"
                    visibility = View.VISIBLE
                    setImageResource(R.drawable.ic_edit)
                    clearColorFilter()
                }
            }

            isMyTeam && !isTeamLeader -> {
                joinLeave.apply {
                    isEnabled = true
                    contentDescription = "${context.getString(R.string.leave)} ${team.name}"
                    visibility = View.VISIBLE
                    setImageResource(R.drawable.logout)
                    clearColorFilter()
                }
            }

            !isMyTeam && hasPendingRequest -> {
                joinLeave.apply {
                    isEnabled = false
                    contentDescription = "${context.getString(R.string.requested)} ${team.name}"
                    visibility = View.VISIBLE
                    setImageResource(R.drawable.baseline_hourglass_top_24)
                    setColorFilter("#9fa0a4".toColorInt(), PorterDuff.Mode.SRC_IN)
                }
            }

            !isMyTeam -> {
                joinLeave.apply {
                    isEnabled = true
                    contentDescription = "${context.getString(R.string.request_to_join)} ${team.name}"
                    visibility = View.VISIBLE
                    setImageResource(R.drawable.ic_join_request)
                    clearColorFilter()
                }
            }

            else -> joinLeave.visibility = View.GONE
        }
    }

    private fun handleJoinLeaveClick(team: RealmMyTeam, user: RealmUserModel?) {
        val teamId = team._id.orEmpty()
        val userId = user?.id
        val cacheKey = "${teamId}_${userId}"
        val teamStatus = teamStatusCache[cacheKey] ?: TeamStatus(
            isMember = false,
            isLeader = false,
            hasPendingRequest = false
        )

        if (teamStatus.isMember) {
            if (teamStatus.isLeader) {
                teamListener?.onEditTeam(team)
            } else {
                AlertDialog.Builder(context, R.style.CustomAlertDialog).setMessage(R.string.confirm_exit)
                    .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                        leaveTeam(team, userId)
                    }.setNegativeButton(R.string.no, null).show()
            }
        } else {
            requestToJoin(team, user)
        }
        syncTeamActivities()
    }

    fun updateList() {
        val user: RealmUserModel? = currentUser
        val userId = user?.id

        updateListJob?.cancel()
        updateListJob = scope.launch {
            val oldList = filteredList.map { team ->
                val teamId = team._id.orEmpty()
                val cacheKey = "${teamId}_${userId}"
                TeamData(
                    _id = team._id,
                    name = team.name,
                    teamType = team.teamType,
                    createdDate = team.createdDate,
                    type = team.type,
                    status = team.status,
                    visitCount = visitCounts[teamId] ?: 0L,
                    teamStatus = teamStatusCache[cacheKey]
                )
            }

            val validTeams = list.filter { it.status?.isNotEmpty() == true }

            if (validTeams.isEmpty()) {
                val diffResult = withContext(Dispatchers.Default) {
                    DiffUtils.calculateDiff(
                        oldList,
                        emptyList(),
                        areItemsTheSame = { old, new -> old._id == new._id },
                        areContentsTheSame = { old, new -> old == new }
                    )
                }
                visitCounts = emptyMap()
                filteredList = emptyList()
                diffResult.dispatchUpdatesTo(this@AdapterTeamList)
                updateCompleteListener?.onUpdateComplete(filteredList.size)
                return@launch
            }

            val teamIds = validTeams.mapNotNull { it._id?.takeIf { id -> id.isNotBlank() } }
            val (cachedVisitIds, nonCachedVisitIds) = teamIds.partition { it in visitCountsCache }
            val visitCountsDeferred = if (nonCachedVisitIds.isNotEmpty()) {
                async(Dispatchers.IO) {
                    teamRepository.getRecentVisitCounts(nonCachedVisitIds)
                }
            } else {
                async { emptyMap<String, Long>() }
            }

            val statusResults = mutableMapOf<String, TeamStatus>()
            val idsToFetch = linkedSetOf<String>()
            validTeams.forEach { team ->
                val teamId = team._id.orEmpty()
                if (teamId.isBlank()) return@forEach
                val cacheKey = "${teamId}_${userId}"
                val cachedStatus = teamStatusCache[cacheKey]
                if (cachedStatus != null) {
                    statusResults[teamId] = cachedStatus
                } else {
                    idsToFetch += teamId
                }
            }

            if (idsToFetch.isNotEmpty()) {
                val batchStatuses = withContext(Dispatchers.IO) {
                    teamRepository.getTeamMemberStatuses(userId, idsToFetch)
                }

                batchStatuses.forEach { (teamId, memberStatus) ->
                    val status = TeamStatus(
                        isMember = memberStatus.isMember,
                        isLeader = memberStatus.isLeader,
                        hasPendingRequest = memberStatus.hasPendingRequest
                    )
                    val cacheKey = "${teamId}_${userId}"
                    teamStatusCache[cacheKey] = status
                    statusResults[teamId] = status
                }
            }

            val newVisitCounts = visitCountsDeferred.await()
            newVisitCounts.forEach { (id, count) -> visitCountsCache[id] = count }
            val allVisitCounts = cachedVisitIds.associateWith { visitCountsCache[it]!! } + newVisitCounts
            val sortedTeams = validTeams.sortedWith(
                compareByDescending<RealmMyTeam> { team ->
                    val teamId = team._id.orEmpty()
                    val status = statusResults[teamId] ?: TeamStatus(false, false, false)
                    when {
                        status.isLeader -> 3
                        status.isMember -> 2
                        else -> 1
                    }
                }.thenByDescending { team ->
                    allVisitCounts[team._id.orEmpty()] ?: 0L
                }
            )

            val newList = sortedTeams.map { team ->
                val teamId = team._id.orEmpty()
                val cacheKey = "${teamId}_${userId}"
                TeamData(
                    _id = team._id,
                    name = team.name,
                    teamType = team.teamType,
                    createdDate = team.createdDate,
                    type = team.type,
                    status = team.status,
                    visitCount = allVisitCounts[teamId] ?: 0L,
                    teamStatus = teamStatusCache[cacheKey]
                )
            }

            val diffResult = withContext(Dispatchers.Default) {
                DiffUtils.calculateDiff(
                    oldList,
                    newList,
                    areItemsTheSame = { old, new -> old._id == new._id },
                    areContentsTheSame = { old, new -> old == new }
                )
            }

            visitCounts = allVisitCounts
            filteredList = sortedTeams
            diffResult.dispatchUpdatesTo(this@AdapterTeamList)
            updateCompleteListener?.onUpdateComplete(filteredList.size)
        }
    }

    private fun requestToJoin(team: RealmMyTeam, user: RealmUserModel?) {
        val teamId = team._id ?: return
        val teamType = team.teamType
        val userId = user?.id
        val userPlanetCode = user?.planetCode
        val cacheKey = "${teamId}_${userId}"
        val position = filteredList.indexOfFirst { it._id == teamId }

        teamStatusCache[cacheKey] = TeamStatus(
            isMember = false,
            isLeader = false,
            hasPendingRequest = true
        )

        if (position >= 0) {
            notifyItemChanged(position)
        }

        scope.launch(Dispatchers.IO) {
            teamRepository.requestToJoin(teamId, userId, userPlanetCode, teamType)
            withContext(Dispatchers.Main) {
                teamStatusCache.remove(cacheKey)
                updateList()
            }
        }
    }

    private fun leaveTeam(team: RealmMyTeam, userId: String?) {
        val teamId = team._id ?: return
        val cacheKey = "${teamId}_${userId}"
        teamStatusCache.remove(cacheKey)

        scope.launch(Dispatchers.IO) {
            teamRepository.leaveTeam(teamId, userId)
            withContext(Dispatchers.Main) {
                updateList()
            }
        }
    }

    private fun syncTeamActivities() {
        MainApplication.applicationScope.launch {
            teamRepository.syncTeamActivities()
        }
    }

    private fun getBundle(team: RealmMyTeam): Bundle {
        return Bundle().apply {
            putString("state", if (team.type?.isEmpty() == true) "teams" else "${team.type}s")
            putString("item", team._id)
            putString("parentCode", "dev")
        }
    }

    fun setType(type: String?) {
        this.type = type
    }

    fun cleanup() {
        scope.cancel()
        teamStatusCache.clear()
        visitCountsCache.clear()
    }

    override fun getItemCount(): Int = filteredList.size

    class ViewHolderTeam(val binding: ItemTeamListBinding) : RecyclerView.ViewHolder(binding.root)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/TeamDetailFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team

import android.content.DialogInterface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.lifecycle.lifecycleScope
import androidx.viewpager2.widget.ViewPager2
import com.google.android.material.snackbar.Snackbar
import com.google.android.material.tabs.TabLayoutMediator
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.MemberChangeListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.callback.TeamUpdateListener
import org.ole.planet.myplanet.databinding.FragmentTeamDetailBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getJoinedMemberCount
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ApplicantsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.CalendarPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ChatPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.CoursesPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.DocumentsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.FinancesPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.JoinRequestsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.MembersPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.MissionPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.PlanPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ReportsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ResourcesPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.SurveyPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.TasksPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.TeamPage
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class TeamDetailFragment : BaseTeamFragment(), MemberChangeListener, TeamUpdateListener {

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    @Inject
    lateinit var syncManager: SyncManager

    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()
    private lateinit var realtimeSyncListener: BaseRealtimeSyncListener

    private var _binding: FragmentTeamDetailBinding? = null
    private val binding get() = _binding!!
    private var directTeamName: String? = null
    private var directTeamType: String? = null
    private var directTeamId: String? = null
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    lateinit var prefManager: SharedPrefManager
    private val serverUrlMapper = ServerUrlMapper()
    private val teamLastPage = mutableMapOf<String, String>()
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""
    private var pageConfigs: List<TeamPageConfig> = emptyList()
    private var loadTeamJob: Job? = null

    private fun getCurrentUser(): RealmUserModel? {
        return userProfileDbHandler.userModel
    }

    private fun detachCurrentUser(): RealmUserModel? {
        return userProfileDbHandler.getUserModelCopy()
    }

    private fun pageIndexById(pageId: String?): Int? {
        pageId ?: return null
        val idx = pageConfigs.indexOfFirst { it.id == pageId }
        return if (idx >= 0) idx else null
    }

    private fun selectPage(pageId: String?, smoothScroll: Boolean = true) {
        val index = pageIndexById(pageId)
        index?.let {
            binding.viewPager2.setCurrentItem(it, smoothScroll)
        }
    }

    private fun buildPages(isMyTeam: Boolean): List<TeamPageConfig> {
        val isEnterprise = team?.type == "enterprise"
        val pages = mutableListOf<TeamPageConfig>()
        if (isMyTeam || team?.isPublic == true) {
            pages += ChatPage
            pages += if (isEnterprise) MissionPage else PlanPage
            pages += if (isEnterprise) TeamPage else MembersPage
            pages += TasksPage
            pages += CalendarPage
            pages += SurveyPage
            pages += if (isEnterprise) FinancesPage else CoursesPage
            if (isEnterprise) pages += ReportsPage
            pages += if (isEnterprise) DocumentsPage else ResourcesPage
            pages += if (isEnterprise) ApplicantsPage else JoinRequestsPage
        } else {
            pages += if (isEnterprise) MissionPage else PlanPage
            pages += if (isEnterprise) TeamPage else MembersPage
        }
        return pages
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        prefManager = SharedPrefManager(requireContext())
        startTeamSync()
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamDetailBinding.inflate(inflater, container, false)
        directTeamId = requireArguments().getString("teamId")
        directTeamName = requireArguments().getString("teamName")
        directTeamType = requireArguments().getString("teamType")

        val teamId = requireArguments().getString("id" ) ?: ""
        val isMyTeam = requireArguments().getBoolean("isMyTeam", false)
        val user = detachCurrentUser()

        renderPlaceholder()

        loadTeamJob?.cancel()
        loadTeamJob = viewLifecycleOwner.lifecycleScope.launch {
            val resolvedTeam = when {
                shouldQueryRealm(teamId) && teamId.isNotEmpty() -> {
                    teamRepository.getTeamByDocumentIdOrTeamId(teamId)
                }

                else -> {
                    val effectiveTeamId = (directTeamId ?: "").ifEmpty { teamId }
                    if (effectiveTeamId.isNotEmpty()) {
                        teamRepository.getTeamById(effectiveTeamId)
                    } else {
                        null
                    }
                }
            }

            if (!isAdded) {
                return@launch
            }

            if (shouldQueryRealm(teamId) && resolvedTeam == null) {
                Snackbar.make(
                    binding.root,
                    getString(R.string.no_team_available),
                    Snackbar.LENGTH_LONG
                ).show()
                return@launch
            }

            resolvedTeam?.let { team = it }

            setupTeamDetails(isMyTeam, user)
            loadTeamJob = null
        }

        return binding.root
    }

    private fun renderPlaceholder() {
        binding.title.text = directTeamName ?: getString(R.string.loading_teams)
        binding.subtitle.text = directTeamType ?: ""
        binding.btnAddDoc.isEnabled = false
        binding.btnLeave.isEnabled = false
        binding.viewPager2.adapter = null
    }

    private fun startTeamSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && prefManager.isTeamsSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch {
            withContext(kotlinx.coroutines.Dispatchers.IO) {
                updateServerIfNecessary(mapping)
            }
            startSyncManager()
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(requireContext().getString(R.string.syncing_team_data))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        refreshTeamData()
                        prefManager.setTeamsSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null

                        Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG)
                            .setAction("Retry") { startTeamSync() }
                            .show()
                    }
                }
            }
        }, "full", listOf("tasks", "meetups", "team_activities"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun setupTeamDetails(isMyTeam: Boolean, user: RealmUserModel?) {
        binding.root.post {
            if (isAdded && !requireActivity().isFinishing) {
                val targetPageId = arguments?.getString("navigateToPage")
                    ?: team?._id?.let { teamLastPage[it] }
                setupViewPager(isMyTeam, targetPageId)
            }
        }

        binding.title.text = getEffectiveTeamName()
        binding.subtitle.text = getEffectiveTeamType()

        if (!isMyTeam) {
            setupNonMyTeamButtons(user)
        } else {
            setupMyTeamButtons(user)
        }

        team?._id?.let { id ->
            if (getJoinedMemberCount(id, mRealm) <= 1 && isMyTeam) {
                binding.btnLeave.visibility = View.GONE
            }
        }
    }

    private fun setupViewPager(isMyTeam: Boolean, restorePageId: String? = null) {
        pageConfigs = buildPages(isMyTeam)
        binding.viewPager2.apply {
            isSaveEnabled = false
            offscreenPageLimit = 2
            isUserInputEnabled = true
            setPageTransformer { page, position ->
                page.alpha = 1.0f - kotlin.math.abs(position)
            }
        }

        if (binding.viewPager2.id == View.NO_ID) {
            binding.viewPager2.id = View.generateViewId()
        }

        binding.viewPager2.adapter = null
        binding.viewPager2.adapter = TeamPagerAdapter(
            requireActivity(),
            pageConfigs,
            team?._id,
            this,
            this
        )
        binding.tabLayout.tabMode = com.google.android.material.tabs.TabLayout.MODE_SCROLLABLE
        binding.tabLayout.isInlineLabel = true

        TabLayoutMediator(binding.tabLayout, binding.viewPager2) { tab, position ->
            val title = (binding.viewPager2.adapter as TeamPagerAdapter).getPageTitle(position)
            val pageConfig = pageConfigs.getOrNull(position)
            tab.text = title
        }.attach()

        selectPage(restorePageId, false)

        binding.viewPager2.registerOnPageChangeCallback(
            object : ViewPager2.OnPageChangeCallback() {
                override fun onPageSelected(position: Int) {
                    val pageConfig = pageConfigs.getOrNull(position)
                    val pageId = pageConfig?.id
                    team?._id?.let { teamId ->
                        pageId?.let {
                            teamLastPage[teamId] = it
                        }
                    }
                }
            }
        )
    }

    private fun setupNonMyTeamButtons(user: RealmUserModel?) {
        binding.btnAddDoc.isEnabled = false
        binding.btnAddDoc.visibility = View.GONE
        binding.btnLeave.isEnabled = true
        binding.btnLeave.visibility = View.VISIBLE

        if (user?.id?.startsWith("guest") == true){
            binding.btnLeave.isEnabled = false
            binding.btnLeave.visibility = View.GONE
        }

        val currentTeam = team
        val teamId = currentTeam?._id
        if (teamId.isNullOrEmpty()) {
            Utilities.toast(activity, getString(R.string.no_team_available))
            return
        }
        val isUserRequested = currentTeam.requested(user?.id, mRealm)
        if (isUserRequested) {
            binding.btnLeave.text = getString(R.string.requested)
            binding.btnLeave.isEnabled = false
        } else {
            binding.btnLeave.text = getString(R.string.join)
            binding.btnLeave.setOnClickListener {
                viewLifecycleOwner.lifecycleScope.launch {
                    val userId = user?.id
                    val userPlanetCode = user?.planetCode
                    val teamType = team?.teamType
                    RealmMyTeam.requestToJoin(teamId, userId, userPlanetCode, teamType)
                    binding.btnLeave.text = getString(R.string.requested)
                    binding.btnLeave.isEnabled = false
                    teamRepository.syncTeamActivities()
                }
            }
        }
    }

    private fun setupMyTeamButtons(user: RealmUserModel?) {
        binding.btnAddDoc.isEnabled = true
        binding.btnAddDoc.visibility = View.VISIBLE
        binding.btnLeave.isEnabled = true
        binding.btnLeave.visibility = View.VISIBLE

        binding.btnLeave.setOnClickListener {
            AlertDialog.Builder(requireContext()).setMessage(R.string.confirm_exit)
                .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                    team?.leave(user, mRealm)
                    Utilities.toast(activity, getString(R.string.left_team))
                    val lastPageId = team?._id?.let { teamLastPage[it] } ?: arguments?.getString("navigateToPage")
                    setupViewPager(false, lastPageId)
                    binding.llActionButtons.visibility = View.GONE
                }.setNegativeButton(R.string.no, null).show()
        }

        binding.btnAddDoc.setOnClickListener {
            MainApplication.showDownload = true
            selectPage(DocumentsPage.id)
            MainApplication.showDownload = false
            MainApplication.listener?.onAddDocument()
        }
    }

    private suspend fun refreshTeamData() {
        if (!isAdded || requireActivity().isFinishing) return

        try {
            val primaryTeamId = requireArguments().getString("id") ?: ""
            val fallbackTeamId = directTeamId ?: ""
            val isMyTeam = requireArguments().getBoolean("isMyTeam", false)

            val updatedTeam = when {
                primaryTeamId.isNotEmpty() -> teamRepository.getTeamByDocumentIdOrTeamId(primaryTeamId)
                fallbackTeamId.isNotEmpty() -> teamRepository.getTeamById(fallbackTeamId)
                else -> null
            }

            if (updatedTeam != null) {
                team = updatedTeam

                // Update arguments and direct variables with new team data
                directTeamName = updatedTeam.name
                directTeamType = updatedTeam.type
                requireArguments().apply {
                    putString("teamName", updatedTeam.name)
                    putString("teamType", updatedTeam.type)
                }

                val lastPageId = team?._id?.let { teamLastPage[it] } ?: arguments?.getString("navigateToPage")
                setupViewPager(isMyTeam, lastPageId)

                binding.title.text = updatedTeam.name
                binding.subtitle.text = updatedTeam.type

                team?._id?.let { id ->
                    if (getJoinedMemberCount(id, mRealm) <= 1 && isMyTeam) {
                        binding.btnLeave.visibility = View.GONE
                    } else {
                        binding.btnLeave.visibility = View.VISIBLE
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    override fun onMemberChanged() {
        _binding ?: return
        _binding?.let { binding ->
            val teamId = team?._id ?: return@let
            val joinedCount = getJoinedMemberCount(teamId, mRealm)
            binding.btnLeave.visibility = if (joinedCount <= 1) {
                View.GONE
            } else {
                View.VISIBLE
            }
        }
    }

    override fun onTeamDetailsUpdated() {
        viewLifecycleOwner.lifecycleScope.launch {
            refreshTeamData()
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupRealtimeSync()
        createTeamLog()
    }

    override fun onNewsItemClick(news: RealmNews?) {}

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun createTeamLog() {
        val userModel = getCurrentUser() ?: return
        val userName = userModel.name
        val userPlanetCode = userModel.planetCode
        val userParentCode = userModel.parentCode
        val teamType = getEffectiveTeamType()

        viewLifecycleOwner.lifecycleScope.launch {
            withContext(kotlinx.coroutines.Dispatchers.IO) {
                teamRepository.logTeamVisit(
                    teamId = getEffectiveTeamId(),
                    userName = userName,
                    userPlanetCode = userPlanetCode,
                    userParentCode = userParentCode,
                    teamType = teamType,
                )
            }
        }
    }

    private fun setupRealtimeSync() {
        realtimeSyncListener = object : BaseRealtimeSyncListener() {
            override fun onTableDataUpdated(update: TableDataUpdate) {
                if (update.table == "teams" && update.shouldRefreshUI) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        refreshTeamData()
                    }
                }
            }
        }
        syncCoordinator.addListener(realtimeSyncListener)
    }

    private fun shouldQueryRealm(teamId: String): Boolean {
        return teamId.isNotEmpty()
    }

    override fun onDestroyView() {
        loadTeamJob?.cancel()
        loadTeamJob = null
        if (::realtimeSyncListener.isInitialized) {
            syncCoordinator.removeListener(realtimeSyncListener)
        }
        super.onDestroyView()
        _binding = null
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        super.onDestroy()
    }

    companion object {
        fun newInstance(
            teamId: String,
            teamName: String,
            teamType: String,
            isMyTeam: Boolean,
            navigateToPage: TeamPageConfig? = null
        ): TeamDetailFragment {
            val fragment = TeamDetailFragment()
            val args = Bundle().apply {
                putString("teamId", teamId)
                putString("teamName", teamName)
                putString("teamType", teamType)
                putBoolean("isMyTeam", isMyTeam)
                navigateToPage?.let { putString("navigateToPage", it.id) }
            }
            fragment.arguments = args
            return fragment
        }
    }
}
=======
package org.ole.planet.myplanet.ui.team


import android.content.DialogInterface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.lifecycle.lifecycleScope
import androidx.viewpager2.widget.ViewPager2
import com.google.android.material.snackbar.Snackbar
import com.google.android.material.tabs.TabLayoutMediator
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.MemberChangeListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.callback.TeamUpdateListener
import org.ole.planet.myplanet.databinding.FragmentTeamDetailBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getJoinedMemberCount
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ApplicantsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.CalendarPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ChatPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.CoursesPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.DocumentsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.FinancesPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.JoinRequestsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.MembersPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.MissionPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.PlanPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ReportsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ResourcesPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.SurveyPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.TasksPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.TeamPage
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class TeamDetailFragment : BaseTeamFragment(), MemberChangeListener, TeamUpdateListener {

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    @Inject
    lateinit var syncManager: SyncManager

    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()
    private lateinit var realtimeSyncListener: BaseRealtimeSyncListener

    private var _binding: FragmentTeamDetailBinding? = null
    private val binding get() = _binding!!
    private var directTeamName: String? = null
    private var directTeamType: String? = null
    private var directTeamId: String? = null
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    lateinit var prefManager: SharedPrefManager
    private val serverUrlMapper = ServerUrlMapper()
    private val teamLastPage = mutableMapOf<String, String>()
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""
    private var pageConfigs: List<TeamPageConfig> = emptyList()
    private var loadTeamJob: Job? = null

    private fun getCurrentUser(): RealmUserModel? {
        return userProfileDbHandler.userModel
    }

    private fun detachCurrentUser(): RealmUserModel? {
        return userProfileDbHandler.getUserModelCopy()
    }

    private fun pageIndexById(pageId: String?): Int? {
        pageId ?: return null
        val idx = pageConfigs.indexOfFirst { it.id == pageId }
        return if (idx >= 0) idx else null
    }

    private fun selectPage(pageId: String?, smoothScroll: Boolean = true) {
        val index = pageIndexById(pageId)
        index?.let {
            binding.viewPager2.setCurrentItem(it, smoothScroll)
        }
    }

    private fun buildPages(isMyTeam: Boolean): List<TeamPageConfig> {
        val isEnterprise = team?.type == "enterprise"
        val pages = mutableListOf<TeamPageConfig>()
        if (isMyTeam || team?.isPublic == true) {
            pages += ChatPage
            pages += if (isEnterprise) MissionPage else PlanPage
            pages += if (isEnterprise) TeamPage else MembersPage
            pages += TasksPage
            pages += CalendarPage
            pages += SurveyPage
            pages += if (isEnterprise) FinancesPage else CoursesPage
            if (isEnterprise) pages += ReportsPage
            pages += if (isEnterprise) DocumentsPage else ResourcesPage
            pages += if (isEnterprise) ApplicantsPage else JoinRequestsPage
        } else {
            pages += if (isEnterprise) MissionPage else PlanPage
            pages += if (isEnterprise) TeamPage else MembersPage
        }
        return pages
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        prefManager = SharedPrefManager(requireContext())
        startTeamSync()
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamDetailBinding.inflate(inflater, container, false)
        directTeamId = requireArguments().getString("teamId")
        directTeamName = requireArguments().getString("teamName")
        directTeamType = requireArguments().getString("teamType")

        val teamId = requireArguments().getString("id" ) ?: ""
        val isMyTeam = requireArguments().getBoolean("isMyTeam", false)
        val user = detachCurrentUser()

        renderPlaceholder()

        loadTeamJob?.cancel()
        loadTeamJob = viewLifecycleOwner.lifecycleScope.launch {
            val resolvedTeam = when {
                shouldQueryRealm(teamId) && teamId.isNotEmpty() -> {
                    teamRepository.getTeamByDocumentIdOrTeamId(teamId)
                }

                else -> {
                    val effectiveTeamId = (directTeamId ?: "").ifEmpty { teamId }
                    if (effectiveTeamId.isNotEmpty()) {
                        teamRepository.getTeamById(effectiveTeamId)
                    } else {
                        null
                    }
                }
            }

            if (!isAdded) {
                return@launch
            }

            if (shouldQueryRealm(teamId) && resolvedTeam == null) {
                Snackbar.make(
                    binding.root,
                    getString(R.string.no_team_available),
                    Snackbar.LENGTH_LONG
                ).show()
                return@launch
            }

            resolvedTeam?.let { team = it }

            setupTeamDetails(isMyTeam, user)
            loadTeamJob = null
        }

        return binding.root
    }

    private fun renderPlaceholder() {
        binding.title.text = directTeamName ?: getString(R.string.loading_teams)
        binding.subtitle.text = directTeamType ?: ""
        binding.btnAddDoc.isEnabled = false
        binding.btnLeave.isEnabled = false
        binding.viewPager2.adapter = null
    }

    private fun startTeamSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && prefManager.isTeamsSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch {
            withContext(kotlinx.coroutines.Dispatchers.IO) {
                updateServerIfNecessary(mapping)
            }
            startSyncManager()
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(requireContext().getString(R.string.syncing_team_data))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        refreshTeamData()
                        prefManager.setTeamsSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null

                        Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG)
                            .setAction("Retry") { startTeamSync() }
                            .show()
                    }
                }
            }
        }, "full", listOf("tasks", "meetups", "team_activities"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun setupTeamDetails(isMyTeam: Boolean, user: RealmUserModel?) {
        binding.root.post {
            if (isAdded && !requireActivity().isFinishing) {
                val targetPageId = arguments?.getString("navigateToPage")
                    ?: team?._id?.let { teamLastPage[it] }
                setupViewPager(isMyTeam, targetPageId)
            }
        }

        binding.title.text = getEffectiveTeamName()
        binding.subtitle.text = getEffectiveTeamType()

        if (!isMyTeam) {
            setupNonMyTeamButtons(user)
        } else {
            setupMyTeamButtons(user)
        }

        team?._id?.let { id ->
            if (getJoinedMemberCount(id, mRealm) <= 1 && isMyTeam) {
                binding.btnLeave.visibility = View.GONE
            }
        }
    }

    private fun setupViewPager(isMyTeam: Boolean, restorePageId: String? = null) {
        pageConfigs = buildPages(isMyTeam)
        binding.viewPager2.apply {
            isSaveEnabled = false
            offscreenPageLimit = 2
            isUserInputEnabled = true
            setPageTransformer { page, position ->
                page.alpha = 1.0f - kotlin.math.abs(position)
            }
        }

        if (binding.viewPager2.id == View.NO_ID) {
            binding.viewPager2.id = View.generateViewId()
        }

        binding.viewPager2.adapter = null
        binding.viewPager2.adapter = TeamPagerAdapter(
            requireActivity(),
            pageConfigs,
            team?._id,
            this,
            this
        )
        binding.tabLayout.tabMode = com.google.android.material.tabs.TabLayout.MODE_SCROLLABLE
        binding.tabLayout.isInlineLabel = true

        TabLayoutMediator(binding.tabLayout, binding.viewPager2) { tab, position ->
            val title = (binding.viewPager2.adapter as TeamPagerAdapter).getPageTitle(position)
            val pageConfig = pageConfigs.getOrNull(position)
            tab.text = title
        }.attach()

        selectPage(restorePageId, false)

        binding.viewPager2.registerOnPageChangeCallback(
            object : ViewPager2.OnPageChangeCallback() {
                override fun onPageSelected(position: Int) {
                    val pageConfig = pageConfigs.getOrNull(position)
                    val pageId = pageConfig?.id
                    team?._id?.let { teamId ->
                        pageId?.let {
                            teamLastPage[teamId] = it
                        }
                    }
                }
            }
        )
    }

    private fun setupNonMyTeamButtons(user: RealmUserModel?) {
        binding.btnAddDoc.isEnabled = false
        binding.btnAddDoc.visibility = View.GONE
        binding.btnLeave.isEnabled = true
        binding.btnLeave.visibility = View.VISIBLE

        if (user?.id?.startsWith("guest") == true){
            binding.btnLeave.isEnabled = false
            binding.btnLeave.visibility = View.GONE
        }

        val currentTeam = team
        val teamId = currentTeam?._id
        if (teamId.isNullOrEmpty()) {
            Utilities.toast(activity, getString(R.string.no_team_available))
            return
        }
        val isUserRequested = currentTeam.requested(user?.id, mRealm)
        if (isUserRequested) {
            binding.btnLeave.text = getString(R.string.requested)
            binding.btnLeave.isEnabled = false
        } else {
            binding.btnLeave.text = getString(R.string.join)
            binding.btnLeave.setOnClickListener {
                viewLifecycleOwner.lifecycleScope.launch {
                    val userId = user?.id
                    val userPlanetCode = user?.planetCode
                    val teamType = team?.teamType
                    RealmMyTeam.requestToJoin(teamId, userId, userPlanetCode, teamType)
                    binding.btnLeave.text = getString(R.string.requested)
                    binding.btnLeave.isEnabled = false
                    teamRepository.syncTeamActivities()
                }
            }
        }
    }

    private fun setupMyTeamButtons(user: RealmUserModel?) {
        binding.btnAddDoc.isEnabled = true
        binding.btnAddDoc.visibility = View.VISIBLE
        binding.btnLeave.isEnabled = true
        binding.btnLeave.visibility = View.VISIBLE

        binding.btnLeave.setOnClickListener {
            AlertDialog.Builder(requireContext()).setMessage(R.string.confirm_exit)
                .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                    team?.leave(user, mRealm)
                    Utilities.toast(activity, getString(R.string.left_team))
                    val lastPageId = team?._id?.let { teamLastPage[it] } ?: arguments?.getString("navigateToPage")
                    setupViewPager(false, lastPageId)
                    binding.llActionButtons.visibility = View.GONE
                }.setNegativeButton(R.string.no, null).show()
        }

        binding.btnAddDoc.setOnClickListener {
            MainApplication.showDownload = true
            selectPage(DocumentsPage.id)
            MainApplication.showDownload = false
            MainApplication.listener?.onAddDocument()
        }
    }

    private suspend fun refreshTeamData() {
        if (!isAdded || requireActivity().isFinishing) return

        try {
            val primaryTeamId = requireArguments().getString("id") ?: ""
            val fallbackTeamId = directTeamId ?: ""
            val isMyTeam = requireArguments().getBoolean("isMyTeam", false)

            val updatedTeam = when {
                primaryTeamId.isNotEmpty() -> teamRepository.getTeamByDocumentIdOrTeamId(primaryTeamId)
                fallbackTeamId.isNotEmpty() -> teamRepository.getTeamById(fallbackTeamId)
                else -> null
            }

            if (updatedTeam != null) {
                team = updatedTeam

                // Update arguments and direct variables with new team data
                directTeamName = updatedTeam.name
                directTeamType = updatedTeam.type
                requireArguments().apply {
                    putString("teamName", updatedTeam.name)
                    putString("teamType", updatedTeam.type)
                }

                val lastPageId = team?._id?.let { teamLastPage[it] } ?: arguments?.getString("navigateToPage")
                setupViewPager(isMyTeam, lastPageId)

                binding.title.text = updatedTeam.name
                binding.subtitle.text = updatedTeam.type

                team?._id?.let { id ->
                    if (getJoinedMemberCount(id, mRealm) <= 1 && isMyTeam) {
                        binding.btnLeave.visibility = View.GONE
                    } else {
                        binding.btnLeave.visibility = View.VISIBLE
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    override fun onMemberChanged() {
        _binding ?: return
        _binding?.let { binding ->
            val teamId = team?._id ?: return@let
            val joinedCount = getJoinedMemberCount(teamId, mRealm)
            binding.btnLeave.visibility = if (joinedCount <= 1) {
                View.GONE
            } else {
                View.VISIBLE
            }
        }
    }

    override fun onTeamDetailsUpdated() {
        viewLifecycleOwner.lifecycleScope.launch {
            refreshTeamData()
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupRealtimeSync()
        createTeamLog()
    }

    override fun onNewsItemClick(news: RealmNews?) {}

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun createTeamLog() {
        val userModel = getCurrentUser() ?: return
        val userName = userModel.name
        val userPlanetCode = userModel.planetCode
        val userParentCode = userModel.parentCode
        val teamType = getEffectiveTeamType()

        viewLifecycleOwner.lifecycleScope.launch {
            withContext(kotlinx.coroutines.Dispatchers.IO) {
                teamRepository.logTeamVisit(
                    teamId = getEffectiveTeamId(),
                    userName = userName,
                    userPlanetCode = userPlanetCode,
                    userParentCode = userParentCode,
                    teamType = teamType,
                )
            }
        }
    }

    private fun setupRealtimeSync() {
        realtimeSyncListener = object : BaseRealtimeSyncListener() {
            override fun onTableDataUpdated(update: TableDataUpdate) {
                if (update.table == "teams" && update.shouldRefreshUI) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        refreshTeamData()
                    }
                }
            }
        }
        syncCoordinator.addListener(realtimeSyncListener)
    }

    private fun shouldQueryRealm(teamId: String): Boolean {
        return teamId.isNotEmpty()
    }

    override fun onDestroyView() {
        loadTeamJob?.cancel()
        loadTeamJob = null
        if (::realtimeSyncListener.isInitialized) {
            syncCoordinator.removeListener(realtimeSyncListener)
        }
        super.onDestroyView()
        _binding = null
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        super.onDestroy()
    }

    companion object {
        fun newInstance(
            teamId: String,
            teamName: String,
            teamType: String,
            isMyTeam: Boolean,
            navigateToPage: TeamPageConfig? = null
        ): TeamDetailFragment {
            val fragment = TeamDetailFragment()
            val args = Bundle().apply {
                putString("teamId", teamId)
                putString("teamName", teamName)
                putString("teamType", teamType)
                putBoolean("isMyTeam", isMyTeam)
                navigateToPage?.let { putString("navigateToPage", it.id) }
            }
            fragment.arguments = args
            return fragment
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamCourse/AdapterTeamCourse.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamCourse

import android.content.Context
import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import io.realm.Realm
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.RowTeamResourceBinding
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getTeamCreator
import org.ole.planet.myplanet.ui.courses.TakeCourseFragment
import org.ole.planet.myplanet.ui.team.teamCourse.AdapterTeamCourse.ViewHolderTeamCourse

class AdapterTeamCourse(
    private val context: Context,
    private var list: MutableList<RealmMyCourse>,
    mRealm: Realm?,
    teamId: String?,
    settings: SharedPreferences
) : RecyclerView.Adapter<ViewHolderTeamCourse>() {
    private var listener: OnHomeItemClickListener? = null
    private val settings: SharedPreferences
    private val teamCreator: String

    init {
        if (context is OnHomeItemClickListener) {
            listener = context
        }
        this.settings = settings
        teamCreator = getTeamCreator(teamId, mRealm)
    }

    fun getList(): List<RealmMyCourse> = list

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderTeamCourse {
        val binding = RowTeamResourceBinding.inflate(LayoutInflater.from(context), parent, false)
        return ViewHolderTeamCourse(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderTeamCourse, position: Int) {
        val course = list[position]
        holder.binding.tvTitle.text = course.courseTitle
        holder.binding.tvDescription.text = course.description
        holder.binding.root.setOnClickListener {
            if (listener != null) {
                val b = Bundle()
                b.putString("id", course.courseId)
                listener?.openCallFragment(TakeCourseFragment.newInstance(b))
            }
        }
        if (!settings.getString("userId", "--").equals(teamCreator, ignoreCase = true)) {
            holder.binding.ivRemove.visibility = View.GONE
        }
    }

    override fun getItemCount(): Int {
        return list.size
    }

    class ViewHolderTeamCourse(val binding: RowTeamResourceBinding) :
        RecyclerView.ViewHolder(binding.root)
}
=======
package org.ole.planet.myplanet.ui.team.teamCourse


import android.content.Context
import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import io.realm.Realm
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.RowTeamResourceBinding
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getTeamCreator
import org.ole.planet.myplanet.ui.courses.TakeCourseFragment
import org.ole.planet.myplanet.ui.team.teamCourse.AdapterTeamCourse.ViewHolderTeamCourse

class AdapterTeamCourse(
    private val context: Context,
    private var list: MutableList<RealmMyCourse>,
    mRealm: Realm?,
    teamId: String?,
    settings: SharedPreferences
) : RecyclerView.Adapter<ViewHolderTeamCourse>() {
    private var listener: OnHomeItemClickListener? = null
    private val settings: SharedPreferences
    private val teamCreator: String

    init {
        if (context is OnHomeItemClickListener) {
            listener = context
        }
        this.settings = settings
        teamCreator = getTeamCreator(teamId, mRealm)
    }

    fun getList(): List<RealmMyCourse> = list

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderTeamCourse {
        val binding = RowTeamResourceBinding.inflate(LayoutInflater.from(context), parent, false)
        return ViewHolderTeamCourse(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderTeamCourse, position: Int) {
        val course = list[position]
        holder.binding.tvTitle.text = course.courseTitle
        holder.binding.tvDescription.text = course.description
        holder.binding.root.setOnClickListener {
            if (listener != null) {
                val b = Bundle()
                b.putString("id", course.courseId)
                listener?.openCallFragment(TakeCourseFragment.newInstance(b))
            }
        }
        if (!settings.getString("userId", "--").equals(teamCreator, ignoreCase = true)) {
            holder.binding.ivRemove.visibility = View.GONE
        }
    }

    override fun getItemCount(): Int {
        return list.size
    }

    class ViewHolderTeamCourse(val binding: RowTeamResourceBinding) :
        RecyclerView.ViewHolder(binding.root)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamCourse/TeamCourseFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamCourse

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.LinearLayoutManager
import org.ole.planet.myplanet.databinding.FragmentTeamCourseBinding
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.ui.team.BaseTeamFragment

class TeamCourseFragment : BaseTeamFragment() {
    private var _binding: FragmentTeamCourseBinding? = null
    private val binding get() = _binding!!
    private var adapterTeamCourse: AdapterTeamCourse? = null

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamCourseBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupCoursesList()
    }

    private fun setupCoursesList() {
        val courses = mRealm.where(RealmMyCourse::class.java).`in`("id", team?.courses?.toTypedArray<String>()).findAll()
        adapterTeamCourse = settings?.let { AdapterTeamCourse(requireActivity(), courses.toMutableList(), mRealm, teamId, it) }
        binding.rvCourse.layoutManager = LinearLayoutManager(activity)
        binding.rvCourse.adapter = adapterTeamCourse
        adapterTeamCourse?.let {
            showNoData(binding.tvNodata, it.itemCount, "teamCourses")
        }
    }
    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.team.teamCourse


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.LinearLayoutManager
import org.ole.planet.myplanet.databinding.FragmentTeamCourseBinding
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.ui.team.BaseTeamFragment

class TeamCourseFragment : BaseTeamFragment() {
    private var _binding: FragmentTeamCourseBinding? = null
    private val binding get() = _binding!!
    private var adapterTeamCourse: AdapterTeamCourse? = null

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamCourseBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupCoursesList()
    }

    private fun setupCoursesList() {
        val courses = mRealm.where(RealmMyCourse::class.java).`in`("id", team?.courses?.toTypedArray<String>()).findAll()
        adapterTeamCourse = settings?.let { AdapterTeamCourse(requireActivity(), courses.toMutableList(), mRealm, teamId, it) }
        binding.rvCourse.layoutManager = LinearLayoutManager(activity)
        binding.rvCourse.adapter = adapterTeamCourse
        adapterTeamCourse?.let {
            showNoData(binding.tvNodata, it.itemCount, "teamCourses")
        }
    }
    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamTask/TeamTaskFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamTask

import android.app.DatePickerDialog
import android.app.TimePickerDialog
import android.content.DialogInterface
import android.graphics.Typeface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.DatePicker
import android.widget.TextView
import android.widget.TimePicker
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.core.view.isVisible
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import com.nex3z.togglebuttongroup.SingleSelectToggleGroup
import dagger.hilt.android.AndroidEntryPoint
import java.util.Calendar
import java.util.Date
import java.util.UUID
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AlertTaskBinding
import org.ole.planet.myplanet.databinding.AlertUsersSpinnerBinding
import org.ole.planet.myplanet.databinding.FragmentTeamTaskBinding
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getJoinedMember
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.myhealth.UserListArrayAdapter
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.ui.team.teamTask.AdapterTask.OnCompletedListener
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.TimeUtils.formatDateTZ
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class TeamTaskFragment : BaseTeamFragment(), OnCompletedListener {
    private var _binding: FragmentTeamTaskBinding? = null
    private val binding get() = _binding!!
    private var deadline: Calendar? = null
    private var datePicker: TextView? = null
    var list: List<RealmTeamTask> = emptyList()
    private var currentTab = R.id.btn_all

    private lateinit var adapterTask: AdapterTask
    var listener = DatePickerDialog.OnDateSetListener { _: DatePicker?, year: Int, monthOfYear: Int, dayOfMonth: Int ->
            deadline = Calendar.getInstance()
            deadline?.set(Calendar.YEAR, year)
            deadline?.set(Calendar.MONTH, monthOfYear)
            deadline?.set(Calendar.DAY_OF_MONTH, dayOfMonth)
            if (datePicker != null) {
                datePicker?.text = deadline?.timeInMillis?.let { formatDateTZ(it) }
            }
            timePicker()
        }

    private fun timePicker() {
        val timePickerDialog = TimePickerDialog(activity, { _: TimePicker?, hourOfDay: Int, minute: Int ->
            deadline?.set(Calendar.HOUR_OF_DAY, hourOfDay)
            deadline?.set(Calendar.MINUTE, minute)
            if (datePicker != null) {
                datePicker?.text = deadline?.timeInMillis?.let {
                    TimeUtils.getFormattedDateWithTime(it)
                }
            }
        }, deadline!![Calendar.HOUR_OF_DAY], deadline!![Calendar.MINUTE], true)
        timePickerDialog.show()
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentTeamTaskBinding.inflate(inflater, container, false)
        binding.fab.isVisible = false
        binding.fab.setOnClickListener { showTaskAlert(null) }
        return binding.root
    }

    private fun showTaskAlert(t: RealmTeamTask?) {
        val alertTaskBinding = AlertTaskBinding.inflate(layoutInflater)
        datePicker = alertTaskBinding.tvPick
        var selectedAssignee: RealmUserModel? = null

        if (t != null) {
            alertTaskBinding.etTask.setText(t.title)
            alertTaskBinding.etDescription.setText(t.description)
            datePicker?.text = formatDate(t.deadline)
            deadline = Calendar.getInstance()
            deadline?.time = Date(t.deadline)

            if (!t.assignee.isNullOrBlank()) {
                val assigneeUser = mRealm.where(RealmUserModel::class.java)
                    .equalTo("id", t.assignee)
                    .findFirst()
                if (assigneeUser != null) {
                    selectedAssignee = assigneeUser
                    val displayName = assigneeUser.getFullName().ifBlank {
                        assigneeUser.name ?: getString(R.string.no_assignee)
                    }
                    alertTaskBinding.tvAssignMember.text = displayName
                    alertTaskBinding.tvAssignMember.setTextColor(requireContext().getColor(R.color.daynight_textColor))
                }
            }
        }

        val myCalendar = Calendar.getInstance()
        datePicker?.setOnClickListener {
            val datePickerDialog = DatePickerDialog(requireContext(), listener, myCalendar[Calendar.YEAR], myCalendar[Calendar.MONTH], myCalendar[Calendar.DAY_OF_MONTH])
            datePickerDialog.datePicker.minDate = myCalendar.timeInMillis
            datePickerDialog.show()
        }

        // Handle member assignment
        alertTaskBinding.tvAssignMember.setOnClickListener {
            val userList: List<RealmUserModel> = getJoinedMember(teamId, mRealm)
            val filteredUserList = userList.filter { user -> user.getFullName().isNotBlank() || !user.name.isNullOrBlank() }

            if (filteredUserList.isEmpty()) {
                Toast.makeText(context, R.string.no_members_task, Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }

            val alertUsersSpinnerBinding = AlertUsersSpinnerBinding.inflate(LayoutInflater.from(requireActivity()))
            val adapter: ArrayAdapter<RealmUserModel> = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, filteredUserList)
            alertUsersSpinnerBinding.spnUser.adapter = adapter

            AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
                .setTitle(R.string.select_member)
                .setView(alertUsersSpinnerBinding.root)
                .setCancelable(false)
                .setPositiveButton(R.string.ok) { _: DialogInterface?, _: Int ->
                    val selectedItem = alertUsersSpinnerBinding.spnUser.selectedItem
                    if (selectedItem != null) {
                        selectedAssignee = selectedItem as RealmUserModel
                        val displayName = selectedAssignee.getFullName().ifBlank {
                            selectedAssignee.name ?: getString(R.string.no_assignee)
                        }
                        alertTaskBinding.tvAssignMember.text = displayName
                        alertTaskBinding.tvAssignMember.setTextColor(requireContext().getColor(R.color.daynight_textColor))
                    }
                }
                .setNegativeButton(R.string.cancel) { dialog: DialogInterface, _: Int ->
                    dialog.dismiss()
                }
                .show()
        }

        val titleView = TextView(requireActivity()).apply {
            text = getString(R.string.add_task)
            setTextColor(context.getColor(R.color.daynight_textColor))
            setPadding(75, 50, 0, 0)
            textSize = 24f
            typeface = Typeface.DEFAULT_BOLD
        }
        val builder = AlertDialog.Builder(requireActivity()).setCustomTitle(titleView)
            .setView(alertTaskBinding.root)
            .setPositiveButton(R.string.save, null)
            .setNegativeButton(getString(R.string.cancel), null)

        val alertDialog = builder.create()
        alertDialog.show()

        alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener {
            val task = alertTaskBinding.etTask.text.toString()
            val desc = alertTaskBinding.etDescription.text.toString()
            if (task.isEmpty()) {
                Utilities.toast(activity, getString(R.string.task_title_is_required))
            } else if (deadline == null) {
                Utilities.toast(activity, getString(R.string.deadline_is_required))
            } else {
                createOrUpdateTask(task, desc, t, selectedAssignee?.id)
                alertDialog.dismiss()
            }
        }
        alertDialog.window?.setBackgroundDrawableResource(R.color.card_bg)
    }

    private fun createOrUpdateTask(task: String, desc: String, teamTask: RealmTeamTask?, assigneeId: String? = null) {
        val isCreate = teamTask == null
        val realmTeamTask = teamTask?.let { mRealm.copyFromRealm(it) } ?: RealmTeamTask().apply {
            id = UUID.randomUUID().toString()
        }
        realmTeamTask.title = task
        realmTeamTask.description = desc
        realmTeamTask.deadline = deadline?.timeInMillis!!
        realmTeamTask.teamId = teamId
        realmTeamTask.assignee = assigneeId
        realmTeamTask.isUpdated = true
        lifecycleScope.launch {
            teamRepository.upsertTask(realmTeamTask)

            if (!mRealm.isClosed) {
                mRealm.refresh()
            }

            if (binding.rvTask.adapter != null) {
                showNoData(binding.tvNodata, binding.rvTask.adapter?.itemCount, "tasks")
            }
            updateTasks()
            Utilities.toast(
                activity,
                String.format(
                    getString(R.string.task_s_successfully),
                    if (isCreate) getString(R.string.added) else getString(R.string.updated)
                )
            )
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.rvTask.layoutManager = LinearLayoutManager(activity)
        adapterTask = AdapterTask(requireContext(), !isMemberFlow.value, viewLifecycleOwner.lifecycleScope, userRepository)
        adapterTask.setListener(this)
        binding.rvTask.adapter = adapterTask
        binding.taskToggle.setOnCheckedChangeListener { _: SingleSelectToggleGroup?, checkedId: Int ->
            currentTab = checkedId
            updateTasks()
        }

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                launch {
                    isMemberFlow.collectLatest { isMember ->
                        binding.fab.isVisible = isMember
                        adapterTask.nonTeamMember = !isMember
                        updateTasks()
                    }
                }
                launch {
                    teamRepository.getTasksByTeamId(teamId).collect { tasks ->
                        list = tasks
                        updateTasks()
                    }
                }
            }
        }
    }

    private fun allTasks(): List<RealmTeamTask> {
        return list.sortedWith(compareBy<RealmTeamTask> { it.completed }.thenByDescending { it.deadline })
    }

    private fun completedTasks(): List<RealmTeamTask> {
        return list.filter { it.completed }.sortedByDescending { it.deadline }
    }

    private fun myTasks(): List<RealmTeamTask> {
        return list.filter { !it.completed && it.assignee == user?.id }.sortedByDescending { it.deadline }
    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun updateTasks() {
        if (isAdded) {
            val taskList = when (currentTab) {
                R.id.btn_my -> myTasks()
                R.id.btn_completed -> completedTasks()
                else -> allTasks()
            }
            adapterTask.submitList(taskList)
            showNoData(binding.tvNodata, taskList.size, "tasks")
        }
    }

    override fun onCheckChange(realmTeamTask: RealmTeamTask?, completed: Boolean) {
        val taskId = realmTeamTask?.id ?: return
        viewLifecycleOwner.lifecycleScope.launch {
            teamRepository.setTaskCompletion(taskId, completed)

            if (!mRealm.isClosed) {
                mRealm.refresh()
            }

            updateTasks()
        }
    }

    override fun onEdit(task: RealmTeamTask?) {
        showTaskAlert(task)
    }

    override fun onDelete(task: RealmTeamTask?) {
        val taskId = task?.id ?: return
        viewLifecycleOwner.lifecycleScope.launch {
            teamRepository.deleteTask(taskId)

            if (!mRealm.isClosed) {
                mRealm.refresh()
            }

            Utilities.toast(activity, getString(R.string.task_deleted_successfully))
            updateTasks()
            showNoData(binding.tvNodata, binding.rvTask.adapter?.itemCount, "tasks")
        }
    }

    override fun onClickMore(realmTeamTask: RealmTeamTask?) {
        if (realmTeamTask?.completed == true) {
            Toast.makeText(context, R.string.cannot_assign_completed_task, Toast.LENGTH_SHORT).show()
            return
        }
        val alertUsersSpinnerBinding = AlertUsersSpinnerBinding.inflate(LayoutInflater.from(requireActivity()))
        val userList: List<RealmUserModel> = getJoinedMember(teamId, mRealm)
        val filteredUserList = userList.filter { user -> user.getFullName().isNotBlank() || !user.name.isNullOrBlank() }
        if (filteredUserList.isEmpty()) {
            Toast.makeText(context, R.string.no_members_task, Toast.LENGTH_SHORT).show()
            return
        }
        val adapter: ArrayAdapter<RealmUserModel> = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, filteredUserList)
        alertUsersSpinnerBinding.spnUser.adapter = adapter
        AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
            .setTitle(R.string.select_member)
            .setView(alertUsersSpinnerBinding.root).setCancelable(false)
            .setPositiveButton(R.string.ok) { _: DialogInterface?, _: Int ->
                val selectedItem = alertUsersSpinnerBinding.spnUser.selectedItem
                if (selectedItem == null) {
                    Toast.makeText(context, R.string.no_member_selected, Toast.LENGTH_SHORT).show()
                    return@setPositiveButton
                }
                val user = selectedItem as RealmUserModel
                val taskId = realmTeamTask?.id
                if (taskId.isNullOrBlank()) {
                    Toast.makeText(context, R.string.no_tasks, Toast.LENGTH_SHORT).show()
                    return@setPositiveButton
                }
                viewLifecycleOwner.lifecycleScope.launch {
                    teamRepository.assignTask(taskId, user.id)
                    Utilities.toast(activity, getString(R.string.assign_task_to) + " " + user.name)
                    adapter.notifyDataSetChanged()
                    updateTasks()
                }
            }
            .setNegativeButton(R.string.cancel) { dialog: DialogInterface, _: Int ->
                dialog.dismiss()
            }
            .show()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        binding.rvTask.adapter = null
        _binding = null
    }
}
=======
package org.ole.planet.myplanet.ui.team.teamTask


import android.app.DatePickerDialog
import android.app.TimePickerDialog
import android.content.DialogInterface
import android.graphics.Typeface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.DatePicker
import android.widget.TextView
import android.widget.TimePicker
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.core.view.isVisible
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import com.nex3z.togglebuttongroup.SingleSelectToggleGroup
import dagger.hilt.android.AndroidEntryPoint
import java.util.Calendar
import java.util.Date
import java.util.UUID
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AlertTaskBinding
import org.ole.planet.myplanet.databinding.AlertUsersSpinnerBinding
import org.ole.planet.myplanet.databinding.FragmentTeamTaskBinding
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getJoinedMember
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.myhealth.UserListArrayAdapter
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.ui.team.teamTask.AdapterTask.OnCompletedListener
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.TimeUtils.formatDateTZ
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class TeamTaskFragment : BaseTeamFragment(), OnCompletedListener {
    private var _binding: FragmentTeamTaskBinding? = null
    private val binding get() = _binding!!
    private var deadline: Calendar? = null
    private var datePicker: TextView? = null
    var list: List<RealmTeamTask> = emptyList()
    private var currentTab = R.id.btn_all

    private lateinit var adapterTask: AdapterTask
    var listener = DatePickerDialog.OnDateSetListener { _: DatePicker?, year: Int, monthOfYear: Int, dayOfMonth: Int ->
            deadline = Calendar.getInstance()
            deadline?.set(Calendar.YEAR, year)
            deadline?.set(Calendar.MONTH, monthOfYear)
            deadline?.set(Calendar.DAY_OF_MONTH, dayOfMonth)
            if (datePicker != null) {
                datePicker?.text = deadline?.timeInMillis?.let { formatDateTZ(it) }
            }
            timePicker()
        }

    private fun timePicker() {
        val timePickerDialog = TimePickerDialog(activity, { _: TimePicker?, hourOfDay: Int, minute: Int ->
            deadline?.set(Calendar.HOUR_OF_DAY, hourOfDay)
            deadline?.set(Calendar.MINUTE, minute)
            if (datePicker != null) {
                datePicker?.text = deadline?.timeInMillis?.let {
                    TimeUtils.getFormattedDateWithTime(it)
                }
            }
        }, deadline!![Calendar.HOUR_OF_DAY], deadline!![Calendar.MINUTE], true)
        timePickerDialog.show()
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentTeamTaskBinding.inflate(inflater, container, false)
        binding.fab.isVisible = false
        binding.fab.setOnClickListener { showTaskAlert(null) }
        return binding.root
    }

    private fun showTaskAlert(t: RealmTeamTask?) {
        val alertTaskBinding = AlertTaskBinding.inflate(layoutInflater)
        datePicker = alertTaskBinding.tvPick
        var selectedAssignee: RealmUserModel? = null

        if (t != null) {
            alertTaskBinding.etTask.setText(t.title)
            alertTaskBinding.etDescription.setText(t.description)
            datePicker?.text = formatDate(t.deadline)
            deadline = Calendar.getInstance()
            deadline?.time = Date(t.deadline)

            if (!t.assignee.isNullOrBlank()) {
                val assigneeUser = mRealm.where(RealmUserModel::class.java)
                    .equalTo("id", t.assignee)
                    .findFirst()
                if (assigneeUser != null) {
                    selectedAssignee = assigneeUser
                    val displayName = assigneeUser.getFullName().ifBlank {
                        assigneeUser.name ?: getString(R.string.no_assignee)
                    }
                    alertTaskBinding.tvAssignMember.text = displayName
                    alertTaskBinding.tvAssignMember.setTextColor(requireContext().getColor(R.color.daynight_textColor))
                }
            }
        }

        val myCalendar = Calendar.getInstance()
        datePicker?.setOnClickListener {
            val datePickerDialog = DatePickerDialog(requireContext(), listener, myCalendar[Calendar.YEAR], myCalendar[Calendar.MONTH], myCalendar[Calendar.DAY_OF_MONTH])
            datePickerDialog.datePicker.minDate = myCalendar.timeInMillis
            datePickerDialog.show()
        }

        // Handle member assignment
        alertTaskBinding.tvAssignMember.setOnClickListener {
            val userList: List<RealmUserModel> = getJoinedMember(teamId, mRealm)
            val filteredUserList = userList.filter { user -> user.getFullName().isNotBlank() || !user.name.isNullOrBlank() }

            if (filteredUserList.isEmpty()) {
                Toast.makeText(context, R.string.no_members_task, Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }

            val alertUsersSpinnerBinding = AlertUsersSpinnerBinding.inflate(LayoutInflater.from(requireActivity()))
            val adapter: ArrayAdapter<RealmUserModel> = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, filteredUserList)
            alertUsersSpinnerBinding.spnUser.adapter = adapter

            AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
                .setTitle(R.string.select_member)
                .setView(alertUsersSpinnerBinding.root)
                .setCancelable(false)
                .setPositiveButton(R.string.ok) { _: DialogInterface?, _: Int ->
                    val selectedItem = alertUsersSpinnerBinding.spnUser.selectedItem
                    if (selectedItem != null) {
                        selectedAssignee = selectedItem as RealmUserModel
                        val displayName = selectedAssignee.getFullName().ifBlank {
                            selectedAssignee.name ?: getString(R.string.no_assignee)
                        }
                        alertTaskBinding.tvAssignMember.text = displayName
                        alertTaskBinding.tvAssignMember.setTextColor(requireContext().getColor(R.color.daynight_textColor))
                    }
                }
                .setNegativeButton(R.string.cancel) { dialog: DialogInterface, _: Int ->
                    dialog.dismiss()
                }
                .show()
        }

        val titleView = TextView(requireActivity()).apply {
            text = getString(R.string.add_task)
            setTextColor(context.getColor(R.color.daynight_textColor))
            setPadding(75, 50, 0, 0)
            textSize = 24f
            typeface = Typeface.DEFAULT_BOLD
        }
        val builder = AlertDialog.Builder(requireActivity()).setCustomTitle(titleView)
            .setView(alertTaskBinding.root)
            .setPositiveButton(R.string.save, null)
            .setNegativeButton(getString(R.string.cancel), null)

        val alertDialog = builder.create()
        alertDialog.show()

        alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener {
            val task = alertTaskBinding.etTask.text.toString()
            val desc = alertTaskBinding.etDescription.text.toString()
            if (task.isEmpty()) {
                Utilities.toast(activity, getString(R.string.task_title_is_required))
            } else if (deadline == null) {
                Utilities.toast(activity, getString(R.string.deadline_is_required))
            } else {
                createOrUpdateTask(task, desc, t, selectedAssignee?.id)
                alertDialog.dismiss()
            }
        }
        alertDialog.window?.setBackgroundDrawableResource(R.color.card_bg)
    }

    private fun createOrUpdateTask(task: String, desc: String, teamTask: RealmTeamTask?, assigneeId: String? = null) {
        val isCreate = teamTask == null
        val realmTeamTask = teamTask?.let { mRealm.copyFromRealm(it) } ?: RealmTeamTask().apply {
            id = UUID.randomUUID().toString()
        }
        realmTeamTask.title = task
        realmTeamTask.description = desc
        realmTeamTask.deadline = deadline?.timeInMillis!!
        realmTeamTask.teamId = teamId
        realmTeamTask.assignee = assigneeId
        realmTeamTask.isUpdated = true
        lifecycleScope.launch {
            teamRepository.upsertTask(realmTeamTask)

            if (!mRealm.isClosed) {
                mRealm.refresh()
            }

            if (binding.rvTask.adapter != null) {
                showNoData(binding.tvNodata, binding.rvTask.adapter?.itemCount, "tasks")
            }
            updateTasks()
            Utilities.toast(
                activity,
                String.format(
                    getString(R.string.task_s_successfully),
                    if (isCreate) getString(R.string.added) else getString(R.string.updated)
                )
            )
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.rvTask.layoutManager = LinearLayoutManager(activity)
        adapterTask = AdapterTask(requireContext(), !isMemberFlow.value, viewLifecycleOwner.lifecycleScope, userRepository)
        adapterTask.setListener(this)
        binding.rvTask.adapter = adapterTask
        binding.taskToggle.setOnCheckedChangeListener { _: SingleSelectToggleGroup?, checkedId: Int ->
            currentTab = checkedId
            updateTasks()
        }

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                launch {
                    isMemberFlow.collectLatest { isMember ->
                        binding.fab.isVisible = isMember
                        adapterTask.nonTeamMember = !isMember
                        updateTasks()
                    }
                }
                launch {
                    teamRepository.getTasksByTeamId(teamId).collect { tasks ->
                        list = tasks
                        updateTasks()
                    }
                }
            }
        }
    }

    private fun allTasks(): List<RealmTeamTask> {
        return list.sortedWith(compareBy<RealmTeamTask> { it.completed }.thenByDescending { it.deadline })
    }

    private fun completedTasks(): List<RealmTeamTask> {
        return list.filter { it.completed }.sortedByDescending { it.deadline }
    }

    private fun myTasks(): List<RealmTeamTask> {
        return list.filter { !it.completed && it.assignee == user?.id }.sortedByDescending { it.deadline }
    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun updateTasks() {
        if (isAdded) {
            val taskList = when (currentTab) {
                R.id.btn_my -> myTasks()
                R.id.btn_completed -> completedTasks()
                else -> allTasks()
            }
            adapterTask.submitList(taskList)
            showNoData(binding.tvNodata, taskList.size, "tasks")
        }
    }

    override fun onCheckChange(realmTeamTask: RealmTeamTask?, completed: Boolean) {
        val taskId = realmTeamTask?.id ?: return
        viewLifecycleOwner.lifecycleScope.launch {
            teamRepository.setTaskCompletion(taskId, completed)

            if (!mRealm.isClosed) {
                mRealm.refresh()
            }

            updateTasks()
        }
    }

    override fun onEdit(task: RealmTeamTask?) {
        showTaskAlert(task)
    }

    override fun onDelete(task: RealmTeamTask?) {
        val taskId = task?.id ?: return
        viewLifecycleOwner.lifecycleScope.launch {
            teamRepository.deleteTask(taskId)

            if (!mRealm.isClosed) {
                mRealm.refresh()
            }

            Utilities.toast(activity, getString(R.string.task_deleted_successfully))
            updateTasks()
            showNoData(binding.tvNodata, binding.rvTask.adapter?.itemCount, "tasks")
        }
    }

    override fun onClickMore(realmTeamTask: RealmTeamTask?) {
        if (realmTeamTask?.completed == true) {
            Toast.makeText(context, R.string.cannot_assign_completed_task, Toast.LENGTH_SHORT).show()
            return
        }
        val alertUsersSpinnerBinding = AlertUsersSpinnerBinding.inflate(LayoutInflater.from(requireActivity()))
        val userList: List<RealmUserModel> = getJoinedMember(teamId, mRealm)
        val filteredUserList = userList.filter { user -> user.getFullName().isNotBlank() || !user.name.isNullOrBlank() }
        if (filteredUserList.isEmpty()) {
            Toast.makeText(context, R.string.no_members_task, Toast.LENGTH_SHORT).show()
            return
        }
        val adapter: ArrayAdapter<RealmUserModel> = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, filteredUserList)
        alertUsersSpinnerBinding.spnUser.adapter = adapter
        AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
            .setTitle(R.string.select_member)
            .setView(alertUsersSpinnerBinding.root).setCancelable(false)
            .setPositiveButton(R.string.ok) { _: DialogInterface?, _: Int ->
                val selectedItem = alertUsersSpinnerBinding.spnUser.selectedItem
                if (selectedItem == null) {
                    Toast.makeText(context, R.string.no_member_selected, Toast.LENGTH_SHORT).show()
                    return@setPositiveButton
                }
                val user = selectedItem as RealmUserModel
                val taskId = realmTeamTask?.id
                if (taskId.isNullOrBlank()) {
                    Toast.makeText(context, R.string.no_tasks, Toast.LENGTH_SHORT).show()
                    return@setPositiveButton
                }
                viewLifecycleOwner.lifecycleScope.launch {
                    teamRepository.assignTask(taskId, user.id)
                    Utilities.toast(activity, getString(R.string.assign_task_to) + " " + user.name)
                    adapter.notifyDataSetChanged()
                    updateTasks()
                }
            }
            .setNegativeButton(R.string.cancel) { dialog: DialogInterface, _: Int ->
                dialog.dismiss()
            }
            .show()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        binding.rvTask.adapter = null
        _binding = null
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamTask/AdapterTask.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamTask

import android.app.AlertDialog
import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CompoundButton
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowTaskBinding
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.ui.team.teamTask.AdapterTask.ViewHolderTask
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate

class AdapterTask(
    private val context: Context,
    var nonTeamMember: Boolean,
    private val coroutineScope: CoroutineScope,
    private val userRepository: UserRepository
) : ListAdapter<RealmTeamTask, ViewHolderTask>(diffCallback) {
    private val assigneeCache: MutableMap<String, String> = mutableMapOf()
    private var listener: OnCompletedListener? = null
    fun setListener(listener: OnCompletedListener?) {
        this.listener = listener
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderTask {
        val binding = RowTaskBinding.inflate(LayoutInflater.from(context), parent, false)
        return ViewHolderTask(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderTask, position: Int) {
        holder.assigneeJob?.cancel()
        val it = getItem(position)
        val binding = holder.binding
        binding.checkbox.setOnCheckedChangeListener(null)
        binding.checkbox.text = it.title
        binding.checkbox.isChecked = it.completed
        if (!it.completed) {
            binding.deadline.text =
                context.getString(R.string.deadline_colon, formatDate(it.deadline))
        } else {
            binding.deadline.text = context.getString(
                R.string.two_strings,
                context.getString(R.string.deadline_colon, formatDate(it.deadline)),
                context.getString(R.string.completed_colon, formatDate(it.deadline))
            )
        }
        holder.assigneeJob = showAssignee(binding, it)
        binding.icMore.setOnClickListener {
            listener?.onClickMore(getItem(position))
        }
        binding.editTask.setOnClickListener {
            listener?.onEdit(getItem(position))
        }
        binding.deleteTask.setOnClickListener {
            listener?.onDelete(getItem(position))
        }
        holder.itemView.setOnClickListener {
            val alertDialog = AlertDialog.Builder(context, R.style.AlertDialogTheme)
                .setTitle(getItem(position).title)
                .setMessage(getItem(position).description)
                .setNegativeButton("Cancel") { dialog, _ ->
                    dialog.dismiss()
                }.create()

            alertDialog.show()
        }
        if (nonTeamMember) {
            binding.editTask.visibility = View.GONE
            binding.deleteTask.visibility = View.GONE
            binding.icMore.visibility = View.GONE
            binding.checkbox.isClickable = false
            binding.checkbox.isFocusable = false
        } else {
            binding.checkbox.setOnCheckedChangeListener { _: CompoundButton?, b: Boolean ->
                listener?.onCheckChange(it, b)
            }
        }
    }

    private fun showAssignee(binding: RowTaskBinding, realmTeamTask: RealmTeamTask): Job? {
        val assigneeId = realmTeamTask.assignee
        if (assigneeId.isNullOrEmpty()) {
            binding.assignee.setText(R.string.no_assignee)
            return null
        }

        assigneeCache[assigneeId]?.let {
            binding.assignee.text = context.getString(R.string.assigned_to_colon, it)
            return null
        }

        return coroutineScope.launch(Dispatchers.IO) {
            val user = userRepository.getUserById(assigneeId)
            withContext(Dispatchers.Main) {
                val name = user?.name
                if (name != null) {
                    assigneeCache[assigneeId] = name
                    binding.assignee.text = context.getString(R.string.assigned_to_colon, name)
                } else {
                    binding.assignee.setText(R.string.no_assignee)
                }
            }
        }
    }

    interface OnCompletedListener {
        fun onCheckChange(realmTeamTask: RealmTeamTask?, b: Boolean)
        fun onEdit(task: RealmTeamTask?)
        fun onDelete(task: RealmTeamTask?)
        fun onClickMore(realmTeamTask: RealmTeamTask?)
    }

    class ViewHolderTask(val binding: RowTaskBinding) : RecyclerView.ViewHolder(binding.root) {
        var assigneeJob: Job? = null
    }

    companion object {
        val diffCallback = DiffUtils.itemCallback<RealmTeamTask>(
            areItemsTheSame = { old, new -> old.id == new.id },
            areContentsTheSame = { old, new -> old == new }
        )
    }
}
=======
package org.ole.planet.myplanet.ui.team.teamTask


import android.app.AlertDialog
import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CompoundButton
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowTaskBinding
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.ui.team.teamTask.AdapterTask.ViewHolderTask
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate

class AdapterTask(
    private val context: Context,
    var nonTeamMember: Boolean,
    private val coroutineScope: CoroutineScope,
    private val userRepository: UserRepository
) : ListAdapter<RealmTeamTask, ViewHolderTask>(diffCallback) {
    private val assigneeCache: MutableMap<String, String> = mutableMapOf()
    private var listener: OnCompletedListener? = null
    fun setListener(listener: OnCompletedListener?) {
        this.listener = listener
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderTask {
        val binding = RowTaskBinding.inflate(LayoutInflater.from(context), parent, false)
        return ViewHolderTask(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderTask, position: Int) {
        holder.assigneeJob?.cancel()
        val it = getItem(position)
        val binding = holder.binding
        binding.checkbox.setOnCheckedChangeListener(null)
        binding.checkbox.text = it.title
        binding.checkbox.isChecked = it.completed
        if (!it.completed) {
            binding.deadline.text =
                context.getString(R.string.deadline_colon, formatDate(it.deadline))
        } else {
            binding.deadline.text = context.getString(
                R.string.two_strings,
                context.getString(R.string.deadline_colon, formatDate(it.deadline)),
                context.getString(R.string.completed_colon, formatDate(it.deadline))
            )
        }
        holder.assigneeJob = showAssignee(binding, it)
        binding.icMore.setOnClickListener {
            listener?.onClickMore(getItem(position))
        }
        binding.editTask.setOnClickListener {
            listener?.onEdit(getItem(position))
        }
        binding.deleteTask.setOnClickListener {
            listener?.onDelete(getItem(position))
        }
        holder.itemView.setOnClickListener {
            val alertDialog = AlertDialog.Builder(context, R.style.AlertDialogTheme)
                .setTitle(getItem(position).title)
                .setMessage(getItem(position).description)
                .setNegativeButton("Cancel") { dialog, _ ->
                    dialog.dismiss()
                }.create()

            alertDialog.show()
        }
        if (nonTeamMember) {
            binding.editTask.visibility = View.GONE
            binding.deleteTask.visibility = View.GONE
            binding.icMore.visibility = View.GONE
            binding.checkbox.isClickable = false
            binding.checkbox.isFocusable = false
        } else {
            binding.checkbox.setOnCheckedChangeListener { _: CompoundButton?, b: Boolean ->
                listener?.onCheckChange(it, b)
            }
        }
    }

    private fun showAssignee(binding: RowTaskBinding, realmTeamTask: RealmTeamTask): Job? {
        val assigneeId = realmTeamTask.assignee
        if (assigneeId.isNullOrEmpty()) {
            binding.assignee.setText(R.string.no_assignee)
            return null
        }

        assigneeCache[assigneeId]?.let {
            binding.assignee.text = context.getString(R.string.assigned_to_colon, it)
            return null
        }

        return coroutineScope.launch(Dispatchers.IO) {
            val user = userRepository.getUserById(assigneeId)
            withContext(Dispatchers.Main) {
                val name = user?.name
                if (name != null) {
                    assigneeCache[assigneeId] = name
                    binding.assignee.text = context.getString(R.string.assigned_to_colon, name)
                } else {
                    binding.assignee.setText(R.string.no_assignee)
                }
            }
        }
    }

    interface OnCompletedListener {
        fun onCheckChange(realmTeamTask: RealmTeamTask?, b: Boolean)
        fun onEdit(task: RealmTeamTask?)
        fun onDelete(task: RealmTeamTask?)
        fun onClickMore(realmTeamTask: RealmTeamTask?)
    }

    class ViewHolderTask(val binding: RowTaskBinding) : RecyclerView.ViewHolder(binding.root) {
        var assigneeJob: Job? = null
    }

    companion object {
        val diffCallback = DiffUtils.itemCallback<RealmTeamTask>(
            areItemsTheSame = { old, new -> old.id == new.id },
            areContentsTheSame = { old, new -> old == new }
        )
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/TeamFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team

import android.content.Context
import android.content.SharedPreferences
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Case
import io.realm.Realm
import io.realm.RealmQuery
import io.realm.RealmResults
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AlertCreateTeamBinding
import org.ole.planet.myplanet.databinding.FragmentTeamBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getMyTeamsByUserId
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class TeamFragment : Fragment(), AdapterTeamList.OnClickTeamItem, AdapterTeamList.OnUpdateCompleteListener {
    private var _binding: FragmentTeamBinding? = null
    private val binding get() = _binding!!
    private lateinit var alertCreateTeamBinding: AlertCreateTeamBinding
    private lateinit var mRealm: Realm
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var teamRepository: TeamRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    var type: String? = null
    private var fromDashboard: Boolean = false
    var user: RealmUserModel? = null
    private var teamList: RealmResults<RealmMyTeam>? = null
    private lateinit var adapterTeamList: AdapterTeamList
    private var conditionApplied: Boolean = false
    private var textWatcher: TextWatcher? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            fromDashboard = requireArguments().getBoolean("fromDashboard")
            type = requireArguments().getString("type")
            if (TextUtils.isEmpty(type)) {
                type = "team"
            }
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamBinding.inflate(inflater, container, false)
        mRealm = databaseService.realmInstance
        user = userProfileDbHandler.getUserModelCopy()

        if (user?.isGuest() == true) {
            binding.addTeam.visibility = View.GONE
        } else {
            binding.addTeam.visibility = View.VISIBLE
        }

        binding.addTeam.setOnClickListener { createTeamAlert(null) }
        binding.tvFragmentInfo.text = if (TextUtils.equals(type, "enterprise")) {
            getString(R.string.enterprises)
        } else {
            getString(R.string.team)
        }

        if (fromDashboard) {
            teamList = getMyTeamsByUserId(mRealm, settings)
        } else {
            val query = mRealm.where(RealmMyTeam::class.java)
                .isEmpty("teamId")
                .notEqualTo("status", "archived")
            teamList = if (TextUtils.isEmpty(type) || type == "team") {
                conditionApplied = false
                query.notEqualTo("type", "enterprise").findAllAsync()
            } else {
                conditionApplied = true
                query.equalTo("type", "enterprise").findAllAsync()
            }
        }

        teamList?.addChangeListener { _ ->
            updatedTeamList()
        }
        return binding.root
    }

     fun createTeamAlert(team: RealmMyTeam?) {
        alertCreateTeamBinding = AlertCreateTeamBinding.inflate(LayoutInflater.from(context))
        if (TextUtils.equals(type, "enterprise")) {
            alertCreateTeamBinding.spnTeamType.visibility = View.GONE
            alertCreateTeamBinding.etDescription.hint = getString(R.string.entMission)
            alertCreateTeamBinding.etName.hint = getString(R.string.enter_enterprise_s_name)
        } else {
            alertCreateTeamBinding.etServices.visibility = View.GONE
            alertCreateTeamBinding.etRules.visibility = View.GONE
            alertCreateTeamBinding.etDescription.hint = getString(R.string.what_is_your_team_s_plan)
            alertCreateTeamBinding.etName.hint = getString(R.string.enter_team_s_name)
        }
        if (team != null) {
            alertCreateTeamBinding.etServices.setText(team.services)
            alertCreateTeamBinding.etRules.setText(team.rules)
            alertCreateTeamBinding.etDescription.setText(team.description)
            alertCreateTeamBinding.etName.setText(team.name)
        }

        val builder = AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
            .setTitle(String.format(getString(R.string.enter) + "%s " + getString(R.string.detail), if (type == null) getString(R.string.team) else type))
            .setView(alertCreateTeamBinding.root).setPositiveButton(getString(R.string.save), null).setNegativeButton(getString(R.string.cancel), null)
        val dialog = builder.create()

        dialog.setOnShowListener {
            val okButton = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            okButton.setOnClickListener {
                val name = alertCreateTeamBinding.etName.text.toString().trim()
                val description = alertCreateTeamBinding.etDescription.text.toString()
                val services = alertCreateTeamBinding.etServices.text.toString()
                val rules = alertCreateTeamBinding.etRules.text.toString()
                val selectedTeamType =
                    if (alertCreateTeamBinding.spnTeamType.selectedItemPosition == 0) {
                        "local"
                    } else {
                        "sync"
                    }
                val currentUser = user
                when {
                    name.isEmpty() -> {
                        Utilities.toast(activity, getString(R.string.name_is_required))
                        alertCreateTeamBinding.etName.error = getString(R.string.please_enter_a_name)
                    } else -> {
                        val failureMessage = getString(R.string.request_failed_please_retry)
                        val userModel = currentUser ?: run {
                            Utilities.toast(activity, failureMessage)
                            return@setOnClickListener
                        }
                        viewLifecycleOwner.lifecycleScope.launch {
                            if (team == null) {
                                teamRepository.createTeam(
                                    category = type,
                                    name = name,
                                    description = description,
                                    services = services,
                                    rules = rules,
                                    teamType = selectedTeamType,
                                    isPublic = alertCreateTeamBinding.switchPublic.isChecked,
                                    user = userModel,
                                ).onSuccess {
                                    binding.etSearch.visibility = View.VISIBLE
                                    binding.tableTitle.visibility = View.VISIBLE
                                    Utilities.toast(activity, getString(R.string.team_created))
                                    refreshTeamList()
                                    dialog.dismiss()
                                }.onFailure {
                                    Utilities.toast(activity, failureMessage)
                                }
                            } else {
                                val targetTeamId = team._id ?: team.teamId
                                if (targetTeamId.isNullOrBlank()) {
                                    Utilities.toast(activity, failureMessage)
                                    return@launch
                                }
                                teamRepository.updateTeam(
                                    teamId = targetTeamId,
                                    name = name,
                                    description = description,
                                    services = services,
                                    rules = rules,
                                    updatedBy = userModel._id,
                                ).onSuccess { updated ->
                                    if (updated) {
                                        binding.etSearch.visibility = View.VISIBLE
                                        binding.tableTitle.visibility = View.VISIBLE
                                        Utilities.toast(activity, getString(R.string.team_created))
                                        refreshTeamList()
                                        dialog.dismiss()
                                    } else {
                                        Utilities.toast(activity, failureMessage)
                                    }
                                }.onFailure {
                                    Utilities.toast(activity, failureMessage)
                                }
                            }
                        }
                    }
                }
            }
        }
        dialog.show()
    }

    override fun onResume() {
        super.onResume()
        setTeamList()
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.rvTeamList.layoutManager = LinearLayoutManager(activity)
        setTeamList()
        textWatcher = object : TextWatcher {
            override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
            override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {
                if (TextUtils.isEmpty(charSequence)) {
                    showNoResultsMessage(false)
                    updatedTeamList()
                    return
                }
                var list: List<RealmMyTeam>
                var conditionApplied = false
                if(fromDashboard){
                    list = teamList?.filter {
                        it.name?.contains(charSequence.toString(), ignoreCase = true) == true
                    } ?: emptyList()
                } else {
                    val query = mRealm.where(RealmMyTeam::class.java).isEmpty("teamId")
                        .notEqualTo("status", "archived")
                        .contains("name", charSequence.toString(), Case.INSENSITIVE)
                    val result = getList(query)
                    list = result.first
                    conditionApplied = result.second
                }

                if (list.isEmpty()) {
                    showNoResultsMessage(true, charSequence.toString())
                    binding.rvTeamList.adapter = null
                } else {
                    showNoResultsMessage(false)
                    val sortedList = list.sortedWith(compareByDescending<RealmMyTeam> {
                        it.name?.startsWith(charSequence.toString(), ignoreCase = true)
                    }.thenBy { it.name })

                    val adapterTeamList = AdapterTeamList(
                        activity as Context,
                        sortedList,
                        childFragmentManager,
                        teamRepository,
                        user,
                        viewLifecycleOwner.lifecycleScope,
                    )
                    adapterTeamList.setTeamListener(this@TeamFragment)
                    adapterTeamList.setUpdateCompleteListener(this@TeamFragment)
                    binding.rvTeamList.adapter = adapterTeamList
                    listContentDescription(conditionApplied)
                }
            }

            override fun afterTextChanged(editable: Editable) {}
        }
        binding.etSearch.addTextChangedListener(textWatcher)
    }

    private fun getList(query: RealmQuery<RealmMyTeam>): Pair<List<RealmMyTeam>, Boolean> {
        var queried = query
        val conditionApplied: Boolean
        queried = if (TextUtils.isEmpty(type) || type == "team") {
            conditionApplied = false
            queried.notEqualTo("type", "enterprise")
        } else {
            conditionApplied = true
            queried.equalTo("type", "enterprise")
        }

        return Pair(queried.findAll(), conditionApplied)
    }

    private fun setTeamList() {
        val list = teamList
        if (list == null) {
            return
        }

        adapterTeamList = activity?.let {
            AdapterTeamList(it, list, childFragmentManager, teamRepository, user, viewLifecycleOwner.lifecycleScope)
        } ?: return

        adapterTeamList.setType(type)
        adapterTeamList.setTeamListener(this@TeamFragment)
        adapterTeamList.setUpdateCompleteListener(this@TeamFragment)
        requireView().findViewById<View>(R.id.type).visibility =
            if (type == null) {
                View.GONE
            } else {
                View.VISIBLE
            }

        binding.rvTeamList.adapter = adapterTeamList
        listContentDescription(conditionApplied)
    }

    private fun refreshTeamList() {
        mRealm.refresh()
        teamList?.removeAllChangeListeners()

        if (fromDashboard) {
            teamList = getMyTeamsByUserId(mRealm, settings)
        } else {
            val query = mRealm.where(RealmMyTeam::class.java)
                .isEmpty("teamId")
                .notEqualTo("status", "archived")
            teamList = if (TextUtils.isEmpty(type) || type == "team") {
                conditionApplied = false
                query.notEqualTo("type", "enterprise").findAllAsync()
            } else {
                conditionApplied = true
                query.equalTo("type", "enterprise").findAllAsync()
            }
        }

        teamList?.addChangeListener { _ ->
            updatedTeamList()
        }
        setTeamList()
    }

    override fun onEditTeam(team: RealmMyTeam?) {
        team?.let { createTeamAlert(it) }
    }

    override fun onUpdateComplete(itemCount: Int) {
        if (itemCount == 0) {
            showNoResultsMessage(true)
        } else {
            showNoResultsMessage(false)
        }
    }

    private fun updatedTeamList() {
        viewLifecycleOwner.lifecycleScope.launch {
            if (!::adapterTeamList.isInitialized || binding.rvTeamList.adapter == null) {
                setTeamList()
            } else {
                adapterTeamList.updateList()
            }
            listContentDescription(conditionApplied)
        }
    }

    private fun listContentDescription(conditionApplied: Boolean) {
        if (conditionApplied) {
            binding.rvTeamList.contentDescription = getString(R.string.enterprise_list)
        } else {
            binding.rvTeamList.contentDescription = getString(R.string.list_of_teams)
        }
    }

    private fun showNoResultsMessage(show: Boolean, searchQuery: String = "") {
        if (show) {
            binding.tvMessage.text = if (searchQuery.isNotEmpty()) {
                if (TextUtils.equals(type, "enterprise")){
                    getString(R.string.no_enterprises_found_for_search, searchQuery)
                } else {
                    getString(R.string.no_teams_found_for_search, searchQuery)
                }
            } else {
                if (TextUtils.equals(type, "enterprise")) {
                    getString(R.string.no_enterprises_found)
                } else {
                    getString(R.string.no_teams_found)
                }
            }
            binding.tvMessage.visibility = View.VISIBLE
            binding.etSearch.visibility = View.VISIBLE
            binding.tableTitle.visibility = View.GONE
        } else {
            binding.tvMessage.visibility = View.GONE
            binding.etSearch.visibility = View.VISIBLE
            binding.tableTitle.visibility = View.VISIBLE
        }
    }

    override fun onDestroyView() {
        teamList?.removeAllChangeListeners()
        if (this::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        _binding?.etSearch?.removeTextChangedListener(textWatcher)
        textWatcher = null
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.team


import android.content.Context
import android.content.SharedPreferences
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Case
import io.realm.Realm
import io.realm.RealmQuery
import io.realm.RealmResults
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AlertCreateTeamBinding
import org.ole.planet.myplanet.databinding.FragmentTeamBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getMyTeamsByUserId
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class TeamFragment : Fragment(), AdapterTeamList.OnClickTeamItem, AdapterTeamList.OnUpdateCompleteListener {
    private var _binding: FragmentTeamBinding? = null
    private val binding get() = _binding!!
    private lateinit var alertCreateTeamBinding: AlertCreateTeamBinding
    private lateinit var mRealm: Realm
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var teamRepository: TeamRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    var type: String? = null
    private var fromDashboard: Boolean = false
    var user: RealmUserModel? = null
    private var teamList: RealmResults<RealmMyTeam>? = null
    private lateinit var adapterTeamList: AdapterTeamList
    private var conditionApplied: Boolean = false
    private var textWatcher: TextWatcher? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            fromDashboard = requireArguments().getBoolean("fromDashboard")
            type = requireArguments().getString("type")
            if (TextUtils.isEmpty(type)) {
                type = "team"
            }
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamBinding.inflate(inflater, container, false)
        mRealm = databaseService.realmInstance
        user = userProfileDbHandler.getUserModelCopy()

        if (user?.isGuest() == true) {
            binding.addTeam.visibility = View.GONE
        } else {
            binding.addTeam.visibility = View.VISIBLE
        }

        binding.addTeam.setOnClickListener { createTeamAlert(null) }
        binding.tvFragmentInfo.text = if (TextUtils.equals(type, "enterprise")) {
            getString(R.string.enterprises)
        } else {
            getString(R.string.team)
        }

        if (fromDashboard) {
            teamList = getMyTeamsByUserId(mRealm, settings)
        } else {
            val query = mRealm.where(RealmMyTeam::class.java)
                .isEmpty("teamId")
                .notEqualTo("status", "archived")
            teamList = if (TextUtils.isEmpty(type) || type == "team") {
                conditionApplied = false
                query.notEqualTo("type", "enterprise").findAllAsync()
            } else {
                conditionApplied = true
                query.equalTo("type", "enterprise").findAllAsync()
            }
        }

        teamList?.addChangeListener { _ ->
            updatedTeamList()
        }
        return binding.root
    }

     fun createTeamAlert(team: RealmMyTeam?) {
        alertCreateTeamBinding = AlertCreateTeamBinding.inflate(LayoutInflater.from(context))
        if (TextUtils.equals(type, "enterprise")) {
            alertCreateTeamBinding.spnTeamType.visibility = View.GONE
            alertCreateTeamBinding.etDescription.hint = getString(R.string.entMission)
            alertCreateTeamBinding.etName.hint = getString(R.string.enter_enterprise_s_name)
        } else {
            alertCreateTeamBinding.etServices.visibility = View.GONE
            alertCreateTeamBinding.etRules.visibility = View.GONE
            alertCreateTeamBinding.etDescription.hint = getString(R.string.what_is_your_team_s_plan)
            alertCreateTeamBinding.etName.hint = getString(R.string.enter_team_s_name)
        }
        if (team != null) {
            alertCreateTeamBinding.etServices.setText(team.services)
            alertCreateTeamBinding.etRules.setText(team.rules)
            alertCreateTeamBinding.etDescription.setText(team.description)
            alertCreateTeamBinding.etName.setText(team.name)
        }

        val builder = AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
            .setTitle(String.format(getString(R.string.enter) + "%s " + getString(R.string.detail), if (type == null) getString(R.string.team) else type))
            .setView(alertCreateTeamBinding.root).setPositiveButton(getString(R.string.save), null).setNegativeButton(getString(R.string.cancel), null)
        val dialog = builder.create()

        dialog.setOnShowListener {
            val okButton = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            okButton.setOnClickListener {
                val name = alertCreateTeamBinding.etName.text.toString().trim()
                val description = alertCreateTeamBinding.etDescription.text.toString()
                val services = alertCreateTeamBinding.etServices.text.toString()
                val rules = alertCreateTeamBinding.etRules.text.toString()
                val selectedTeamType =
                    if (alertCreateTeamBinding.spnTeamType.selectedItemPosition == 0) {
                        "local"
                    } else {
                        "sync"
                    }
                val currentUser = user
                when {
                    name.isEmpty() -> {
                        Utilities.toast(activity, getString(R.string.name_is_required))
                        alertCreateTeamBinding.etName.error = getString(R.string.please_enter_a_name)
                    } else -> {
                        val failureMessage = getString(R.string.request_failed_please_retry)
                        val userModel = currentUser ?: run {
                            Utilities.toast(activity, failureMessage)
                            return@setOnClickListener
                        }
                        viewLifecycleOwner.lifecycleScope.launch {
                            if (team == null) {
                                teamRepository.createTeam(
                                    category = type,
                                    name = name,
                                    description = description,
                                    services = services,
                                    rules = rules,
                                    teamType = selectedTeamType,
                                    isPublic = alertCreateTeamBinding.switchPublic.isChecked,
                                    user = userModel,
                                ).onSuccess {
                                    binding.etSearch.visibility = View.VISIBLE
                                    binding.tableTitle.visibility = View.VISIBLE
                                    Utilities.toast(activity, getString(R.string.team_created))
                                    refreshTeamList()
                                    dialog.dismiss()
                                }.onFailure {
                                    Utilities.toast(activity, failureMessage)
                                }
                            } else {
                                val targetTeamId = team._id ?: team.teamId
                                if (targetTeamId.isNullOrBlank()) {
                                    Utilities.toast(activity, failureMessage)
                                    return@launch
                                }
                                teamRepository.updateTeam(
                                    teamId = targetTeamId,
                                    name = name,
                                    description = description,
                                    services = services,
                                    rules = rules,
                                    updatedBy = userModel._id,
                                ).onSuccess { updated ->
                                    if (updated) {
                                        binding.etSearch.visibility = View.VISIBLE
                                        binding.tableTitle.visibility = View.VISIBLE
                                        Utilities.toast(activity, getString(R.string.team_created))
                                        refreshTeamList()
                                        dialog.dismiss()
                                    } else {
                                        Utilities.toast(activity, failureMessage)
                                    }
                                }.onFailure {
                                    Utilities.toast(activity, failureMessage)
                                }
                            }
                        }
                    }
                }
            }
        }
        dialog.show()
    }

    override fun onResume() {
        super.onResume()
        setTeamList()
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.rvTeamList.layoutManager = LinearLayoutManager(activity)
        setTeamList()
        textWatcher = object : TextWatcher {
            override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
            override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {
                if (TextUtils.isEmpty(charSequence)) {
                    showNoResultsMessage(false)
                    updatedTeamList()
                    return
                }
                var list: List<RealmMyTeam>
                var conditionApplied = false
                if(fromDashboard){
                    list = teamList?.filter {
                        it.name?.contains(charSequence.toString(), ignoreCase = true) == true
                    } ?: emptyList()
                } else {
                    val query = mRealm.where(RealmMyTeam::class.java).isEmpty("teamId")
                        .notEqualTo("status", "archived")
                        .contains("name", charSequence.toString(), Case.INSENSITIVE)
                    val result = getList(query)
                    list = result.first
                    conditionApplied = result.second
                }

                if (list.isEmpty()) {
                    showNoResultsMessage(true, charSequence.toString())
                    binding.rvTeamList.adapter = null
                } else {
                    showNoResultsMessage(false)
                    val sortedList = list.sortedWith(compareByDescending<RealmMyTeam> {
                        it.name?.startsWith(charSequence.toString(), ignoreCase = true)
                    }.thenBy { it.name })

                    val adapterTeamList = AdapterTeamList(
                        activity as Context,
                        sortedList,
                        childFragmentManager,
                        teamRepository,
                        user,
                        viewLifecycleOwner.lifecycleScope,
                    )
                    adapterTeamList.setTeamListener(this@TeamFragment)
                    adapterTeamList.setUpdateCompleteListener(this@TeamFragment)
                    binding.rvTeamList.adapter = adapterTeamList
                    listContentDescription(conditionApplied)
                }
            }

            override fun afterTextChanged(editable: Editable) {}
        }
        binding.etSearch.addTextChangedListener(textWatcher)
    }

    private fun getList(query: RealmQuery<RealmMyTeam>): Pair<List<RealmMyTeam>, Boolean> {
        var queried = query
        val conditionApplied: Boolean
        queried = if (TextUtils.isEmpty(type) || type == "team") {
            conditionApplied = false
            queried.notEqualTo("type", "enterprise")
        } else {
            conditionApplied = true
            queried.equalTo("type", "enterprise")
        }

        return Pair(queried.findAll(), conditionApplied)
    }

    private fun setTeamList() {
        val list = teamList
        if (list == null) {
            return
        }

        adapterTeamList = activity?.let {
            AdapterTeamList(it, list, childFragmentManager, teamRepository, user, viewLifecycleOwner.lifecycleScope)
        } ?: return

        adapterTeamList.setType(type)
        adapterTeamList.setTeamListener(this@TeamFragment)
        adapterTeamList.setUpdateCompleteListener(this@TeamFragment)
        requireView().findViewById<View>(R.id.type).visibility =
            if (type == null) {
                View.GONE
            } else {
                View.VISIBLE
            }

        binding.rvTeamList.adapter = adapterTeamList
        listContentDescription(conditionApplied)
    }

    private fun refreshTeamList() {
        mRealm.refresh()
        teamList?.removeAllChangeListeners()

        if (fromDashboard) {
            teamList = getMyTeamsByUserId(mRealm, settings)
        } else {
            val query = mRealm.where(RealmMyTeam::class.java)
                .isEmpty("teamId")
                .notEqualTo("status", "archived")
            teamList = if (TextUtils.isEmpty(type) || type == "team") {
                conditionApplied = false
                query.notEqualTo("type", "enterprise").findAllAsync()
            } else {
                conditionApplied = true
                query.equalTo("type", "enterprise").findAllAsync()
            }
        }

        teamList?.addChangeListener { _ ->
            updatedTeamList()
        }
        setTeamList()
    }

    override fun onEditTeam(team: RealmMyTeam?) {
        team?.let { createTeamAlert(it) }
    }

    override fun onUpdateComplete(itemCount: Int) {
        if (itemCount == 0) {
            showNoResultsMessage(true)
        } else {
            showNoResultsMessage(false)
        }
    }

    private fun updatedTeamList() {
        viewLifecycleOwner.lifecycleScope.launch {
            if (!::adapterTeamList.isInitialized || binding.rvTeamList.adapter == null) {
                setTeamList()
            } else {
                adapterTeamList.updateList()
            }
            listContentDescription(conditionApplied)
        }
    }

    private fun listContentDescription(conditionApplied: Boolean) {
        if (conditionApplied) {
            binding.rvTeamList.contentDescription = getString(R.string.enterprise_list)
        } else {
            binding.rvTeamList.contentDescription = getString(R.string.list_of_teams)
        }
    }

    private fun showNoResultsMessage(show: Boolean, searchQuery: String = "") {
        if (show) {
            binding.tvMessage.text = if (searchQuery.isNotEmpty()) {
                if (TextUtils.equals(type, "enterprise")){
                    getString(R.string.no_enterprises_found_for_search, searchQuery)
                } else {
                    getString(R.string.no_teams_found_for_search, searchQuery)
                }
            } else {
                if (TextUtils.equals(type, "enterprise")) {
                    getString(R.string.no_enterprises_found)
                } else {
                    getString(R.string.no_teams_found)
                }
            }
            binding.tvMessage.visibility = View.VISIBLE
            binding.etSearch.visibility = View.VISIBLE
            binding.tableTitle.visibility = View.GONE
        } else {
            binding.tvMessage.visibility = View.GONE
            binding.etSearch.visibility = View.VISIBLE
            binding.tableTitle.visibility = View.VISIBLE
        }
    }

    override fun onDestroyView() {
        teamList?.removeAllChangeListeners()
        if (this::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        _binding?.etSearch?.removeTextChangedListener(textWatcher)
        textWatcher = null
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/TeamPagerAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team

import android.os.Bundle
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.viewpager2.adapter.FragmentStateAdapter
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.callback.MemberChangeListener
import org.ole.planet.myplanet.callback.TeamUpdateListener
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ApplicantsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.DocumentsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.JoinRequestsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.MembersPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ResourcesPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.SurveyPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.TeamPage
import org.ole.planet.myplanet.ui.team.teamMember.JoinedMemberFragment
import org.ole.planet.myplanet.ui.team.teamMember.MembersFragment
import org.ole.planet.myplanet.ui.team.teamResource.TeamResourceFragment

class TeamPagerAdapter(
    private val fm: FragmentActivity,
    private val pages: List<TeamPageConfig>,
    private val teamId: String?,
    private val memberChangeListener: MemberChangeListener,
    private val teamUpdateListener: TeamUpdateListener
) : FragmentStateAdapter(fm) {

    override fun getItemCount(): Int = pages.size

    fun getPageTitle(position: Int): CharSequence =
        fm.getString(pages[position].titleRes)

    override fun getItemId(position: Int): Long {
        val page = pages.getOrNull(position)
        val pageId = page?.id?.hashCode()?.toLong() ?: position.toLong()
        return pageId
    }

    override fun containsItem(itemId: Long): Boolean {
        val contains = pages.any { it.id.hashCode().toLong() == itemId }
        return contains
    }

    override fun createFragment(position: Int): Fragment {
        val page = pages[position]
        val fragment = page.createFragment()

        when (page) {
            TeamPage -> if (fragment is JoinedMemberFragment) {
                fragment.setMemberChangeListener(memberChangeListener)
            }
            MembersPage -> if (fragment is JoinedMemberFragment) {
                fragment.setMemberChangeListener(memberChangeListener)
            }
            ApplicantsPage, JoinRequestsPage -> if (fragment is MembersFragment) {
                fragment.setMemberChangeListener(memberChangeListener)
            }
            DocumentsPage, ResourcesPage -> if (fragment is TeamResourceFragment) {
                MainApplication.listener = fragment
            }
            SurveyPage -> {
                fragment.arguments = (fragment.arguments ?: Bundle()).apply {
                    putBoolean("isTeam", true)
                    putString("teamId", teamId)
                }
            }
            else -> {}
        }

        if (fragment is PlanFragment) {
            fragment.setTeamUpdateListener(teamUpdateListener)
        }

        val args = fragment.arguments ?: Bundle().also { fragment.arguments = it }
        if (!args.containsKey("id")) {
            args.putString("id", teamId)
        }

        args.putString("fragmentType", page.id)
        args.putInt("fragmentPosition", position)

        return fragment
    }
}
=======
package org.ole.planet.myplanet.ui.team


import android.os.Bundle
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.viewpager2.adapter.FragmentStateAdapter
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.callback.MemberChangeListener
import org.ole.planet.myplanet.callback.TeamUpdateListener
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ApplicantsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.DocumentsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.JoinRequestsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.MembersPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.ResourcesPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.SurveyPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.TeamPage
import org.ole.planet.myplanet.ui.team.teamMember.JoinedMemberFragment
import org.ole.planet.myplanet.ui.team.teamMember.MembersFragment
import org.ole.planet.myplanet.ui.team.teamResource.TeamResourceFragment

class TeamPagerAdapter(
    private val fm: FragmentActivity,
    private val pages: List<TeamPageConfig>,
    private val teamId: String?,
    private val memberChangeListener: MemberChangeListener,
    private val teamUpdateListener: TeamUpdateListener
) : FragmentStateAdapter(fm) {

    override fun getItemCount(): Int = pages.size

    fun getPageTitle(position: Int): CharSequence =
        fm.getString(pages[position].titleRes)

    override fun getItemId(position: Int): Long {
        val page = pages.getOrNull(position)
        val pageId = page?.id?.hashCode()?.toLong() ?: position.toLong()
        return pageId
    }

    override fun containsItem(itemId: Long): Boolean {
        val contains = pages.any { it.id.hashCode().toLong() == itemId }
        return contains
    }

    override fun createFragment(position: Int): Fragment {
        val page = pages[position]
        val fragment = page.createFragment()

        when (page) {
            TeamPage -> if (fragment is JoinedMemberFragment) {
                fragment.setMemberChangeListener(memberChangeListener)
            }
            MembersPage -> if (fragment is JoinedMemberFragment) {
                fragment.setMemberChangeListener(memberChangeListener)
            }
            ApplicantsPage, JoinRequestsPage -> if (fragment is MembersFragment) {
                fragment.setMemberChangeListener(memberChangeListener)
            }
            DocumentsPage, ResourcesPage -> if (fragment is TeamResourceFragment) {
                MainApplication.listener = fragment
            }
            SurveyPage -> {
                fragment.arguments = (fragment.arguments ?: Bundle()).apply {
                    putBoolean("isTeam", true)
                    putString("teamId", teamId)
                }
            }
            else -> {}
        }

        if (fragment is PlanFragment) {
            fragment.setTeamUpdateListener(teamUpdateListener)
        }

        val args = fragment.arguments ?: Bundle().also { fragment.arguments = it }
        if (!args.containsKey("id")) {
            args.putString("id", teamId)
        }

        args.putString("fragmentType", page.id)
        args.putInt("fragmentPosition", position)

        return fragment
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamMember/AdapterMemberRequest.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamMember

import android.content.Context
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import io.realm.Realm
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.MemberChangeListener
import org.ole.planet.myplanet.databinding.RowMemberRequestBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getJoinedMember
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.utilities.Utilities

class AdapterMemberRequest(
    private val context: Context,
    private val list: MutableList<RealmUserModel>,
    private val mRealm: Realm,
    private val currentUser: RealmUserModel,
    private val listener: MemberChangeListener,
    private val teamRepository: TeamRepository,
) : RecyclerView.Adapter<AdapterMemberRequest.ViewHolderUser>() {
    private var teamId: String? = null
    private lateinit var team: RealmMyTeam
    private var cachedModerationStatus: Boolean? = null

    fun setTeamId(teamId: String?) {
        this.teamId = teamId
        cachedModerationStatus = null
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderUser {
        val binding = RowMemberRequestBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderUser(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderUser, position: Int) {
        val currentItem = list.getOrNull(position) ?: return
        val binding = holder.binding
        binding.tvName.text = currentItem.name ?: currentItem.toString()

        team = try {
            mRealm.where(RealmMyTeam::class.java).equalTo("_id", teamId).findFirst()
                ?: throw IllegalArgumentException("Team not found for ID: $teamId")
        } catch (e: IllegalArgumentException) {
            e.printStackTrace()
            try {
                mRealm.where(RealmMyTeam::class.java).equalTo("teamId", teamId).findFirst()
                    ?: throw IllegalArgumentException("Team not found for ID: $teamId")
            } catch (e: IllegalArgumentException) {
                e.printStackTrace()
                return
            }
        }

        with(binding) {
            val members = getJoinedMember("$teamId", mRealm).size
            val userCanModerateRequests = canModerateRequests()
            val isRequester = currentItem.id == currentUser.id
            btnAccept.isEnabled = members < 12
            btnReject.isEnabled = true
            btnAccept.setOnClickListener(null)
            btnReject.setOnClickListener(null)

            if (isRequester) {
                btnAccept.isEnabled = false
                btnReject.isEnabled = false
                btnAccept.setOnClickListener(null)
                btnReject.setOnClickListener(null)
            } else if (isGuestUser() || !userCanModerateRequests) {
                btnAccept.isEnabled = false
                btnReject.isEnabled = false
            } else {
                btnAccept.setOnClickListener { handleClick(holder, true) }
                btnReject.setOnClickListener { handleClick(holder, false) }
            }
        }
    }

    private fun isGuestUser() = currentUser.id?.startsWith("guest") == true

    private fun canModerateRequests(): Boolean {
        cachedModerationStatus?.let { return it }

        val teamId = this.teamId
        val userId = currentUser.id
        if (teamId.isNullOrBlank() || userId.isNullOrBlank()) {
            cachedModerationStatus = false
            return false
        }

        val membershipRecord = mRealm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("docType", "membership")
            .equalTo("userId", userId)
            .findFirst()

        val canModerate = membershipRecord?.let { it.isLeader || it.docType == "membership" } ?: false
        cachedModerationStatus = canModerate
        return canModerate
    }


    private fun handleClick(holder: RecyclerView.ViewHolder, isAccepted: Boolean) {
        val adapterPosition = holder.bindingAdapterPosition
        if (adapterPosition != RecyclerView.NO_POSITION && adapterPosition < list.size) {
            val targetUser = list[adapterPosition]
            if (targetUser.id == currentUser.id) return
            acceptReject(targetUser, isAccepted, adapterPosition)
        }
    }

    private fun acceptReject(userModel: RealmUserModel, isAccept: Boolean, position: Int) {
        val userId = userModel.id
        val teamId = this.teamId

        if (teamId.isNullOrBlank() || userId.isNullOrBlank()) {
            Utilities.toast(context, context.getString(R.string.request_failed_please_retry))
            return
        }

        list.removeAt(position)
        notifyItemRemoved(position)
        notifyItemRangeChanged(position, list.size)

        MainApplication.applicationScope.launch {
            val result = teamRepository.respondToMemberRequest(teamId, userId, isAccept)
            if (result.isSuccess) {
                runCatching { teamRepository.syncTeamActivities() }
                    .onFailure { it.printStackTrace() }
                withContext(Dispatchers.Main) {
                    listener.onMemberChanged()
                }
            } else {
                withContext(Dispatchers.Main) {
                    list.add(position, userModel)
                    notifyItemInserted(position)
                    Utilities.toast(context, context.getString(R.string.request_failed_please_retry))
                    listener.onMemberChanged()
                }
            }
        }
    }

    override fun getItemCount(): Int {
        return list.size
    }

    class ViewHolderUser(val binding: RowMemberRequestBinding) : RecyclerView.ViewHolder(binding.root)
}
=======
package org.ole.planet.myplanet.ui.team.teamMember


import android.content.Context
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import io.realm.Realm
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.MemberChangeListener
import org.ole.planet.myplanet.databinding.RowMemberRequestBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getJoinedMember
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.utilities.Utilities

class AdapterMemberRequest(
    private val context: Context,
    private val list: MutableList<RealmUserModel>,
    private val mRealm: Realm,
    private val currentUser: RealmUserModel,
    private val listener: MemberChangeListener,
    private val teamRepository: TeamRepository,
) : RecyclerView.Adapter<AdapterMemberRequest.ViewHolderUser>() {
    private var teamId: String? = null
    private lateinit var team: RealmMyTeam
    private var cachedModerationStatus: Boolean? = null

    fun setTeamId(teamId: String?) {
        this.teamId = teamId
        cachedModerationStatus = null
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderUser {
        val binding = RowMemberRequestBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderUser(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderUser, position: Int) {
        val currentItem = list.getOrNull(position) ?: return
        val binding = holder.binding
        binding.tvName.text = currentItem.name ?: currentItem.toString()

        team = try {
            mRealm.where(RealmMyTeam::class.java).equalTo("_id", teamId).findFirst()
                ?: throw IllegalArgumentException("Team not found for ID: $teamId")
        } catch (e: IllegalArgumentException) {
            e.printStackTrace()
            try {
                mRealm.where(RealmMyTeam::class.java).equalTo("teamId", teamId).findFirst()
                    ?: throw IllegalArgumentException("Team not found for ID: $teamId")
            } catch (e: IllegalArgumentException) {
                e.printStackTrace()
                return
            }
        }

        with(binding) {
            val members = getJoinedMember("$teamId", mRealm).size
            val userCanModerateRequests = canModerateRequests()
            val isRequester = currentItem.id == currentUser.id
            btnAccept.isEnabled = members < 12
            btnReject.isEnabled = true
            btnAccept.setOnClickListener(null)
            btnReject.setOnClickListener(null)

            if (isRequester) {
                btnAccept.isEnabled = false
                btnReject.isEnabled = false
                btnAccept.setOnClickListener(null)
                btnReject.setOnClickListener(null)
            } else if (isGuestUser() || !userCanModerateRequests) {
                btnAccept.isEnabled = false
                btnReject.isEnabled = false
            } else {
                btnAccept.setOnClickListener { handleClick(holder, true) }
                btnReject.setOnClickListener { handleClick(holder, false) }
            }
        }
    }

    private fun isGuestUser() = currentUser.id?.startsWith("guest") == true

    private fun canModerateRequests(): Boolean {
        cachedModerationStatus?.let { return it }

        val teamId = this.teamId
        val userId = currentUser.id
        if (teamId.isNullOrBlank() || userId.isNullOrBlank()) {
            cachedModerationStatus = false
            return false
        }

        val membershipRecord = mRealm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("docType", "membership")
            .equalTo("userId", userId)
            .findFirst()

        val canModerate = membershipRecord?.let { it.isLeader || it.docType == "membership" } ?: false
        cachedModerationStatus = canModerate
        return canModerate
    }


    private fun handleClick(holder: RecyclerView.ViewHolder, isAccepted: Boolean) {
        val adapterPosition = holder.bindingAdapterPosition
        if (adapterPosition != RecyclerView.NO_POSITION && adapterPosition < list.size) {
            val targetUser = list[adapterPosition]
            if (targetUser.id == currentUser.id) return
            acceptReject(targetUser, isAccepted, adapterPosition)
        }
    }

    private fun acceptReject(userModel: RealmUserModel, isAccept: Boolean, position: Int) {
        val userId = userModel.id
        val teamId = this.teamId

        if (teamId.isNullOrBlank() || userId.isNullOrBlank()) {
            Utilities.toast(context, context.getString(R.string.request_failed_please_retry))
            return
        }

        list.removeAt(position)
        notifyItemRemoved(position)
        notifyItemRangeChanged(position, list.size)

        MainApplication.applicationScope.launch {
            val result = teamRepository.respondToMemberRequest(teamId, userId, isAccept)
            if (result.isSuccess) {
                runCatching { teamRepository.syncTeamActivities() }
                    .onFailure { it.printStackTrace() }
                withContext(Dispatchers.Main) {
                    listener.onMemberChanged()
                }
            } else {
                withContext(Dispatchers.Main) {
                    list.add(position, userModel)
                    notifyItemInserted(position)
                    Utilities.toast(context, context.getString(R.string.request_failed_please_retry))
                    listener.onMemberChanged()
                }
            }
        }
    }

    override fun getItemCount(): Int {
        return list.size
    }

    class ViewHolderUser(val binding: RowMemberRequestBinding) : RecyclerView.ViewHolder(binding.root)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamMember/MembersFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamMember

import android.content.Context
import android.content.res.Configuration
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import org.ole.planet.myplanet.base.BaseMemberFragment
import org.ole.planet.myplanet.callback.MemberChangeListener
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getRequestedMember
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler

@AndroidEntryPoint
class MembersFragment : BaseMemberFragment() {

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    private lateinit var currentUser: RealmUserModel
    private var memberChangeListener: MemberChangeListener = object : MemberChangeListener {
        override fun onMemberChanged() = Unit
    }

    fun setMemberChangeListener(listener: MemberChangeListener) {
        this.memberChangeListener = listener
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        currentUser = userProfileDbHandler.userModel ?: RealmUserModel()
    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    override val list: List<RealmUserModel>
        get() = getRequestedMember(teamId, mRealm)

    override val adapter: RecyclerView.Adapter<*>
        get() = AdapterMemberRequest(
            requireActivity(),
            list.toMutableList(),
            mRealm,
            currentUser,
            memberChangeListener,
            teamRepository,
        ).apply { setTeamId(teamId) }

    override val layoutManager: RecyclerView.LayoutManager
        get() {
            val columns = when (resources.configuration.screenLayout and Configuration.SCREENLAYOUT_SIZE_MASK) {
                Configuration.SCREENLAYOUT_SIZE_LARGE -> 3
                Configuration.SCREENLAYOUT_SIZE_NORMAL -> 2
                Configuration.SCREENLAYOUT_SIZE_SMALL -> 1
                else -> 1
            }
            return GridLayoutManager(activity, columns)
        }

}
=======
package org.ole.planet.myplanet.ui.team.teamMember


import android.content.Context
import android.content.res.Configuration
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import org.ole.planet.myplanet.base.BaseMemberFragment
import org.ole.planet.myplanet.callback.MemberChangeListener
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getRequestedMember
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler

@AndroidEntryPoint
class MembersFragment : BaseMemberFragment() {

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    private lateinit var currentUser: RealmUserModel
    private var memberChangeListener: MemberChangeListener = object : MemberChangeListener {
        override fun onMemberChanged() = Unit
    }

    fun setMemberChangeListener(listener: MemberChangeListener) {
        this.memberChangeListener = listener
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        currentUser = userProfileDbHandler.userModel ?: RealmUserModel()
    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    override val list: List<RealmUserModel>
        get() = getRequestedMember(teamId, mRealm)

    override val adapter: RecyclerView.Adapter<*>
        get() = AdapterMemberRequest(
            requireActivity(),
            list.toMutableList(),
            mRealm,
            currentUser,
            memberChangeListener,
            teamRepository,
        ).apply { setTeamId(teamId) }

    override val layoutManager: RecyclerView.LayoutManager
        get() {
            val columns = when (resources.configuration.screenLayout and Configuration.SCREENLAYOUT_SIZE_MASK) {
                Configuration.SCREENLAYOUT_SIZE_LARGE -> 3
                Configuration.SCREENLAYOUT_SIZE_NORMAL -> 2
                Configuration.SCREENLAYOUT_SIZE_SMALL -> 1
                else -> 1
            }
            return GridLayoutManager(activity, columns)
        }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamMember/JoinedMemberFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamMember

import android.content.res.Configuration
import android.widget.Toast
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import io.realm.Realm
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseMemberFragment
import org.ole.planet.myplanet.callback.MemberChangeListener
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getJoinedMember
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmTeamLog
import org.ole.planet.myplanet.model.RealmUserModel

class JoinedMemberFragment : BaseMemberFragment() {
    private var memberChangeListener: MemberChangeListener = object : MemberChangeListener {
        override fun onMemberChanged() {
            // fallback listener to prevent crash
        }
    }

    private var adapterJoined: AdapterJoinedMember? = null

    fun setMemberChangeListener(listener: MemberChangeListener) {
        this.memberChangeListener = listener
    }

    private val joinedMembers: List<JoinedMemberData>
        get() = databaseService.withRealm { realm ->
            val members = getJoinedMember(teamId, realm).map { realm.copyFromRealm(it) }.toMutableList()
            val leaderId = realm.where(RealmMyTeam::class.java)
                .equalTo("teamId", teamId)
                .equalTo("isLeader", true)
                .findFirst()?.userId
            val leader = members.find { it.id == leaderId }
            if (leader != null) {
                members.remove(leader)
                members.add(0, leader)
            }
            members.map { member ->
                val lastVisitTimestamp = RealmTeamLog.getLastVisit(realm, member.name, teamId)
                val lastVisitDate = if (lastVisitTimestamp != null) {
                    val sdf = SimpleDateFormat("dd MMM yyyy", Locale.getDefault())
                    sdf.format(Date(lastVisitTimestamp))
                } else {
                    getString(R.string.no_visit)
                }
                val visitCount = RealmTeamLog.getVisitCount(realm, member.name, teamId)
                val offlineVisits = profileDbHandler?.getOfflineVisits(member)?.toString() ?: "0"
                val profileLastVisit = profileDbHandler?.getLastVisit(member) ?: ""
                JoinedMemberData(
                    member,
                    visitCount,
                    lastVisitDate,
                    offlineVisits,
                    profileLastVisit,
                    member.id == leaderId
                )
            }
        }

    override val list: List<RealmUserModel>
        get() = joinedMembers.map { it.user }

    override val adapter: RecyclerView.Adapter<*>
        get() {
            if (adapterJoined == null) {
                val members = joinedMembers
                val currentUserId = user?.id
                val isLeader = members.any { it.user.id == currentUserId && it.isLeader }
                adapterJoined = AdapterJoinedMember(
                    requireActivity(),
                    members.toMutableList(),
                    isLeader,
                    object : AdapterJoinedMember.MemberActionListener {
                        override fun onRemoveMember(member: JoinedMemberData, position: Int) {
                            handleRemoveMember(member)
                        }

                        override fun onMakeLeader(member: JoinedMemberData) {
                            member.user.id?.let { handleMakeLeader(it) }
                        }
                    }
                )
            }
            return adapterJoined as AdapterJoinedMember
        }

    override val layoutManager: RecyclerView.LayoutManager
        get() {
            val columns = when (resources.configuration.screenLayout and Configuration.SCREENLAYOUT_SIZE_MASK) {
                Configuration.SCREENLAYOUT_SIZE_LARGE -> 3
                Configuration.SCREENLAYOUT_SIZE_NORMAL -> 2
                Configuration.SCREENLAYOUT_SIZE_SMALL -> 1
                else -> 1
            }
            return GridLayoutManager(activity, columns)
        }

    private fun handleRemoveMember(member: JoinedMemberData) {
        val memberId = member.user.id ?: return
        val currentUserId = user?.id

        viewLifecycleOwner.lifecycleScope.launch {
            try {
                val removalResult = databaseService.withRealm { realm ->
                    if (currentUserId != memberId) {
                        RemovalResult(canRemove = true, newLeaderId = null)
                    } else {
                        val nextOfKin = getNextOfKinSync(realm)

                        val nextOfKinId = nextOfKin?.id
                        if (nextOfKinId != null) {
                            RemovalResult(canRemove = true, newLeaderId = nextOfKinId)
                        } else {
                            RemovalResult(canRemove = false, newLeaderId = null)
                        }
                    }
                }

                if (removalResult.canRemove) {
                    if (removalResult.newLeaderId != null && currentUserId == memberId) {
                        databaseService.executeTransactionAsync { realm ->
                            makeLeaderSync(realm, removalResult.newLeaderId)
                        }
                    }

                    teamRepository.removeMember(teamId, memberId)

                    adapterJoined?.removeMember(memberId)

                    removalResult.newLeaderId?.let { newLeaderId ->
                        adapterJoined?.updateLeadership(currentUserId, newLeaderId)
                    }

                    memberChangeListener.onMemberChanged()
                    showNoData(binding.tvNodata, adapterJoined?.itemCount ?: 0, "members")
                } else {
                    Toast.makeText(requireContext(), R.string.cannot_remove_user, Toast.LENGTH_SHORT).show()
                }
            } catch (e: Exception) {
                Toast.makeText(requireContext(), "Error removing member: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }

    private data class RemovalResult(val canRemove: Boolean, val newLeaderId: String?)

    private fun handleMakeLeader(userId: String) {
        viewLifecycleOwner.lifecycleScope.launch {
            try {
                databaseService.executeTransactionAsync { realm ->
                    makeLeaderSync(realm, userId)
                }

                val currentUserId = user?.id
                adapterJoined?.updateLeadership(currentUserId, userId)
                Toast.makeText(requireContext(), getString(R.string.leader_selected), Toast.LENGTH_SHORT).show()
                memberChangeListener.onMemberChanged()
            } catch (e: Exception) {
                Toast.makeText(requireContext(), "Error making leader: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }

    private fun makeLeaderSync(realm: Realm, userId: String) {
        val currentLeaders = realm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("isLeader", true)
            .findAll()
        currentLeaders.forEach { it.isLeader = false }

        val newLeader = realm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("userId", userId)
            .findFirst()

        if (newLeader != null) {
            newLeader.isLeader = true
        }
    }

    private fun getNextOfKinSync(realm: Realm): RealmUserModel? {
        val members = realm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("isLeader", false)
            .notEqualTo("status", "archived")
            .findAll()

        if (members.isEmpty()) {
            return null
        }

        val userIds = members.mapNotNull { it.userId }.toTypedArray()
        if (userIds.isEmpty()) {
            return null
        }

        val users = realm.where(RealmUserModel::class.java)
            .`in`("id", userIds)
            .findAll()

        val userMap = users.associateBy { it.id }
        val successorMember = members.maxByOrNull { member ->
            userMap[member.userId]?.let { user ->
                val visitCount = RealmTeamLog.getVisitCount(realm, user.name, teamId)
                visitCount
            } ?: 0L
        }

        val result = successorMember?.userId?.let { id ->
            userMap[id]?.let {
                val copy = realm.copyFromRealm(it)
                copy
            }
        }
        return result
    }

    override fun onNewsItemClick(news: RealmNews?) {}

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }
}
=======
package org.ole.planet.myplanet.ui.team.teamMember


import android.content.res.Configuration
import android.widget.Toast
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import io.realm.Realm
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseMemberFragment
import org.ole.planet.myplanet.callback.MemberChangeListener
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmMyTeam.Companion.getJoinedMember
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmTeamLog
import org.ole.planet.myplanet.model.RealmUserModel

class JoinedMemberFragment : BaseMemberFragment() {
    private var memberChangeListener: MemberChangeListener = object : MemberChangeListener {
        override fun onMemberChanged() {
            // fallback listener to prevent crash
        }
    }

    private var adapterJoined: AdapterJoinedMember? = null

    fun setMemberChangeListener(listener: MemberChangeListener) {
        this.memberChangeListener = listener
    }

    private val joinedMembers: List<JoinedMemberData>
        get() = databaseService.withRealm { realm ->
            val members = getJoinedMember(teamId, realm).map { realm.copyFromRealm(it) }.toMutableList()
            val leaderId = realm.where(RealmMyTeam::class.java)
                .equalTo("teamId", teamId)
                .equalTo("isLeader", true)
                .findFirst()?.userId
            val leader = members.find { it.id == leaderId }
            if (leader != null) {
                members.remove(leader)
                members.add(0, leader)
            }
            members.map { member ->
                val lastVisitTimestamp = RealmTeamLog.getLastVisit(realm, member.name, teamId)
                val lastVisitDate = if (lastVisitTimestamp != null) {
                    val sdf = SimpleDateFormat("dd MMM yyyy", Locale.getDefault())
                    sdf.format(Date(lastVisitTimestamp))
                } else {
                    getString(R.string.no_visit)
                }
                val visitCount = RealmTeamLog.getVisitCount(realm, member.name, teamId)
                val offlineVisits = profileDbHandler?.getOfflineVisits(member)?.toString() ?: "0"
                val profileLastVisit = profileDbHandler?.getLastVisit(member) ?: ""
                JoinedMemberData(
                    member,
                    visitCount,
                    lastVisitDate,
                    offlineVisits,
                    profileLastVisit,
                    member.id == leaderId
                )
            }
        }

    override val list: List<RealmUserModel>
        get() = joinedMembers.map { it.user }

    override val adapter: RecyclerView.Adapter<*>
        get() {
            if (adapterJoined == null) {
                val members = joinedMembers
                val currentUserId = user?.id
                val isLeader = members.any { it.user.id == currentUserId && it.isLeader }
                adapterJoined = AdapterJoinedMember(
                    requireActivity(),
                    members.toMutableList(),
                    isLeader,
                    object : AdapterJoinedMember.MemberActionListener {
                        override fun onRemoveMember(member: JoinedMemberData, position: Int) {
                            handleRemoveMember(member)
                        }

                        override fun onMakeLeader(member: JoinedMemberData) {
                            member.user.id?.let { handleMakeLeader(it) }
                        }
                    }
                )
            }
            return adapterJoined as AdapterJoinedMember
        }

    override val layoutManager: RecyclerView.LayoutManager
        get() {
            val columns = when (resources.configuration.screenLayout and Configuration.SCREENLAYOUT_SIZE_MASK) {
                Configuration.SCREENLAYOUT_SIZE_LARGE -> 3
                Configuration.SCREENLAYOUT_SIZE_NORMAL -> 2
                Configuration.SCREENLAYOUT_SIZE_SMALL -> 1
                else -> 1
            }
            return GridLayoutManager(activity, columns)
        }

    private fun handleRemoveMember(member: JoinedMemberData) {
        val memberId = member.user.id ?: return
        val currentUserId = user?.id

        viewLifecycleOwner.lifecycleScope.launch {
            try {
                val removalResult = databaseService.withRealm { realm ->
                    if (currentUserId != memberId) {
                        RemovalResult(canRemove = true, newLeaderId = null)
                    } else {
                        val nextOfKin = getNextOfKinSync(realm)

                        val nextOfKinId = nextOfKin?.id
                        if (nextOfKinId != null) {
                            RemovalResult(canRemove = true, newLeaderId = nextOfKinId)
                        } else {
                            RemovalResult(canRemove = false, newLeaderId = null)
                        }
                    }
                }

                if (removalResult.canRemove) {
                    if (removalResult.newLeaderId != null && currentUserId == memberId) {
                        databaseService.executeTransactionAsync { realm ->
                            makeLeaderSync(realm, removalResult.newLeaderId)
                        }
                    }

                    teamRepository.removeMember(teamId, memberId)

                    adapterJoined?.removeMember(memberId)

                    removalResult.newLeaderId?.let { newLeaderId ->
                        adapterJoined?.updateLeadership(currentUserId, newLeaderId)
                    }

                    memberChangeListener.onMemberChanged()
                    showNoData(binding.tvNodata, adapterJoined?.itemCount ?: 0, "members")
                } else {
                    Toast.makeText(requireContext(), R.string.cannot_remove_user, Toast.LENGTH_SHORT).show()
                }
            } catch (e: Exception) {
                Toast.makeText(requireContext(), "Error removing member: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }

    private data class RemovalResult(val canRemove: Boolean, val newLeaderId: String?)

    private fun handleMakeLeader(userId: String) {
        viewLifecycleOwner.lifecycleScope.launch {
            try {
                databaseService.executeTransactionAsync { realm ->
                    makeLeaderSync(realm, userId)
                }

                val currentUserId = user?.id
                adapterJoined?.updateLeadership(currentUserId, userId)
                Toast.makeText(requireContext(), getString(R.string.leader_selected), Toast.LENGTH_SHORT).show()
                memberChangeListener.onMemberChanged()
            } catch (e: Exception) {
                Toast.makeText(requireContext(), "Error making leader: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }

    private fun makeLeaderSync(realm: Realm, userId: String) {
        val currentLeaders = realm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("isLeader", true)
            .findAll()
        currentLeaders.forEach { it.isLeader = false }

        val newLeader = realm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("userId", userId)
            .findFirst()

        if (newLeader != null) {
            newLeader.isLeader = true
        }
    }

    private fun getNextOfKinSync(realm: Realm): RealmUserModel? {
        val members = realm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("isLeader", false)
            .notEqualTo("status", "archived")
            .findAll()

        if (members.isEmpty()) {
            return null
        }

        val userIds = members.mapNotNull { it.userId }.toTypedArray()
        if (userIds.isEmpty()) {
            return null
        }

        val users = realm.where(RealmUserModel::class.java)
            .`in`("id", userIds)
            .findAll()

        val userMap = users.associateBy { it.id }
        val successorMember = members.maxByOrNull { member ->
            userMap[member.userId]?.let { user ->
                val visitCount = RealmTeamLog.getVisitCount(realm, user.name, teamId)
                visitCount
            } ?: 0L
        }

        val result = successorMember?.userId?.let { id ->
            userMap[id]?.let {
                val copy = realm.copyFromRealm(it)
                copy
            }
        }
        return result
    }

    override fun onNewsItemClick(news: RealmNews?) {}

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamMember/AdapterJoinedMember.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamMember

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowJoinedUserBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.DiffUtils

data class JoinedMemberData(
    val user: RealmUserModel,
    val visitCount: Long,
    val lastVisitDate: String,
    val offlineVisits: String,
    val profileLastVisit: String,
    var isLeader: Boolean
)

class AdapterJoinedMember(
    private val context: Context,
    private val list: MutableList<JoinedMemberData>,
    private var isLoggedInUserTeamLeader: Boolean,
    private val actionListener: MemberActionListener
) : RecyclerView.Adapter<AdapterJoinedMember.ViewHolderUser>() {

    interface MemberActionListener {
        fun onRemoveMember(member: JoinedMemberData, position: Int)
        fun onMakeLeader(member: JoinedMemberData)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderUser {
        val binding = RowJoinedUserBinding.inflate(LayoutInflater.from(context), parent, false)
        return ViewHolderUser(binding)
    }

    override fun onBindViewHolder(
        holder: ViewHolderUser,
        position: Int,
        payloads: MutableList<Any>
    ) {
        if (payloads.isNotEmpty()) {
            val payload = payloads[0] as Bundle
            if (payload.containsKey("KEY_LEADER")) {
                val isLeader = payload.getBoolean("KEY_LEADER")
                holder.binding.tvIsLeader.visibility = if (isLeader) View.VISIBLE else View.GONE
                if (isLeader) {
                    holder.binding.tvIsLeader.text = context.getString(R.string.team_leader)
                }
            }
        } else {
            super.onBindViewHolder(holder, position, payloads)
        }
    }

    override fun onBindViewHolder(holder: ViewHolderUser, position: Int) {
        val memberData = list[position]
        val member = memberData.user
        val binding = holder.binding

        binding.tvTitle.text = if (member.toString() == " ") member.name else member.toString()
        binding.tvDescription.text = context.getString(
            R.string.member_description,
            member.getRoleAsString(),
            memberData.visitCount
        )
        binding.tvLastVisit.text = context.getString(
            R.string.last_visit,
            memberData.lastVisitDate
        )
        Glide.with(binding.memberImage.context)
            .load(member.userImage)
            .placeholder(R.drawable.profile)
            .error(R.drawable.profile)
            .into(binding.memberImage)

        if (memberData.isLeader) {
            binding.tvIsLeader.visibility = View.VISIBLE
            binding.tvIsLeader.text = context.getString(R.string.team_leader)
        } else {
            binding.tvIsLeader.visibility = View.GONE
        }

        checkUserAndShowOverflowMenu(binding, position)

        holder.itemView.setOnClickListener {
            val activity = it.context as AppCompatActivity
            val userName = "${member.firstName} ${member.lastName}".trim().ifBlank {
                member.name
            }
            val fragment = MemberDetailFragment.newInstance(
                userName.toString(),
                member.email.toString(),
                member.dob.toString().substringBefore("T"),
                member.language.toString(),
                member.phoneNumber.toString(),
                memberData.offlineVisits,
                memberData.profileLastVisit,
                "${member.firstName} ${member.lastName}",
                member.level.toString(),
                member.userImage
            )
            NavigationHelper.replaceFragment(
                activity.supportFragmentManager,
                R.id.fragment_container,
                fragment,
                addToBackStack = true
            )
        }
    }

    private fun checkUserAndShowOverflowMenu(
        binding: RowJoinedUserBinding,
        position: Int
    ) {
        if (isLoggedInUserTeamLeader && list.size > 1) {
            binding.icMore.visibility = View.VISIBLE
            binding.icMore.setOnClickListener {
                val overflowMenuOptions = arrayOf(
                    context.getString(R.string.remove),
                    context.getString(R.string.make_leader)
                )
                val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
                val adapter = object : ArrayAdapter<CharSequence>(
                    context,
                    android.R.layout.simple_list_item_1,
                    overflowMenuOptions
                ) {
                    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
                        val view = super.getView(position, convertView, parent) as TextView
                        val color = ContextCompat.getColor(context, R.color.daynight_textColor)
                        view.setTextColor(color)
                        return view
                    }
                }
                builder.setAdapter(adapter) { _, i ->
                    when (i) {
                        0 -> actionListener.onRemoveMember(list[position], position)
                        1 -> actionListener.onMakeLeader(list[position])
                    }
                }.setNegativeButton(R.string.dismiss, null).show()
            }
        } else {
            binding.icMore.visibility = View.GONE
        }
    }

    override fun getItemCount(): Int = list.size

    fun updateData(newList: List<JoinedMemberData>, isLoggedInUserTeamLeader: Boolean) {
        this.isLoggedInUserTeamLeader = isLoggedInUserTeamLeader
        val oldList = ArrayList(this.list)
        val diffResult = DiffUtils.calculateDiff(
            oldList,
            newList,
            areItemsTheSame = { old, new -> old.user.id == new.user.id },
            areContentsTheSame = { old, new -> old == new },
            getChangePayload = { old, new ->
                val payload = Bundle()
                if (old.isLeader != new.isLeader) {
                    payload.putBoolean("KEY_LEADER", new.isLeader)
                }
                if (payload.isEmpty) null else payload
            }
        )
        this.list.clear()
        this.list.addAll(newList)
        diffResult.dispatchUpdatesTo(this)
    }

    fun removeMember(memberId: String) {
        val position = list.indexOfFirst { it.user.id == memberId }
        if (position != -1) {
            list.removeAt(position)
            notifyItemRemoved(position)

            if (list.isNotEmpty()) {
                notifyItemRangeChanged(0, list.size)
            }
        }
    }

    fun updateLeadership(loggedInUserId: String?, newLeaderId: String) {
        var oldLeaderPos = -1
        var newLeaderPos = -1

        list.forEachIndexed { index, memberData ->
            if (memberData.isLeader) {
                memberData.isLeader = false
                oldLeaderPos = index
            }
            if (memberData.user.id == newLeaderId) {
                memberData.isLeader = true
                newLeaderPos = index
            }
        }

        isLoggedInUserTeamLeader = (loggedInUserId == newLeaderId)

        if (newLeaderPos > 0) {
            val newLeader = list.removeAt(newLeaderPos)
            list.add(0, newLeader)
            notifyItemMoved(newLeaderPos, 0)
        }

        if (oldLeaderPos != -1) notifyItemChanged(if (oldLeaderPos == 0) 1 else oldLeaderPos)
        notifyItemChanged(0)

        if (list.size > 2) {
            notifyItemRangeChanged(1, list.size - 1)
        }
    }

    class ViewHolderUser(val binding: RowJoinedUserBinding) :
        RecyclerView.ViewHolder(binding.root)
}
=======
package org.ole.planet.myplanet.ui.team.teamMember


import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowJoinedUserBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.DiffUtils

data class JoinedMemberData(
    val user: RealmUserModel,
    val visitCount: Long,
    val lastVisitDate: String,
    val offlineVisits: String,
    val profileLastVisit: String,
    var isLeader: Boolean
)

class AdapterJoinedMember(
    private val context: Context,
    private val list: MutableList<JoinedMemberData>,
    private var isLoggedInUserTeamLeader: Boolean,
    private val actionListener: MemberActionListener
) : RecyclerView.Adapter<AdapterJoinedMember.ViewHolderUser>() {

    interface MemberActionListener {
        fun onRemoveMember(member: JoinedMemberData, position: Int)
        fun onMakeLeader(member: JoinedMemberData)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderUser {
        val binding = RowJoinedUserBinding.inflate(LayoutInflater.from(context), parent, false)
        return ViewHolderUser(binding)
    }

    override fun onBindViewHolder(
        holder: ViewHolderUser,
        position: Int,
        payloads: MutableList<Any>
    ) {
        if (payloads.isNotEmpty()) {
            val payload = payloads[0] as Bundle
            if (payload.containsKey("KEY_LEADER")) {
                val isLeader = payload.getBoolean("KEY_LEADER")
                holder.binding.tvIsLeader.visibility = if (isLeader) View.VISIBLE else View.GONE
                if (isLeader) {
                    holder.binding.tvIsLeader.text = context.getString(R.string.team_leader)
                }
            }
        } else {
            super.onBindViewHolder(holder, position, payloads)
        }
    }

    override fun onBindViewHolder(holder: ViewHolderUser, position: Int) {
        val memberData = list[position]
        val member = memberData.user
        val binding = holder.binding

        binding.tvTitle.text = if (member.toString() == " ") member.name else member.toString()
        binding.tvDescription.text = context.getString(
            R.string.member_description,
            member.getRoleAsString(),
            memberData.visitCount
        )
        binding.tvLastVisit.text = context.getString(
            R.string.last_visit,
            memberData.lastVisitDate
        )
        Glide.with(binding.memberImage.context)
            .load(member.userImage)
            .placeholder(R.drawable.profile)
            .error(R.drawable.profile)
            .into(binding.memberImage)

        if (memberData.isLeader) {
            binding.tvIsLeader.visibility = View.VISIBLE
            binding.tvIsLeader.text = context.getString(R.string.team_leader)
        } else {
            binding.tvIsLeader.visibility = View.GONE
        }

        checkUserAndShowOverflowMenu(binding, position)

        holder.itemView.setOnClickListener {
            val activity = it.context as AppCompatActivity
            val userName = "${member.firstName} ${member.lastName}".trim().ifBlank {
                member.name
            }
            val fragment = MemberDetailFragment.newInstance(
                userName.toString(),
                member.email.toString(),
                member.dob.toString().substringBefore("T"),
                member.language.toString(),
                member.phoneNumber.toString(),
                memberData.offlineVisits,
                memberData.profileLastVisit,
                "${member.firstName} ${member.lastName}",
                member.level.toString(),
                member.userImage
            )
            NavigationHelper.replaceFragment(
                activity.supportFragmentManager,
                R.id.fragment_container,
                fragment,
                addToBackStack = true
            )
        }
    }

    private fun checkUserAndShowOverflowMenu(
        binding: RowJoinedUserBinding,
        position: Int
    ) {
        if (isLoggedInUserTeamLeader && list.size > 1) {
            binding.icMore.visibility = View.VISIBLE
            binding.icMore.setOnClickListener {
                val overflowMenuOptions = arrayOf(
                    context.getString(R.string.remove),
                    context.getString(R.string.make_leader)
                )
                val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
                val adapter = object : ArrayAdapter<CharSequence>(
                    context,
                    android.R.layout.simple_list_item_1,
                    overflowMenuOptions
                ) {
                    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
                        val view = super.getView(position, convertView, parent) as TextView
                        val color = ContextCompat.getColor(context, R.color.daynight_textColor)
                        view.setTextColor(color)
                        return view
                    }
                }
                builder.setAdapter(adapter) { _, i ->
                    when (i) {
                        0 -> actionListener.onRemoveMember(list[position], position)
                        1 -> actionListener.onMakeLeader(list[position])
                    }
                }.setNegativeButton(R.string.dismiss, null).show()
            }
        } else {
            binding.icMore.visibility = View.GONE
        }
    }

    override fun getItemCount(): Int = list.size

    fun updateData(newList: List<JoinedMemberData>, isLoggedInUserTeamLeader: Boolean) {
        this.isLoggedInUserTeamLeader = isLoggedInUserTeamLeader
        val oldList = ArrayList(this.list)
        val diffResult = DiffUtils.calculateDiff(
            oldList,
            newList,
            areItemsTheSame = { old, new -> old.user.id == new.user.id },
            areContentsTheSame = { old, new -> old == new },
            getChangePayload = { old, new ->
                val payload = Bundle()
                if (old.isLeader != new.isLeader) {
                    payload.putBoolean("KEY_LEADER", new.isLeader)
                }
                if (payload.isEmpty) null else payload
            }
        )
        this.list.clear()
        this.list.addAll(newList)
        diffResult.dispatchUpdatesTo(this)
    }

    fun removeMember(memberId: String) {
        val position = list.indexOfFirst { it.user.id == memberId }
        if (position != -1) {
            list.removeAt(position)
            notifyItemRemoved(position)

            if (list.isNotEmpty()) {
                notifyItemRangeChanged(0, list.size)
            }
        }
    }

    fun updateLeadership(loggedInUserId: String?, newLeaderId: String) {
        var oldLeaderPos = -1
        var newLeaderPos = -1

        list.forEachIndexed { index, memberData ->
            if (memberData.isLeader) {
                memberData.isLeader = false
                oldLeaderPos = index
            }
            if (memberData.user.id == newLeaderId) {
                memberData.isLeader = true
                newLeaderPos = index
            }
        }

        isLoggedInUserTeamLeader = (loggedInUserId == newLeaderId)

        if (newLeaderPos > 0) {
            val newLeader = list.removeAt(newLeaderPos)
            list.add(0, newLeader)
            notifyItemMoved(newLeaderPos, 0)
        }

        if (oldLeaderPos != -1) notifyItemChanged(if (oldLeaderPos == 0) 1 else oldLeaderPos)
        notifyItemChanged(0)

        if (list.size > 2) {
            notifyItemRangeChanged(1, list.size - 1)
        }
    }

    class ViewHolderUser(val binding: RowJoinedUserBinding) :
        RecyclerView.ViewHolder(binding.root)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamMember/MemberDetailFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamMember

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import com.bumptech.glide.Glide
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentMemberDetailBinding
import org.ole.planet.myplanet.ui.navigation.NavigationHelper

class MemberDetailFragment : Fragment() {
    private var _binding: FragmentMemberDetailBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMemberDetailBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        arguments?.let { args ->
            val fullName = args.getString("member_name")?.trim()
            val username = args.getString("username")?.trim()
            val imageUrl = args.getString("profile_photo_url")
            binding.tvProfileName.text = if (fullName.isNullOrEmpty()) username else fullName
            Glide.with(requireContext())
                .load(imageUrl)
                .placeholder(R.drawable.profile)
                .error(R.drawable.profile)
                .into(binding.memberImage)

            setFieldOrHide(binding.tvFullName, fullName)
            setFieldOrHide(binding.tvProfileEmail, args.getString("profile_email"))
            setFieldOrHide(binding.tvDetailDob, args.getString("detail_dob"))
            setFieldOrHide(binding.tvDetailLanguage, args.getString("detail_language"))
            setFieldOrHide(binding.tvProfilePhone, args.getString("profile_phone"))
            setFieldOrHide(binding.tvNumberOfVisits, args.getString("number_of_visits"))
            setFieldOrHide(binding.tvLastLogin, args.getString("last_login"))
            setFieldOrHide(binding.tvLevel, args.getString("user_level"))
        }

        binding.btnClose.setOnClickListener {
            activity?.supportFragmentManager?.let { NavigationHelper.popBackStack(it) }
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    private fun setFieldOrHide(view: View, value: String?) {
        val shouldShow = value != null
                && value != "null"
                && !value.isBlank()
        if (shouldShow) {
            when (view) {
                is androidx.appcompat.widget.AppCompatTextView -> view.text = value
            }
            view.visibility = View.VISIBLE
            (view.parent as? View)?.visibility = View.VISIBLE
        } else {
            view.visibility = View.GONE
            (view.parent as? View)?.visibility = View.GONE
        }
    }


    companion object {
        @JvmStatic
        fun newInstance(
            name: String,
            email: String,
            dob: String,
            language: String,
            phone: String,
            visits: String,
            lastLogin: String,
            username: String,
            memberLevel: String,
            imageUrl: String?
        ) = MemberDetailFragment().apply {
            arguments = Bundle().apply {
                putString("member_name", name)
                putString("profile_email", email)
                putString("detail_dob", dob)
                putString("detail_language", language)
                putString("profile_phone", phone)
                putString("number_of_visits", visits)
                putString("last_login", lastLogin)
                putString("username", username)
                putString("user_level", memberLevel)
                putString("profile_photo_url", imageUrl)
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.team.teamMember


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import com.bumptech.glide.Glide
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentMemberDetailBinding
import org.ole.planet.myplanet.ui.navigation.NavigationHelper

class MemberDetailFragment : Fragment() {
    private var _binding: FragmentMemberDetailBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMemberDetailBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        arguments?.let { args ->
            val fullName = args.getString("member_name")?.trim()
            val username = args.getString("username")?.trim()
            val imageUrl = args.getString("profile_photo_url")
            binding.tvProfileName.text = if (fullName.isNullOrEmpty()) username else fullName
            Glide.with(requireContext())
                .load(imageUrl)
                .placeholder(R.drawable.profile)
                .error(R.drawable.profile)
                .into(binding.memberImage)

            setFieldOrHide(binding.tvFullName, fullName)
            setFieldOrHide(binding.tvProfileEmail, args.getString("profile_email"))
            setFieldOrHide(binding.tvDetailDob, args.getString("detail_dob"))
            setFieldOrHide(binding.tvDetailLanguage, args.getString("detail_language"))
            setFieldOrHide(binding.tvProfilePhone, args.getString("profile_phone"))
            setFieldOrHide(binding.tvNumberOfVisits, args.getString("number_of_visits"))
            setFieldOrHide(binding.tvLastLogin, args.getString("last_login"))
            setFieldOrHide(binding.tvLevel, args.getString("user_level"))
        }

        binding.btnClose.setOnClickListener {
            activity?.supportFragmentManager?.let { NavigationHelper.popBackStack(it) }
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    private fun setFieldOrHide(view: View, value: String?) {
        val shouldShow = value != null
                && value != "null"
                && !value.isBlank()
        if (shouldShow) {
            when (view) {
                is androidx.appcompat.widget.AppCompatTextView -> view.text = value
            }
            view.visibility = View.VISIBLE
            (view.parent as? View)?.visibility = View.VISIBLE
        } else {
            view.visibility = View.GONE
            (view.parent as? View)?.visibility = View.GONE
        }
    }


    companion object {
        @JvmStatic
        fun newInstance(
            name: String,
            email: String,
            dob: String,
            language: String,
            phone: String,
            visits: String,
            lastLogin: String,
            username: String,
            memberLevel: String,
            imageUrl: String?
        ) = MemberDetailFragment().apply {
            arguments = Bundle().apply {
                putString("member_name", name)
                putString("profile_email", email)
                putString("detail_dob", dob)
                putString("detail_language", language)
                putString("profile_phone", phone)
                putString("number_of_visits", visits)
                putString("last_login", lastLogin)
                putString("username", username)
                putString("user_level", memberLevel)
                putString("profile_photo_url", imageUrl)
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/TeamCalendarFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team

import android.app.DatePickerDialog
import android.app.TimePickerDialog
import android.content.Context
import android.content.res.Resources
import android.os.Bundle
import android.util.TypedValue
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.RadioButton
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.applandeo.materialcalendarview.CalendarDay
import com.applandeo.materialcalendarview.CalendarView
import com.applandeo.materialcalendarview.listeners.OnCalendarDayClickListener
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import java.net.MalformedURLException
import java.net.URL
import java.text.SimpleDateFormat
import java.time.Instant
import java.time.ZoneId
import java.util.Calendar
import java.util.Locale
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AddMeetupBinding
import org.ole.planet.myplanet.databinding.FragmentEnterpriseCalendarBinding
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.repository.MeetupRepository
import org.ole.planet.myplanet.ui.mymeetup.AdapterMeetup
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class TeamCalendarFragment : BaseTeamFragment() {
    private var _binding: FragmentEnterpriseCalendarBinding? = null
    private val binding get() = _binding!!
    private val selectedDates: MutableList<Calendar> = mutableListOf()
    private lateinit var calendar: CalendarView
    private lateinit var list: List<Calendar>
    private lateinit var start: Calendar
    private lateinit var end: Calendar
    private lateinit var clickedCalendar: Calendar
    private lateinit var calendarEventsMap: MutableMap<CalendarDay, RealmMeetup>
    private var meetupList: List<RealmMeetup> = emptyList()
    private val eventDates: MutableList<Calendar> = mutableListOf()
    private var addMeetupDialog: AlertDialog? = null
    @Inject
    lateinit var meetupRepository: MeetupRepository

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentEnterpriseCalendarBinding.inflate(inflater, container, false)
        start = Calendar.getInstance()
        end = Calendar.getInstance()
        return binding.root
    }

    fun String.isValidWebLink(): Boolean {
        val toCheck = when {
            startsWith("http://",  ignoreCase = true) || startsWith("https://", ignoreCase = true) -> this
            else -> "http://$this"
        }
        return try {
            val url = URL(toCheck)
            url.host.contains(".")
        } catch (e: MalformedURLException) {
            false
        }
    }

    private fun showMeetupAlert() {
        if (addMeetupDialog?.isShowing == true) return
        val addMeetupBinding = AddMeetupBinding.inflate(layoutInflater)
        setDatePickerListener(addMeetupBinding.tvStartDate, start, end)
        setDatePickerListener(addMeetupBinding.tvEndDate, end, null)
        setTimePicker(addMeetupBinding.tvStartTime)
        setTimePicker(addMeetupBinding.tvEndTime)
        if (!::clickedCalendar.isInitialized) {
            clickedCalendar = Calendar.getInstance()
        }
        addMeetupDialog = AlertDialog.Builder(requireActivity()).setView(addMeetupBinding.root).create()
        addMeetupBinding.btnSave.setOnClickListener {
            val title = "${addMeetupBinding.etTitle.text.trim()}"
            val link = "${addMeetupBinding.etLink.text.trim()}"
            val description = "${addMeetupBinding.etDescription.text.trim()}"
            val location = "${addMeetupBinding.etLocation.text.trim()}"
            if (title.isEmpty()) {
                Utilities.toast(activity, getString(R.string.title_is_required))
            } else if (description.isEmpty()) {
                Utilities.toast(activity, getString(R.string.description_is_required))
            } else if (!link.isValidWebLink() && link.isNotEmpty()) {
                Utilities.toast(activity, getString(R.string.invalid_url))
            } else {
                try {
                    if (!mRealm.isInTransaction) {
                        mRealm.beginTransaction()
                    }
                    val defaultPlaceholder = getString(R.string.click_here_to_pick_time)
                    val meetup = mRealm.createObject(RealmMeetup::class.java, "${UUID.randomUUID()}")
                    meetup.title = title
                    meetup.meetupLink = link
                    meetup.description = description
                    meetup.meetupLocation = location
                    meetup.creator = user?.name
                    meetup.startDate = start.timeInMillis
                    meetup.endDate = end.timeInMillis
                    if (addMeetupBinding.tvStartTime.text == defaultPlaceholder) {
                        meetup.startTime = ""
                    } else {
                        meetup.startTime = "${addMeetupBinding.tvStartTime.text}"
                    }
                    if (addMeetupBinding.tvEndTime.text == defaultPlaceholder) {
                        meetup.endTime = ""
                    } else {
                        meetup.endTime = "${addMeetupBinding.tvEndTime.text}"
                    }
                    meetup.createdDate = System.currentTimeMillis()
                    meetup.sourcePlanet = team?.teamPlanetCode
                    val jo = JsonObject()
                    jo.addProperty("type", "local")
                    jo.addProperty("planetCode", team?.teamPlanetCode)
                    meetup.sync = Gson().toJson(jo)
                    val rb = addMeetupBinding.rgRecuring.findViewById<RadioButton>(addMeetupBinding.rgRecuring.checkedRadioButtonId)
                    if (rb != null) {
                        meetup.recurring = "${rb.text}"
                    }
                    val ob = JsonObject()
                    ob.addProperty("teams", teamId)
                    meetup.link = Gson().toJson(ob)
                    meetup.teamId = teamId
                    mRealm.commitTransaction()
                    Utilities.toast(activity, getString(R.string.meetup_added))
                    addMeetupDialog?.dismiss()
                    refreshCalendarView()
                } catch (e: Exception) {
                    mRealm.cancelTransaction()
                    e.printStackTrace()
                    Utilities.toast(activity, getString(R.string.meetup_not_added))
                }
            }
        }

        addMeetupBinding.btnCancel.setOnClickListener {
            addMeetupDialog?.dismiss()
        }

        addMeetupDialog?.setOnDismissListener {
            if (selectedDates.contains(clickedCalendar)) {
                selectedDates.remove(clickedCalendar)
                refreshCalendarView()
            }
        }
        addMeetupDialog?.show()
        addMeetupDialog?.window?.setBackgroundDrawableResource(R.color.card_bg)
    }

    private fun setDatePickerListener(view: TextView, date: Calendar?, endDate: Calendar?) {
        val initCal = date ?: Calendar.getInstance()
        if (date != null && endDate != null) {
            view.text = date.timeInMillis.let { it1 -> TimeUtils.formatDate(it1, "yyyy-MM-dd") }
        }
        view.setOnClickListener {
            DatePickerDialog(requireActivity(), { _, year, monthOfYear, dayOfMonth ->
                date?.set(Calendar.YEAR, year)
                date?.set(Calendar.MONTH, monthOfYear)
                date?.set(Calendar.DAY_OF_MONTH, dayOfMonth)
                view.text = date?.timeInMillis?.let { it1 -> TimeUtils.formatDate(it1, "yyyy-MM-dd") }
            }, initCal.get(Calendar.YEAR),
                initCal.get(Calendar.MONTH),
                initCal.get(Calendar.DAY_OF_MONTH)).show()
        }
    }

    private fun setTimePicker(time: TextView) {
        val c = Calendar.getInstance()
        time.setOnClickListener {
            val timePickerDialog = TimePickerDialog(
                activity, { _, hourOfDay, minute ->
                    time.text = String.format(Locale.getDefault(), "%02d:%02d", hourOfDay, minute) },
                c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true)
            timePickerDialog.show()
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        list = mutableListOf()
        calendar = binding.calendarView
        calendarEventsMap = mutableMapOf()
        setupCalendarClickListener()
    }

    override fun onResume() {
        super.onResume()
        setupCalendarClickListener()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    private fun setupCalendarClickListener(){
        binding.calendarView.setOnCalendarDayClickListener(object : OnCalendarDayClickListener {
            override fun onClick(calendarDay: CalendarDay) {
                lifecycleScope.launch {
                    meetupList = meetupRepository.getMeetupsForTeam(teamId)
                    clickedCalendar = calendarDay.calendar
                    val clickedDateInMillis = clickedCalendar.timeInMillis
                    val clickedDate = Instant.ofEpochMilli(clickedDateInMillis)
                        .atZone(ZoneId.systemDefault())
                        .toLocalDate()

                    val markedDates = meetupList.filter { meetup ->
                        val meetupDate = Instant.ofEpochMilli(meetup.startDate)
                            .atZone(ZoneId.systemDefault())
                            .toLocalDate()
                        meetupDate == clickedDate
                    }

                    if (markedDates.isNotEmpty()) {
                        showMeetupDialog(markedDates)
                    } else {
                        if(arguments?.getBoolean("fromLogin", false) != false || user?.id?.startsWith("guest") == true){
                            binding.calendarView.selectedDates = eventDates
                        } else{
                            start = clickedCalendar.clone() as Calendar
                            end = clickedCalendar.clone() as Calendar
                            showMeetupAlert()
                        }
                    }
                    if (!selectedDates.contains(clickedCalendar)) {
                        selectedDates.add(clickedCalendar)
                    } else {
                        selectedDates.remove(clickedCalendar)
                    }
                }
            }
        })
        refreshCalendarView()
    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun getCardViewHeight(context: Context): Int {
        val view = LayoutInflater.from(context).inflate(R.layout.item_meetup, null)
        view.measure(
            View.MeasureSpec.makeMeasureSpec(Resources.getSystem().displayMetrics.widthPixels, View.MeasureSpec.AT_MOST),
            View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
        )
        return view.measuredHeight
    }

    private fun showMeetupDialog(meetupList: List<RealmMeetup>) {
        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.meetup_dialog, null)
        val recyclerView = dialogView.findViewById<RecyclerView>(R.id.rvMeetups)
        val dialogTitle = dialogView.findViewById< TextView>(R.id.tvTitle)
        val dateFormat = SimpleDateFormat("EEE, MMM d, yyyy", Locale.getDefault())
        dialogTitle.text = dateFormat.format(clickedCalendar.time)
        val extraHeight = TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_DIP, 12f, resources.displayMetrics
        ).toInt()
        val cardHeight = getCardViewHeight(requireContext())
        recyclerView.layoutParams.height = cardHeight + extraHeight
        recyclerView.requestLayout()
        recyclerView.layoutManager = LinearLayoutManager(requireContext())
        val adapter = AdapterMeetup()
        recyclerView.adapter = adapter
        adapter.submitList(meetupList)

        val dialog = AlertDialog.Builder(requireContext())
            .setView(dialogView)
            .create()
        val btnAdd = dialogView.findViewById<Button>(R.id.btnadd)
        if (arguments?.getBoolean("fromLogin", false) != true) {
            btnAdd.visibility = View.VISIBLE
        } else {
            btnAdd.visibility = View.GONE
        }
        dialogView.findViewById<Button>(R.id.btnClose).setOnClickListener {
            dialog.dismiss()
        }
        btnAdd.setOnClickListener {
            if(arguments?.getBoolean("fromLogin", false) != true){
                start = clickedCalendar
                end = clickedCalendar
                showMeetupAlert()
            }
        }

        dialog.setOnDismissListener {
            eventDates.add(clickedCalendar)
            lifecycleScope.launch {
                binding.calendarView.selectedDates = emptyList()
                binding.calendarView.selectedDates = eventDates.toList()
            }
            binding.calendarView.selectedDates = eventDates
        }

        dialog.show()
    }

    private fun refreshCalendarView() {
        if (teamId.isEmpty()) {
            return
        }
        viewLifecycleOwner.lifecycleScope.launch {
            val newDates = meetupRepository.getMeetupsForTeam(teamId).mapTo(mutableListOf()) { meetup ->
                val calendarInstance = Calendar.getInstance()
                calendarInstance.timeInMillis = meetup.startDate
                calendarInstance
            }

            if (isAdded && activity != null) {
                eventDates.clear()
                eventDates.addAll(newDates)
                binding.calendarView.selectedDates = ArrayList(newDates)
            }
        }
    }


}
=======
package org.ole.planet.myplanet.ui.team


import android.app.DatePickerDialog
import android.app.TimePickerDialog
import android.content.Context
import android.content.res.Resources
import android.os.Bundle
import android.util.TypedValue
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.RadioButton
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.applandeo.materialcalendarview.CalendarDay
import com.applandeo.materialcalendarview.CalendarView
import com.applandeo.materialcalendarview.listeners.OnCalendarDayClickListener
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import java.net.MalformedURLException
import java.net.URL
import java.text.SimpleDateFormat
import java.time.Instant
import java.time.ZoneId
import java.util.Calendar
import java.util.Locale
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AddMeetupBinding
import org.ole.planet.myplanet.databinding.FragmentEnterpriseCalendarBinding
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.repository.MeetupRepository
import org.ole.planet.myplanet.ui.mymeetup.AdapterMeetup
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class TeamCalendarFragment : BaseTeamFragment() {
    private var _binding: FragmentEnterpriseCalendarBinding? = null
    private val binding get() = _binding!!
    private val selectedDates: MutableList<Calendar> = mutableListOf()
    private lateinit var calendar: CalendarView
    private lateinit var list: List<Calendar>
    private lateinit var start: Calendar
    private lateinit var end: Calendar
    private lateinit var clickedCalendar: Calendar
    private lateinit var calendarEventsMap: MutableMap<CalendarDay, RealmMeetup>
    private var meetupList: List<RealmMeetup> = emptyList()
    private val eventDates: MutableList<Calendar> = mutableListOf()
    private var addMeetupDialog: AlertDialog? = null
    @Inject
    lateinit var meetupRepository: MeetupRepository

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentEnterpriseCalendarBinding.inflate(inflater, container, false)
        start = Calendar.getInstance()
        end = Calendar.getInstance()
        return binding.root
    }

    fun String.isValidWebLink(): Boolean {
        val toCheck = when {
            startsWith("http://",  ignoreCase = true) || startsWith("https://", ignoreCase = true) -> this
            else -> "http://$this"
        }
        return try {
            val url = URL(toCheck)
            url.host.contains(".")
        } catch (e: MalformedURLException) {
            false
        }
    }

    private fun showMeetupAlert() {
        if (addMeetupDialog?.isShowing == true) return
        val addMeetupBinding = AddMeetupBinding.inflate(layoutInflater)
        setDatePickerListener(addMeetupBinding.tvStartDate, start, end)
        setDatePickerListener(addMeetupBinding.tvEndDate, end, null)
        setTimePicker(addMeetupBinding.tvStartTime)
        setTimePicker(addMeetupBinding.tvEndTime)
        if (!::clickedCalendar.isInitialized) {
            clickedCalendar = Calendar.getInstance()
        }
        addMeetupDialog = AlertDialog.Builder(requireActivity()).setView(addMeetupBinding.root).create()
        addMeetupBinding.btnSave.setOnClickListener {
            val title = "${addMeetupBinding.etTitle.text.trim()}"
            val link = "${addMeetupBinding.etLink.text.trim()}"
            val description = "${addMeetupBinding.etDescription.text.trim()}"
            val location = "${addMeetupBinding.etLocation.text.trim()}"
            if (title.isEmpty()) {
                Utilities.toast(activity, getString(R.string.title_is_required))
            } else if (description.isEmpty()) {
                Utilities.toast(activity, getString(R.string.description_is_required))
            } else if (!link.isValidWebLink() && link.isNotEmpty()) {
                Utilities.toast(activity, getString(R.string.invalid_url))
            } else {
                try {
                    if (!mRealm.isInTransaction) {
                        mRealm.beginTransaction()
                    }
                    val defaultPlaceholder = getString(R.string.click_here_to_pick_time)
                    val meetup = mRealm.createObject(RealmMeetup::class.java, "${UUID.randomUUID()}")
                    meetup.title = title
                    meetup.meetupLink = link
                    meetup.description = description
                    meetup.meetupLocation = location
                    meetup.creator = user?.name
                    meetup.startDate = start.timeInMillis
                    meetup.endDate = end.timeInMillis
                    if (addMeetupBinding.tvStartTime.text == defaultPlaceholder) {
                        meetup.startTime = ""
                    } else {
                        meetup.startTime = "${addMeetupBinding.tvStartTime.text}"
                    }
                    if (addMeetupBinding.tvEndTime.text == defaultPlaceholder) {
                        meetup.endTime = ""
                    } else {
                        meetup.endTime = "${addMeetupBinding.tvEndTime.text}"
                    }
                    meetup.createdDate = System.currentTimeMillis()
                    meetup.sourcePlanet = team?.teamPlanetCode
                    val jo = JsonObject()
                    jo.addProperty("type", "local")
                    jo.addProperty("planetCode", team?.teamPlanetCode)
                    meetup.sync = Gson().toJson(jo)
                    val rb = addMeetupBinding.rgRecuring.findViewById<RadioButton>(addMeetupBinding.rgRecuring.checkedRadioButtonId)
                    if (rb != null) {
                        meetup.recurring = "${rb.text}"
                    }
                    val ob = JsonObject()
                    ob.addProperty("teams", teamId)
                    meetup.link = Gson().toJson(ob)
                    meetup.teamId = teamId
                    mRealm.commitTransaction()
                    Utilities.toast(activity, getString(R.string.meetup_added))
                    addMeetupDialog?.dismiss()
                    refreshCalendarView()
                } catch (e: Exception) {
                    mRealm.cancelTransaction()
                    e.printStackTrace()
                    Utilities.toast(activity, getString(R.string.meetup_not_added))
                }
            }
        }

        addMeetupBinding.btnCancel.setOnClickListener {
            addMeetupDialog?.dismiss()
        }

        addMeetupDialog?.setOnDismissListener {
            if (selectedDates.contains(clickedCalendar)) {
                selectedDates.remove(clickedCalendar)
                refreshCalendarView()
            }
        }
        addMeetupDialog?.show()
        addMeetupDialog?.window?.setBackgroundDrawableResource(R.color.card_bg)
    }

    private fun setDatePickerListener(view: TextView, date: Calendar?, endDate: Calendar?) {
        val initCal = date ?: Calendar.getInstance()
        if (date != null && endDate != null) {
            view.text = date.timeInMillis.let { it1 -> TimeUtils.formatDate(it1, "yyyy-MM-dd") }
        }
        view.setOnClickListener {
            DatePickerDialog(requireActivity(), { _, year, monthOfYear, dayOfMonth ->
                date?.set(Calendar.YEAR, year)
                date?.set(Calendar.MONTH, monthOfYear)
                date?.set(Calendar.DAY_OF_MONTH, dayOfMonth)
                view.text = date?.timeInMillis?.let { it1 -> TimeUtils.formatDate(it1, "yyyy-MM-dd") }
            }, initCal.get(Calendar.YEAR),
                initCal.get(Calendar.MONTH),
                initCal.get(Calendar.DAY_OF_MONTH)).show()
        }
    }

    private fun setTimePicker(time: TextView) {
        val c = Calendar.getInstance()
        time.setOnClickListener {
            val timePickerDialog = TimePickerDialog(
                activity, { _, hourOfDay, minute ->
                    time.text = String.format(Locale.getDefault(), "%02d:%02d", hourOfDay, minute) },
                c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), true)
            timePickerDialog.show()
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        list = mutableListOf()
        calendar = binding.calendarView
        calendarEventsMap = mutableMapOf()
        setupCalendarClickListener()
    }

    override fun onResume() {
        super.onResume()
        setupCalendarClickListener()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    private fun setupCalendarClickListener(){
        binding.calendarView.setOnCalendarDayClickListener(object : OnCalendarDayClickListener {
            override fun onClick(calendarDay: CalendarDay) {
                lifecycleScope.launch {
                    meetupList = meetupRepository.getMeetupsForTeam(teamId)
                    clickedCalendar = calendarDay.calendar
                    val clickedDateInMillis = clickedCalendar.timeInMillis
                    val clickedDate = Instant.ofEpochMilli(clickedDateInMillis)
                        .atZone(ZoneId.systemDefault())
                        .toLocalDate()

                    val markedDates = meetupList.filter { meetup ->
                        val meetupDate = Instant.ofEpochMilli(meetup.startDate)
                            .atZone(ZoneId.systemDefault())
                            .toLocalDate()
                        meetupDate == clickedDate
                    }

                    if (markedDates.isNotEmpty()) {
                        showMeetupDialog(markedDates)
                    } else {
                        if(arguments?.getBoolean("fromLogin", false) != false || user?.id?.startsWith("guest") == true){
                            binding.calendarView.selectedDates = eventDates
                        } else{
                            start = clickedCalendar.clone() as Calendar
                            end = clickedCalendar.clone() as Calendar
                            showMeetupAlert()
                        }
                    }
                    if (!selectedDates.contains(clickedCalendar)) {
                        selectedDates.add(clickedCalendar)
                    } else {
                        selectedDates.remove(clickedCalendar)
                    }
                }
            }
        })
        refreshCalendarView()
    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun getCardViewHeight(context: Context): Int {
        val view = LayoutInflater.from(context).inflate(R.layout.item_meetup, null)
        view.measure(
            View.MeasureSpec.makeMeasureSpec(Resources.getSystem().displayMetrics.widthPixels, View.MeasureSpec.AT_MOST),
            View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
        )
        return view.measuredHeight
    }

    private fun showMeetupDialog(meetupList: List<RealmMeetup>) {
        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.meetup_dialog, null)
        val recyclerView = dialogView.findViewById<RecyclerView>(R.id.rvMeetups)
        val dialogTitle = dialogView.findViewById< TextView>(R.id.tvTitle)
        val dateFormat = SimpleDateFormat("EEE, MMM d, yyyy", Locale.getDefault())
        dialogTitle.text = dateFormat.format(clickedCalendar.time)
        val extraHeight = TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_DIP, 12f, resources.displayMetrics
        ).toInt()
        val cardHeight = getCardViewHeight(requireContext())
        recyclerView.layoutParams.height = cardHeight + extraHeight
        recyclerView.requestLayout()
        recyclerView.layoutManager = LinearLayoutManager(requireContext())
        val adapter = AdapterMeetup()
        recyclerView.adapter = adapter
        adapter.submitList(meetupList)

        val dialog = AlertDialog.Builder(requireContext())
            .setView(dialogView)
            .create()
        val btnAdd = dialogView.findViewById<Button>(R.id.btnadd)
        if (arguments?.getBoolean("fromLogin", false) != true) {
            btnAdd.visibility = View.VISIBLE
        } else {
            btnAdd.visibility = View.GONE
        }
        dialogView.findViewById<Button>(R.id.btnClose).setOnClickListener {
            dialog.dismiss()
        }
        btnAdd.setOnClickListener {
            if(arguments?.getBoolean("fromLogin", false) != true){
                start = clickedCalendar
                end = clickedCalendar
                showMeetupAlert()
            }
        }

        dialog.setOnDismissListener {
            eventDates.add(clickedCalendar)
            lifecycleScope.launch {
                binding.calendarView.selectedDates = emptyList()
                binding.calendarView.selectedDates = eventDates.toList()
            }
            binding.calendarView.selectedDates = eventDates
        }

        dialog.show()
    }

    private fun refreshCalendarView() {
        if (teamId.isEmpty()) {
            return
        }
        viewLifecycleOwner.lifecycleScope.launch {
            val newDates = meetupRepository.getMeetupsForTeam(teamId).mapTo(mutableListOf()) { meetup ->
                val calendarInstance = Calendar.getInstance()
                calendarInstance.timeInMillis = meetup.startDate
                calendarInstance
            }

            if (isAdded && activity != null) {
                eventDates.clear()
                eventDates.addAll(newDates)
                binding.calendarView.selectedDates = ArrayList(newDates)
            }
        }
    }


}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/PlanFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team

import android.app.AlertDialog
import android.content.Context
import android.os.Bundle
import android.text.Html
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.isVisible
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.TeamUpdateListener
import org.ole.planet.myplanet.databinding.AlertCreateTeamBinding
import org.ole.planet.myplanet.databinding.FragmentPlanBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities

class PlanFragment : BaseTeamFragment() {
    private var _binding: FragmentPlanBinding? = null
    private val binding get() = _binding!!
    private var isEnterprise: Boolean = false
    private var teamUpdateListener: TeamUpdateListener? = null

    fun setTeamUpdateListener(listener: TeamUpdateListener) {
        teamUpdateListener = listener
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentPlanBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                teamFlow.collect { updatedTeam ->
                    if (updatedTeam != null) {
                        updateUIWithTeamData(updatedTeam)
                        updateButtonVisibility(updatedTeam)
                    }
                }
            }
        }

        if (team != null) {
            updateUIWithTeamData(team)
            updateButtonVisibility(team!!)
        }
    }

    private fun updateButtonVisibility(currentTeam: RealmMyTeam) {
        val isMyTeam = RealmMyTeam.isTeamLeader(currentTeam._id, user?.id, mRealm)
        isEnterprise = currentTeam.type?.equals("enterprise", ignoreCase = true) == true

        binding.btnAddPlan.text = if (isEnterprise) {
            getString(R.string.edit_mission_and_services)
        } else {
            getString(R.string.edit_plan)
        }

        binding.btnAddPlan.isVisible = isMyTeam
        binding.btnAddPlan.isEnabled = isMyTeam

        binding.btnAddPlan.setOnClickListener {
            if (isMyTeam) {
                editTeam()
            }
        }
    }

    private fun editTeam() {
        if (!isAdded) {
            return
        }
        team?.let {
            showCreateTeamDialog(requireContext(), requireActivity(), it)
        }
    }

    private fun showCreateTeamDialog(context: Context, activity: FragmentActivity, team: RealmMyTeam) {
        val alertCreateTeamBinding = AlertCreateTeamBinding.inflate(LayoutInflater.from(context))
        setupDialogFields(alertCreateTeamBinding, team)

        val dialog = AlertDialog.Builder(activity, R.style.AlertDialogTheme)
            .setTitle("${context.getString(R.string.enter)} ${team.type} ${context.getString(R.string.detail)}")
            .setView(alertCreateTeamBinding.root)
            .setPositiveButton(context.getString(R.string.save), null)
            .setNegativeButton(context.getString(R.string.cancel), null)
            .create()

        dialog.setOnShowListener {
            dialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener {
                handleSaveButtonClick(alertCreateTeamBinding, activity, context, team, dialog)
            }
        }
        dialog.show()
    }

    private fun setupDialogFields(binding: AlertCreateTeamBinding, team: RealmMyTeam) {
        binding.spnTeamType.visibility = if (isEnterprise) View.GONE else View.VISIBLE
        binding.etServices.visibility = if (isEnterprise) View.VISIBLE else View.GONE
        binding.etRules.visibility = if (isEnterprise) View.VISIBLE else View.GONE
        binding.etDescription.hint = requireContext().getString(
            if (isEnterprise) R.string.entMission else R.string.what_is_your_team_s_plan
        )
        binding.etName.hint = requireContext().getString(
            if (isEnterprise) R.string.enter_enterprise_s_name else R.string.enter_team_s_name
        )

        binding.etServices.setText(team.services)
        binding.etRules.setText(team.rules)
        binding.etDescription.setText(team.description)
        binding.etName.setText(team.name)

        val teamTypePosition = when (team.teamType) {
            "local" -> 0
            "sync" -> 1
            else -> 0
        }
        binding.spnTeamType.setSelection(teamTypePosition)
        binding.switchPublic.isChecked = team.isPublic
    }

    private fun handleSaveButtonClick(
        binding: AlertCreateTeamBinding,
        activity: FragmentActivity,
        context: Context,
        team: RealmMyTeam,
        dialog: AlertDialog,
    ) {
        val name = binding.etName.text.toString().trim()
        if (name.isEmpty()) {
            Utilities.toast(activity, context.getString(R.string.name_is_required))
            binding.etName.error = context.getString(R.string.please_enter_a_name)
            return
        }

        val userId = user?.id ?: return
        val createdBy = userId
        val teamIdentifier = team._id?.takeIf { it.isNotBlank() }
            ?: team.teamId?.takeIf { it.isNotBlank() }
        if (teamIdentifier == null) {
            Utilities.toast(activity, context.getString(R.string.failed_to_add_please_retry))
            return
        }
        val servicesToSave = binding.etServices.text.toString()
        val rulesToSave = binding.etRules.text.toString()
        val descriptionToSave = binding.etDescription.text.toString()
        val teamType = when (binding.spnTeamType.selectedItemPosition) {
            0 -> "local"
            1 -> "sync"
            else -> ""
        }
        val isPublic = binding.switchPublic.isChecked

        viewLifecycleOwner.lifecycleScope.launch {
            try {
                val wasUpdated = teamRepository.updateTeamDetails(
                    teamId = teamIdentifier,
                    name = name,
                    description = descriptionToSave,
                    services = servicesToSave,
                    rules = rulesToSave,
                    teamType = teamType,
                    isPublic = isPublic,
                    createdBy = createdBy,
                )

                if (wasUpdated) {
                    val refreshedTeam = teamRepository.getTeamByDocumentIdOrTeamId(teamIdentifier)
                        ?: (this@PlanFragment.team ?: team)

                    refreshedTeam.apply {
                        this.name = name
                        this.services = servicesToSave
                        this.rules = rulesToSave
                        this.description = descriptionToSave
                        this.teamType = teamType
                        this.isPublic = isPublic
                        this.createdBy = createdBy.takeIf { it.isNotBlank() } ?: this.createdBy
                        this.updated = true
                    }

                    this@PlanFragment.team = refreshedTeam
                    updateUIWithTeamData(refreshedTeam)
                    teamUpdateListener?.onTeamDetailsUpdated()
                    Utilities.toast(requireContext(), context.getString(R.string.added_successfully))
                    dialog.dismiss()
                } else {
                    Utilities.toast(requireContext(), context.getString(R.string.failed_to_add_please_retry))
                }
            } catch (e: Exception) {
                Utilities.toast(requireContext(), context.getString(R.string.failed_to_add_please_retry))
            }
        }
    }

    private fun updateUIWithTeamData(updatedTeam: RealmMyTeam?) {
        if (updatedTeam == null) return
        isEnterprise = updatedTeam.type?.equals("enterprise", ignoreCase = true) == true

        val missionText = formatTeamDetail(updatedTeam.description,
            getString(if (isEnterprise) R.string.entMission else R.string.what_is_your_team_s_plan)
        )
        val servicesText = formatTeamDetail(updatedTeam.services,
            if (isEnterprise) getString(R.string.entServices) else ""
        )
        val rulesText = formatTeamDetail(updatedTeam.rules,
            if (isEnterprise) getString(R.string.entRules) else ""
        )

        val finalText = if (missionText.isEmpty() && servicesText.isEmpty() && rulesText.isEmpty()) {
            "<br/>" + (if (isEnterprise) getString(R.string.entEmptyDescription) else getString(R.string.this_team_has_no_description_defined)) + "<br/>"
        } else {
            missionText + servicesText + rulesText
        }

        binding.tvDescription.text = Html.fromHtml(finalText, Html.FROM_HTML_MODE_LEGACY)
        binding.tvDate.text = getString(
            R.string.two_strings,
            getString(R.string.created_on),
            updatedTeam.createdDate?.let { formatDate(it) }
        )
    }

    private fun formatTeamDetail(detail: String?, title: String): String {
        if (detail?.trim().isNullOrEmpty()) return ""
        val formattedDetail = detail?.replace("\n", "<br/>")
        return "<b>$title</b><br/>$formattedDetail<br/><br/>"    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.team


import android.app.AlertDialog
import android.content.Context
import android.os.Bundle
import android.text.Html
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.isVisible
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.TeamUpdateListener
import org.ole.planet.myplanet.databinding.AlertCreateTeamBinding
import org.ole.planet.myplanet.databinding.FragmentPlanBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities

class PlanFragment : BaseTeamFragment() {
    private var _binding: FragmentPlanBinding? = null
    private val binding get() = _binding!!
    private var isEnterprise: Boolean = false
    private var teamUpdateListener: TeamUpdateListener? = null

    fun setTeamUpdateListener(listener: TeamUpdateListener) {
        teamUpdateListener = listener
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentPlanBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                teamFlow.collect { updatedTeam ->
                    if (updatedTeam != null) {
                        updateUIWithTeamData(updatedTeam)
                        updateButtonVisibility(updatedTeam)
                    }
                }
            }
        }

        if (team != null) {
            updateUIWithTeamData(team)
            updateButtonVisibility(team!!)
        }
    }

    private fun updateButtonVisibility(currentTeam: RealmMyTeam) {
        val isMyTeam = RealmMyTeam.isTeamLeader(currentTeam._id, user?.id, mRealm)
        isEnterprise = currentTeam.type?.equals("enterprise", ignoreCase = true) == true

        binding.btnAddPlan.text = if (isEnterprise) {
            getString(R.string.edit_mission_and_services)
        } else {
            getString(R.string.edit_plan)
        }

        binding.btnAddPlan.isVisible = isMyTeam
        binding.btnAddPlan.isEnabled = isMyTeam

        binding.btnAddPlan.setOnClickListener {
            if (isMyTeam) {
                editTeam()
            }
        }
    }

    private fun editTeam() {
        if (!isAdded) {
            return
        }
        team?.let {
            showCreateTeamDialog(requireContext(), requireActivity(), it)
        }
    }

    private fun showCreateTeamDialog(context: Context, activity: FragmentActivity, team: RealmMyTeam) {
        val alertCreateTeamBinding = AlertCreateTeamBinding.inflate(LayoutInflater.from(context))
        setupDialogFields(alertCreateTeamBinding, team)

        val dialog = AlertDialog.Builder(activity, R.style.AlertDialogTheme)
            .setTitle("${context.getString(R.string.enter)} ${team.type} ${context.getString(R.string.detail)}")
            .setView(alertCreateTeamBinding.root)
            .setPositiveButton(context.getString(R.string.save), null)
            .setNegativeButton(context.getString(R.string.cancel), null)
            .create()

        dialog.setOnShowListener {
            dialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener {
                handleSaveButtonClick(alertCreateTeamBinding, activity, context, team, dialog)
            }
        }
        dialog.show()
    }

    private fun setupDialogFields(binding: AlertCreateTeamBinding, team: RealmMyTeam) {
        binding.spnTeamType.visibility = if (isEnterprise) View.GONE else View.VISIBLE
        binding.etServices.visibility = if (isEnterprise) View.VISIBLE else View.GONE
        binding.etRules.visibility = if (isEnterprise) View.VISIBLE else View.GONE
        binding.etDescription.hint = requireContext().getString(
            if (isEnterprise) R.string.entMission else R.string.what_is_your_team_s_plan
        )
        binding.etName.hint = requireContext().getString(
            if (isEnterprise) R.string.enter_enterprise_s_name else R.string.enter_team_s_name
        )

        binding.etServices.setText(team.services)
        binding.etRules.setText(team.rules)
        binding.etDescription.setText(team.description)
        binding.etName.setText(team.name)

        val teamTypePosition = when (team.teamType) {
            "local" -> 0
            "sync" -> 1
            else -> 0
        }
        binding.spnTeamType.setSelection(teamTypePosition)
        binding.switchPublic.isChecked = team.isPublic
    }

    private fun handleSaveButtonClick(
        binding: AlertCreateTeamBinding,
        activity: FragmentActivity,
        context: Context,
        team: RealmMyTeam,
        dialog: AlertDialog,
    ) {
        val name = binding.etName.text.toString().trim()
        if (name.isEmpty()) {
            Utilities.toast(activity, context.getString(R.string.name_is_required))
            binding.etName.error = context.getString(R.string.please_enter_a_name)
            return
        }

        val userId = user?.id ?: return
        val createdBy = userId
        val teamIdentifier = team._id?.takeIf { it.isNotBlank() }
            ?: team.teamId?.takeIf { it.isNotBlank() }
        if (teamIdentifier == null) {
            Utilities.toast(activity, context.getString(R.string.failed_to_add_please_retry))
            return
        }
        val servicesToSave = binding.etServices.text.toString()
        val rulesToSave = binding.etRules.text.toString()
        val descriptionToSave = binding.etDescription.text.toString()
        val teamType = when (binding.spnTeamType.selectedItemPosition) {
            0 -> "local"
            1 -> "sync"
            else -> ""
        }
        val isPublic = binding.switchPublic.isChecked

        viewLifecycleOwner.lifecycleScope.launch {
            try {
                val wasUpdated = teamRepository.updateTeamDetails(
                    teamId = teamIdentifier,
                    name = name,
                    description = descriptionToSave,
                    services = servicesToSave,
                    rules = rulesToSave,
                    teamType = teamType,
                    isPublic = isPublic,
                    createdBy = createdBy,
                )

                if (wasUpdated) {
                    val refreshedTeam = teamRepository.getTeamByDocumentIdOrTeamId(teamIdentifier)
                        ?: (this@PlanFragment.team ?: team)

                    refreshedTeam.apply {
                        this.name = name
                        this.services = servicesToSave
                        this.rules = rulesToSave
                        this.description = descriptionToSave
                        this.teamType = teamType
                        this.isPublic = isPublic
                        this.createdBy = createdBy.takeIf { it.isNotBlank() } ?: this.createdBy
                        this.updated = true
                    }

                    this@PlanFragment.team = refreshedTeam
                    updateUIWithTeamData(refreshedTeam)
                    teamUpdateListener?.onTeamDetailsUpdated()
                    Utilities.toast(requireContext(), context.getString(R.string.added_successfully))
                    dialog.dismiss()
                } else {
                    Utilities.toast(requireContext(), context.getString(R.string.failed_to_add_please_retry))
                }
            } catch (e: Exception) {
                Utilities.toast(requireContext(), context.getString(R.string.failed_to_add_please_retry))
            }
        }
    }

    private fun updateUIWithTeamData(updatedTeam: RealmMyTeam?) {
        if (updatedTeam == null) return
        isEnterprise = updatedTeam.type?.equals("enterprise", ignoreCase = true) == true

        val missionText = formatTeamDetail(updatedTeam.description,
            getString(if (isEnterprise) R.string.entMission else R.string.what_is_your_team_s_plan)
        )
        val servicesText = formatTeamDetail(updatedTeam.services,
            if (isEnterprise) getString(R.string.entServices) else ""
        )
        val rulesText = formatTeamDetail(updatedTeam.rules,
            if (isEnterprise) getString(R.string.entRules) else ""
        )

        val finalText = if (missionText.isEmpty() && servicesText.isEmpty() && rulesText.isEmpty()) {
            "<br/>" + (if (isEnterprise) getString(R.string.entEmptyDescription) else getString(R.string.this_team_has_no_description_defined)) + "<br/>"
        } else {
            missionText + servicesText + rulesText
        }

        binding.tvDescription.text = Html.fromHtml(finalText, Html.FROM_HTML_MODE_LEGACY)
        binding.tvDate.text = getString(
            R.string.two_strings,
            getString(R.string.created_on),
            updatedTeam.createdDate?.let { formatDate(it) }
        )
    }

    private fun formatTeamDetail(detail: String?, title: String): String {
        if (detail?.trim().isNullOrEmpty()) return ""
        val formattedDetail = detail?.replace("\n", "<br/>")
        return "<b>$title</b><br/>$formattedDetail<br/><br/>"    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamResource/AdapterTeamResource.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamResource

import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.RowTeamResourceBinding
import org.ole.planet.myplanet.model.RealmMyLibrary

class AdapterTeamResource(
    private val context: Context,
    private val list: MutableList<RealmMyLibrary>,
    private val canRemoveResources: Boolean,
    private val updateListener: ResourceUpdateListner,
    private val onRemoveResource: (RealmMyLibrary, Int) -> Unit,
) : RecyclerView.Adapter<AdapterTeamResource.ViewHolderTeamResource>() {

    private var listener: OnHomeItemClickListener? = null

    init {
        if (context is OnHomeItemClickListener) {
            listener = context
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderTeamResource {
        val binding = RowTeamResourceBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderTeamResource(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderTeamResource, position: Int) {
        val adapterPosition = holder.bindingAdapterPosition
        if (adapterPosition == RecyclerView.NO_POSITION) return

        val resource = list[adapterPosition]

        holder.binding.apply {
            tvTitle.text = resource.title
            tvDescription.text = resource.description

            root.setOnClickListener {
                listener?.openLibraryDetailFragment(resource)
            }

            ivRemove.apply {
                visibility = if (canRemoveResources) View.VISIBLE else View.GONE
                setOnClickListener {
                    val currentPosition = holder.bindingAdapterPosition
                    if (currentPosition != RecyclerView.NO_POSITION) {
                        onRemoveResource(list[currentPosition], currentPosition)
                    }
                }
            }
        }
    }

    override fun getItemCount(): Int {
        return list.size
    }

    fun removeResourceAt(position: Int) {
        if (position < 0 || position >= list.size) return
        list.removeAt(position)
        notifyItemRemoved(position)
        updateListener.onResourceListUpdated()
    }

    class ViewHolderTeamResource(val binding: RowTeamResourceBinding) : RecyclerView.ViewHolder(binding.root)
}
=======
package org.ole.planet.myplanet.ui.team.teamResource


import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.RowTeamResourceBinding
import org.ole.planet.myplanet.model.RealmMyLibrary

class AdapterTeamResource(
    private val context: Context,
    private val list: MutableList<RealmMyLibrary>,
    private val canRemoveResources: Boolean,
    private val updateListener: ResourceUpdateListner,
    private val onRemoveResource: (RealmMyLibrary, Int) -> Unit,
) : RecyclerView.Adapter<AdapterTeamResource.ViewHolderTeamResource>() {

    private var listener: OnHomeItemClickListener? = null

    init {
        if (context is OnHomeItemClickListener) {
            listener = context
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderTeamResource {
        val binding = RowTeamResourceBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderTeamResource(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderTeamResource, position: Int) {
        val adapterPosition = holder.bindingAdapterPosition
        if (adapterPosition == RecyclerView.NO_POSITION) return

        val resource = list[adapterPosition]

        holder.binding.apply {
            tvTitle.text = resource.title
            tvDescription.text = resource.description

            root.setOnClickListener {
                listener?.openLibraryDetailFragment(resource)
            }

            ivRemove.apply {
                visibility = if (canRemoveResources) View.VISIBLE else View.GONE
                setOnClickListener {
                    val currentPosition = holder.bindingAdapterPosition
                    if (currentPosition != RecyclerView.NO_POSITION) {
                        onRemoveResource(list[currentPosition], currentPosition)
                    }
                }
            }
        }
    }

    override fun getItemCount(): Int {
        return list.size
    }

    fun removeResourceAt(position: Int) {
        if (position < 0 || position >= list.size) return
        list.removeAt(position)
        notifyItemRemoved(position)
        updateListener.onResourceListUpdated()
    }

    class ViewHolderTeamResource(val binding: RowTeamResourceBinding) : RecyclerView.ViewHolder(binding.root)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamResource/TeamResourceFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamResource

import android.content.DialogInterface
import android.graphics.Typeface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ListView
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.view.isVisible
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.GridLayoutManager
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.TeamPageListener
import org.ole.planet.myplanet.databinding.FragmentTeamResourceBinding
import org.ole.planet.myplanet.databinding.MyLibraryAlertdialogBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.utilities.CheckboxListView

@AndroidEntryPoint
class TeamResourceFragment : BaseTeamFragment(), TeamPageListener, ResourceUpdateListner {
    private var _binding: FragmentTeamResourceBinding? = null
    private val binding get() = _binding!!
    private lateinit var adapterLibrary: AdapterTeamResource

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamResourceBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        showLibraryList()
        binding.fabAddResource.isVisible = false
        binding.fabAddResource.setOnClickListener { showResourceListDialog() }

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                isMemberFlow.collectLatest { isMember ->
                    binding.fabAddResource.isVisible = isMember
                }
            }
        }
    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun showLibraryList() {
        if (!isAdded || activity == null) return
        val safeActivity = activity ?: return

        viewLifecycleOwner.lifecycleScope.launch {
            val libraries = teamRepository.getTeamResources(teamId).toMutableList()
            val canRemoveResources = teamRepository.isTeamLeader(teamId, user?.id)
            adapterLibrary = AdapterTeamResource(
                safeActivity,
                libraries,
                canRemoveResources,
                this@TeamResourceFragment,
            ) { resource, position ->
                handleResourceRemoval(resource, position)
            }
            binding.rvResource.layoutManager = GridLayoutManager(safeActivity, 3)
            binding.rvResource.adapter = adapterLibrary
            checkAndShowNoData()
        }
    }

    private fun showResourceListDialog() {
        if (!isAdded || activity == null) return
        val safeActivity = activity ?: return

        viewLifecycleOwner.lifecycleScope.launch {
            val existing = teamRepository.getTeamResources(teamId)
            val existingIds = existing.mapNotNull { it._id }
            val availableLibraries = libraryRepository.getAllLibraryItems()
                .filter { it._id !in existingIds }

            val titleView = TextView(safeActivity).apply {
                text = getString(R.string.select_resource)
                setTextColor(context.getColor(R.color.daynight_textColor))
                setPadding(75, 50, 0, 0)
                textSize = 24f
                typeface = Typeface.DEFAULT_BOLD
            }

            val myLibraryAlertdialogBinding = MyLibraryAlertdialogBinding.inflate(layoutInflater)
            val alertDialogBuilder = AlertDialog.Builder(safeActivity)
                .setCustomTitle(titleView)

            alertDialogBuilder.setView(myLibraryAlertdialogBinding.root)
                .setPositiveButton(R.string.add) { _: DialogInterface?, _: Int ->
                    val selectedResources = myLibraryAlertdialogBinding.alertDialogListView.selectedItemsList
                        .map { index -> availableLibraries[index] }
                    viewLifecycleOwner.lifecycleScope.launch {
                        teamRepository.addResourceLinks(teamId, selectedResources, user)
                        showLibraryList()
                    }
                }.setNegativeButton(R.string.cancel, null)

            val alertDialog = alertDialogBuilder.create()
            alertDialog.window?.setBackgroundDrawableResource(R.color.card_bg)
            listSetting(alertDialog, availableLibraries, myLibraryAlertdialogBinding.alertDialogListView)
        }
    }

    private fun listSetting(alertDialog: AlertDialog, libraries: List<RealmMyLibrary>, lv: CheckboxListView) {
        val names = libraries.map { it.title }
        val adapter = ArrayAdapter(requireActivity(), R.layout.rowlayout, R.id.checkBoxRowLayout, names)
        lv.choiceMode = ListView.CHOICE_MODE_MULTIPLE
        lv.setCheckChangeListener {
            alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = lv.selectedItemsList.isNotEmpty()
        }
        lv.adapter = adapter
        alertDialog.show()
        alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = lv.selectedItemsList.isNotEmpty()
    }

    fun checkAndShowNoData() {
        showNoData(binding.tvNodata, adapterLibrary.itemCount, "teamResources")
    }

    override fun onResourceListUpdated() {
        checkAndShowNoData()
    }

    override fun onResourceUpdateFailed(messageResId: Int) {
        view?.let {
            Snackbar.make(it, getString(messageResId), Snackbar.LENGTH_LONG).show()
        }
    }

    private fun handleResourceRemoval(resource: RealmMyLibrary, position: Int) {
        val resourceId = resource.id ?: resource.resourceId
        if (resourceId.isNullOrBlank()) {
            onResourceUpdateFailed(R.string.failed_to_remove_resource)
            return
        }
        viewLifecycleOwner.lifecycleScope.launch {
            runCatching {
                teamRepository.removeResourceLink(teamId, resourceId)
            }.onSuccess {
                adapterLibrary.removeResourceAt(position)
            }.onFailure {
                onResourceUpdateFailed(R.string.failed_to_remove_resource)
            }
        }
    }

    override fun onAddDocument() {
        showResourceListDialog()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
=======
package org.ole.planet.myplanet.ui.team.teamResource


import android.content.DialogInterface
import android.graphics.Typeface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ListView
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.view.isVisible
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.GridLayoutManager
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.TeamPageListener
import org.ole.planet.myplanet.databinding.FragmentTeamResourceBinding
import org.ole.planet.myplanet.databinding.MyLibraryAlertdialogBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.utilities.CheckboxListView

@AndroidEntryPoint
class TeamResourceFragment : BaseTeamFragment(), TeamPageListener, ResourceUpdateListner {
    private var _binding: FragmentTeamResourceBinding? = null
    private val binding get() = _binding!!
    private lateinit var adapterLibrary: AdapterTeamResource

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTeamResourceBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        showLibraryList()
        binding.fabAddResource.isVisible = false
        binding.fabAddResource.setOnClickListener { showResourceListDialog() }

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                isMemberFlow.collectLatest { isMember ->
                    binding.fabAddResource.isVisible = isMember
                }
            }
        }
    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun showLibraryList() {
        if (!isAdded || activity == null) return
        val safeActivity = activity ?: return

        viewLifecycleOwner.lifecycleScope.launch {
            val libraries = teamRepository.getTeamResources(teamId).toMutableList()
            val canRemoveResources = teamRepository.isTeamLeader(teamId, user?.id)
            adapterLibrary = AdapterTeamResource(
                safeActivity,
                libraries,
                canRemoveResources,
                this@TeamResourceFragment,
            ) { resource, position ->
                handleResourceRemoval(resource, position)
            }
            binding.rvResource.layoutManager = GridLayoutManager(safeActivity, 3)
            binding.rvResource.adapter = adapterLibrary
            checkAndShowNoData()
        }
    }

    private fun showResourceListDialog() {
        if (!isAdded || activity == null) return
        val safeActivity = activity ?: return

        viewLifecycleOwner.lifecycleScope.launch {
            val existing = teamRepository.getTeamResources(teamId)
            val existingIds = existing.mapNotNull { it._id }
            val availableLibraries = libraryRepository.getAllLibraryItems()
                .filter { it._id !in existingIds }

            val titleView = TextView(safeActivity).apply {
                text = getString(R.string.select_resource)
                setTextColor(context.getColor(R.color.daynight_textColor))
                setPadding(75, 50, 0, 0)
                textSize = 24f
                typeface = Typeface.DEFAULT_BOLD
            }

            val myLibraryAlertdialogBinding = MyLibraryAlertdialogBinding.inflate(layoutInflater)
            val alertDialogBuilder = AlertDialog.Builder(safeActivity)
                .setCustomTitle(titleView)

            alertDialogBuilder.setView(myLibraryAlertdialogBinding.root)
                .setPositiveButton(R.string.add) { _: DialogInterface?, _: Int ->
                    val selectedResources = myLibraryAlertdialogBinding.alertDialogListView.selectedItemsList
                        .map { index -> availableLibraries[index] }
                    viewLifecycleOwner.lifecycleScope.launch {
                        teamRepository.addResourceLinks(teamId, selectedResources, user)
                        showLibraryList()
                    }
                }.setNegativeButton(R.string.cancel, null)

            val alertDialog = alertDialogBuilder.create()
            alertDialog.window?.setBackgroundDrawableResource(R.color.card_bg)
            listSetting(alertDialog, availableLibraries, myLibraryAlertdialogBinding.alertDialogListView)
        }
    }

    private fun listSetting(alertDialog: AlertDialog, libraries: List<RealmMyLibrary>, lv: CheckboxListView) {
        val names = libraries.map { it.title }
        val adapter = ArrayAdapter(requireActivity(), R.layout.rowlayout, R.id.checkBoxRowLayout, names)
        lv.choiceMode = ListView.CHOICE_MODE_MULTIPLE
        lv.setCheckChangeListener {
            alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = lv.selectedItemsList.isNotEmpty()
        }
        lv.adapter = adapter
        alertDialog.show()
        alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = lv.selectedItemsList.isNotEmpty()
    }

    fun checkAndShowNoData() {
        showNoData(binding.tvNodata, adapterLibrary.itemCount, "teamResources")
    }

    override fun onResourceListUpdated() {
        checkAndShowNoData()
    }

    override fun onResourceUpdateFailed(messageResId: Int) {
        view?.let {
            Snackbar.make(it, getString(messageResId), Snackbar.LENGTH_LONG).show()
        }
    }

    private fun handleResourceRemoval(resource: RealmMyLibrary, position: Int) {
        val resourceId = resource.id ?: resource.resourceId
        if (resourceId.isNullOrBlank()) {
            onResourceUpdateFailed(R.string.failed_to_remove_resource)
            return
        }
        viewLifecycleOwner.lifecycleScope.launch {
            runCatching {
                teamRepository.removeResourceLink(teamId, resourceId)
            }.onSuccess {
                adapterLibrary.removeResourceAt(position)
            }.onFailure {
                onResourceUpdateFailed(R.string.failed_to_remove_resource)
            }
        }
    }

    override fun onAddDocument() {
        showResourceListDialog()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/BaseTeamFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team

import android.os.Bundle
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.base.BaseNewsFragment
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TeamRepository

private val Realm.isOpen: Boolean
    get() = !isClosed

@AndroidEntryPoint
abstract class BaseTeamFragment : BaseNewsFragment() {
    var user: RealmUserModel? = null
    var teamId: String = ""
        set(value) {
            if (field != value) {
                field = value
                _isMemberFlow.value = false
            }
        }
    var team: RealmMyTeam? = null
    @Inject
    lateinit var teamRepository: TeamRepository
    private val _teamFlow = MutableStateFlow<RealmMyTeam?>(null)
    val teamFlow: StateFlow<RealmMyTeam?> = _teamFlow.asStateFlow()
    private val _isMemberFlow = MutableStateFlow(false)
    val isMemberFlow: StateFlow<Boolean> = _isMemberFlow.asStateFlow()


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val sParentCode = settings.getString("parentCode", "")
        val communityName = settings.getString("communityName", "")
        mRealm = databaseService.realmInstance
        user = profileDbHandler?.userModel
        teamId = requireArguments().getString("id", "") ?: "$communityName@$sParentCode"

        loadTeamData()
    }

    override fun setData(list: List<RealmNews?>?) {}

    private fun loadTeamData() {
        val shouldQueryTeam = shouldQueryTeamFromRealm()
        val existingTeam = team
        lifecycleScope.launch(Dispatchers.IO) {
            val teamResult = if (shouldQueryTeam) {
                try {
                    teamRepository.getTeamByDocumentIdOrTeamId(teamId)
                } catch (e: IllegalArgumentException) {
                    e.printStackTrace()
                    null
                }
            } else {
                existingTeam
            }

            if (shouldQueryTeam && teamResult == null) {
                return@launch
            }

            val membership = teamRepository.isMember(user?.id, teamId)

            withContext(Dispatchers.Main) {
                teamResult?.let {
                    team = it
                }
                _teamFlow.value = teamResult ?: team
                _isMemberFlow.value = membership
            }
        }
    }

    private fun shouldQueryTeamFromRealm(): Boolean {
        val hasDirectData = requireArguments().containsKey("teamName") &&
                requireArguments().containsKey("teamType") &&
                requireArguments().containsKey("teamId")
        return !hasDirectData
    }

    protected fun getEffectiveTeamName(): String {
        return requireArguments().getString("teamName") ?: team?.name ?: ""
    }

    protected fun getEffectiveTeamType(): String {
        return requireArguments().getString("teamType") ?: team?.type ?: ""
    }

    protected fun getEffectiveTeamId(): String {
        return requireArguments().getString("teamId") ?: teamId
    }

    override fun onDestroy() {
        _isMemberFlow.value = false
        if (isRealmInitialized() && mRealm.isOpen) {
            mRealm.close()
        }
        super.onDestroy()
    }

}
=======
package org.ole.planet.myplanet.ui.team


import android.os.Bundle
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.base.BaseNewsFragment
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TeamRepository

private val Realm.isOpen: Boolean
    get() = !isClosed

@AndroidEntryPoint
abstract class BaseTeamFragment : BaseNewsFragment() {
    var user: RealmUserModel? = null
    var teamId: String = ""
        set(value) {
            if (field != value) {
                field = value
                _isMemberFlow.value = false
            }
        }
    var team: RealmMyTeam? = null
    @Inject
    lateinit var teamRepository: TeamRepository
    private val _teamFlow = MutableStateFlow<RealmMyTeam?>(null)
    val teamFlow: StateFlow<RealmMyTeam?> = _teamFlow.asStateFlow()
    private val _isMemberFlow = MutableStateFlow(false)
    val isMemberFlow: StateFlow<Boolean> = _isMemberFlow.asStateFlow()


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val sParentCode = settings.getString("parentCode", "")
        val communityName = settings.getString("communityName", "")
        mRealm = databaseService.realmInstance
        user = profileDbHandler?.userModel
        teamId = requireArguments().getString("id", "") ?: "$communityName@$sParentCode"

        loadTeamData()
    }

    override fun setData(list: List<RealmNews?>?) {}

    private fun loadTeamData() {
        val shouldQueryTeam = shouldQueryTeamFromRealm()
        val existingTeam = team
        lifecycleScope.launch(Dispatchers.IO) {
            val teamResult = if (shouldQueryTeam) {
                try {
                    teamRepository.getTeamByDocumentIdOrTeamId(teamId)
                } catch (e: IllegalArgumentException) {
                    e.printStackTrace()
                    null
                }
            } else {
                existingTeam
            }

            if (shouldQueryTeam && teamResult == null) {
                return@launch
            }

            val membership = teamRepository.isMember(user?.id, teamId)

            withContext(Dispatchers.Main) {
                teamResult?.let {
                    team = it
                }
                _teamFlow.value = teamResult ?: team
                _isMemberFlow.value = membership
            }
        }
    }

    private fun shouldQueryTeamFromRealm(): Boolean {
        val hasDirectData = requireArguments().containsKey("teamName") &&
                requireArguments().containsKey("teamType") &&
                requireArguments().containsKey("teamId")
        return !hasDirectData
    }

    protected fun getEffectiveTeamName(): String {
        return requireArguments().getString("teamName") ?: team?.name ?: ""
    }

    protected fun getEffectiveTeamType(): String {
        return requireArguments().getString("teamType") ?: team?.type ?: ""
    }

    protected fun getEffectiveTeamId(): String {
        return requireArguments().getString("teamId") ?: teamId
    }

    override fun onDestroy() {
        _isMemberFlow.value = false
        if (isRealmInitialized() && mRealm.isOpen) {
            mRealm.close()
        }
        super.onDestroy()
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/TeamPageConfig.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team

import androidx.annotation.StringRes
import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.ui.enterprises.FinanceFragment
import org.ole.planet.myplanet.ui.enterprises.ReportsFragment
import org.ole.planet.myplanet.ui.survey.SurveyFragment
import org.ole.planet.myplanet.ui.team.teamCourse.TeamCourseFragment
import org.ole.planet.myplanet.ui.team.teamDiscussion.DiscussionListFragment
import org.ole.planet.myplanet.ui.team.teamMember.JoinedMemberFragment
import org.ole.planet.myplanet.ui.team.teamMember.MembersFragment
import org.ole.planet.myplanet.ui.team.teamResource.TeamResourceFragment
import org.ole.planet.myplanet.ui.team.teamTask.TeamTaskFragment

sealed class TeamPageConfig(val id: String, @StringRes val titleRes: Int) {
    abstract fun createFragment(): Fragment

    object ChatPage : TeamPageConfig("CHAT", R.string.chat) {
        override fun createFragment() = DiscussionListFragment()
    }

    object PlanPage : TeamPageConfig("PLAN", R.string.plan) {
        override fun createFragment() = PlanFragment()
    }

    object MissionPage : TeamPageConfig("MISSION", R.string.mission) {
        override fun createFragment() = PlanFragment()
    }

    object TeamPage : TeamPageConfig("TEAM", R.string.team) {
        override fun createFragment() = JoinedMemberFragment()
    }

    object MembersPage : TeamPageConfig("MEMBERS", R.string.members) {
        override fun createFragment() = JoinedMemberFragment()
    }

    object TasksPage : TeamPageConfig("TASKS", R.string.tasks) {
        override fun createFragment() = TeamTaskFragment()
    }

    object CalendarPage : TeamPageConfig("CALENDAR", R.string.calendar) {
        override fun createFragment() = TeamCalendarFragment()
    }

    object SurveyPage : TeamPageConfig("SURVEY", R.string.survey) {
        override fun createFragment() = SurveyFragment()
    }

    object CoursesPage : TeamPageConfig("COURSES", R.string.courses) {
        override fun createFragment() = TeamCourseFragment()
    }

    object FinancesPage : TeamPageConfig("FINANCES", R.string.finances) {
        override fun createFragment() = FinanceFragment()
    }

    object ReportsPage : TeamPageConfig("REPORTS", R.string.reports) {
        override fun createFragment() = ReportsFragment()
    }

    object DocumentsPage : TeamPageConfig("DOCUMENTS", R.string.documents) {
        override fun createFragment() = TeamResourceFragment()
    }

    object ResourcesPage : TeamPageConfig("RESOURCES", R.string.resources) {
        override fun createFragment() = TeamResourceFragment()
    }

    object ApplicantsPage : TeamPageConfig("APPLICANTS", R.string.applicants) {
        override fun createFragment() = MembersFragment()
    }

    object JoinRequestsPage : TeamPageConfig("JOIN_REQUESTS", R.string.join_requests) {
        override fun createFragment() = MembersFragment()
    }
}
=======
package org.ole.planet.myplanet.ui.team


import androidx.annotation.StringRes
import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.ui.enterprises.FinanceFragment
import org.ole.planet.myplanet.ui.enterprises.ReportsFragment
import org.ole.planet.myplanet.ui.survey.SurveyFragment
import org.ole.planet.myplanet.ui.team.teamCourse.TeamCourseFragment
import org.ole.planet.myplanet.ui.team.teamDiscussion.DiscussionListFragment
import org.ole.planet.myplanet.ui.team.teamMember.JoinedMemberFragment
import org.ole.planet.myplanet.ui.team.teamMember.MembersFragment
import org.ole.planet.myplanet.ui.team.teamResource.TeamResourceFragment
import org.ole.planet.myplanet.ui.team.teamTask.TeamTaskFragment

sealed class TeamPageConfig(val id: String, @StringRes val titleRes: Int) {
    abstract fun createFragment(): Fragment

    object ChatPage : TeamPageConfig("CHAT", R.string.chat) {
        override fun createFragment() = DiscussionListFragment()
    }

    object PlanPage : TeamPageConfig("PLAN", R.string.plan) {
        override fun createFragment() = PlanFragment()
    }

    object MissionPage : TeamPageConfig("MISSION", R.string.mission) {
        override fun createFragment() = PlanFragment()
    }

    object TeamPage : TeamPageConfig("TEAM", R.string.team) {
        override fun createFragment() = JoinedMemberFragment()
    }

    object MembersPage : TeamPageConfig("MEMBERS", R.string.members) {
        override fun createFragment() = JoinedMemberFragment()
    }

    object TasksPage : TeamPageConfig("TASKS", R.string.tasks) {
        override fun createFragment() = TeamTaskFragment()
    }

    object CalendarPage : TeamPageConfig("CALENDAR", R.string.calendar) {
        override fun createFragment() = TeamCalendarFragment()
    }

    object SurveyPage : TeamPageConfig("SURVEY", R.string.survey) {
        override fun createFragment() = SurveyFragment()
    }

    object CoursesPage : TeamPageConfig("COURSES", R.string.courses) {
        override fun createFragment() = TeamCourseFragment()
    }

    object FinancesPage : TeamPageConfig("FINANCES", R.string.finances) {
        override fun createFragment() = FinanceFragment()
    }

    object ReportsPage : TeamPageConfig("REPORTS", R.string.reports) {
        override fun createFragment() = ReportsFragment()
    }

    object DocumentsPage : TeamPageConfig("DOCUMENTS", R.string.documents) {
        override fun createFragment() = TeamResourceFragment()
    }

    object ResourcesPage : TeamPageConfig("RESOURCES", R.string.resources) {
        override fun createFragment() = TeamResourceFragment()
    }

    object ApplicantsPage : TeamPageConfig("APPLICANTS", R.string.applicants) {
        override fun createFragment() = MembersFragment()
    }

    object JoinRequestsPage : TeamPageConfig("JOIN_REQUESTS", R.string.join_requests) {
        override fun createFragment() = MembersFragment()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/team/teamDiscussion/DiscussionListFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.team.teamDiscussion

import android.content.res.Configuration
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.isVisible
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import com.google.gson.Gson
import com.google.gson.JsonArray
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmResults
import io.realm.Sort
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentDiscussionListBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmNews.Companion.createNews
import org.ole.planet.myplanet.model.RealmTeamNotification
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.chat.ChatDetailFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.news.AdapterNews
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.utilities.FileUtils

@AndroidEntryPoint
class DiscussionListFragment : BaseTeamFragment() {
    private var _binding: FragmentDiscussionListBinding? = null
    private val binding get() = _binding!!
    private var updatedNewsList: RealmResults<RealmNews>? = null

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private var filteredNewsList: List<RealmNews?> = listOf()

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentDiscussionListBinding.inflate(inflater, container, false)
        binding.addMessage.setOnClickListener {
            binding.llAddNews.visibility = if (binding.llAddNews.isVisible) {
                binding.etMessage.setText("")
                binding.tlMessage.error = null
                clearImages()
                View.GONE
            } else {
                View.VISIBLE
            }
            binding.addMessage.text = if (binding.llAddNews.isVisible) {
                getString(R.string.hide_new_message)
            } else {
                getString(R.string.add_message)
            }
        }

        binding.addNewsImage.setOnClickListener {
            llImage = binding.llImages
            val openFolderIntent = FileUtils.openOleFolder(requireContext())
            openFolderLauncher.launch(openFolderIntent)
        }

        binding.btnSubmit.setOnClickListener {
            val message = binding.etMessage.text.toString().trim { it <= ' ' }
            if (message.isEmpty()) {
                binding.tlMessage.error = getString(R.string.please_enter_message)
                return@setOnClickListener
            }
            binding.etMessage.setText(R.string.empty_text)
            val map = HashMap<String?, String>()
            map["viewInId"] = getEffectiveTeamId()
            map["viewInSection"] = "teams"
            map["message"] = message
            map["messageType"] = getEffectiveTeamType()
            map["messagePlanetCode"] = team?.teamPlanetCode ?: ""
            map["name"] = getEffectiveTeamName()

            user?.let { userModel ->
                viewLifecycleOwner.lifecycleScope.launch {
                    try {
                        databaseService.executeTransactionAsync { realm ->
                            createNews(map, realm, userModel, imageList)
                        }
                        binding.rvDiscussion.post {
                            binding.rvDiscussion.smoothScrollToPosition(0)
                        }
                        binding.etMessage.text?.clear()
                        imageList.clear()
                        llImage?.removeAllViews()
                        binding.llAddNews.visibility = View.GONE
                        binding.tlMessage.error = null
                        binding.addMessage.text = getString(R.string.add_message)
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
        }

        if (shouldQueryTeamFromRealm()) {
            team = try {
                mRealm.where(RealmMyTeam::class.java).equalTo("_id", teamId).findFirst()
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }

            if (team == null) {
                try {
                    team = mRealm.where(RealmMyTeam::class.java).equalTo("teamId", teamId).findFirst()
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }
        binding.addMessage.isVisible = false
        updatedNewsList = mRealm.where(RealmNews::class.java).isEmpty("replyTo").sort("time", Sort.DESCENDING).findAllAsync()

        updatedNewsList?.addChangeListener { results ->
            filteredNewsList = filterNewsList(results)
            setData(filteredNewsList)
        }
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val realmNewsList = news
        val count = realmNewsList.size
        mRealm.executeTransactionAsync { realm: Realm ->
            var notification = realm.where(RealmTeamNotification::class.java).equalTo("type", "chat").equalTo("parentId", getEffectiveTeamId()).findFirst()
            if (notification == null) {
                notification = realm.createObject(RealmTeamNotification::class.java, UUID.randomUUID().toString())
                notification.parentId = getEffectiveTeamId()
                notification.type = "chat"
            }
            notification?.lastCount = count
        }
        changeLayoutManager(resources.configuration.orientation, binding.rvDiscussion)
        showRecyclerView(realmNewsList)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                combine(isMemberFlow, teamFlow) { isMember, teamData ->
                    Pair(isMember, teamData?.isPublic == true)
                }.collectLatest { (isMember, isPublicTeamFromFlow) ->
                    val isGuest = user?.id?.startsWith("guest") == true
                    val isPublicTeam = isPublicTeamFromFlow || team?.isPublic == true
                    val canPost = !isGuest && (isMember || isPublicTeam)
                    binding.addMessage.isVisible = canPost
                    (binding.rvDiscussion.adapter as? AdapterNews)?.setNonTeamMember(!isMember)
                }
            }
        }
    }

    override fun onNewsItemClick(news: RealmNews?) {
        val bundle = Bundle()
        bundle.putString("newsId", news?.newsId)
        bundle.putString("newsRev", news?.newsRev)
        bundle.putString("conversations", news?.conversations)

        val chatDetailFragment = ChatDetailFragment()
        chatDetailFragment.arguments = bundle

        NavigationHelper.replaceFragment(
            parentFragmentManager,
            R.id.fragment_container,
            chatDetailFragment,
            addToBackStack = true
        )
    }

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun filterNewsList(results: RealmResults<RealmNews>): List<RealmNews?> {
        val filteredList: MutableList<RealmNews?> = ArrayList()
        val effectiveTeamId = getEffectiveTeamId()

        for (news in results) {
            if (!TextUtils.isEmpty(news.viewableBy) && news.viewableBy.equals("teams", ignoreCase = true) && news.viewableId.equals(effectiveTeamId, ignoreCase = true)) {
                filteredList.add(news)
            } else if (!TextUtils.isEmpty(news.viewIn)) {
                val ar = Gson().fromJson(news.viewIn, JsonArray::class.java)
                for (e in ar) {
                    val ob = e.asJsonObject
                    if (ob["_id"].asString.equals(effectiveTeamId, ignoreCase = true)) {
                        filteredList.add(news)
                    }
                }
            }
        }
        return filteredList
    }

    private val news: List<RealmNews>
        get() {
            val realmNewsList: List<RealmNews> = mRealm.where(RealmNews::class.java).isEmpty("replyTo").sort("time", Sort.DESCENDING).findAll()
            val list: MutableList<RealmNews> = ArrayList()
            val effectiveTeamId = getEffectiveTeamId()

            for (news in realmNewsList) {
                if (!TextUtils.isEmpty(news.viewableBy) && news.viewableBy.equals("teams", ignoreCase = true) && news.viewableId.equals(effectiveTeamId, ignoreCase = true)) {
                    list.add(news)
                } else if (!TextUtils.isEmpty(news.viewIn)) {
                    val ar = Gson().fromJson(news.viewIn, JsonArray::class.java)
                    for (e in ar) {
                        val ob = e.asJsonObject
                        if (ob["_id"].asString.equals(effectiveTeamId, ignoreCase = true)) {
                            list.add(news)
                        }
                    }
                }
            }
            return list
        }

    override fun onConfigurationChanged(newConfig: Configuration) {
        super.onConfigurationChanged(newConfig)
        changeLayoutManager(newConfig.orientation, binding.rvDiscussion)
    }

    private fun showRecyclerView(realmNewsList: List<RealmNews?>?) {
        val existingAdapter = binding.rvDiscussion.adapter
        if (existingAdapter == null) {
            val adapterNews = activity?.let {
                AdapterNews(it, user, null, getEffectiveTeamName(), teamId, userProfileDbHandler, databaseService)
            }
            adapterNews?.setmRealm(mRealm)
            adapterNews?.setListener(this)
            if (!isMemberFlow.value) adapterNews?.setNonTeamMember(true)
            realmNewsList?.let { adapterNews?.updateList(it) }
            binding.rvDiscussion.adapter = adapterNews
            adapterNews?.let {
                showNoData(binding.tvNodata, it.itemCount, "discussions")
            }
        } else {
            (existingAdapter as? AdapterNews)?.let { adapter ->
                realmNewsList?.let {
                    adapter.updateList(it)
                    showNoData(binding.tvNodata, adapter.itemCount, "discussions")
                }
            }
        }
    }

    override fun setData(list: List<RealmNews?>?) {
        showRecyclerView(list)
    }

    override fun onDestroyView() {
        updatedNewsList?.removeAllChangeListeners()
        updatedNewsList = null
        if (isRealmInitialized()) {
            mRealm.close()
        }
        _binding = null
        super.onDestroyView()
    }

    private fun shouldQueryTeamFromRealm(): Boolean {
        val hasDirectData = requireArguments().containsKey("teamName") &&
                requireArguments().containsKey("teamType") &&
                requireArguments().containsKey("teamId")
        return !hasDirectData
    }
}
=======
package org.ole.planet.myplanet.ui.team.teamDiscussion


import android.content.res.Configuration
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.isVisible
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import com.google.gson.Gson
import com.google.gson.JsonArray
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmResults
import io.realm.Sort
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentDiscussionListBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmNews.Companion.createNews
import org.ole.planet.myplanet.model.RealmTeamNotification
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.chat.ChatDetailFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.news.AdapterNews
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.utilities.FileUtils

@AndroidEntryPoint
class DiscussionListFragment : BaseTeamFragment() {
    private var _binding: FragmentDiscussionListBinding? = null
    private val binding get() = _binding!!
    private var updatedNewsList: RealmResults<RealmNews>? = null

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private var filteredNewsList: List<RealmNews?> = listOf()

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentDiscussionListBinding.inflate(inflater, container, false)
        binding.addMessage.setOnClickListener {
            binding.llAddNews.visibility = if (binding.llAddNews.isVisible) {
                binding.etMessage.setText("")
                binding.tlMessage.error = null
                clearImages()
                View.GONE
            } else {
                View.VISIBLE
            }
            binding.addMessage.text = if (binding.llAddNews.isVisible) {
                getString(R.string.hide_new_message)
            } else {
                getString(R.string.add_message)
            }
        }

        binding.addNewsImage.setOnClickListener {
            llImage = binding.llImages
            val openFolderIntent = FileUtils.openOleFolder(requireContext())
            openFolderLauncher.launch(openFolderIntent)
        }

        binding.btnSubmit.setOnClickListener {
            val message = binding.etMessage.text.toString().trim { it <= ' ' }
            if (message.isEmpty()) {
                binding.tlMessage.error = getString(R.string.please_enter_message)
                return@setOnClickListener
            }
            binding.etMessage.setText(R.string.empty_text)
            val map = HashMap<String?, String>()
            map["viewInId"] = getEffectiveTeamId()
            map["viewInSection"] = "teams"
            map["message"] = message
            map["messageType"] = getEffectiveTeamType()
            map["messagePlanetCode"] = team?.teamPlanetCode ?: ""
            map["name"] = getEffectiveTeamName()

            user?.let { userModel ->
                viewLifecycleOwner.lifecycleScope.launch {
                    try {
                        databaseService.executeTransactionAsync { realm ->
                            createNews(map, realm, userModel, imageList)
                        }
                        binding.rvDiscussion.post {
                            binding.rvDiscussion.smoothScrollToPosition(0)
                        }
                        binding.etMessage.text?.clear()
                        imageList.clear()
                        llImage?.removeAllViews()
                        binding.llAddNews.visibility = View.GONE
                        binding.tlMessage.error = null
                        binding.addMessage.text = getString(R.string.add_message)
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
        }

        if (shouldQueryTeamFromRealm()) {
            team = try {
                mRealm.where(RealmMyTeam::class.java).equalTo("_id", teamId).findFirst()
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }

            if (team == null) {
                try {
                    team = mRealm.where(RealmMyTeam::class.java).equalTo("teamId", teamId).findFirst()
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }
        binding.addMessage.isVisible = false
        updatedNewsList = mRealm.where(RealmNews::class.java).isEmpty("replyTo").sort("time", Sort.DESCENDING).findAllAsync()

        updatedNewsList?.addChangeListener { results ->
            filteredNewsList = filterNewsList(results)
            setData(filteredNewsList)
        }
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val realmNewsList = news
        val count = realmNewsList.size
        mRealm.executeTransactionAsync { realm: Realm ->
            var notification = realm.where(RealmTeamNotification::class.java).equalTo("type", "chat").equalTo("parentId", getEffectiveTeamId()).findFirst()
            if (notification == null) {
                notification = realm.createObject(RealmTeamNotification::class.java, UUID.randomUUID().toString())
                notification.parentId = getEffectiveTeamId()
                notification.type = "chat"
            }
            notification?.lastCount = count
        }
        changeLayoutManager(resources.configuration.orientation, binding.rvDiscussion)
        showRecyclerView(realmNewsList)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                combine(isMemberFlow, teamFlow) { isMember, teamData ->
                    Pair(isMember, teamData?.isPublic == true)
                }.collectLatest { (isMember, isPublicTeamFromFlow) ->
                    val isGuest = user?.id?.startsWith("guest") == true
                    val isPublicTeam = isPublicTeamFromFlow || team?.isPublic == true
                    val canPost = !isGuest && (isMember || isPublicTeam)
                    binding.addMessage.isVisible = canPost
                    (binding.rvDiscussion.adapter as? AdapterNews)?.setNonTeamMember(!isMember)
                }
            }
        }
    }

    override fun onNewsItemClick(news: RealmNews?) {
        val bundle = Bundle()
        bundle.putString("newsId", news?.newsId)
        bundle.putString("newsRev", news?.newsRev)
        bundle.putString("conversations", news?.conversations)

        val chatDetailFragment = ChatDetailFragment()
        chatDetailFragment.arguments = bundle

        NavigationHelper.replaceFragment(
            parentFragmentManager,
            R.id.fragment_container,
            chatDetailFragment,
            addToBackStack = true
        )
    }

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun filterNewsList(results: RealmResults<RealmNews>): List<RealmNews?> {
        val filteredList: MutableList<RealmNews?> = ArrayList()
        val effectiveTeamId = getEffectiveTeamId()

        for (news in results) {
            if (!TextUtils.isEmpty(news.viewableBy) && news.viewableBy.equals("teams", ignoreCase = true) && news.viewableId.equals(effectiveTeamId, ignoreCase = true)) {
                filteredList.add(news)
            } else if (!TextUtils.isEmpty(news.viewIn)) {
                val ar = Gson().fromJson(news.viewIn, JsonArray::class.java)
                for (e in ar) {
                    val ob = e.asJsonObject
                    if (ob["_id"].asString.equals(effectiveTeamId, ignoreCase = true)) {
                        filteredList.add(news)
                    }
                }
            }
        }
        return filteredList
    }

    private val news: List<RealmNews>
        get() {
            val realmNewsList: List<RealmNews> = mRealm.where(RealmNews::class.java).isEmpty("replyTo").sort("time", Sort.DESCENDING).findAll()
            val list: MutableList<RealmNews> = ArrayList()
            val effectiveTeamId = getEffectiveTeamId()

            for (news in realmNewsList) {
                if (!TextUtils.isEmpty(news.viewableBy) && news.viewableBy.equals("teams", ignoreCase = true) && news.viewableId.equals(effectiveTeamId, ignoreCase = true)) {
                    list.add(news)
                } else if (!TextUtils.isEmpty(news.viewIn)) {
                    val ar = Gson().fromJson(news.viewIn, JsonArray::class.java)
                    for (e in ar) {
                        val ob = e.asJsonObject
                        if (ob["_id"].asString.equals(effectiveTeamId, ignoreCase = true)) {
                            list.add(news)
                        }
                    }
                }
            }
            return list
        }

    override fun onConfigurationChanged(newConfig: Configuration) {
        super.onConfigurationChanged(newConfig)
        changeLayoutManager(newConfig.orientation, binding.rvDiscussion)
    }

    private fun showRecyclerView(realmNewsList: List<RealmNews?>?) {
        val existingAdapter = binding.rvDiscussion.adapter
        if (existingAdapter == null) {
            val adapterNews = activity?.let {
                AdapterNews(it, user, null, getEffectiveTeamName(), teamId, userProfileDbHandler, databaseService)
            }
            adapterNews?.setmRealm(mRealm)
            adapterNews?.setListener(this)
            if (!isMemberFlow.value) adapterNews?.setNonTeamMember(true)
            realmNewsList?.let { adapterNews?.updateList(it) }
            binding.rvDiscussion.adapter = adapterNews
            adapterNews?.let {
                showNoData(binding.tvNodata, it.itemCount, "discussions")
            }
        } else {
            (existingAdapter as? AdapterNews)?.let { adapter ->
                realmNewsList?.let {
                    adapter.updateList(it)
                    showNoData(binding.tvNodata, adapter.itemCount, "discussions")
                }
            }
        }
    }

    override fun setData(list: List<RealmNews?>?) {
        showRecyclerView(list)
    }

    override fun onDestroyView() {
        updatedNewsList?.removeAllChangeListeners()
        updatedNewsList = null
        if (isRealmInitialized()) {
            mRealm.close()
        }
        _binding = null
        super.onDestroyView()
    }

    private fun shouldQueryTeamFromRealm(): Boolean {
        val hasDirectData = requireArguments().containsKey("teamName") &&
                requireArguments().containsKey("teamType") &&
                requireArguments().containsKey("teamId")
        return !hasDirectData
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dictionary/DictionaryActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dictionary

import android.os.Bundle
import androidx.core.text.HtmlCompat
import androidx.lifecycle.lifecycleScope
import com.google.gson.Gson
import com.google.gson.JsonArray
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Case
import java.util.UUID
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseActivity
import org.ole.planet.myplanet.databinding.FragmentDictionaryBinding
import org.ole.planet.myplanet.model.RealmDictionary
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class DictionaryActivity : BaseActivity() {
    private lateinit var fragmentDictionaryBinding: FragmentDictionaryBinding
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        fragmentDictionaryBinding = FragmentDictionaryBinding.inflate(layoutInflater)
        setContentView(fragmentDictionaryBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, fragmentDictionaryBinding.root)
        initActionBar()
        title = getString(R.string.dictionary)

        databaseService.withRealm { realm ->
            val list = realm.where(RealmDictionary::class.java).findAll()
            fragmentDictionaryBinding.tvResult.text =
                getString(R.string.list_size, list.size)
        }

        if (FileUtils.checkFileExist(this, Constants.DICTIONARY_URL)) {
            lifecycleScope.launch {
                loadDictionaryIfNeeded()
            }
        } else {
            val list = ArrayList<String>()
            list.add(Constants.DICTIONARY_URL)
            Utilities.toast(this, getString(R.string.downloading_started_please_check_notificati))
            DownloadUtils.openDownloadService(this, list, false)
        }
    }

    private suspend fun loadDictionaryIfNeeded() {
        var isEmpty = true
        databaseService.withRealm { realm ->
            isEmpty = realm.where(RealmDictionary::class.java).count() == 0L
        }
        if (isEmpty) {
            val context = this@DictionaryActivity
            val json = withContext(Dispatchers.IO) {
                try {
                    val data = FileUtils.getStringFromFile(
                        FileUtils.getSDPathFromUrl(context, Constants.DICTIONARY_URL)
                    )
                    Gson().fromJson(data, JsonArray::class.java)
                } catch (e: Exception) {
                    e.printStackTrace()
                    null
                }
            }
            json?.let { jsonArray ->
                databaseService.withRealm { realm ->
                    realm.executeTransactionAsync { bgRealm ->
                        jsonArray.forEach { js ->
                            val doc = js.asJsonObject
                            val dict = bgRealm.createObject(
                                RealmDictionary::class.java, UUID.randomUUID().toString()
                            )
                            dict.code = JsonUtils.getString("code", doc)
                            dict.language = JsonUtils.getString("language", doc)
                            dict.advanceCode = JsonUtils.getString("advance_code", doc)
                            dict.word = JsonUtils.getString("word", doc)
                            dict.meaning = JsonUtils.getString("meaning", doc)
                            dict.definition = JsonUtils.getString("definition", doc)
                            dict.synonym = JsonUtils.getString("synonym", doc)
                            dict.antonym = JsonUtils.getString("antonoym", doc)
                        }
                    }
                }
            }
        } else {
            setClickListener()
        }
    }

    private fun setClickListener() {
        fragmentDictionaryBinding.btnSearch.setOnClickListener {
            databaseService.withRealm { realm ->
                val dict = realm.where(RealmDictionary::class.java)
                    .equalTo(
                        "word",
                        fragmentDictionaryBinding.etSearch.text.toString(),
                        Case.INSENSITIVE
                    )
                    .findFirst()
                if (dict != null) {
                    fragmentDictionaryBinding.tvResult.text = HtmlCompat.fromHtml(
                        "Definition of'<b>" + dict.word + "</b>'<br/><br/>\n " +
                            "<b>" + dict.definition + "\n</b><br/><br/><br/>" +
                            "<b>Synonym : </b>" + dict.synonym + "\n<br/><br/>" +
                            "<b>Antonoym : </b>" + dict.antonym + "\n<br/>",
                        HtmlCompat.FROM_HTML_MODE_LEGACY
                    )
                } else {
                    Utilities.toast(
                        this,
                        getString(R.string.word_not_available_in_our_database)
                    )
                }
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.dictionary


import android.os.Bundle
import androidx.core.text.HtmlCompat
import androidx.lifecycle.lifecycleScope
import com.google.gson.Gson
import com.google.gson.JsonArray
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Case
import java.util.UUID
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseActivity
import org.ole.planet.myplanet.databinding.FragmentDictionaryBinding
import org.ole.planet.myplanet.model.RealmDictionary
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class DictionaryActivity : BaseActivity() {
    private lateinit var fragmentDictionaryBinding: FragmentDictionaryBinding
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        fragmentDictionaryBinding = FragmentDictionaryBinding.inflate(layoutInflater)
        setContentView(fragmentDictionaryBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, fragmentDictionaryBinding.root)
        initActionBar()
        title = getString(R.string.dictionary)

        databaseService.withRealm { realm ->
            val list = realm.where(RealmDictionary::class.java).findAll()
            fragmentDictionaryBinding.tvResult.text =
                getString(R.string.list_size, list.size)
        }

        if (FileUtils.checkFileExist(this, Constants.DICTIONARY_URL)) {
            lifecycleScope.launch {
                loadDictionaryIfNeeded()
            }
        } else {
            val list = ArrayList<String>()
            list.add(Constants.DICTIONARY_URL)
            Utilities.toast(this, getString(R.string.downloading_started_please_check_notificati))
            DownloadUtils.openDownloadService(this, list, false)
        }
    }

    private suspend fun loadDictionaryIfNeeded() {
        var isEmpty = true
        databaseService.withRealm { realm ->
            isEmpty = realm.where(RealmDictionary::class.java).count() == 0L
        }
        if (isEmpty) {
            val context = this@DictionaryActivity
            val json = withContext(Dispatchers.IO) {
                try {
                    val data = FileUtils.getStringFromFile(
                        FileUtils.getSDPathFromUrl(context, Constants.DICTIONARY_URL)
                    )
                    Gson().fromJson(data, JsonArray::class.java)
                } catch (e: Exception) {
                    e.printStackTrace()
                    null
                }
            }
            json?.let { jsonArray ->
                databaseService.withRealm { realm ->
                    realm.executeTransactionAsync { bgRealm ->
                        jsonArray.forEach { js ->
                            val doc = js.asJsonObject
                            val dict = bgRealm.createObject(
                                RealmDictionary::class.java, UUID.randomUUID().toString()
                            )
                            dict.code = JsonUtils.getString("code", doc)
                            dict.language = JsonUtils.getString("language", doc)
                            dict.advanceCode = JsonUtils.getString("advance_code", doc)
                            dict.word = JsonUtils.getString("word", doc)
                            dict.meaning = JsonUtils.getString("meaning", doc)
                            dict.definition = JsonUtils.getString("definition", doc)
                            dict.synonym = JsonUtils.getString("synonym", doc)
                            dict.antonym = JsonUtils.getString("antonoym", doc)
                        }
                    }
                }
            }
        } else {
            setClickListener()
        }
    }

    private fun setClickListener() {
        fragmentDictionaryBinding.btnSearch.setOnClickListener {
            databaseService.withRealm { realm ->
                val dict = realm.where(RealmDictionary::class.java)
                    .equalTo(
                        "word",
                        fragmentDictionaryBinding.etSearch.text.toString(),
                        Case.INSENSITIVE
                    )
                    .findFirst()
                if (dict != null) {
                    fragmentDictionaryBinding.tvResult.text = HtmlCompat.fromHtml(
                        "Definition of'<b>" + dict.word + "</b>'<br/><br/>\n " +
                            "<b>" + dict.definition + "\n</b><br/><br/><br/>" +
                            "<b>Synonym : </b>" + dict.synonym + "\n<br/><br/>" +
                            "<b>Antonoym : </b>" + dict.antonym + "\n<br/>",
                        HtmlCompat.FROM_HTML_MODE_LEGACY
                    )
                } else {
                    Utilities.toast(
                        this,
                        getString(R.string.word_not_available_in_our_database)
                    )
                }
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/feedback/FeedbackDetailActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.feedback

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.text.TextUtils
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import java.util.Date
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityFeedbackDetailBinding
import org.ole.planet.myplanet.databinding.RowFeedbackReplyBinding
import org.ole.planet.myplanet.model.FeedbackReply
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.feedback.FeedbackDetailActivity.RvFeedbackAdapter.ReplyViewHolder
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDateWithTime

@AndroidEntryPoint
class FeedbackDetailActivity : AppCompatActivity() {
    private lateinit var activityFeedbackDetailBinding: ActivityFeedbackDetailBinding
    private var mAdapter: RecyclerView.Adapter<*>? = null
    private var layoutManager: RecyclerView.LayoutManager? = null
    private var feedback: RealmFeedback? = null
    private lateinit var rowFeedbackReplyBinding: RowFeedbackReplyBinding
    private lateinit var feedbackId: String
    private val viewModel: FeedbackDetailViewModel by viewModels()

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(base))
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        activityFeedbackDetailBinding = ActivityFeedbackDetailBinding.inflate(layoutInflater)
        setContentView(activityFeedbackDetailBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, activityFeedbackDetailBinding.root)
        supportActionBar?.setHomeButtonEnabled(true)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        setTitle(R.string.feedback)
        val id = intent.getStringExtra("id")
        if (id.isNullOrEmpty()) {
            finish()
            return
        }
        feedbackId = id
        setUpReplies()

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.feedback.collectLatest { fb ->
                    fb?.let {
                        feedback = it
                        activityFeedbackDetailBinding.tvDate.text = getFormattedDateWithTime(it.openTime)
                        activityFeedbackDetailBinding.tvMessage.text =
                            if (TextUtils.isEmpty(it.message)) "N/A" else it.message
                        mAdapter = RvFeedbackAdapter(it.messageList, applicationContext)
                        activityFeedbackDetailBinding.rvFeedbackReply.adapter = mAdapter
                        updateForClosed()
                    }
                }
            }
        }

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.events.collectLatest { event ->
                    when (event) {
                        is FeedbackDetailViewModel.FeedbackDetailEvent.CloseFeedbackSuccess ->
                            navigateToFeedbackListFragment()
                    }
                }
            }
        }

        activityFeedbackDetailBinding.closeFeedback.setOnClickListener {
            viewModel.closeFeedback(feedbackId)
        }
        activityFeedbackDetailBinding.replyFeedback.setOnClickListener {
            if (TextUtils.isEmpty(activityFeedbackDetailBinding.feedbackReplyEditText.text.toString().trim { it <= ' ' })) {
                activityFeedbackDetailBinding.feedbackReplyEditText.error =
                    getString(R.string.kindly_enter_reply_message)
            } else {
                val message = activityFeedbackDetailBinding.feedbackReplyEditText.text.toString().trim { it <= ' ' }
                val obj = JsonObject().apply {
                    addProperty("message", message)
                    addProperty("time", Date().time.toString())
                    addProperty("user", feedback?.owner ?: "")
                }
                viewModel.addReply(feedbackId, obj)
                activityFeedbackDetailBinding.feedbackReplyEditText.setText(R.string.empty_text)
                activityFeedbackDetailBinding.feedbackReplyEditText.clearFocus()
            }
        }

        viewModel.loadFeedback(feedbackId)
    }

    private fun setUpReplies() {
        activityFeedbackDetailBinding.rvFeedbackReply.setHasFixedSize(true)
        layoutManager = LinearLayoutManager(this)
        activityFeedbackDetailBinding.rvFeedbackReply.layoutManager = layoutManager
    }

    private fun updateForClosed() {
        if (feedback?.status.equals("Closed", ignoreCase = true)) {
            activityFeedbackDetailBinding.closeFeedback.isEnabled = false
            activityFeedbackDetailBinding.replyFeedback.isEnabled = false
            activityFeedbackDetailBinding.feedbackReplyEditText.visibility = View.INVISIBLE
        }
    }

    private fun navigateToFeedbackListFragment() {
        val intent = Intent(this, DashboardActivity::class.java)
        intent.putExtra("fragmentToOpen", "feedbackList")
        startActivity(intent)
        finish()
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == android.R.id.home) finish()
        return super.onOptionsItemSelected(item)
    }

    inner class RvFeedbackAdapter(private val replyList: List<FeedbackReply>?, var context: Context) : RecyclerView.Adapter<ReplyViewHolder>() {
        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ReplyViewHolder {
            rowFeedbackReplyBinding = RowFeedbackReplyBinding.inflate(layoutInflater, parent, false)
            return ReplyViewHolder(rowFeedbackReplyBinding)
        }

        override fun onBindViewHolder(holder: ReplyViewHolder, position: Int) {
            rowFeedbackReplyBinding.tvDate.text = replyList?.get(position)?.date?.let {
                getFormattedDateWithTime(it.toLong())
            }
            rowFeedbackReplyBinding.tvUser.text = replyList?.get(position)?.user
            rowFeedbackReplyBinding.tvMessage.text = replyList?.get(position)?.message
        }

        override fun getItemCount(): Int {
            return replyList?.size ?: 0
        }

        inner class ReplyViewHolder(rowFeedbackReplyBinding: RowFeedbackReplyBinding) : RecyclerView.ViewHolder(rowFeedbackReplyBinding.root)
    }
}
=======
package org.ole.planet.myplanet.ui.feedback


import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.text.TextUtils
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import java.util.Date
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityFeedbackDetailBinding
import org.ole.planet.myplanet.databinding.RowFeedbackReplyBinding
import org.ole.planet.myplanet.model.FeedbackReply
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.feedback.FeedbackDetailActivity.RvFeedbackAdapter.ReplyViewHolder
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDateWithTime

@AndroidEntryPoint
class FeedbackDetailActivity : AppCompatActivity() {
    private lateinit var activityFeedbackDetailBinding: ActivityFeedbackDetailBinding
    private var mAdapter: RecyclerView.Adapter<*>? = null
    private var layoutManager: RecyclerView.LayoutManager? = null
    private var feedback: RealmFeedback? = null
    private lateinit var rowFeedbackReplyBinding: RowFeedbackReplyBinding
    private lateinit var feedbackId: String
    private val viewModel: FeedbackDetailViewModel by viewModels()

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(base))
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        activityFeedbackDetailBinding = ActivityFeedbackDetailBinding.inflate(layoutInflater)
        setContentView(activityFeedbackDetailBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, activityFeedbackDetailBinding.root)
        supportActionBar?.setHomeButtonEnabled(true)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        setTitle(R.string.feedback)
        val id = intent.getStringExtra("id")
        if (id.isNullOrEmpty()) {
            finish()
            return
        }
        feedbackId = id
        setUpReplies()

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.feedback.collectLatest { fb ->
                    fb?.let {
                        feedback = it
                        activityFeedbackDetailBinding.tvDate.text = getFormattedDateWithTime(it.openTime)
                        activityFeedbackDetailBinding.tvMessage.text =
                            if (TextUtils.isEmpty(it.message)) "N/A" else it.message
                        mAdapter = RvFeedbackAdapter(it.messageList, applicationContext)
                        activityFeedbackDetailBinding.rvFeedbackReply.adapter = mAdapter
                        updateForClosed()
                    }
                }
            }
        }

        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.events.collectLatest { event ->
                    when (event) {
                        is FeedbackDetailViewModel.FeedbackDetailEvent.CloseFeedbackSuccess ->
                            navigateToFeedbackListFragment()
                    }
                }
            }
        }

        activityFeedbackDetailBinding.closeFeedback.setOnClickListener {
            viewModel.closeFeedback(feedbackId)
        }
        activityFeedbackDetailBinding.replyFeedback.setOnClickListener {
            if (TextUtils.isEmpty(activityFeedbackDetailBinding.feedbackReplyEditText.text.toString().trim { it <= ' ' })) {
                activityFeedbackDetailBinding.feedbackReplyEditText.error =
                    getString(R.string.kindly_enter_reply_message)
            } else {
                val message = activityFeedbackDetailBinding.feedbackReplyEditText.text.toString().trim { it <= ' ' }
                val obj = JsonObject().apply {
                    addProperty("message", message)
                    addProperty("time", Date().time.toString())
                    addProperty("user", feedback?.owner ?: "")
                }
                viewModel.addReply(feedbackId, obj)
                activityFeedbackDetailBinding.feedbackReplyEditText.setText(R.string.empty_text)
                activityFeedbackDetailBinding.feedbackReplyEditText.clearFocus()
            }
        }

        viewModel.loadFeedback(feedbackId)
    }

    private fun setUpReplies() {
        activityFeedbackDetailBinding.rvFeedbackReply.setHasFixedSize(true)
        layoutManager = LinearLayoutManager(this)
        activityFeedbackDetailBinding.rvFeedbackReply.layoutManager = layoutManager
    }

    private fun updateForClosed() {
        if (feedback?.status.equals("Closed", ignoreCase = true)) {
            activityFeedbackDetailBinding.closeFeedback.isEnabled = false
            activityFeedbackDetailBinding.replyFeedback.isEnabled = false
            activityFeedbackDetailBinding.feedbackReplyEditText.visibility = View.INVISIBLE
        }
    }

    private fun navigateToFeedbackListFragment() {
        val intent = Intent(this, DashboardActivity::class.java)
        intent.putExtra("fragmentToOpen", "feedbackList")
        startActivity(intent)
        finish()
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == android.R.id.home) finish()
        return super.onOptionsItemSelected(item)
    }

    inner class RvFeedbackAdapter(private val replyList: List<FeedbackReply>?, var context: Context) : RecyclerView.Adapter<ReplyViewHolder>() {
        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ReplyViewHolder {
            rowFeedbackReplyBinding = RowFeedbackReplyBinding.inflate(layoutInflater, parent, false)
            return ReplyViewHolder(rowFeedbackReplyBinding)
        }

        override fun onBindViewHolder(holder: ReplyViewHolder, position: Int) {
            rowFeedbackReplyBinding.tvDate.text = replyList?.get(position)?.date?.let {
                getFormattedDateWithTime(it.toLong())
            }
            rowFeedbackReplyBinding.tvUser.text = replyList?.get(position)?.user
            rowFeedbackReplyBinding.tvMessage.text = replyList?.get(position)?.message
        }

        override fun getItemCount(): Int {
            return replyList?.size ?: 0
        }

        inner class ReplyViewHolder(rowFeedbackReplyBinding: RowFeedbackReplyBinding) : RecyclerView.ViewHolder(rowFeedbackReplyBinding.root)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/feedback/AdapterFeedback.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.feedback

import android.content.Intent
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.core.content.res.ResourcesCompat
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowFeedbackBinding
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.ui.feedback.AdapterFeedback.ViewHolderFeedback
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDate

class AdapterFeedback :
    ListAdapter<RealmFeedback, ViewHolderFeedback>(
        DiffUtils.itemCallback(
            { oldItem, newItem ->
                oldItem.id == newItem.id
            },
            { oldItem, newItem ->
                oldItem.title == newItem.title &&
                    oldItem.type == newItem.type &&
                    oldItem.priority == newItem.priority &&
                    oldItem.status == newItem.status &&
                    oldItem.openTime == newItem.openTime
            }
        )
    ) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderFeedback {
        val binding = RowFeedbackBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderFeedback(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderFeedback, position: Int) {
        val feedback = getItem(position)
        val binding = holder.rowFeedbackBinding
        val context = binding.root.context

        binding.tvTitle.text = feedback.title
        binding.tvType.text = feedback.type
        binding.tvPriority.text = feedback.priority
        binding.tvStatus.text = feedback.status
        val contentDescription = "${feedback.title}, ${feedback.type}, " +
                "${context.getString(R.string.status)}: ${feedback.status}, ${context.getString(R.string.priority)}: ${feedback.priority}, " +
                "${context.getString(R.string.open_date)}: ${getFormattedDate(feedback.openTime)}"
        binding.feedbackCardView.contentDescription = contentDescription

        if ("yes".equals(feedback.priority, ignoreCase = true)) {
            binding.tvPriority.background =
                ResourcesCompat.getDrawable(context.resources, R.drawable.bg_primary, null)
        } else {
            binding.tvPriority.background =
                ResourcesCompat.getDrawable(context.resources, R.drawable.bg_grey, null)
        }
        binding.tvStatus.background = ResourcesCompat.getDrawable(
            context.resources,
            if ("open".equals(feedback.status, ignoreCase = true)) {
                R.drawable.bg_primary
            } else {
                R.drawable.bg_grey
            },
            null
        )
        binding.tvOpenDate.text = getFormattedDate(feedback.openTime)
        binding.root.setOnClickListener {
            binding.root.contentDescription = feedback.title
            context.startActivity(
                Intent(context, FeedbackDetailActivity::class.java)
                    .putExtra("id", feedback.id)
            )
        }
    }

    class ViewHolderFeedback(val rowFeedbackBinding: RowFeedbackBinding) :
        RecyclerView.ViewHolder(rowFeedbackBinding.root)
}
=======
package org.ole.planet.myplanet.ui.feedback


import android.content.Intent
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.core.content.res.ResourcesCompat
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowFeedbackBinding
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.ui.feedback.AdapterFeedback.ViewHolderFeedback
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDate

class AdapterFeedback :
    ListAdapter<RealmFeedback, ViewHolderFeedback>(
        DiffUtils.itemCallback(
            { oldItem, newItem ->
                oldItem.id == newItem.id
            },
            { oldItem, newItem ->
                oldItem.title == newItem.title &&
                    oldItem.type == newItem.type &&
                    oldItem.priority == newItem.priority &&
                    oldItem.status == newItem.status &&
                    oldItem.openTime == newItem.openTime
            }
        )
    ) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderFeedback {
        val binding = RowFeedbackBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderFeedback(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderFeedback, position: Int) {
        val feedback = getItem(position)
        val binding = holder.rowFeedbackBinding
        val context = binding.root.context

        binding.tvTitle.text = feedback.title
        binding.tvType.text = feedback.type
        binding.tvPriority.text = feedback.priority
        binding.tvStatus.text = feedback.status
        val contentDescription = "${feedback.title}, ${feedback.type}, " +
                "${context.getString(R.string.status)}: ${feedback.status}, ${context.getString(R.string.priority)}: ${feedback.priority}, " +
                "${context.getString(R.string.open_date)}: ${getFormattedDate(feedback.openTime)}"
        binding.feedbackCardView.contentDescription = contentDescription

        if ("yes".equals(feedback.priority, ignoreCase = true)) {
            binding.tvPriority.background =
                ResourcesCompat.getDrawable(context.resources, R.drawable.bg_primary, null)
        } else {
            binding.tvPriority.background =
                ResourcesCompat.getDrawable(context.resources, R.drawable.bg_grey, null)
        }
        binding.tvStatus.background = ResourcesCompat.getDrawable(
            context.resources,
            if ("open".equals(feedback.status, ignoreCase = true)) {
                R.drawable.bg_primary
            } else {
                R.drawable.bg_grey
            },
            null
        )
        binding.tvOpenDate.text = getFormattedDate(feedback.openTime)
        binding.root.setOnClickListener {
            binding.root.contentDescription = feedback.title
            context.startActivity(
                Intent(context, FeedbackDetailActivity::class.java)
                    .putExtra("id", feedback.id)
            )
        }
    }

    class ViewHolderFeedback(val rowFeedbackBinding: RowFeedbackBinding) :
        RecyclerView.ViewHolder(rowFeedbackBinding.root)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/feedback/FeedbackDetailViewModel.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.feedback

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.gson.JsonObject
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.repository.FeedbackRepository

@HiltViewModel
class FeedbackDetailViewModel @Inject constructor(
    private val feedbackRepository: FeedbackRepository
) : ViewModel() {

    private val _feedback = MutableStateFlow<RealmFeedback?>(null)
    val feedback: StateFlow<RealmFeedback?> = _feedback.asStateFlow()

    private val _events = MutableSharedFlow<FeedbackDetailEvent>(extraBufferCapacity = 1)
    val events: SharedFlow<FeedbackDetailEvent> = _events.asSharedFlow()

    fun loadFeedback(id: String?) {
        viewModelScope.launch(Dispatchers.IO) {
            _feedback.value = feedbackRepository.getFeedbackById(id)
        }
    }

    fun closeFeedback(id: String?) {
        viewModelScope.launch(Dispatchers.IO) {
            feedbackRepository.closeFeedback(id)
            _feedback.value = feedbackRepository.getFeedbackById(id)
            _events.emit(FeedbackDetailEvent.CloseFeedbackSuccess)
        }
    }

    fun addReply(id: String?, obj: JsonObject) {
        viewModelScope.launch(Dispatchers.IO) {
            feedbackRepository.addReply(id, obj)
            _feedback.value = feedbackRepository.getFeedbackById(id)
        }
    }

    sealed class FeedbackDetailEvent {
        object CloseFeedbackSuccess : FeedbackDetailEvent()
    }
}
=======
package org.ole.planet.myplanet.ui.feedback


import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.gson.JsonObject
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.repository.FeedbackRepository

@HiltViewModel
class FeedbackDetailViewModel @Inject constructor(
    private val feedbackRepository: FeedbackRepository
) : ViewModel() {

    private val _feedback = MutableStateFlow<RealmFeedback?>(null)
    val feedback: StateFlow<RealmFeedback?> = _feedback.asStateFlow()

    private val _events = MutableSharedFlow<FeedbackDetailEvent>(extraBufferCapacity = 1)
    val events: SharedFlow<FeedbackDetailEvent> = _events.asSharedFlow()

    fun loadFeedback(id: String?) {
        viewModelScope.launch(Dispatchers.IO) {
            _feedback.value = feedbackRepository.getFeedbackById(id)
        }
    }

    fun closeFeedback(id: String?) {
        viewModelScope.launch(Dispatchers.IO) {
            feedbackRepository.closeFeedback(id)
            _feedback.value = feedbackRepository.getFeedbackById(id)
            _events.emit(FeedbackDetailEvent.CloseFeedbackSuccess)
        }
    }

    fun addReply(id: String?, obj: JsonObject) {
        viewModelScope.launch(Dispatchers.IO) {
            feedbackRepository.addReply(id, obj)
            _feedback.value = feedbackRepository.getFeedbackById(id)
        }
    }

    sealed class FeedbackDetailEvent {
        object CloseFeedbackSuccess : FeedbackDetailEvent()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/feedback/FeedbackFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.feedback

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.RadioButton
import android.widget.Toast
import androidx.fragment.app.DialogFragment
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentFeedbackBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.FeedbackRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class FeedbackFragment : DialogFragment(), View.OnClickListener {
    private var _binding: FragmentFeedbackBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var feedbackRepository: FeedbackRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private var model: RealmUserModel ?= null
    var user: String? = ""

    interface OnFeedbackSubmittedListener {
        fun onFeedbackSubmitted()
    }

    private var mListener: OnFeedbackSubmittedListener? = null
    fun setOnFeedbackSubmittedListener(listener: OnFeedbackSubmittedListener?) {
        mListener = listener
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NO_TITLE, R.style.AppTheme_Dialog_NoActionBar_MinWidth)
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentFeedbackBinding.inflate(inflater, container, false)
        model = userProfileDbHandler.userModel
        user = model?.name
        binding.btnSubmit.setOnClickListener(this)
        binding.btnCancel.setOnClickListener(this)
        return binding.root
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }

    override fun onClick(view: View) {
        if (view.id == R.id.btn_submit) {
            clearError()
            validateAndSaveData()
        } else if (view.id == R.id.btn_cancel) {
            dismiss()
        }
    }

    private fun validateAndSaveData() {
        val message = binding.etMessage.text.toString().trim { it <= ' ' }
        if (message.isEmpty()) {
            binding.tlMessage.error = getString(R.string.please_enter_feedback)
            return
        }
        val rbUrgent = requireView().findViewById<RadioButton>(binding.rgUrgent.checkedRadioButtonId)
        val rbType = requireView().findViewById<RadioButton>(binding.rgType.checkedRadioButtonId)
        if (rbUrgent == null) {
            binding.tlUrgent.error = getString(R.string.feedback_priority_is_required)
            return
        }
        if (rbType == null) {
            binding.tlType.error = getString(R.string.feedback_type_is_required)
            return
        }
        val urgent = rbUrgent.text.toString()
        val type = rbType.text.toString()
        val item = arguments?.getString("item")
        val state = arguments?.getString("state")
        val feedback = feedbackRepository.createFeedback(user, urgent, type, message, item, state)
        viewLifecycleOwner.lifecycleScope.launch {
            feedbackRepository.saveFeedback(feedback)
            Utilities.toast(activity, getString(R.string.feedback_saved))
        }
        Toast.makeText(activity, R.string.thank_you_your_feedback_has_been_submitted, Toast.LENGTH_SHORT).show()
        mListener?.onFeedbackSubmitted()
        dismiss()
    }

    private fun clearError() {
        binding.tlUrgent.error = ""
        binding.tlType.error = ""
        binding.tlMessage.error = ""
    }

}
=======
package org.ole.planet.myplanet.ui.feedback


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.RadioButton
import android.widget.Toast
import androidx.fragment.app.DialogFragment
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentFeedbackBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.FeedbackRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class FeedbackFragment : DialogFragment(), View.OnClickListener {
    private var _binding: FragmentFeedbackBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var feedbackRepository: FeedbackRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private var model: RealmUserModel ?= null
    var user: String? = ""

    interface OnFeedbackSubmittedListener {
        fun onFeedbackSubmitted()
    }

    private var mListener: OnFeedbackSubmittedListener? = null
    fun setOnFeedbackSubmittedListener(listener: OnFeedbackSubmittedListener?) {
        mListener = listener
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NO_TITLE, R.style.AppTheme_Dialog_NoActionBar_MinWidth)
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentFeedbackBinding.inflate(inflater, container, false)
        model = userProfileDbHandler.userModel
        user = model?.name
        binding.btnSubmit.setOnClickListener(this)
        binding.btnCancel.setOnClickListener(this)
        return binding.root
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }

    override fun onClick(view: View) {
        if (view.id == R.id.btn_submit) {
            clearError()
            validateAndSaveData()
        } else if (view.id == R.id.btn_cancel) {
            dismiss()
        }
    }

    private fun validateAndSaveData() {
        val message = binding.etMessage.text.toString().trim { it <= ' ' }
        if (message.isEmpty()) {
            binding.tlMessage.error = getString(R.string.please_enter_feedback)
            return
        }
        val rbUrgent = requireView().findViewById<RadioButton>(binding.rgUrgent.checkedRadioButtonId)
        val rbType = requireView().findViewById<RadioButton>(binding.rgType.checkedRadioButtonId)
        if (rbUrgent == null) {
            binding.tlUrgent.error = getString(R.string.feedback_priority_is_required)
            return
        }
        if (rbType == null) {
            binding.tlType.error = getString(R.string.feedback_type_is_required)
            return
        }
        val urgent = rbUrgent.text.toString()
        val type = rbType.text.toString()
        val item = arguments?.getString("item")
        val state = arguments?.getString("state")
        val feedback = feedbackRepository.createFeedback(user, urgent, type, message, item, state)
        viewLifecycleOwner.lifecycleScope.launch {
            feedbackRepository.saveFeedback(feedback)
            Utilities.toast(activity, getString(R.string.feedback_saved))
        }
        Toast.makeText(activity, R.string.thank_you_your_feedback_has_been_submitted, Toast.LENGTH_SHORT).show()
        mListener?.onFeedbackSubmitted()
        dismiss()
    }

    private fun clearError() {
        binding.tlUrgent.error = ""
        binding.tlType.error = ""
        binding.tlMessage.error = ""
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/feedback/FeedbackListFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.feedback

import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment.Companion.showNoData
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.databinding.FragmentFeedbackListBinding
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.FeedbackRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator
import org.ole.planet.myplanet.ui.feedback.FeedbackFragment.OnFeedbackSubmittedListener
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager

@AndroidEntryPoint
class FeedbackListFragment : Fragment(), OnFeedbackSubmittedListener {
    private var _binding: FragmentFeedbackListBinding? = null
    private val binding get() = _binding!!
    var userModel: RealmUserModel? = null
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    lateinit var prefManager: SharedPrefManager

    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    @Inject
    lateinit var feedbackRepository: FeedbackRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private val serverUrlMapper = ServerUrlMapper()

    @Inject
    lateinit var syncManager: SyncManager
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()
    private lateinit var realtimeSyncListener: BaseRealtimeSyncListener
    private lateinit var adapterFeedback: AdapterFeedback

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        prefManager = SharedPrefManager(requireContext())

        startFeedbackSync()
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentFeedbackListBinding.inflate(inflater, container, false)
        userModel = userProfileDbHandler.userModel

        binding.fab.setOnClickListener {
            val feedbackFragment = FeedbackFragment()
            feedbackFragment.setOnFeedbackSubmittedListener(this)
            if (!childFragmentManager.isStateSaved) {
                feedbackFragment.show(childFragmentManager, "")
            }
        }

        setupRealtimeSync()

        return binding.root
    }

    private fun setupRealtimeSync() {
        realtimeSyncListener = object : BaseRealtimeSyncListener() {
            override fun onTableDataUpdated(update: TableDataUpdate) {
                if (update.table == "feedback" && update.shouldRefreshUI) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        refreshFeedbackListData()
                    }
                }
            }

            override fun onSyncStarted() {}
            override fun onSyncComplete() {}
            override fun onSyncFailed(msg: String?) {}
        }
        syncCoordinator.addListener(realtimeSyncListener)
    }

    private fun refreshFeedbackListData() {
        onFeedbackSubmitted()
    }

    private fun startFeedbackSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isFeedbackSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(getString(R.string.syncing_feedback))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        onFeedbackSubmitted()
                        prefManager.setFeedbackSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null

                        Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG)
                            .setAction("Retry") { startFeedbackSync() }.show()
                    }
                }
            }
        }, "full", listOf("feedback"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        adapterFeedback = AdapterFeedback()
        binding.rvFeedback.layoutManager = LinearLayoutManager(activity)
        binding.rvFeedback.adapter = adapterFeedback
        onFeedbackSubmitted()
    }

    override fun onDestroyView() {
        if (::realtimeSyncListener.isInitialized) {
            syncCoordinator.removeListener(realtimeSyncListener)
        }
        _binding = null
        super.onDestroyView()
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        super.onDestroy()
    }

    override fun onFeedbackSubmitted() {
        lifecycleScope.launch {
            feedbackRepository.getFeedback(userModel).collectLatest { feedbackList ->
                updatedFeedbackList(feedbackList)
            }
        }
    }

    private fun updatedFeedbackList(updatedList: List<RealmFeedback>?) {
        adapterFeedback.submitList(updatedList)
        val itemCount = updatedList?.size ?: 0
        showNoData(binding.tvMessage, itemCount, "feedback")
        updateTextViewsVisibility(itemCount)
    }

    private fun updateTextViewsVisibility(itemCount: Int) {
        val visibility = if (itemCount == 0) View.GONE else View.VISIBLE
        binding.tvTitle.visibility = visibility
        binding.tvType.visibility = visibility
        binding.tvPriority.visibility = visibility
        binding.tvStatus.visibility = visibility
        binding.tvOpenDate.visibility = visibility
    }
}
=======
package org.ole.planet.myplanet.ui.feedback


import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment.Companion.showNoData
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.databinding.FragmentFeedbackListBinding
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.FeedbackRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator
import org.ole.planet.myplanet.ui.feedback.FeedbackFragment.OnFeedbackSubmittedListener
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager

@AndroidEntryPoint
class FeedbackListFragment : Fragment(), OnFeedbackSubmittedListener {
    private var _binding: FragmentFeedbackListBinding? = null
    private val binding get() = _binding!!
    var userModel: RealmUserModel? = null
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    lateinit var prefManager: SharedPrefManager

    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    @Inject
    lateinit var feedbackRepository: FeedbackRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private val serverUrlMapper = ServerUrlMapper()

    @Inject
    lateinit var syncManager: SyncManager
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()
    private lateinit var realtimeSyncListener: BaseRealtimeSyncListener
    private lateinit var adapterFeedback: AdapterFeedback

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        prefManager = SharedPrefManager(requireContext())

        startFeedbackSync()
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentFeedbackListBinding.inflate(inflater, container, false)
        userModel = userProfileDbHandler.userModel

        binding.fab.setOnClickListener {
            val feedbackFragment = FeedbackFragment()
            feedbackFragment.setOnFeedbackSubmittedListener(this)
            if (!childFragmentManager.isStateSaved) {
                feedbackFragment.show(childFragmentManager, "")
            }
        }

        setupRealtimeSync()

        return binding.root
    }

    private fun setupRealtimeSync() {
        realtimeSyncListener = object : BaseRealtimeSyncListener() {
            override fun onTableDataUpdated(update: TableDataUpdate) {
                if (update.table == "feedback" && update.shouldRefreshUI) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        refreshFeedbackListData()
                    }
                }
            }

            override fun onSyncStarted() {}
            override fun onSyncComplete() {}
            override fun onSyncFailed(msg: String?) {}
        }
        syncCoordinator.addListener(realtimeSyncListener)
    }

    private fun refreshFeedbackListData() {
        onFeedbackSubmitted()
    }

    private fun startFeedbackSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isFeedbackSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(getString(R.string.syncing_feedback))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        onFeedbackSubmitted()
                        prefManager.setFeedbackSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null

                        Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG)
                            .setAction("Retry") { startFeedbackSync() }.show()
                    }
                }
            }
        }, "full", listOf("feedback"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        adapterFeedback = AdapterFeedback()
        binding.rvFeedback.layoutManager = LinearLayoutManager(activity)
        binding.rvFeedback.adapter = adapterFeedback
        onFeedbackSubmitted()
    }

    override fun onDestroyView() {
        if (::realtimeSyncListener.isInitialized) {
            syncCoordinator.removeListener(realtimeSyncListener)
        }
        _binding = null
        super.onDestroyView()
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        super.onDestroy()
    }

    override fun onFeedbackSubmitted() {
        lifecycleScope.launch {
            feedbackRepository.getFeedback(userModel).collectLatest { feedbackList ->
                updatedFeedbackList(feedbackList)
            }
        }
    }

    private fun updatedFeedbackList(updatedList: List<RealmFeedback>?) {
        adapterFeedback.submitList(updatedList)
        val itemCount = updatedList?.size ?: 0
        showNoData(binding.tvMessage, itemCount, "feedback")
        updateTextViewsVisibility(itemCount)
    }

    private fun updateTextViewsVisibility(itemCount: Int) {
        val visibility = if (itemCount == 0) View.GONE else View.VISIBLE
        binding.tvTitle.visibility = visibility
        binding.tvType.visibility = visibility
        binding.tvPriority.visibility = visibility
        binding.tvStatus.visibility = visibility
        binding.tvOpenDate.visibility = visibility
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/references/ReferenceFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.references

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.FragmentReferenceBinding
import org.ole.planet.myplanet.databinding.RowReferenceBinding
import org.ole.planet.myplanet.model.Reference
import org.ole.planet.myplanet.ui.dictionary.DictionaryActivity
import org.ole.planet.myplanet.ui.map.OfflineMapActivity

class ReferenceFragment : Fragment() {
    private var _binding: FragmentReferenceBinding? = null
    private val binding get() = _binding!!
    private lateinit var rowReferenceBinding: RowReferenceBinding
    private var homeItemClickListener: OnHomeItemClickListener? = null

    override fun onAttach(context: Context) {
        super.onAttach(context)
        homeItemClickListener = context as? OnHomeItemClickListener
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentReferenceBinding.inflate(inflater, container, false)
        val list = listOf(
            Reference(getString(R.string.maps), android.R.drawable.ic_dialog_map),
            Reference(getString(R.string.english_dictionary), R.drawable.ic_dictionary)
        )
        binding.rvReferences.layoutManager = GridLayoutManager(activity, 3)
        setRecyclerAdapter(list)
        return binding.root
    }

    private fun setRecyclerAdapter(list: List<Reference>) {
        binding.rvReferences.adapter = object : RecyclerView.Adapter<ViewHolderReference>() {
            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderReference {
                rowReferenceBinding = RowReferenceBinding.inflate(LayoutInflater.from(parent.context), parent, false)
                return ViewHolderReference(rowReferenceBinding.root)
            }

            override fun onBindViewHolder(holder: ViewHolderReference, position: Int) {
                rowReferenceBinding.title.text = list[position].title
                rowReferenceBinding.icon.setImageResource(list[position].icon)
                rowReferenceBinding.root.setOnClickListener {
                    if (position == 0)
                        startActivity(Intent(activity, OfflineMapActivity::class.java))
                    else {
                        startActivity(Intent(activity, DictionaryActivity::class.java))
                    }
                }
            }

            override fun getItemCount(): Int = list.size
        }
    }

    class ViewHolderReference(itemView: View) : RecyclerView.ViewHolder(itemView)

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.references


import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.FragmentReferenceBinding
import org.ole.planet.myplanet.databinding.RowReferenceBinding
import org.ole.planet.myplanet.model.Reference
import org.ole.planet.myplanet.ui.dictionary.DictionaryActivity
import org.ole.planet.myplanet.ui.map.OfflineMapActivity

class ReferenceFragment : Fragment() {
    private var _binding: FragmentReferenceBinding? = null
    private val binding get() = _binding!!
    private lateinit var rowReferenceBinding: RowReferenceBinding
    private var homeItemClickListener: OnHomeItemClickListener? = null

    override fun onAttach(context: Context) {
        super.onAttach(context)
        homeItemClickListener = context as? OnHomeItemClickListener
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentReferenceBinding.inflate(inflater, container, false)
        val list = listOf(
            Reference(getString(R.string.maps), android.R.drawable.ic_dialog_map),
            Reference(getString(R.string.english_dictionary), R.drawable.ic_dictionary)
        )
        binding.rvReferences.layoutManager = GridLayoutManager(activity, 3)
        setRecyclerAdapter(list)
        return binding.root
    }

    private fun setRecyclerAdapter(list: List<Reference>) {
        binding.rvReferences.adapter = object : RecyclerView.Adapter<ViewHolderReference>() {
            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderReference {
                rowReferenceBinding = RowReferenceBinding.inflate(LayoutInflater.from(parent.context), parent, false)
                return ViewHolderReference(rowReferenceBinding.root)
            }

            override fun onBindViewHolder(holder: ViewHolderReference, position: Int) {
                rowReferenceBinding.title.text = list[position].title
                rowReferenceBinding.icon.setImageResource(list[position].icon)
                rowReferenceBinding.root.setOnClickListener {
                    if (position == 0)
                        startActivity(Intent(activity, OfflineMapActivity::class.java))
                    else {
                        startActivity(Intent(activity, DictionaryActivity::class.java))
                    }
                }
            }

            override fun getItemCount(): Int = list.size
        }
    }

    class ViewHolderReference(itemView: View) : RecyclerView.ViewHolder(itemView)

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/news/AdapterNews.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.news

import android.annotation.SuppressLint
import android.app.Dialog
import android.content.Context
import android.content.DialogInterface
import android.content.SharedPreferences
import android.graphics.Color
import android.os.Build
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.cardview.widget.CardView
import androidx.core.content.ContextCompat
import androidx.core.graphics.drawable.toDrawable
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.github.chrisbanes.photoview.PhotoView
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Case
import io.realm.Realm
import io.realm.RealmList
import io.realm.Sort
import java.io.File
import java.util.Calendar
import java.util.Locale
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowNewsBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.Conversation
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.chat.ChatAdapter
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.ImageUtils
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.Markdown.prependBaseUrlToImages
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities
import org.ole.planet.myplanet.utilities.makeExpandable

class AdapterNews(var context: Context, private var currentUser: RealmUserModel?, private val parentNews: RealmNews?, private val teamName: String = "", private val teamId: String? = null, private val userProfileDbHandler: UserProfileDbHandler, private val databaseService: DatabaseService) : ListAdapter<RealmNews?, RecyclerView.ViewHolder?>(
    DiffUtils.itemCallback(
        areItemsTheSame = { oldItem, newItem ->
            if (oldItem === newItem) return@itemCallback true
            if (oldItem == null || newItem == null) return@itemCallback oldItem == newItem

            try {
                val oId = oldItem.takeIf { it.isValid }?.id
                val nId = newItem.takeIf { it.isValid }?.id
                oId != null && oId == nId
            } catch (e: Exception) {
                false
            }
        },
        areContentsTheSame = { oldItem, newItem ->
            if (oldItem === newItem) return@itemCallback true
            if (oldItem == null || newItem == null) return@itemCallback oldItem == newItem

            try {
                if (!oldItem.isValid || !newItem.isValid) return@itemCallback false

                oldItem.id == newItem.id &&
                    oldItem.time == newItem.time &&
                    oldItem.isEdited == newItem.isEdited &&
                    oldItem.message == newItem.message &&
                    oldItem.userName == newItem.userName &&
                    oldItem.userId == newItem.userId &&
                    oldItem.sharedBy == newItem.sharedBy
            } catch (e: Exception) {
                false
            }
        }
    )
) {
    private var listener: OnNewsItemClickListener? = null
    private var imageList: RealmList<String>? = null
    lateinit var mRealm: Realm
    private var fromLogin = false
    private var nonTeamMember = false
    private var sharedPreferences: SharedPrefManager? = null
    private var recyclerView: RecyclerView? = null
    var user: RealmUserModel? = null
    private var labelManager: NewsLabelManager? = null
    private val gson = Gson()
    private val profileDbHandler = userProfileDbHandler
    lateinit var settings: SharedPreferences
    private val userCache = mutableMapOf<String, RealmUserModel?>()
    private val leadersList: List<RealmUserModel> by lazy {
        val raw = settings.getString("communityLeaders", "") ?: ""
        RealmUserModel.parseLeadersJson(raw)
    }

    fun setImageList(imageList: RealmList<String>?) {
        this.imageList = imageList
    }

    fun addItem(news: RealmNews?) {
        val currentList = currentList.toMutableList()
        currentList.add(0, news)
        submitListSafely(currentList) {
            recyclerView?.post {
                recyclerView?.scrollToPosition(0)
                recyclerView?.smoothScrollToPosition(0)
            }
        }
    }

    fun setFromLogin(fromLogin: Boolean) {
        this.fromLogin = fromLogin
    }

    fun setNonTeamMember(nonTeamMember: Boolean) {
        if (this.nonTeamMember != nonTeamMember) {
            this.nonTeamMember = nonTeamMember
            notifyItemRangeChanged(0, itemCount)
        }
    }

    fun setListener(listener: OnNewsItemClickListener?) {
        this.listener = listener
    }

    fun setmRealm(mRealm: Realm?) {
        if (mRealm != null) {
            this.mRealm = mRealm
            labelManager = NewsLabelManager(context, this.mRealm)
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val binding = RowNewsBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        sharedPreferences = SharedPrefManager(context)
        user = userProfileDbHandler.userModel
        settings = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        if (::mRealm.isInitialized) {
            if (labelManager == null) labelManager = NewsLabelManager(context, mRealm)
        }
        return ViewHolderNews(binding)
    }

    @SuppressLint("SetTextI18n")
    @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder is ViewHolderNews) {
            holder.bind(position)
            val news = getNews(holder, position)

            if (news?.isValid == true) {
                val viewHolder = holder
                val sharedTeamName = extractSharedTeamName(news)

                resetViews(viewHolder)

                updateReplyCount(viewHolder = viewHolder, getReplies(news), position)

                val userModel = configureUser(viewHolder, news)
                showShareButton(viewHolder, news)

                setMessageAndDate(viewHolder, news, sharedTeamName)

                configureEditDeleteButtons(viewHolder, news)

                loadImage(viewHolder.binding, news)
                showReplyButton(viewHolder, news, position)
                val canManageLabels = canAddLabel(news)
                labelManager?.setupAddLabelMenu(viewHolder.binding, news, canManageLabels)
                news.let { labelManager?.showChips(viewHolder.binding, it, canManageLabels) }

                handleChat(viewHolder, news)

                val currentLeader = getCurrentLeader(userModel, news)
                setMemberClickListeners(viewHolder, userModel, currentLeader)
            }
        }
    }

    fun updateReplyBadge(newsId: String?) {
        if (newsId.isNullOrEmpty()) return
        val index = if (parentNews != null) {
            when {
                parentNews.id == newsId -> 0
                else -> currentList.indexOfFirst { it?.id == newsId }.let { if (it != -1) it + 1 else -1 }
            }
        } else {
            currentList.indexOfFirst { it?.id == newsId }
        }
        if (index >= 0) {
            notifyItemChanged(index)
        }
    }

    private fun extractSharedTeamName(news: RealmNews): String {
        if (!TextUtils.isEmpty(news.viewIn)) {
            val ar = gson.fromJson(news.viewIn, JsonArray::class.java)
            if (ar.size() > 1) {
                val ob = ar[0].asJsonObject
                if (ob.has("name") && !ob.get("name").isJsonNull) {
                    return ob.get("name").asString
                }
            }
        }
        return ""
    }

    private fun resetViews(holder: ViewHolderNews) {
        with(holder.binding) {
            tvName.text = ""
            imgUser.setImageResource(0)
            llEditDelete.visibility = View.GONE
            linearLayout51.visibility = View.VISIBLE
            tvMessage.text = ""
            tvDate.text = ""
            imgDelete.setOnClickListener(null)
            imgEdit.setOnClickListener(null)
            btnAddLabel.visibility = View.GONE
            imgEdit.visibility = View.GONE
            imgDelete.visibility = View.GONE
            btnReply.visibility = View.GONE
            imgNews.visibility = View.GONE
            llNewsImages.visibility = View.GONE
            llNewsImages.removeAllViews()
            recyclerGchat.visibility = View.GONE
            sharedChat.visibility = View.GONE
        }
    }

    private fun configureUser(holder: ViewHolderNews, news: RealmNews): RealmUserModel? {
        val userId = news.userId
        val userModel = when {
            userId.isNullOrEmpty() -> null
            userCache.containsKey(userId) -> userCache[userId]
            ::mRealm.isInitialized -> {
                val managedUser = mRealm.where(RealmUserModel::class.java)
                    .equalTo("id", userId)
                    .findFirst()
                val detachedUser = managedUser?.let {
                    try {
                        mRealm.copyFromRealm(it)
                    } catch (e: Exception) {
                        null
                    }
                }
                if (detachedUser != null) {
                    userCache[userId] = detachedUser
                } else if (managedUser == null) {
                    userCache[userId] = null
                }
                detachedUser ?: managedUser
            }
            else -> null
        }
        val userFullName = userModel?.getFullNameWithMiddleName()?.trim()
        if (userModel != null && currentUser != null) {
            holder.binding.tvName.text =
                if (userFullName.isNullOrEmpty()) news.userName else userFullName
            ImageUtils.loadImage(userModel.userImage, holder.binding.imgUser)
            showHideButtons(news, holder)
        } else {
            holder.binding.tvName.text = news.userName
            ImageUtils.loadImage(null, holder.binding.imgUser)
        }
        return userModel
    }

    private fun setMessageAndDate(holder: ViewHolderNews, news: RealmNews, sharedTeamName: String) {
        val markdownContentWithLocalPaths = prependBaseUrlToImages(
            news.message,
            "file://" + context.getExternalFilesDir(null) + "/ole/",
            600,
            350
        )
        setMarkdownText(holder.binding.tvMessage, markdownContentWithLocalPaths)
        val fulltext = holder.binding.tvMessage.text
        holder.binding.tvMessage.makeExpandable(
            fullText = fulltext,
            collapsedMaxLines = 6
        )
        holder.binding.tvDate.text =
            if (sharedTeamName.isEmpty() || teamName.isNotEmpty()) {
                formatDate(news.time)
            } else {
                "${formatDate(news.time)} | Shared from $sharedTeamName"
            }
        holder.binding.tvEdited.visibility = if (news.isEdited) View.VISIBLE else View.GONE
    }

    private fun configureEditDeleteButtons(holder: ViewHolderNews, news: RealmNews) {
        if (news.sharedBy == currentUser?._id && !fromLogin && !nonTeamMember && teamName.isEmpty()) {
            holder.binding.imgDelete.visibility = View.VISIBLE
        }

        if (news.userId == currentUser?._id || news.sharedBy == currentUser?._id) {
            holder.binding.imgDelete.setOnClickListener {
                AlertDialog.Builder(context, R.style.AlertDialogTheme)
                    .setMessage(R.string.delete_record)
                    .setPositiveButton(R.string.ok) { _: DialogInterface?, _: Int ->
                        val currentList = currentList.toMutableList()
                        val pos = holder.adapterPosition
                        val adjustedPos = if (parentNews != null && pos > 0) pos - 1 else pos
                        if (adjustedPos >= 0 && adjustedPos < currentList.size) {
                            currentList.removeAt(adjustedPos)
                            submitListSafely(currentList)
                        }
                        NewsActions.deletePost(mRealm, news, currentList.toMutableList(), teamName, listener)
                    }
                    .setNegativeButton(R.string.cancel, null)
                    .show()
            }
        }

        if (news.userId == currentUser?._id) {
            holder.binding.imgEdit.setOnClickListener {
                NewsActions.showEditAlert(
                    context,
                    mRealm,
                    news.id,
                    true,
                    currentUser,
                    listener,
                    holder,
                ) { holder, updatedNews, position ->
                    showReplyButton(holder, updatedNews, position)
                    notifyItemChanged(position)
                }
            }
        } else {
            holder.binding.imgEdit.visibility = View.GONE
        }
    }

    private fun handleChat(holder: ViewHolderNews, news: RealmNews) {
        if (news.newsId?.isNotEmpty() == true) {
            val conversations = gson.fromJson(news.conversations, Array<Conversation>::class.java).toList()
            val chatAdapter = ChatAdapter(context, holder.binding.recyclerGchat)

            if (user?.id?.startsWith("guest") == false) {
                chatAdapter.setOnChatItemClickListener(object : ChatAdapter.OnChatItemClickListener {
                    override fun onChatItemClick(position: Int, chatItem: String) {
                        listener?.onNewsItemClick(news)
                    }
                })
            }

            for (conversation in conversations) {
                val query = conversation.query
                val response = conversation.response
                if (query != null) {
                    chatAdapter.addQuery(query)
                }
                chatAdapter.responseSource = ChatAdapter.RESPONSE_SOURCE_SHARED_VIEW_MODEL
                if (response != null) {
                    chatAdapter.addResponse(response)
                }
            }

            holder.binding.recyclerGchat.adapter = chatAdapter
            holder.binding.recyclerGchat.layoutManager = LinearLayoutManager(context)
            holder.binding.recyclerGchat.visibility = View.VISIBLE
            holder.binding.sharedChat.visibility = View.VISIBLE
        } else {
            holder.binding.recyclerGchat.visibility = View.GONE
            holder.binding.sharedChat.visibility = View.GONE
        }
    }

    private fun getCurrentLeader(userModel: RealmUserModel?, news: RealmNews): RealmUserModel? {
        if (userModel == null) {
            for (leader in leadersList) {
                if (leader.name == news.userName) {
                    return leader
                }
            }
        }
        return null
    }

    fun updateList(newList: List<RealmNews?>) {
        submitListSafely(newList)
    }

    fun refreshCurrentItems() {
        submitListSafely(currentList.toList())
    }

    private fun submitListSafely(list: List<RealmNews?>, commitCallback: Runnable? = null) {
        userCache.clear()
        val detachedList = list.map { news ->
            if (news?.isValid == true && ::mRealm.isInitialized) {
                try {
                    mRealm.copyFromRealm(news)
                } catch (e: Exception) {
                    news
                }
            } else {
                news
            }
        }
        submitList(detachedList, commitCallback)
    }

    private fun setMemberClickListeners(holder: ViewHolderNews, userModel: RealmUserModel?, currentLeader: RealmUserModel?) {
        if (!fromLogin) {
            holder.binding.imgUser.setOnClickListener {
                val model = userModel ?: currentLeader
                listener?.onMemberSelected(model)
            }
            holder.binding.tvName.setOnClickListener {
                val model = userModel ?: currentLeader
                listener?.onMemberSelected(model)
            }
        }
    }

    private fun isGuestUser() = user?.id?.startsWith("guest") == true

    private fun isOwner(news: RealmNews?): Boolean =
        news?.userId == currentUser?._id

    private fun isSharedByCurrentUser(news: RealmNews?): Boolean =
        news?.sharedBy == currentUser?._id

    private fun isAdmin(): Boolean =
        currentUser?.level.equals("admin", ignoreCase = true)

    private fun isLoggedInAndMember(): Boolean =
        !fromLogin && !nonTeamMember

    private fun canEdit(news: RealmNews?): Boolean =
        isLoggedInAndMember() && (isOwner(news) || isAdmin() || isTeamLeader())

    private fun canDelete(news: RealmNews?): Boolean =
        isLoggedInAndMember() && (isOwner(news) || isSharedByCurrentUser(news) || isAdmin() || isTeamLeader())

    private fun canReply(): Boolean =
        isLoggedInAndMember() && !isGuestUser()

    private fun canAddLabel(news: RealmNews?): Boolean =
        isLoggedInAndMember() && (isOwner(news) || isTeamLeader())

    private fun canShare(news: RealmNews?): Boolean =
        isLoggedInAndMember() && !news?.isCommunityNews!! && !isGuestUser()

    private fun View.setVisibility(condition: Boolean) {
        visibility = if (condition) View.VISIBLE else View.GONE
    }

    fun isTeamLeader(): Boolean {
        if(teamId==null)return false
        return try {
            if (::mRealm.isInitialized && !mRealm.isClosed) {
                val team = mRealm.where(RealmMyTeam::class.java)
                    .equalTo("teamId", teamId)
                    .equalTo("isLeader", true)
                    .findFirst()
                team?.userId == currentUser?._id
            } else {
                databaseService.withRealm { realm ->
                    val team = realm.where(RealmMyTeam::class.java)
                        .equalTo("teamId", teamId)
                        .equalTo("isLeader", true)
                        .findFirst()
                    team?.userId == currentUser?._id
                }
            }
        } catch (e: Exception) {
            false
        }
    }

    private fun getReplies(finalNews: RealmNews?): List<RealmNews> {
        return try {
            if (::mRealm.isInitialized && !mRealm.isClosed) {
                mRealm.where(RealmNews::class.java)
                    .sort("time", Sort.DESCENDING)
                    .equalTo("replyTo", finalNews?.id, Case.INSENSITIVE)
                    .findAll()
            } else {
                databaseService.withRealm { realm ->
                    realm.where(RealmNews::class.java)
                        .sort("time", Sort.DESCENDING)
                        .equalTo("replyTo", finalNews?.id, Case.INSENSITIVE)
                        .findAll()
                        .let { realm.copyFromRealm(it) }
                }
            }
        } catch (e: Exception) {
            emptyList()
        }
    }

    private fun updateReplyCount(viewHolder: ViewHolderNews, replies: List<RealmNews>, position: Int) {
        with(viewHolder.binding) {
            btnShowReply.text = String.format(Locale.getDefault(),"(%d)", replies.size)
            btnShowReply.setTextColor(context.getColor(R.color.daynight_textColor))
            val visible = replies.isNotEmpty() && !(position == 0 && parentNews != null) && canReply()
            btnShowReply.visibility = if (visible) View.VISIBLE else View.GONE
        }
    }

    private fun getNews(holder: RecyclerView.ViewHolder, position: Int): RealmNews? {
        val news: RealmNews? = if (parentNews != null) {
            if (position == 0) {
                (holder.itemView as CardView).setCardBackgroundColor(ContextCompat.getColor(context, R.color.md_blue_50))
                parentNews
            } else {
                (holder.itemView as CardView).setCardBackgroundColor(ContextCompat.getColor(context, R.color.md_white_1000))
                getItem(position - 1)
            }
        } else {
            (holder.itemView as CardView).setCardBackgroundColor(ContextCompat.getColor(context, R.color.md_white_1000))
            getItem(position)
        }
        return news
    }

    private fun showHideButtons(news: RealmNews?, holder: RecyclerView.ViewHolder) {
        val viewHolder = holder as ViewHolderNews
        with(viewHolder.binding) {
            imgEdit.setVisibility(canEdit(news))
            imgDelete.setVisibility(canDelete(news))
            btnAddLabel.setVisibility(canAddLabel(news))
            llEditDelete.setVisibility(canEdit(news) || canDelete(news))
        }
    }

    private fun shouldShowReplyButton(): Boolean = canReply()

    private fun showReplyButton(holder: RecyclerView.ViewHolder, finalNews: RealmNews?, position: Int) {
        val viewHolder = holder as ViewHolderNews
        if (shouldShowReplyButton()) {
            viewHolder.binding.btnReply.visibility = if (nonTeamMember) View.GONE else View.VISIBLE
            viewHolder.binding.btnReply.setOnClickListener {
                NewsActions.showEditAlert(
                    context,
                    mRealm,
                    finalNews?.id,
                    false,
                    currentUser,
                    listener,
                     viewHolder,
                ) { holder, news, i -> showReplyButton(holder, news, i) }
            }
        } else {
            viewHolder.binding.btnReply.visibility = View.GONE
        }

        val replies = getReplies(finalNews)
        updateReplyCount(viewHolder, replies, position)

        viewHolder.binding.btnShowReply.setOnClickListener {
            sharedPreferences?.setRepliedNewsId(finalNews?.id)
            listener?.showReply(finalNews, fromLogin, nonTeamMember)
        }
    }

    override fun getItemCount(): Int {
        return if (parentNews == null) super.getItemCount() else super.getItemCount() + 1
    }

    interface OnNewsItemClickListener {
        fun showReply(news: RealmNews?, fromLogin: Boolean, nonTeamMember: Boolean)
        fun addImage(llImage: ViewGroup?)
        fun onNewsItemClick(news: RealmNews?)
        fun clearImages()
        fun onDataChanged()
        fun onMemberSelected(userModel: RealmUserModel?)
        fun getCurrentImageList(): RealmList<String>?
    }

    private fun showShareButton(holder: RecyclerView.ViewHolder, news: RealmNews?) {
        val viewHolder = holder as ViewHolderNews

        viewHolder.binding.btnShare.setVisibility(canShare(news))

        viewHolder.binding.btnShare.setOnClickListener {
            AlertDialog.Builder(context, R.style.AlertDialogTheme)
                .setTitle(R.string.share_with_community)
                .setMessage(R.string.confirm_share_community)
                .setPositiveButton(R.string.yes) { _, _ ->
                    val array = gson.fromJson(news?.viewIn, JsonArray::class.java)
                    val firstElement = array.get(0)
                    val obj = firstElement.asJsonObject
                    if(!obj.has("name")){
                        obj.addProperty("name", teamName)
                    }
                    val ob = JsonObject()
                    ob.addProperty("section", "community")
                    ob.addProperty("_id", currentUser?.planetCode + "@" + currentUser?.parentCode)
                    ob.addProperty("sharedDate", Calendar.getInstance().timeInMillis)
                    array.add(ob)
                    if (!mRealm.isInTransaction) {
                        mRealm.beginTransaction()
                    }

                    val managedNews = news?.let { newsItem ->
                        if (newsItem.isManaged) {
                            newsItem
                        } else {
                            mRealm.where(RealmNews::class.java)
                                .equalTo("id", newsItem.id)
                                .findFirst()
                        }
                    }

                    managedNews?.sharedBy = currentUser?.id
                    managedNews?.viewIn = gson.toJson(array)
                    mRealm.commitTransaction()
                    Utilities.toast(context, context.getString(R.string.shared_to_community))
                    viewHolder.binding.btnShare.visibility = View.GONE
                }
                .setNegativeButton(R.string.cancel, null)
                .show()
        }
    }

    override fun onAttachedToRecyclerView(recyclerView: RecyclerView) {
        super.onAttachedToRecyclerView(recyclerView)
        this.recyclerView = recyclerView
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        super.onDetachedFromRecyclerView(recyclerView)
        this.recyclerView = null
    }

    private fun loadImage(binding: RowNewsBinding, news: RealmNews?) {
        binding.imgNews.visibility = View.GONE
        binding.llNewsImages.visibility = View.GONE
        binding.llNewsImages.removeAllViews()

        val imageUrls = news?.imageUrls
        if (!imageUrls.isNullOrEmpty()) {
            try {
                if (imageUrls.size == 1) {
                    val imgObject = gson.fromJson(imageUrls[0], JsonObject::class.java)
                    val path = JsonUtils.getString("imageUrl", imgObject)
                    loadSingleImage(binding, path)
                } else {
                    binding.llNewsImages.visibility = View.VISIBLE
                    for (imageUrl in imageUrls) {
                        val imgObject = gson.fromJson(imageUrl, JsonObject::class.java)
                        val path = JsonUtils.getString("imageUrl", imgObject)
                        addImageToContainer(binding, path)
                    }
                }
                return
            } catch (_: Exception) {
            }
        }

        news?.imagesArray?.let { imagesArray ->
            if (imagesArray.size() > 0) {
                if (imagesArray.size() == 1) {
                    val ob = imagesArray[0]?.asJsonObject
                    val resourceId = JsonUtils.getString("resourceId", ob)
                    loadLibraryImage(binding, resourceId)
                } else {
                    binding.llNewsImages.visibility = View.VISIBLE
                    for (i in 0 until imagesArray.size()) {
                        val ob = imagesArray[i]?.asJsonObject
                        val resourceId = JsonUtils.getString("resourceId", ob)
                        addLibraryImageToContainer(binding, resourceId)
                    }
                }
            }
        }
    }

    private fun loadSingleImage(binding: RowNewsBinding, path: String?) {
        if (path == null) return
        val request = Glide.with(binding.imgNews.context)
        val target = if (path.lowercase(Locale.getDefault()).endsWith(".gif")) {
            request.asGif().load(if (File(path).exists()) File(path) else path)
        } else {
            request.load(if (File(path).exists()) File(path) else path)
        }
        target.placeholder(R.drawable.ic_loading)
            .error(R.drawable.ic_loading)
            .into(binding.imgNews)
        binding.imgNews.visibility = View.VISIBLE
        binding.imgNews.setOnClickListener {
            showZoomableImage(it.context, path)
        }
    }

    private fun addImageToContainer(binding: RowNewsBinding, path: String?) {
        if (path == null) return
        val imageView = ImageView(context)
        val size = (100 * context.resources.displayMetrics.density).toInt()
        val margin = (4 * context.resources.displayMetrics.density).toInt()
        val params = ViewGroup.MarginLayoutParams(size, size)
        params.setMargins(margin, margin, margin, margin)
        imageView.layoutParams = params
        imageView.scaleType = ImageView.ScaleType.CENTER_CROP

        val request = Glide.with(context)
        val target = if (path.lowercase(Locale.getDefault()).endsWith(".gif")) {
            request.asGif().load(if (File(path).exists()) File(path) else path)
        } else {
            request.load(if (File(path).exists()) File(path) else path)
        }
        target.placeholder(R.drawable.ic_loading)
            .error(R.drawable.ic_loading)
            .into(imageView)

        imageView.setOnClickListener {
            showZoomableImage(context, path)
        }

        binding.llNewsImages.addView(imageView)
    }

    private fun loadLibraryImage(binding: RowNewsBinding, resourceId: String?) {
        if (resourceId == null) return
        val library = mRealm.where(RealmMyLibrary::class.java)
            .equalTo("_id", resourceId)
            .findFirst()

        val basePath = context.getExternalFilesDir(null)
        if (library != null && basePath != null) {
            val imageFile = File(basePath, "ole/${library.id}/${library.resourceLocalAddress}")
            if (imageFile.exists()) {
                val request = Glide.with(binding.imgNews.context)
                val isGif = library.resourceLocalAddress?.lowercase(Locale.getDefault())?.endsWith(".gif") == true
                val target = if (isGif) {
                    request.asGif().load(imageFile)
                } else {
                    request.load(imageFile)
                }
                target.placeholder(R.drawable.ic_loading)
                    .error(R.drawable.ic_loading)
                    .into(binding.imgNews)
                binding.imgNews.visibility = View.VISIBLE
                binding.imgNews.setOnClickListener {
                    showZoomableImage(it.context, imageFile.toString())
                }
            }
        }
    }

    private fun addLibraryImageToContainer(binding: RowNewsBinding, resourceId: String?) {
        if (resourceId == null) return
        val library = mRealm.where(RealmMyLibrary::class.java)
            .equalTo("_id", resourceId)
            .findFirst()

        val basePath = context.getExternalFilesDir(null)
        if (library != null && basePath != null) {
            val imageFile = File(basePath, "ole/${library.id}/${library.resourceLocalAddress}")
            if (imageFile.exists()) {
                val imageView = ImageView(context)
                val size = (100 * context.resources.displayMetrics.density).toInt()
                val margin = (4 * context.resources.displayMetrics.density).toInt()
                val params = ViewGroup.MarginLayoutParams(size, size)
                params.setMargins(margin, margin, margin, margin)
                imageView.layoutParams = params
                imageView.scaleType = ImageView.ScaleType.CENTER_CROP

                val request = Glide.with(context)
                val isGif = library.resourceLocalAddress?.lowercase(Locale.getDefault())?.endsWith(".gif") == true
                val target = if (isGif) {
                    request.asGif().load(imageFile)
                } else {
                    request.load(imageFile)
                }
                target.placeholder(R.drawable.ic_loading)
                    .error(R.drawable.ic_loading)
                    .into(imageView)

                imageView.setOnClickListener {
                    showZoomableImage(context, imageFile.toString())
                }

                binding.llNewsImages.addView(imageView)
            }
        }
    }

    private fun showZoomableImage(context: Context, imageUrl: String) {
        val dialog = Dialog(context, android.R.style.Theme_Black_NoTitleBar_Fullscreen)
        val view = LayoutInflater.from(context).inflate(R.layout.dialog_zoomable_image, null)
        val photoView = view.findViewById<PhotoView>(R.id.photoView)
        val closeButton = view.findViewById<ImageView>(R.id.closeButton)

        dialog.setContentView(view)
        dialog.window?.setBackgroundDrawable(Color.BLACK.toDrawable())

        val request = Glide.with(photoView.context)
        val target = if (imageUrl.lowercase(Locale.getDefault()).endsWith(".gif")) {
            val file = File(imageUrl)
            if (file.exists()) request.asGif().load(file) else request.asGif().load(imageUrl)
        } else {
            val file = File(imageUrl)
            if (file.exists()) request.load(file) else request.load(imageUrl)
        }
        target.error(R.drawable.ic_loading).into(photoView)

        closeButton.setOnClickListener { dialog.dismiss() }

        dialog.show()
    }

    internal inner class ViewHolderNews(val binding: RowNewsBinding) : RecyclerView.ViewHolder(binding.root) {
        private var adapterPosition = 0
        fun bind(position: Int) {
            adapterPosition = position
        }
    }

}
=======
package org.ole.planet.myplanet.ui.news


import android.annotation.SuppressLint
import android.app.Dialog
import android.content.Context
import android.content.DialogInterface
import android.content.SharedPreferences
import android.graphics.Color
import android.os.Build
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.cardview.widget.CardView
import androidx.core.content.ContextCompat
import androidx.core.graphics.drawable.toDrawable
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.github.chrisbanes.photoview.PhotoView
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Case
import io.realm.Realm
import io.realm.RealmList
import io.realm.Sort
import java.io.File
import java.util.Calendar
import java.util.Locale
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowNewsBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.Conversation
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.chat.ChatAdapter
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.ImageUtils
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.Markdown.prependBaseUrlToImages
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities
import org.ole.planet.myplanet.utilities.makeExpandable

class AdapterNews(var context: Context, private var currentUser: RealmUserModel?, private val parentNews: RealmNews?, private val teamName: String = "", private val teamId: String? = null, private val userProfileDbHandler: UserProfileDbHandler, private val databaseService: DatabaseService) : ListAdapter<RealmNews?, RecyclerView.ViewHolder?>(
    DiffUtils.itemCallback(
        areItemsTheSame = { oldItem, newItem ->
            if (oldItem === newItem) return@itemCallback true
            if (oldItem == null || newItem == null) return@itemCallback oldItem == newItem

            try {
                val oId = oldItem.takeIf { it.isValid }?.id
                val nId = newItem.takeIf { it.isValid }?.id
                oId != null && oId == nId
            } catch (e: Exception) {
                false
            }
        },
        areContentsTheSame = { oldItem, newItem ->
            if (oldItem === newItem) return@itemCallback true
            if (oldItem == null || newItem == null) return@itemCallback oldItem == newItem

            try {
                if (!oldItem.isValid || !newItem.isValid) return@itemCallback false

                oldItem.id == newItem.id &&
                    oldItem.time == newItem.time &&
                    oldItem.isEdited == newItem.isEdited &&
                    oldItem.message == newItem.message &&
                    oldItem.userName == newItem.userName &&
                    oldItem.userId == newItem.userId &&
                    oldItem.sharedBy == newItem.sharedBy
            } catch (e: Exception) {
                false
            }
        }
    )
) {
    private var listener: OnNewsItemClickListener? = null
    private var imageList: RealmList<String>? = null
    lateinit var mRealm: Realm
    private var fromLogin = false
    private var nonTeamMember = false
    private var sharedPreferences: SharedPrefManager? = null
    private var recyclerView: RecyclerView? = null
    var user: RealmUserModel? = null
    private var labelManager: NewsLabelManager? = null
    private val gson = Gson()
    private val profileDbHandler = userProfileDbHandler
    lateinit var settings: SharedPreferences
    private val userCache = mutableMapOf<String, RealmUserModel?>()
    private val leadersList: List<RealmUserModel> by lazy {
        val raw = settings.getString("communityLeaders", "") ?: ""
        RealmUserModel.parseLeadersJson(raw)
    }

    fun setImageList(imageList: RealmList<String>?) {
        this.imageList = imageList
    }

    fun addItem(news: RealmNews?) {
        val currentList = currentList.toMutableList()
        currentList.add(0, news)
        submitListSafely(currentList) {
            recyclerView?.post {
                recyclerView?.scrollToPosition(0)
                recyclerView?.smoothScrollToPosition(0)
            }
        }
    }

    fun setFromLogin(fromLogin: Boolean) {
        this.fromLogin = fromLogin
    }

    fun setNonTeamMember(nonTeamMember: Boolean) {
        if (this.nonTeamMember != nonTeamMember) {
            this.nonTeamMember = nonTeamMember
            notifyItemRangeChanged(0, itemCount)
        }
    }

    fun setListener(listener: OnNewsItemClickListener?) {
        this.listener = listener
    }

    fun setmRealm(mRealm: Realm?) {
        if (mRealm != null) {
            this.mRealm = mRealm
            labelManager = NewsLabelManager(context, this.mRealm)
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val binding = RowNewsBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        sharedPreferences = SharedPrefManager(context)
        user = userProfileDbHandler.userModel
        settings = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        if (::mRealm.isInitialized) {
            if (labelManager == null) labelManager = NewsLabelManager(context, mRealm)
        }
        return ViewHolderNews(binding)
    }

    @SuppressLint("SetTextI18n")
    @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder is ViewHolderNews) {
            holder.bind(position)
            val news = getNews(holder, position)

            if (news?.isValid == true) {
                val viewHolder = holder
                val sharedTeamName = extractSharedTeamName(news)

                resetViews(viewHolder)

                updateReplyCount(viewHolder = viewHolder, getReplies(news), position)

                val userModel = configureUser(viewHolder, news)
                showShareButton(viewHolder, news)

                setMessageAndDate(viewHolder, news, sharedTeamName)

                configureEditDeleteButtons(viewHolder, news)

                loadImage(viewHolder.binding, news)
                showReplyButton(viewHolder, news, position)
                val canManageLabels = canAddLabel(news)
                labelManager?.setupAddLabelMenu(viewHolder.binding, news, canManageLabels)
                news.let { labelManager?.showChips(viewHolder.binding, it, canManageLabels) }

                handleChat(viewHolder, news)

                val currentLeader = getCurrentLeader(userModel, news)
                setMemberClickListeners(viewHolder, userModel, currentLeader)
            }
        }
    }

    fun updateReplyBadge(newsId: String?) {
        if (newsId.isNullOrEmpty()) return
        val index = if (parentNews != null) {
            when {
                parentNews.id == newsId -> 0
                else -> currentList.indexOfFirst { it?.id == newsId }.let { if (it != -1) it + 1 else -1 }
            }
        } else {
            currentList.indexOfFirst { it?.id == newsId }
        }
        if (index >= 0) {
            notifyItemChanged(index)
        }
    }

    private fun extractSharedTeamName(news: RealmNews): String {
        if (!TextUtils.isEmpty(news.viewIn)) {
            val ar = gson.fromJson(news.viewIn, JsonArray::class.java)
            if (ar.size() > 1) {
                val ob = ar[0].asJsonObject
                if (ob.has("name") && !ob.get("name").isJsonNull) {
                    return ob.get("name").asString
                }
            }
        }
        return ""
    }

    private fun resetViews(holder: ViewHolderNews) {
        with(holder.binding) {
            tvName.text = ""
            imgUser.setImageResource(0)
            llEditDelete.visibility = View.GONE
            linearLayout51.visibility = View.VISIBLE
            tvMessage.text = ""
            tvDate.text = ""
            imgDelete.setOnClickListener(null)
            imgEdit.setOnClickListener(null)
            btnAddLabel.visibility = View.GONE
            imgEdit.visibility = View.GONE
            imgDelete.visibility = View.GONE
            btnReply.visibility = View.GONE
            imgNews.visibility = View.GONE
            llNewsImages.visibility = View.GONE
            llNewsImages.removeAllViews()
            recyclerGchat.visibility = View.GONE
            sharedChat.visibility = View.GONE
        }
    }

    private fun configureUser(holder: ViewHolderNews, news: RealmNews): RealmUserModel? {
        val userId = news.userId
        val userModel = when {
            userId.isNullOrEmpty() -> null
            userCache.containsKey(userId) -> userCache[userId]
            ::mRealm.isInitialized -> {
                val managedUser = mRealm.where(RealmUserModel::class.java)
                    .equalTo("id", userId)
                    .findFirst()
                val detachedUser = managedUser?.let {
                    try {
                        mRealm.copyFromRealm(it)
                    } catch (e: Exception) {
                        null
                    }
                }
                if (detachedUser != null) {
                    userCache[userId] = detachedUser
                } else if (managedUser == null) {
                    userCache[userId] = null
                }
                detachedUser ?: managedUser
            }
            else -> null
        }
        val userFullName = userModel?.getFullNameWithMiddleName()?.trim()
        if (userModel != null && currentUser != null) {
            holder.binding.tvName.text =
                if (userFullName.isNullOrEmpty()) news.userName else userFullName
            ImageUtils.loadImage(userModel.userImage, holder.binding.imgUser)
            showHideButtons(news, holder)
        } else {
            holder.binding.tvName.text = news.userName
            ImageUtils.loadImage(null, holder.binding.imgUser)
        }
        return userModel
    }

    private fun setMessageAndDate(holder: ViewHolderNews, news: RealmNews, sharedTeamName: String) {
        val markdownContentWithLocalPaths = prependBaseUrlToImages(
            news.message,
            "file://" + context.getExternalFilesDir(null) + "/ole/",
            600,
            350
        )
        setMarkdownText(holder.binding.tvMessage, markdownContentWithLocalPaths)
        val fulltext = holder.binding.tvMessage.text
        holder.binding.tvMessage.makeExpandable(
            fullText = fulltext,
            collapsedMaxLines = 6
        )
        holder.binding.tvDate.text =
            if (sharedTeamName.isEmpty() || teamName.isNotEmpty()) {
                formatDate(news.time)
            } else {
                "${formatDate(news.time)} | Shared from $sharedTeamName"
            }
        holder.binding.tvEdited.visibility = if (news.isEdited) View.VISIBLE else View.GONE
    }

    private fun configureEditDeleteButtons(holder: ViewHolderNews, news: RealmNews) {
        if (news.sharedBy == currentUser?._id && !fromLogin && !nonTeamMember && teamName.isEmpty()) {
            holder.binding.imgDelete.visibility = View.VISIBLE
        }

        if (news.userId == currentUser?._id || news.sharedBy == currentUser?._id) {
            holder.binding.imgDelete.setOnClickListener {
                AlertDialog.Builder(context, R.style.AlertDialogTheme)
                    .setMessage(R.string.delete_record)
                    .setPositiveButton(R.string.ok) { _: DialogInterface?, _: Int ->
                        val currentList = currentList.toMutableList()
                        val pos = holder.adapterPosition
                        val adjustedPos = if (parentNews != null && pos > 0) pos - 1 else pos
                        if (adjustedPos >= 0 && adjustedPos < currentList.size) {
                            currentList.removeAt(adjustedPos)
                            submitListSafely(currentList)
                        }
                        NewsActions.deletePost(mRealm, news, currentList.toMutableList(), teamName, listener)
                    }
                    .setNegativeButton(R.string.cancel, null)
                    .show()
            }
        }

        if (news.userId == currentUser?._id) {
            holder.binding.imgEdit.setOnClickListener {
                NewsActions.showEditAlert(
                    context,
                    mRealm,
                    news.id,
                    true,
                    currentUser,
                    listener,
                    holder,
                ) { holder, updatedNews, position ->
                    showReplyButton(holder, updatedNews, position)
                    notifyItemChanged(position)
                }
            }
        } else {
            holder.binding.imgEdit.visibility = View.GONE
        }
    }

    private fun handleChat(holder: ViewHolderNews, news: RealmNews) {
        if (news.newsId?.isNotEmpty() == true) {
            val conversations = gson.fromJson(news.conversations, Array<Conversation>::class.java).toList()
            val chatAdapter = ChatAdapter(context, holder.binding.recyclerGchat)

            if (user?.id?.startsWith("guest") == false) {
                chatAdapter.setOnChatItemClickListener(object : ChatAdapter.OnChatItemClickListener {
                    override fun onChatItemClick(position: Int, chatItem: String) {
                        listener?.onNewsItemClick(news)
                    }
                })
            }

            for (conversation in conversations) {
                val query = conversation.query
                val response = conversation.response
                if (query != null) {
                    chatAdapter.addQuery(query)
                }
                chatAdapter.responseSource = ChatAdapter.RESPONSE_SOURCE_SHARED_VIEW_MODEL
                if (response != null) {
                    chatAdapter.addResponse(response)
                }
            }

            holder.binding.recyclerGchat.adapter = chatAdapter
            holder.binding.recyclerGchat.layoutManager = LinearLayoutManager(context)
            holder.binding.recyclerGchat.visibility = View.VISIBLE
            holder.binding.sharedChat.visibility = View.VISIBLE
        } else {
            holder.binding.recyclerGchat.visibility = View.GONE
            holder.binding.sharedChat.visibility = View.GONE
        }
    }

    private fun getCurrentLeader(userModel: RealmUserModel?, news: RealmNews): RealmUserModel? {
        if (userModel == null) {
            for (leader in leadersList) {
                if (leader.name == news.userName) {
                    return leader
                }
            }
        }
        return null
    }

    fun updateList(newList: List<RealmNews?>) {
        submitListSafely(newList)
    }

    fun refreshCurrentItems() {
        submitListSafely(currentList.toList())
    }

    private fun submitListSafely(list: List<RealmNews?>, commitCallback: Runnable? = null) {
        userCache.clear()
        val detachedList = list.map { news ->
            if (news?.isValid == true && ::mRealm.isInitialized) {
                try {
                    mRealm.copyFromRealm(news)
                } catch (e: Exception) {
                    news
                }
            } else {
                news
            }
        }
        submitList(detachedList, commitCallback)
    }

    private fun setMemberClickListeners(holder: ViewHolderNews, userModel: RealmUserModel?, currentLeader: RealmUserModel?) {
        if (!fromLogin) {
            holder.binding.imgUser.setOnClickListener {
                val model = userModel ?: currentLeader
                listener?.onMemberSelected(model)
            }
            holder.binding.tvName.setOnClickListener {
                val model = userModel ?: currentLeader
                listener?.onMemberSelected(model)
            }
        }
    }

    private fun isGuestUser() = user?.id?.startsWith("guest") == true

    private fun isOwner(news: RealmNews?): Boolean =
        news?.userId == currentUser?._id

    private fun isSharedByCurrentUser(news: RealmNews?): Boolean =
        news?.sharedBy == currentUser?._id

    private fun isAdmin(): Boolean =
        currentUser?.level.equals("admin", ignoreCase = true)

    private fun isLoggedInAndMember(): Boolean =
        !fromLogin && !nonTeamMember

    private fun canEdit(news: RealmNews?): Boolean =
        isLoggedInAndMember() && (isOwner(news) || isAdmin() || isTeamLeader())

    private fun canDelete(news: RealmNews?): Boolean =
        isLoggedInAndMember() && (isOwner(news) || isSharedByCurrentUser(news) || isAdmin() || isTeamLeader())

    private fun canReply(): Boolean =
        isLoggedInAndMember() && !isGuestUser()

    private fun canAddLabel(news: RealmNews?): Boolean =
        isLoggedInAndMember() && (isOwner(news) || isTeamLeader())

    private fun canShare(news: RealmNews?): Boolean =
        isLoggedInAndMember() && !news?.isCommunityNews!! && !isGuestUser()

    private fun View.setVisibility(condition: Boolean) {
        visibility = if (condition) View.VISIBLE else View.GONE
    }

    fun isTeamLeader(): Boolean {
        if(teamId==null)return false
        return try {
            if (::mRealm.isInitialized && !mRealm.isClosed) {
                val team = mRealm.where(RealmMyTeam::class.java)
                    .equalTo("teamId", teamId)
                    .equalTo("isLeader", true)
                    .findFirst()
                team?.userId == currentUser?._id
            } else {
                databaseService.withRealm { realm ->
                    val team = realm.where(RealmMyTeam::class.java)
                        .equalTo("teamId", teamId)
                        .equalTo("isLeader", true)
                        .findFirst()
                    team?.userId == currentUser?._id
                }
            }
        } catch (e: Exception) {
            false
        }
    }

    private fun getReplies(finalNews: RealmNews?): List<RealmNews> {
        return try {
            if (::mRealm.isInitialized && !mRealm.isClosed) {
                mRealm.where(RealmNews::class.java)
                    .sort("time", Sort.DESCENDING)
                    .equalTo("replyTo", finalNews?.id, Case.INSENSITIVE)
                    .findAll()
            } else {
                databaseService.withRealm { realm ->
                    realm.where(RealmNews::class.java)
                        .sort("time", Sort.DESCENDING)
                        .equalTo("replyTo", finalNews?.id, Case.INSENSITIVE)
                        .findAll()
                        .let { realm.copyFromRealm(it) }
                }
            }
        } catch (e: Exception) {
            emptyList()
        }
    }

    private fun updateReplyCount(viewHolder: ViewHolderNews, replies: List<RealmNews>, position: Int) {
        with(viewHolder.binding) {
            btnShowReply.text = String.format(Locale.getDefault(),"(%d)", replies.size)
            btnShowReply.setTextColor(context.getColor(R.color.daynight_textColor))
            val visible = replies.isNotEmpty() && !(position == 0 && parentNews != null) && canReply()
            btnShowReply.visibility = if (visible) View.VISIBLE else View.GONE
        }
    }

    private fun getNews(holder: RecyclerView.ViewHolder, position: Int): RealmNews? {
        val news: RealmNews? = if (parentNews != null) {
            if (position == 0) {
                (holder.itemView as CardView).setCardBackgroundColor(ContextCompat.getColor(context, R.color.md_blue_50))
                parentNews
            } else {
                (holder.itemView as CardView).setCardBackgroundColor(ContextCompat.getColor(context, R.color.md_white_1000))
                getItem(position - 1)
            }
        } else {
            (holder.itemView as CardView).setCardBackgroundColor(ContextCompat.getColor(context, R.color.md_white_1000))
            getItem(position)
        }
        return news
    }

    private fun showHideButtons(news: RealmNews?, holder: RecyclerView.ViewHolder) {
        val viewHolder = holder as ViewHolderNews
        with(viewHolder.binding) {
            imgEdit.setVisibility(canEdit(news))
            imgDelete.setVisibility(canDelete(news))
            btnAddLabel.setVisibility(canAddLabel(news))
            llEditDelete.setVisibility(canEdit(news) || canDelete(news))
        }
    }

    private fun shouldShowReplyButton(): Boolean = canReply()

    private fun showReplyButton(holder: RecyclerView.ViewHolder, finalNews: RealmNews?, position: Int) {
        val viewHolder = holder as ViewHolderNews
        if (shouldShowReplyButton()) {
            viewHolder.binding.btnReply.visibility = if (nonTeamMember) View.GONE else View.VISIBLE
            viewHolder.binding.btnReply.setOnClickListener {
                NewsActions.showEditAlert(
                    context,
                    mRealm,
                    finalNews?.id,
                    false,
                    currentUser,
                    listener,
                     viewHolder,
                ) { holder, news, i -> showReplyButton(holder, news, i) }
            }
        } else {
            viewHolder.binding.btnReply.visibility = View.GONE
        }

        val replies = getReplies(finalNews)
        updateReplyCount(viewHolder, replies, position)

        viewHolder.binding.btnShowReply.setOnClickListener {
            sharedPreferences?.setRepliedNewsId(finalNews?.id)
            listener?.showReply(finalNews, fromLogin, nonTeamMember)
        }
    }

    override fun getItemCount(): Int {
        return if (parentNews == null) super.getItemCount() else super.getItemCount() + 1
    }

    interface OnNewsItemClickListener {
        fun showReply(news: RealmNews?, fromLogin: Boolean, nonTeamMember: Boolean)
        fun addImage(llImage: ViewGroup?)
        fun onNewsItemClick(news: RealmNews?)
        fun clearImages()
        fun onDataChanged()
        fun onMemberSelected(userModel: RealmUserModel?)
        fun getCurrentImageList(): RealmList<String>?
    }

    private fun showShareButton(holder: RecyclerView.ViewHolder, news: RealmNews?) {
        val viewHolder = holder as ViewHolderNews

        viewHolder.binding.btnShare.setVisibility(canShare(news))

        viewHolder.binding.btnShare.setOnClickListener {
            AlertDialog.Builder(context, R.style.AlertDialogTheme)
                .setTitle(R.string.share_with_community)
                .setMessage(R.string.confirm_share_community)
                .setPositiveButton(R.string.yes) { _, _ ->
                    val array = gson.fromJson(news?.viewIn, JsonArray::class.java)
                    val firstElement = array.get(0)
                    val obj = firstElement.asJsonObject
                    if(!obj.has("name")){
                        obj.addProperty("name", teamName)
                    }
                    val ob = JsonObject()
                    ob.addProperty("section", "community")
                    ob.addProperty("_id", currentUser?.planetCode + "@" + currentUser?.parentCode)
                    ob.addProperty("sharedDate", Calendar.getInstance().timeInMillis)
                    array.add(ob)
                    if (!mRealm.isInTransaction) {
                        mRealm.beginTransaction()
                    }

                    val managedNews = news?.let { newsItem ->
                        if (newsItem.isManaged) {
                            newsItem
                        } else {
                            mRealm.where(RealmNews::class.java)
                                .equalTo("id", newsItem.id)
                                .findFirst()
                        }
                    }

                    managedNews?.sharedBy = currentUser?.id
                    managedNews?.viewIn = gson.toJson(array)
                    mRealm.commitTransaction()
                    Utilities.toast(context, context.getString(R.string.shared_to_community))
                    viewHolder.binding.btnShare.visibility = View.GONE
                }
                .setNegativeButton(R.string.cancel, null)
                .show()
        }
    }

    override fun onAttachedToRecyclerView(recyclerView: RecyclerView) {
        super.onAttachedToRecyclerView(recyclerView)
        this.recyclerView = recyclerView
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        super.onDetachedFromRecyclerView(recyclerView)
        this.recyclerView = null
    }

    private fun loadImage(binding: RowNewsBinding, news: RealmNews?) {
        binding.imgNews.visibility = View.GONE
        binding.llNewsImages.visibility = View.GONE
        binding.llNewsImages.removeAllViews()

        val imageUrls = news?.imageUrls
        if (!imageUrls.isNullOrEmpty()) {
            try {
                if (imageUrls.size == 1) {
                    val imgObject = gson.fromJson(imageUrls[0], JsonObject::class.java)
                    val path = JsonUtils.getString("imageUrl", imgObject)
                    loadSingleImage(binding, path)
                } else {
                    binding.llNewsImages.visibility = View.VISIBLE
                    for (imageUrl in imageUrls) {
                        val imgObject = gson.fromJson(imageUrl, JsonObject::class.java)
                        val path = JsonUtils.getString("imageUrl", imgObject)
                        addImageToContainer(binding, path)
                    }
                }
                return
            } catch (_: Exception) {
            }
        }

        news?.imagesArray?.let { imagesArray ->
            if (imagesArray.size() > 0) {
                if (imagesArray.size() == 1) {
                    val ob = imagesArray[0]?.asJsonObject
                    val resourceId = JsonUtils.getString("resourceId", ob)
                    loadLibraryImage(binding, resourceId)
                } else {
                    binding.llNewsImages.visibility = View.VISIBLE
                    for (i in 0 until imagesArray.size()) {
                        val ob = imagesArray[i]?.asJsonObject
                        val resourceId = JsonUtils.getString("resourceId", ob)
                        addLibraryImageToContainer(binding, resourceId)
                    }
                }
            }
        }
    }

    private fun loadSingleImage(binding: RowNewsBinding, path: String?) {
        if (path == null) return
        val request = Glide.with(binding.imgNews.context)
        val target = if (path.lowercase(Locale.getDefault()).endsWith(".gif")) {
            request.asGif().load(if (File(path).exists()) File(path) else path)
        } else {
            request.load(if (File(path).exists()) File(path) else path)
        }
        target.placeholder(R.drawable.ic_loading)
            .error(R.drawable.ic_loading)
            .into(binding.imgNews)
        binding.imgNews.visibility = View.VISIBLE
        binding.imgNews.setOnClickListener {
            showZoomableImage(it.context, path)
        }
    }

    private fun addImageToContainer(binding: RowNewsBinding, path: String?) {
        if (path == null) return
        val imageView = ImageView(context)
        val size = (100 * context.resources.displayMetrics.density).toInt()
        val margin = (4 * context.resources.displayMetrics.density).toInt()
        val params = ViewGroup.MarginLayoutParams(size, size)
        params.setMargins(margin, margin, margin, margin)
        imageView.layoutParams = params
        imageView.scaleType = ImageView.ScaleType.CENTER_CROP

        val request = Glide.with(context)
        val target = if (path.lowercase(Locale.getDefault()).endsWith(".gif")) {
            request.asGif().load(if (File(path).exists()) File(path) else path)
        } else {
            request.load(if (File(path).exists()) File(path) else path)
        }
        target.placeholder(R.drawable.ic_loading)
            .error(R.drawable.ic_loading)
            .into(imageView)

        imageView.setOnClickListener {
            showZoomableImage(context, path)
        }

        binding.llNewsImages.addView(imageView)
    }

    private fun loadLibraryImage(binding: RowNewsBinding, resourceId: String?) {
        if (resourceId == null) return
        val library = mRealm.where(RealmMyLibrary::class.java)
            .equalTo("_id", resourceId)
            .findFirst()

        val basePath = context.getExternalFilesDir(null)
        if (library != null && basePath != null) {
            val imageFile = File(basePath, "ole/${library.id}/${library.resourceLocalAddress}")
            if (imageFile.exists()) {
                val request = Glide.with(binding.imgNews.context)
                val isGif = library.resourceLocalAddress?.lowercase(Locale.getDefault())?.endsWith(".gif") == true
                val target = if (isGif) {
                    request.asGif().load(imageFile)
                } else {
                    request.load(imageFile)
                }
                target.placeholder(R.drawable.ic_loading)
                    .error(R.drawable.ic_loading)
                    .into(binding.imgNews)
                binding.imgNews.visibility = View.VISIBLE
                binding.imgNews.setOnClickListener {
                    showZoomableImage(it.context, imageFile.toString())
                }
            }
        }
    }

    private fun addLibraryImageToContainer(binding: RowNewsBinding, resourceId: String?) {
        if (resourceId == null) return
        val library = mRealm.where(RealmMyLibrary::class.java)
            .equalTo("_id", resourceId)
            .findFirst()

        val basePath = context.getExternalFilesDir(null)
        if (library != null && basePath != null) {
            val imageFile = File(basePath, "ole/${library.id}/${library.resourceLocalAddress}")
            if (imageFile.exists()) {
                val imageView = ImageView(context)
                val size = (100 * context.resources.displayMetrics.density).toInt()
                val margin = (4 * context.resources.displayMetrics.density).toInt()
                val params = ViewGroup.MarginLayoutParams(size, size)
                params.setMargins(margin, margin, margin, margin)
                imageView.layoutParams = params
                imageView.scaleType = ImageView.ScaleType.CENTER_CROP

                val request = Glide.with(context)
                val isGif = library.resourceLocalAddress?.lowercase(Locale.getDefault())?.endsWith(".gif") == true
                val target = if (isGif) {
                    request.asGif().load(imageFile)
                } else {
                    request.load(imageFile)
                }
                target.placeholder(R.drawable.ic_loading)
                    .error(R.drawable.ic_loading)
                    .into(imageView)

                imageView.setOnClickListener {
                    showZoomableImage(context, imageFile.toString())
                }

                binding.llNewsImages.addView(imageView)
            }
        }
    }

    private fun showZoomableImage(context: Context, imageUrl: String) {
        val dialog = Dialog(context, android.R.style.Theme_Black_NoTitleBar_Fullscreen)
        val view = LayoutInflater.from(context).inflate(R.layout.dialog_zoomable_image, null)
        val photoView = view.findViewById<PhotoView>(R.id.photoView)
        val closeButton = view.findViewById<ImageView>(R.id.closeButton)

        dialog.setContentView(view)
        dialog.window?.setBackgroundDrawable(Color.BLACK.toDrawable())

        val request = Glide.with(photoView.context)
        val target = if (imageUrl.lowercase(Locale.getDefault()).endsWith(".gif")) {
            val file = File(imageUrl)
            if (file.exists()) request.asGif().load(file) else request.asGif().load(imageUrl)
        } else {
            val file = File(imageUrl)
            if (file.exists()) request.load(file) else request.load(imageUrl)
        }
        target.error(R.drawable.ic_loading).into(photoView)

        closeButton.setOnClickListener { dialog.dismiss() }

        dialog.show()
    }

    internal inner class ViewHolderNews(val binding: RowNewsBinding) : RecyclerView.ViewHolder(binding.root) {
        private var adapterPosition = 0
        fun bind(position: Int) {
            adapterPosition = position
        }
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/news/NewsLabelManager.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.news

import android.content.Context
import android.view.MenuItem
import android.view.View
import fisk.chipcloud.ChipCloud
import io.realm.Realm
import io.realm.RealmList
import java.util.Locale
import java.util.concurrent.atomic.AtomicBoolean
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowNewsBinding
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Utilities

class NewsLabelManager(private val context: Context, private val realm: Realm) {
    fun setupAddLabelMenu(binding: RowNewsBinding, news: RealmNews?, canManageLabels: Boolean) {
        binding.btnAddLabel.setOnClickListener(null)
        binding.btnAddLabel.isEnabled = canManageLabels
        if (!canManageLabels) {
            return
        }

        binding.btnAddLabel.setOnClickListener {
            val usedLabels = news?.labels?.toSet() ?: emptySet()
            val availableLabels = Constants.LABELS.filterValues { it !in usedLabels }

            val wrapper = androidx.appcompat.view.ContextThemeWrapper(context, R.style.CustomPopupMenu)
            val menu = android.widget.PopupMenu(wrapper, binding.btnAddLabel)
            availableLabels.keys.forEach { labelName ->
                menu.menu.add(labelName)
            }
            menu.setOnMenuItemClickListener { menuItem: MenuItem ->
                val selectedLabel = Constants.LABELS[menuItem.title]
                val newsId = news?.id
                if (selectedLabel != null && newsId != null) {
                    if (news?.labels?.contains(selectedLabel) == true) {
                        return@setOnMenuItemClickListener true
                    }

                    val labelAdded = AtomicBoolean(false)
                    realm.executeTransactionAsync({ transactionRealm ->
                        val managedNews = transactionRealm.where(RealmNews::class.java)
                            .equalTo("id", newsId)
                            .findFirst()
                        if (managedNews != null) {
                            var managedLabels = managedNews.labels
                            if (managedLabels == null) {
                                managedLabels = RealmList()
                                managedNews.labels = managedLabels
                            }
                            if (!managedLabels.contains(selectedLabel)) {
                                managedLabels.add(selectedLabel)
                                labelAdded.set(true)
                            }
                        }
                    }, {
                        if (labelAdded.get()) {
                            val managedNews = realm.where(RealmNews::class.java)
                                .equalTo("id", newsId)
                                .findFirst()
                            val managedLabels = managedNews?.labels
                            val newLabels = RealmList<String>().apply {
                                managedLabels?.forEach { add(it) }
                            }
                            news?.labels = newLabels
                            Utilities.toast(context, context.getString(R.string.label_added))
                            news?.let { showChips(binding, it, canManageLabels) }
                        }
                    }, { error ->
                        error.printStackTrace()
                    })
                    return@setOnMenuItemClickListener false
                }
                true
            }
            menu.show()
        }
    }

    fun showChips(binding: RowNewsBinding, news: RealmNews, canManageLabels: Boolean) {
        binding.fbChips.removeAllViews()

        for (label in news.labels ?: emptyList()) {
            val chipConfig = Utilities.getCloudConfig().apply {
                selectMode(if (canManageLabels) ChipCloud.SelectMode.close else ChipCloud.SelectMode.none)
            }

            val chipCloud = ChipCloud(context, binding.fbChips, chipConfig)
            chipCloud.addChip(getLabel(label))

            if (canManageLabels) {
                chipCloud.setDeleteListener { _: Int, labelText: String? ->
                    val selectedLabel = when {
                        labelText == null -> null
                        Constants.LABELS.containsKey(labelText) -> Constants.LABELS[labelText]
                        else -> news.labels?.firstOrNull { getLabel(it) == labelText }
                    }
                    val newsId = news.id
                    if (selectedLabel != null && newsId != null) {
                        val labelRemoved = AtomicBoolean(false)
                        realm.executeTransactionAsync({ transactionRealm ->
                            val managedNews = transactionRealm.where(RealmNews::class.java)
                                .equalTo("id", newsId)
                                .findFirst()
                            if (managedNews != null) {
                                var managedLabels = managedNews.labels
                                if (managedLabels == null) {
                                    managedLabels = RealmList()
                                    managedNews.labels = managedLabels
                                }
                                if (managedLabels.remove(selectedLabel)) {
                                    labelRemoved.set(true)
                                }
                            }
                        }, {
                            if (labelRemoved.get()) {
                                val managedNews = realm.where(RealmNews::class.java)
                                    .equalTo("id", newsId)
                                    .findFirst()
                                val managedLabels = managedNews?.labels
                                val newLabels = RealmList<String>().apply {
                                    managedLabels?.forEach { add(it) }
                                }
                                news.labels = newLabels
                                showChips(binding, news, canManageLabels)
                            }
                        }, { error ->
                            error.printStackTrace()
                        })
                    }
                }
            }
        }
        updateAddLabelVisibility(binding, news, canManageLabels)
    }

    private fun updateAddLabelVisibility(
        binding: RowNewsBinding,
        news: RealmNews?,
        canManageLabels: Boolean,
    ) {
        if (!canManageLabels) {
            binding.btnAddLabel.visibility = View.GONE
            return
        }

        val usedLabels = news?.labels?.toSet() ?: emptySet()
        val labels = Constants.LABELS.values.toSet()
        binding.btnAddLabel.visibility =
            if (usedLabels.containsAll(labels)) View.GONE else View.VISIBLE
    }

    private fun getLabel(s: String): String {
        for (key in Constants.LABELS.keys) {
            if (s == Constants.LABELS[key]) {
                return key
            }
        }
        return formatLabelValue(s)
    }

    companion object {
        internal fun formatLabelValue(raw: String): String {
            val cleaned = raw.replace("_", " ").replace("-", " ")
            if (cleaned.isBlank()) {
                return raw
            }
            return cleaned
                .trim()
                .split(Regex("\\s+"))
                .joinToString(" ") { part ->
                    part.lowercase(Locale.getDefault()).replaceFirstChar { ch ->
                        if (ch.isLowerCase()) ch.titlecase(Locale.getDefault()) else ch.toString()
                    }
                }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.news


import android.content.Context
import android.view.MenuItem
import android.view.View
import fisk.chipcloud.ChipCloud
import io.realm.Realm
import io.realm.RealmList
import java.util.Locale
import java.util.concurrent.atomic.AtomicBoolean
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowNewsBinding
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Utilities

class NewsLabelManager(private val context: Context, private val realm: Realm) {
    fun setupAddLabelMenu(binding: RowNewsBinding, news: RealmNews?, canManageLabels: Boolean) {
        binding.btnAddLabel.setOnClickListener(null)
        binding.btnAddLabel.isEnabled = canManageLabels
        if (!canManageLabels) {
            return
        }

        binding.btnAddLabel.setOnClickListener {
            val usedLabels = news?.labels?.toSet() ?: emptySet()
            val availableLabels = Constants.LABELS.filterValues { it !in usedLabels }

            val wrapper = androidx.appcompat.view.ContextThemeWrapper(context, R.style.CustomPopupMenu)
            val menu = android.widget.PopupMenu(wrapper, binding.btnAddLabel)
            availableLabels.keys.forEach { labelName ->
                menu.menu.add(labelName)
            }
            menu.setOnMenuItemClickListener { menuItem: MenuItem ->
                val selectedLabel = Constants.LABELS[menuItem.title]
                val newsId = news?.id
                if (selectedLabel != null && newsId != null) {
                    if (news?.labels?.contains(selectedLabel) == true) {
                        return@setOnMenuItemClickListener true
                    }

                    val labelAdded = AtomicBoolean(false)
                    realm.executeTransactionAsync({ transactionRealm ->
                        val managedNews = transactionRealm.where(RealmNews::class.java)
                            .equalTo("id", newsId)
                            .findFirst()
                        if (managedNews != null) {
                            var managedLabels = managedNews.labels
                            if (managedLabels == null) {
                                managedLabels = RealmList()
                                managedNews.labels = managedLabels
                            }
                            if (!managedLabels.contains(selectedLabel)) {
                                managedLabels.add(selectedLabel)
                                labelAdded.set(true)
                            }
                        }
                    }, {
                        if (labelAdded.get()) {
                            val managedNews = realm.where(RealmNews::class.java)
                                .equalTo("id", newsId)
                                .findFirst()
                            val managedLabels = managedNews?.labels
                            val newLabels = RealmList<String>().apply {
                                managedLabels?.forEach { add(it) }
                            }
                            news?.labels = newLabels
                            Utilities.toast(context, context.getString(R.string.label_added))
                            news?.let { showChips(binding, it, canManageLabels) }
                        }
                    }, { error ->
                        error.printStackTrace()
                    })
                    return@setOnMenuItemClickListener false
                }
                true
            }
            menu.show()
        }
    }

    fun showChips(binding: RowNewsBinding, news: RealmNews, canManageLabels: Boolean) {
        binding.fbChips.removeAllViews()

        for (label in news.labels ?: emptyList()) {
            val chipConfig = Utilities.getCloudConfig().apply {
                selectMode(if (canManageLabels) ChipCloud.SelectMode.close else ChipCloud.SelectMode.none)
            }

            val chipCloud = ChipCloud(context, binding.fbChips, chipConfig)
            chipCloud.addChip(getLabel(label))

            if (canManageLabels) {
                chipCloud.setDeleteListener { _: Int, labelText: String? ->
                    val selectedLabel = when {
                        labelText == null -> null
                        Constants.LABELS.containsKey(labelText) -> Constants.LABELS[labelText]
                        else -> news.labels?.firstOrNull { getLabel(it) == labelText }
                    }
                    val newsId = news.id
                    if (selectedLabel != null && newsId != null) {
                        val labelRemoved = AtomicBoolean(false)
                        realm.executeTransactionAsync({ transactionRealm ->
                            val managedNews = transactionRealm.where(RealmNews::class.java)
                                .equalTo("id", newsId)
                                .findFirst()
                            if (managedNews != null) {
                                var managedLabels = managedNews.labels
                                if (managedLabels == null) {
                                    managedLabels = RealmList()
                                    managedNews.labels = managedLabels
                                }
                                if (managedLabels.remove(selectedLabel)) {
                                    labelRemoved.set(true)
                                }
                            }
                        }, {
                            if (labelRemoved.get()) {
                                val managedNews = realm.where(RealmNews::class.java)
                                    .equalTo("id", newsId)
                                    .findFirst()
                                val managedLabels = managedNews?.labels
                                val newLabels = RealmList<String>().apply {
                                    managedLabels?.forEach { add(it) }
                                }
                                news.labels = newLabels
                                showChips(binding, news, canManageLabels)
                            }
                        }, { error ->
                            error.printStackTrace()
                        })
                    }
                }
            }
        }
        updateAddLabelVisibility(binding, news, canManageLabels)
    }

    private fun updateAddLabelVisibility(
        binding: RowNewsBinding,
        news: RealmNews?,
        canManageLabels: Boolean,
    ) {
        if (!canManageLabels) {
            binding.btnAddLabel.visibility = View.GONE
            return
        }

        val usedLabels = news?.labels?.toSet() ?: emptySet()
        val labels = Constants.LABELS.values.toSet()
        binding.btnAddLabel.visibility =
            if (usedLabels.containsAll(labels)) View.GONE else View.VISIBLE
    }

    private fun getLabel(s: String): String {
        for (key in Constants.LABELS.keys) {
            if (s == Constants.LABELS[key]) {
                return key
            }
        }
        return formatLabelValue(s)
    }

    companion object {
        internal fun formatLabelValue(raw: String): String {
            val cleaned = raw.replace("_", " ").replace("-", " ")
            if (cleaned.isBlank()) {
                return raw
            }
            return cleaned
                .trim()
                .split(Regex("\\s+"))
                .joinToString(" ") { part ->
                    part.lowercase(Locale.getDefault()).replaceFirstChar { ch ->
                        if (ch.isLowerCase()) ch.titlecase(Locale.getDefault()) else ch.toString()
                    }
                }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/news/ExpandableListAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.news

import android.content.Context
import android.graphics.Typeface
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseExpandableListAdapter
import android.widget.ImageView
import android.widget.TextView
import androidx.core.content.ContextCompat
import org.ole.planet.myplanet.R

class ExpandableListAdapter(private val context: Context, private val expandableTitleList: List<String>, private val expandableDetailList: HashMap<String, List<String>>) : BaseExpandableListAdapter() {
    override fun getChild(lstPosn: Int, expandedListPosition: Int): Any {
        return expandableDetailList[expandableTitleList[lstPosn]]!![expandedListPosition]
    }

    override fun getChildId(listPosition: Int, expandedListPosition: Int): Long {
        return expandedListPosition.toLong()
    }

    override fun getChildView(lstPosn: Int, expandedListPosition: Int, isLastChild: Boolean, convertView: View?, parent: ViewGroup): View {
        var reusedView = convertView
        val expandedListText = getChild(lstPosn, expandedListPosition) as String
        if (reusedView == null) {
            val layoutInflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
            reusedView = layoutInflater.inflate(R.layout.expandable_list_item, parent, false)
        }
        val expandedListTextView = reusedView?.findViewById<View>(R.id.expandedListItem) as TextView
        expandedListTextView.text = expandedListText
        reusedView.setBackgroundColor(ContextCompat.getColor(parent?.context!!, R.color.multi_select_grey))
        expandedListTextView.setTextColor(ContextCompat.getColor(parent.context, R.color.daynight_textColor))
        return reusedView
    }

    override fun getChildrenCount(listPosition: Int): Int {
        return expandableDetailList[expandableTitleList[listPosition]]!!.size
    }

    override fun getGroup(listPosition: Int): Any {
        return expandableTitleList[listPosition]
    }

    override fun getGroupCount(): Int {
        return expandableTitleList.size
    }

    override fun getGroupId(listPosition: Int): Long {
        return listPosition.toLong()
    }

    override fun getGroupView(listPosition: Int, isExpanded: Boolean, convertView: View?, parent: ViewGroup): View {
        var reusedView = convertView
        val listTitle = getGroup(listPosition) as String
        if (reusedView == null) {
            val layoutInflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
            reusedView = layoutInflater.inflate(R.layout.expandable_list_group, parent, false)
        }
        val listTitleTextView = reusedView?.findViewById<View>(R.id.listTitle) as TextView
        val arrowIcon = reusedView?.findViewById<ImageView>(R.id.arrowIcon)
        listTitleTextView.setTypeface(null, Typeface.BOLD)
        listTitleTextView.text = listTitle
        listTitleTextView.setTextColor(ContextCompat.getColor(parent.context, R.color.daynight_textColor))
        arrowIcon?.rotation = if (isExpanded) 180f else 0f
        return reusedView
    }

    override fun hasStableIds(): Boolean {
        return false
    }

    override fun isChildSelectable(listPosition: Int, expandedListPosition: Int): Boolean {
        return true
    }
}
=======
package org.ole.planet.myplanet.ui.news


import android.content.Context
import android.graphics.Typeface
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseExpandableListAdapter
import android.widget.ImageView
import android.widget.TextView
import androidx.core.content.ContextCompat
import org.ole.planet.myplanet.R

class ExpandableListAdapter(private val context: Context, private val expandableTitleList: List<String>, private val expandableDetailList: HashMap<String, List<String>>) : BaseExpandableListAdapter() {
    override fun getChild(lstPosn: Int, expandedListPosition: Int): Any {
        return expandableDetailList[expandableTitleList[lstPosn]]!![expandedListPosition]
    }

    override fun getChildId(listPosition: Int, expandedListPosition: Int): Long {
        return expandedListPosition.toLong()
    }

    override fun getChildView(lstPosn: Int, expandedListPosition: Int, isLastChild: Boolean, convertView: View?, parent: ViewGroup): View {
        var reusedView = convertView
        val expandedListText = getChild(lstPosn, expandedListPosition) as String
        if (reusedView == null) {
            val layoutInflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
            reusedView = layoutInflater.inflate(R.layout.expandable_list_item, parent, false)
        }
        val expandedListTextView = reusedView?.findViewById<View>(R.id.expandedListItem) as TextView
        expandedListTextView.text = expandedListText
        reusedView.setBackgroundColor(ContextCompat.getColor(parent?.context!!, R.color.multi_select_grey))
        expandedListTextView.setTextColor(ContextCompat.getColor(parent.context, R.color.daynight_textColor))
        return reusedView
    }

    override fun getChildrenCount(listPosition: Int): Int {
        return expandableDetailList[expandableTitleList[listPosition]]!!.size
    }

    override fun getGroup(listPosition: Int): Any {
        return expandableTitleList[listPosition]
    }

    override fun getGroupCount(): Int {
        return expandableTitleList.size
    }

    override fun getGroupId(listPosition: Int): Long {
        return listPosition.toLong()
    }

    override fun getGroupView(listPosition: Int, isExpanded: Boolean, convertView: View?, parent: ViewGroup): View {
        var reusedView = convertView
        val listTitle = getGroup(listPosition) as String
        if (reusedView == null) {
            val layoutInflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
            reusedView = layoutInflater.inflate(R.layout.expandable_list_group, parent, false)
        }
        val listTitleTextView = reusedView?.findViewById<View>(R.id.listTitle) as TextView
        val arrowIcon = reusedView?.findViewById<ImageView>(R.id.arrowIcon)
        listTitleTextView.setTypeface(null, Typeface.BOLD)
        listTitleTextView.text = listTitle
        listTitleTextView.setTextColor(ContextCompat.getColor(parent.context, R.color.daynight_textColor))
        arrowIcon?.rotation = if (isExpanded) 180f else 0f
        return reusedView
    }

    override fun hasStableIds(): Boolean {
        return false
    }

    override fun isChildSelectable(listPosition: Int, expandedListPosition: Int): Boolean {
        return true
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/news/NewsFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.news

import android.content.res.Configuration
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.EditText
import androidx.core.view.isVisible
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView.AdapterDataObserver
import com.google.gson.Gson
import com.google.gson.JsonArray
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.flow.debounce
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseNewsFragment
import org.ole.planet.myplanet.databinding.FragmentNewsBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmNews.Companion.createNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.NewsRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.chat.ChatDetailFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.KeyboardUtils.setupUI
import org.ole.planet.myplanet.utilities.textChanges

@AndroidEntryPoint
class NewsFragment : BaseNewsFragment() {
    private var _binding: FragmentNewsBinding? = null
    private val binding get() = _binding!!
    var user: RealmUserModel? = null

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    @Inject
    lateinit var newsRepository: NewsRepository
    private var filteredNewsList: List<RealmNews?> = listOf()
    private var searchFilteredList: List<RealmNews?> = listOf()
    private var labelFilteredList: List<RealmNews?> = listOf()
    private val gson = Gson()
    private lateinit var etSearch: EditText
    private var selectedLabel: String = "All"
    private val labelDisplayToValue = mutableMapOf<String, String>()

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentNewsBinding.inflate(inflater, container, false)
        llImage = binding.llImages
        user = userProfileDbHandler.getUserModelCopy()
        setupUI(binding.newsFragmentParentLayout, requireActivity())
        if (user?.id?.startsWith("guest") == true) {
            binding.btnNewVoice.visibility = View.GONE
        }
        etSearch = binding.root.findViewById(R.id.et_search)
        binding.btnNewVoice.setOnClickListener {
            binding.llAddNews.visibility = if (binding.llAddNews.isVisible) {
                binding.etMessage.setText("")
                binding.tlMessage.error = null
                clearImages()
                View.GONE
            } else {
                View.VISIBLE
            }
            binding.btnNewVoice.text = if (binding.llAddNews.isVisible) {
                getString(R.string.hide_new_voice)
            } else {
                getString(R.string.new_voice)
            }
        }
        if (requireArguments().getBoolean("fromLogin")) {
            binding.btnNewVoice.visibility = View.GONE
            binding.llAddNews.visibility = View.GONE
        }

        if (mRealm.isInTransaction) {
            try {
                mRealm.commitTransaction()
            } catch (_: Exception) {
                mRealm.cancelTransaction()
            }
        }

        setupSearchTextListener()
        setupLabelFilter()

        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewLifecycleOwner.lifecycleScope.launch {
            newsRepository.getCommunityNews(getUserIdentifier()).collect { news ->
                val filtered = news.map { it as RealmNews? }
                val labels = collectAllLabels(filtered)
                val labelFiltered = applyLabelFilter(filtered)
                val searchFiltered = applySearchFilter(labelFiltered, etSearch.text.toString().trim())
                if (_binding != null) {
                    filteredNewsList = filtered
                    labelFilteredList = labelFiltered
                    searchFilteredList = searchFiltered
                    setupLabelFilter(labels)
                    setData(searchFilteredList)
                }
            }
        }
        binding.btnSubmit.setOnClickListener {
            val message = binding.etMessage.text.toString().trim { it <= ' ' }
            if (message.isEmpty()) {
                binding.tlMessage.error = getString(R.string.please_enter_message)
                return@setOnClickListener
            }
            binding.etMessage.setText(R.string.empty_text)
            val map = HashMap<String?, String>()
            map["message"] = message
            map["viewInId"] = "${user?.planetCode ?: ""}@${user?.parentCode ?: ""}"
            map["viewInSection"] = "community"
            map["messageType"] = "sync"
            map["messagePlanetCode"] = user?.planetCode ?: ""

            val n = user?.let { it1 -> createNews(map, mRealm, it1, imageList) }
            imageList.clear()
            llImage?.removeAllViews()
            adapterNews?.addItem(n)
            labelFilteredList = applyLabelFilter(filteredNewsList)
            searchFilteredList = applySearchFilter(labelFilteredList)
            setData(searchFilteredList)
            scrollToTop()
        }

        binding.addNewsImage.setOnClickListener {
            llImage = binding.llImages
            val openFolderIntent = FileUtils.openOleFolder(requireContext())
            openFolderLauncher.launch(openFolderIntent)
        }
    }

    private fun getUserIdentifier(): String {
        val defaultUserIdentifier = "${user?.planetCode ?: ""}@${user?.parentCode ?: ""}"
        if (defaultUserIdentifier.isNotEmpty() && defaultUserIdentifier != "@") {
            return defaultUserIdentifier
        }
        val planetCode = settings?.getString("planetCode", "") ?: ""
        val parentCode = settings?.getString("parentCode", "") ?: ""
        return "$planetCode@$parentCode"
    }

    override fun setData(list: List<RealmNews?>?) {
        if (!isAdded || list == null) return

        if (binding.rvNews.adapter == null) {
            changeLayoutManager(resources.configuration.orientation, binding.rvNews)
            val resourceIds = mutableSetOf<String>()
            list.forEach { news ->
                if ((news?.imagesArray?.size() ?: 0) > 0) {
                    val ob = news?.imagesArray?.get(0)?.asJsonObject
                    val resourceId = getString("resourceId", ob?.asJsonObject)
                    if (!resourceId.isNullOrBlank()) {
                        resourceIds.add(resourceId)
                    }
                }
            }
            viewLifecycleOwner.lifecycleScope.launch {
                if (resourceIds.isNotEmpty()) {
                    val libraries = libraryRepository.getLibraryItemsByIds(resourceIds)
                    getUrlsAndStartDownload(
                        libraries.map<RealmMyLibrary, RealmMyLibrary?> { it },
                        arrayListOf()
                    )
                }
            }
            val updatedListAsMutable: MutableList<RealmNews?> = list.toMutableList()
            val sortedList = updatedListAsMutable.sortedWith(compareByDescending { news ->
                getSortDate(news)
            })
            adapterNews = AdapterNews(requireActivity(), user, null, "", null, userProfileDbHandler, databaseService)

            adapterNews?.setmRealm(mRealm)
            adapterNews?.setFromLogin(requireArguments().getBoolean("fromLogin"))
            adapterNews?.setListener(this)
            adapterNews?.registerAdapterDataObserver(observer)
            adapterNews?.updateList(sortedList)
            binding.rvNews.adapter = adapterNews
        } else {
            (binding.rvNews.adapter as? AdapterNews)?.updateList(list)
        }
        adapterNews?.let { showNoData(binding.tvMessage, it.itemCount, "news") }
        binding.llAddNews.visibility = View.GONE
        binding.btnNewVoice.text = getString(R.string.new_voice)
    }

    override fun onNewsItemClick(news: RealmNews?) {
        val fromLogin = arguments?.getBoolean("fromLogin")
        if (fromLogin == false) {
            val bundle = Bundle()
            bundle.putString("newsId", news?.newsId)
            bundle.putString("newsRev", news?.newsRev)
            bundle.putString("conversations", news?.conversations)

            val chatDetailFragment = ChatDetailFragment()
            chatDetailFragment.arguments = bundle

            NavigationHelper.replaceFragment(
                parentFragmentManager,
                R.id.fragment_container,
                chatDetailFragment,
                addToBackStack = true
            )
        }
    }

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    override fun onConfigurationChanged(newConfig: Configuration) {
        super.onConfigurationChanged(newConfig)
        val orientation = newConfig.orientation
        changeLayoutManager(orientation, binding.rvNews)
    }

    private fun scrollToTop() {
        binding.rvNews.post {
            binding.rvNews.scrollToPosition(0)
        }
    }

    private val observer: AdapterDataObserver = object : AdapterDataObserver() {
        override fun onChanged() {
            adapterNews?.let { showNoData(binding.tvMessage, it.itemCount, "news") }
        }

        override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {
            adapterNews?.let { showNoData(binding.tvMessage, it.itemCount, "news") }
        }

        override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {
            adapterNews?.let { showNoData(binding.tvMessage, it.itemCount, "news") }
        }
    }
    private fun getSortDate(news: RealmNews?): Long {
        if (news == null) return 0
        try {
            if (!news.viewIn.isNullOrEmpty()) {
                val ar = gson.fromJson(news.viewIn, JsonArray::class.java)
                for (elem in ar) {
                    val obj = elem.asJsonObject
                    if (obj.has("section") && obj.get("section").asString.equals("community", true) && obj.has("sharedDate")) {
                        return obj.get("sharedDate").asLong
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return news.time
    }

    private fun setupSearchTextListener() {
        etSearch.textChanges()
            .debounce(300)
            .onEach { text ->
                val searchQuery = text.toString().trim()
                searchFilteredList = applySearchFilter(labelFilteredList, searchQuery)
                setData(searchFilteredList)
                scrollToTop()
            }
            .launchIn(viewLifecycleOwner.lifecycleScope)
    }

    private fun applySearchFilter(list: List<RealmNews?>, queryParam: String? = null): List<RealmNews?> {
        val query = queryParam ?: etSearch.text.toString().trim()

        if (query.isEmpty()) {
            return list
        }

        val filtered = list.filter { news ->
            val message = news?.message?.trim() ?: ""
            val matches = message.contains(query, ignoreCase = true)
            matches
        }
        return filtered
    }

    private fun setupLabelFilter(precomputedLabels: List<String>? = null) {
        updateLabelSpinner(precomputedLabels)

        binding.filterByLabel.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                val labels = (binding.filterByLabel.adapter as ArrayAdapter<String>)
                selectedLabel = labels.getItem(position) ?: "All"
                labelFilteredList = applyLabelFilter(filteredNewsList)
                searchFilteredList = applySearchFilter(labelFilteredList)
                setData(searchFilteredList)
                scrollToTop()
            }
            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }
    }

    private fun updateLabelSpinner(precomputedLabels: List<String>? = null) {
        val binding = _binding ?: return
        val labels = precomputedLabels ?: collectAllLabels(filteredNewsList)
        val themedContext = androidx.appcompat.view.ContextThemeWrapper(requireContext(), R.style.ResourcePopupMenu)
        val adapter = ArrayAdapter(themedContext, android.R.layout.simple_spinner_item, labels)
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        binding.filterByLabel.adapter = adapter

        val position = labels.indexOf(selectedLabel)
        if (position >= 0) {
            binding.filterByLabel.setSelection(position)
        } else {
            selectedLabel = "All"
            binding.filterByLabel.setSelection(0)
        }
    }

    private fun collectAllLabels(list: List<RealmNews?>): List<String> {
        labelDisplayToValue.clear()

        val allLabels = mutableSetOf<String>()
        allLabels.add("All")

        Constants.LABELS.forEach { (labelName, labelValue) ->
            allLabels.add(labelName)
            labelDisplayToValue[labelName] = labelValue
        }

        allLabels.add("Shared Chat")

        list.forEach { news ->
            if (!news?.viewIn.isNullOrEmpty()) {
                try {
                    val ar = gson.fromJson(news.viewIn, JsonArray::class.java)
                    if (ar.size() > 1) {
                        val ob = ar[0].asJsonObject
                        if (ob.has("name") && !ob.get("name").isJsonNull) {
                            val sharedTeamName = ob.get("name").asString
                            if (sharedTeamName.isNotEmpty()) {
                                allLabels.add(sharedTeamName)
                            }
                        }
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }

            news?.labels?.forEach { label ->
                val labelName = Constants.LABELS.entries.find { it.value == label }?.key
                    ?: NewsLabelManager.formatLabelValue(label)
                allLabels.add(labelName)
                labelDisplayToValue.putIfAbsent(labelName, label)
            }
        }

        return allLabels.sorted()
    }

    private fun applyLabelFilter(list: List<RealmNews?>): List<RealmNews?> {
        if (selectedLabel == "All") {
            return list
        }

        return list.filter { news ->
            when {
                selectedLabel == "Shared Chat" -> {
                    news?.chat == true || news?.viewableBy.equals("community", ignoreCase = true)
                }
                labelDisplayToValue.containsKey(selectedLabel) -> {
                    val labelValue = labelDisplayToValue[selectedLabel]
                    news?.labels?.contains(labelValue) == true
                }
                else -> {
                    extractSharedTeamName(news) == selectedLabel
                }
            }
        }
    }

    private fun extractSharedTeamName(news: RealmNews?): String {
        if (!news?.viewIn.isNullOrEmpty()) {
            try {
                val ar = gson.fromJson(news.viewIn, JsonArray::class.java)
                if (ar.size() > 1) {
                    val ob = ar[0].asJsonObject
                    if (ob.has("name") && !ob.get("name").isJsonNull) {
                        return ob.get("name").asString
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
        return ""
    }

    override fun onDestroyView() {
        adapterNews?.unregisterAdapterDataObserver(observer)
        if (isRealmInitialized()) {
            mRealm.close()
        }
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.news


import android.content.res.Configuration
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.EditText
import androidx.core.view.isVisible
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView.AdapterDataObserver
import com.google.gson.Gson
import com.google.gson.JsonArray
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.flow.debounce
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseNewsFragment
import org.ole.planet.myplanet.databinding.FragmentNewsBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmNews.Companion.createNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.NewsRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.chat.ChatDetailFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.KeyboardUtils.setupUI
import org.ole.planet.myplanet.utilities.textChanges

@AndroidEntryPoint
class NewsFragment : BaseNewsFragment() {
    private var _binding: FragmentNewsBinding? = null
    private val binding get() = _binding!!
    var user: RealmUserModel? = null

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    @Inject
    lateinit var newsRepository: NewsRepository
    private var filteredNewsList: List<RealmNews?> = listOf()
    private var searchFilteredList: List<RealmNews?> = listOf()
    private var labelFilteredList: List<RealmNews?> = listOf()
    private val gson = Gson()
    private lateinit var etSearch: EditText
    private var selectedLabel: String = "All"
    private val labelDisplayToValue = mutableMapOf<String, String>()

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentNewsBinding.inflate(inflater, container, false)
        llImage = binding.llImages
        user = userProfileDbHandler.getUserModelCopy()
        setupUI(binding.newsFragmentParentLayout, requireActivity())
        if (user?.id?.startsWith("guest") == true) {
            binding.btnNewVoice.visibility = View.GONE
        }
        etSearch = binding.root.findViewById(R.id.et_search)
        binding.btnNewVoice.setOnClickListener {
            binding.llAddNews.visibility = if (binding.llAddNews.isVisible) {
                binding.etMessage.setText("")
                binding.tlMessage.error = null
                clearImages()
                View.GONE
            } else {
                View.VISIBLE
            }
            binding.btnNewVoice.text = if (binding.llAddNews.isVisible) {
                getString(R.string.hide_new_voice)
            } else {
                getString(R.string.new_voice)
            }
        }
        if (requireArguments().getBoolean("fromLogin")) {
            binding.btnNewVoice.visibility = View.GONE
            binding.llAddNews.visibility = View.GONE
        }

        if (mRealm.isInTransaction) {
            try {
                mRealm.commitTransaction()
            } catch (_: Exception) {
                mRealm.cancelTransaction()
            }
        }

        setupSearchTextListener()
        setupLabelFilter()

        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewLifecycleOwner.lifecycleScope.launch {
            newsRepository.getCommunityNews(getUserIdentifier()).collect { news ->
                val filtered = news.map { it as RealmNews? }
                val labels = collectAllLabels(filtered)
                val labelFiltered = applyLabelFilter(filtered)
                val searchFiltered = applySearchFilter(labelFiltered, etSearch.text.toString().trim())
                if (_binding != null) {
                    filteredNewsList = filtered
                    labelFilteredList = labelFiltered
                    searchFilteredList = searchFiltered
                    setupLabelFilter(labels)
                    setData(searchFilteredList)
                }
            }
        }
        binding.btnSubmit.setOnClickListener {
            val message = binding.etMessage.text.toString().trim { it <= ' ' }
            if (message.isEmpty()) {
                binding.tlMessage.error = getString(R.string.please_enter_message)
                return@setOnClickListener
            }
            binding.etMessage.setText(R.string.empty_text)
            val map = HashMap<String?, String>()
            map["message"] = message
            map["viewInId"] = "${user?.planetCode ?: ""}@${user?.parentCode ?: ""}"
            map["viewInSection"] = "community"
            map["messageType"] = "sync"
            map["messagePlanetCode"] = user?.planetCode ?: ""

            val n = user?.let { it1 -> createNews(map, mRealm, it1, imageList) }
            imageList.clear()
            llImage?.removeAllViews()
            adapterNews?.addItem(n)
            labelFilteredList = applyLabelFilter(filteredNewsList)
            searchFilteredList = applySearchFilter(labelFilteredList)
            setData(searchFilteredList)
            scrollToTop()
        }

        binding.addNewsImage.setOnClickListener {
            llImage = binding.llImages
            val openFolderIntent = FileUtils.openOleFolder(requireContext())
            openFolderLauncher.launch(openFolderIntent)
        }
    }

    private fun getUserIdentifier(): String {
        val defaultUserIdentifier = "${user?.planetCode ?: ""}@${user?.parentCode ?: ""}"
        if (defaultUserIdentifier.isNotEmpty() && defaultUserIdentifier != "@") {
            return defaultUserIdentifier
        }
        val planetCode = settings?.getString("planetCode", "") ?: ""
        val parentCode = settings?.getString("parentCode", "") ?: ""
        return "$planetCode@$parentCode"
    }

    override fun setData(list: List<RealmNews?>?) {
        if (!isAdded || list == null) return

        if (binding.rvNews.adapter == null) {
            changeLayoutManager(resources.configuration.orientation, binding.rvNews)
            val resourceIds = mutableSetOf<String>()
            list.forEach { news ->
                if ((news?.imagesArray?.size() ?: 0) > 0) {
                    val ob = news?.imagesArray?.get(0)?.asJsonObject
                    val resourceId = getString("resourceId", ob?.asJsonObject)
                    if (!resourceId.isNullOrBlank()) {
                        resourceIds.add(resourceId)
                    }
                }
            }
            viewLifecycleOwner.lifecycleScope.launch {
                if (resourceIds.isNotEmpty()) {
                    val libraries = libraryRepository.getLibraryItemsByIds(resourceIds)
                    getUrlsAndStartDownload(
                        libraries.map<RealmMyLibrary, RealmMyLibrary?> { it },
                        arrayListOf()
                    )
                }
            }
            val updatedListAsMutable: MutableList<RealmNews?> = list.toMutableList()
            val sortedList = updatedListAsMutable.sortedWith(compareByDescending { news ->
                getSortDate(news)
            })
            adapterNews = AdapterNews(requireActivity(), user, null, "", null, userProfileDbHandler, databaseService)

            adapterNews?.setmRealm(mRealm)
            adapterNews?.setFromLogin(requireArguments().getBoolean("fromLogin"))
            adapterNews?.setListener(this)
            adapterNews?.registerAdapterDataObserver(observer)
            adapterNews?.updateList(sortedList)
            binding.rvNews.adapter = adapterNews
        } else {
            (binding.rvNews.adapter as? AdapterNews)?.updateList(list)
        }
        adapterNews?.let { showNoData(binding.tvMessage, it.itemCount, "news") }
        binding.llAddNews.visibility = View.GONE
        binding.btnNewVoice.text = getString(R.string.new_voice)
    }

    override fun onNewsItemClick(news: RealmNews?) {
        val fromLogin = arguments?.getBoolean("fromLogin")
        if (fromLogin == false) {
            val bundle = Bundle()
            bundle.putString("newsId", news?.newsId)
            bundle.putString("newsRev", news?.newsRev)
            bundle.putString("conversations", news?.conversations)

            val chatDetailFragment = ChatDetailFragment()
            chatDetailFragment.arguments = bundle

            NavigationHelper.replaceFragment(
                parentFragmentManager,
                R.id.fragment_container,
                chatDetailFragment,
                addToBackStack = true
            )
        }
    }

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    override fun onConfigurationChanged(newConfig: Configuration) {
        super.onConfigurationChanged(newConfig)
        val orientation = newConfig.orientation
        changeLayoutManager(orientation, binding.rvNews)
    }

    private fun scrollToTop() {
        binding.rvNews.post {
            binding.rvNews.scrollToPosition(0)
        }
    }

    private val observer: AdapterDataObserver = object : AdapterDataObserver() {
        override fun onChanged() {
            adapterNews?.let { showNoData(binding.tvMessage, it.itemCount, "news") }
        }

        override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {
            adapterNews?.let { showNoData(binding.tvMessage, it.itemCount, "news") }
        }

        override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {
            adapterNews?.let { showNoData(binding.tvMessage, it.itemCount, "news") }
        }
    }
    private fun getSortDate(news: RealmNews?): Long {
        if (news == null) return 0
        try {
            if (!news.viewIn.isNullOrEmpty()) {
                val ar = gson.fromJson(news.viewIn, JsonArray::class.java)
                for (elem in ar) {
                    val obj = elem.asJsonObject
                    if (obj.has("section") && obj.get("section").asString.equals("community", true) && obj.has("sharedDate")) {
                        return obj.get("sharedDate").asLong
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return news.time
    }

    private fun setupSearchTextListener() {
        etSearch.textChanges()
            .debounce(300)
            .onEach { text ->
                val searchQuery = text.toString().trim()
                searchFilteredList = applySearchFilter(labelFilteredList, searchQuery)
                setData(searchFilteredList)
                scrollToTop()
            }
            .launchIn(viewLifecycleOwner.lifecycleScope)
    }

    private fun applySearchFilter(list: List<RealmNews?>, queryParam: String? = null): List<RealmNews?> {
        val query = queryParam ?: etSearch.text.toString().trim()

        if (query.isEmpty()) {
            return list
        }

        val filtered = list.filter { news ->
            val message = news?.message?.trim() ?: ""
            val matches = message.contains(query, ignoreCase = true)
            matches
        }
        return filtered
    }

    private fun setupLabelFilter(precomputedLabels: List<String>? = null) {
        updateLabelSpinner(precomputedLabels)

        binding.filterByLabel.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                val labels = (binding.filterByLabel.adapter as ArrayAdapter<String>)
                selectedLabel = labels.getItem(position) ?: "All"
                labelFilteredList = applyLabelFilter(filteredNewsList)
                searchFilteredList = applySearchFilter(labelFilteredList)
                setData(searchFilteredList)
                scrollToTop()
            }
            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }
    }

    private fun updateLabelSpinner(precomputedLabels: List<String>? = null) {
        val binding = _binding ?: return
        val labels = precomputedLabels ?: collectAllLabels(filteredNewsList)
        val themedContext = androidx.appcompat.view.ContextThemeWrapper(requireContext(), R.style.ResourcePopupMenu)
        val adapter = ArrayAdapter(themedContext, android.R.layout.simple_spinner_item, labels)
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        binding.filterByLabel.adapter = adapter

        val position = labels.indexOf(selectedLabel)
        if (position >= 0) {
            binding.filterByLabel.setSelection(position)
        } else {
            selectedLabel = "All"
            binding.filterByLabel.setSelection(0)
        }
    }

    private fun collectAllLabels(list: List<RealmNews?>): List<String> {
        labelDisplayToValue.clear()

        val allLabels = mutableSetOf<String>()
        allLabels.add("All")

        Constants.LABELS.forEach { (labelName, labelValue) ->
            allLabels.add(labelName)
            labelDisplayToValue[labelName] = labelValue
        }

        allLabels.add("Shared Chat")

        list.forEach { news ->
            if (!news?.viewIn.isNullOrEmpty()) {
                try {
                    val ar = gson.fromJson(news.viewIn, JsonArray::class.java)
                    if (ar.size() > 1) {
                        val ob = ar[0].asJsonObject
                        if (ob.has("name") && !ob.get("name").isJsonNull) {
                            val sharedTeamName = ob.get("name").asString
                            if (sharedTeamName.isNotEmpty()) {
                                allLabels.add(sharedTeamName)
                            }
                        }
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }

            news?.labels?.forEach { label ->
                val labelName = Constants.LABELS.entries.find { it.value == label }?.key
                    ?: NewsLabelManager.formatLabelValue(label)
                allLabels.add(labelName)
                labelDisplayToValue.putIfAbsent(labelName, label)
            }
        }

        return allLabels.sorted()
    }

    private fun applyLabelFilter(list: List<RealmNews?>): List<RealmNews?> {
        if (selectedLabel == "All") {
            return list
        }

        return list.filter { news ->
            when {
                selectedLabel == "Shared Chat" -> {
                    news?.chat == true || news?.viewableBy.equals("community", ignoreCase = true)
                }
                labelDisplayToValue.containsKey(selectedLabel) -> {
                    val labelValue = labelDisplayToValue[selectedLabel]
                    news?.labels?.contains(labelValue) == true
                }
                else -> {
                    extractSharedTeamName(news) == selectedLabel
                }
            }
        }
    }

    private fun extractSharedTeamName(news: RealmNews?): String {
        if (!news?.viewIn.isNullOrEmpty()) {
            try {
                val ar = gson.fromJson(news.viewIn, JsonArray::class.java)
                if (ar.size() > 1) {
                    val ob = ar[0].asJsonObject
                    if (ob.has("name") && !ob.get("name").isJsonNull) {
                        return ob.get("name").asString
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
        return ""
    }

    override fun onDestroyView() {
        adapterNews?.unregisterAdapterDataObserver(observer)
        if (isRealmInitialized()) {
            mRealm.close()
        }
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/news/ReplyActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.news

import android.app.Activity
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import androidx.activity.result.ActivityResult
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.bumptech.glide.Glide
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.RealmList
import java.io.File
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityReplyBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.news.AdapterNews.OnNewsItemClickListener
import org.ole.planet.myplanet.ui.news.NewsActions
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils.getFileNameFromUrl
import org.ole.planet.myplanet.utilities.FileUtils.getImagePath
import org.ole.planet.myplanet.utilities.FileUtils.getRealPathFromURI
import org.ole.planet.myplanet.utilities.JsonUtils.getString

@AndroidEntryPoint
open class ReplyActivity : AppCompatActivity(), OnNewsItemClickListener {
    private lateinit var activityReplyBinding: ActivityReplyBinding
    @Inject
    lateinit var databaseService: DatabaseService
    var id: String? = null
    private lateinit var newsAdapter: AdapterNews
    private val gson = Gson()
    var user: RealmUserModel? = null

    private val viewModel: ReplyViewModel by viewModels()

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private lateinit var imageList: RealmList<String>
    private var llImage: ViewGroup? = null
    private lateinit var openFolderLauncher: ActivityResultLauncher<Intent>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        activityReplyBinding = ActivityReplyBinding.inflate(layoutInflater)
        setContentView(activityReplyBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, activityReplyBinding.root)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.setHomeButtonEnabled(true)
        title = "Reply"
        imageList = RealmList()
        id = intent.getStringExtra("id")
        user = userProfileDbHandler.userModel
        activityReplyBinding.rvReply.layoutManager = LinearLayoutManager(this)
        activityReplyBinding.rvReply.isNestedScrollingEnabled = false
        showData(id)
        openFolderLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result: ActivityResult ->
            if (result.resultCode == RESULT_OK && result.data != null) {
                val url = result.data?.data
                handleImageSelection(url)
            }
        }
        val resultIntent = Intent().putExtra("newsId", id)
        setResult(Activity.RESULT_OK, resultIntent)
    }

    private fun showData(id: String?) {
        id ?: return
        lifecycleScope.launch {
            val (news, list) = viewModel.getNewsWithReplies(id)
            databaseService.withRealm { realm ->
                newsAdapter = AdapterNews(this@ReplyActivity, user, news, "", null, userProfileDbHandler, databaseService)
                newsAdapter.setListener(this@ReplyActivity)
                newsAdapter.setmRealm(realm)
                newsAdapter.setFromLogin(intent.getBooleanExtra("fromLogin", false))
                newsAdapter.setNonTeamMember(intent.getBooleanExtra("nonTeamMember", false))
                newsAdapter.setImageList(imageList)
                newsAdapter.updateList(list)
                activityReplyBinding.rvReply.adapter = newsAdapter
            }
        }
    }

    override fun onResume() {
        super.onResume()
        refreshData()

    }
    private fun refreshData() {
        id?.let { showData(it) }
    }

    override fun onDataChanged() {
        refreshData()
    }

    override fun showReply(news: RealmNews?, fromLogin: Boolean, nonTeamMember: Boolean) {
        startActivity(Intent(this, ReplyActivity::class.java).putExtra("id", news?.id))
    }

    override fun addImage(llImage: ViewGroup?) {
        this.llImage = llImage
        val intent = Intent(Intent.ACTION_GET_CONTENT)
        intent.type = "image/*"
        openFolderLauncher.launch(Intent.createChooser(intent, "Select Image"))
    }

    override fun onNewsItemClick(news: RealmNews?) {}

    override fun onMemberSelected(userModel: RealmUserModel?) {
        val fragment = NewsActions.showMemberDetails(userModel, userProfileDbHandler) ?: return
        NavigationHelper.replaceFragment(
            supportFragmentManager,
            R.id.fragment_container,
            fragment,
            addToBackStack = true
        )
    }

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    override fun getCurrentImageList(): RealmList<String> {
        return imageList
    }

    private fun handleImageSelection(url: Uri?) {
        if (url == null) {
            return
        }

        var path: String? = getRealPathFromURI(this, url)
        if (TextUtils.isEmpty(path)) {
            path = getImagePath(this, url)
        }

        if (path == null) {
            return
        }

        val jsonObject = JsonObject()
        jsonObject.addProperty("imageUrl", path)
        jsonObject.addProperty("fileName", getFileNameFromUrl(path))
        imageList.add(gson.toJson(jsonObject))

        try {
            showSelectedImages()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun showSelectedImages() {
        llImage?.removeAllViews()
        llImage?.visibility = View.VISIBLE
        for (img in imageList) {
            val ob = gson.fromJson(img, JsonObject::class.java)
            val inflater = LayoutInflater.from(this).inflate(R.layout.image_thumb, llImage, false)
            val imgView = inflater.findViewById<ImageView>(R.id.thumb)
            Glide.with(this)
                .load(File(getString("imageUrl", ob)))
                .placeholder(R.drawable.ic_loading)
                .error(R.drawable.ic_loading)
                .into(imgView)
            llImage?.addView(inflater)
        }
        newsAdapter.setImageList(imageList)
    }


    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == android.R.id.home) finish()
        return super.onOptionsItemSelected(item)
    }

    override fun onDestroy() {
        super.onDestroy()
    }
}
=======
package org.ole.planet.myplanet.ui.news


import android.app.Activity
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import androidx.activity.result.ActivityResult
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.bumptech.glide.Glide
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.RealmList
import java.io.File
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityReplyBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.news.AdapterNews.OnNewsItemClickListener
import org.ole.planet.myplanet.ui.news.NewsActions
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils.getFileNameFromUrl
import org.ole.planet.myplanet.utilities.FileUtils.getImagePath
import org.ole.planet.myplanet.utilities.FileUtils.getRealPathFromURI
import org.ole.planet.myplanet.utilities.JsonUtils.getString

@AndroidEntryPoint
open class ReplyActivity : AppCompatActivity(), OnNewsItemClickListener {
    private lateinit var activityReplyBinding: ActivityReplyBinding
    @Inject
    lateinit var databaseService: DatabaseService
    var id: String? = null
    private lateinit var newsAdapter: AdapterNews
    private val gson = Gson()
    var user: RealmUserModel? = null

    private val viewModel: ReplyViewModel by viewModels()

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private lateinit var imageList: RealmList<String>
    private var llImage: ViewGroup? = null
    private lateinit var openFolderLauncher: ActivityResultLauncher<Intent>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        activityReplyBinding = ActivityReplyBinding.inflate(layoutInflater)
        setContentView(activityReplyBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, activityReplyBinding.root)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.setHomeButtonEnabled(true)
        title = "Reply"
        imageList = RealmList()
        id = intent.getStringExtra("id")
        user = userProfileDbHandler.userModel
        activityReplyBinding.rvReply.layoutManager = LinearLayoutManager(this)
        activityReplyBinding.rvReply.isNestedScrollingEnabled = false
        showData(id)
        openFolderLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result: ActivityResult ->
            if (result.resultCode == RESULT_OK && result.data != null) {
                val url = result.data?.data
                handleImageSelection(url)
            }
        }
        val resultIntent = Intent().putExtra("newsId", id)
        setResult(Activity.RESULT_OK, resultIntent)
    }

    private fun showData(id: String?) {
        id ?: return
        lifecycleScope.launch {
            val (news, list) = viewModel.getNewsWithReplies(id)
            databaseService.withRealm { realm ->
                newsAdapter = AdapterNews(this@ReplyActivity, user, news, "", null, userProfileDbHandler, databaseService)
                newsAdapter.setListener(this@ReplyActivity)
                newsAdapter.setmRealm(realm)
                newsAdapter.setFromLogin(intent.getBooleanExtra("fromLogin", false))
                newsAdapter.setNonTeamMember(intent.getBooleanExtra("nonTeamMember", false))
                newsAdapter.setImageList(imageList)
                newsAdapter.updateList(list)
                activityReplyBinding.rvReply.adapter = newsAdapter
            }
        }
    }

    override fun onResume() {
        super.onResume()
        refreshData()

    }
    private fun refreshData() {
        id?.let { showData(it) }
    }

    override fun onDataChanged() {
        refreshData()
    }

    override fun showReply(news: RealmNews?, fromLogin: Boolean, nonTeamMember: Boolean) {
        startActivity(Intent(this, ReplyActivity::class.java).putExtra("id", news?.id))
    }

    override fun addImage(llImage: ViewGroup?) {
        this.llImage = llImage
        val intent = Intent(Intent.ACTION_GET_CONTENT)
        intent.type = "image/*"
        openFolderLauncher.launch(Intent.createChooser(intent, "Select Image"))
    }

    override fun onNewsItemClick(news: RealmNews?) {}

    override fun onMemberSelected(userModel: RealmUserModel?) {
        val fragment = NewsActions.showMemberDetails(userModel, userProfileDbHandler) ?: return
        NavigationHelper.replaceFragment(
            supportFragmentManager,
            R.id.fragment_container,
            fragment,
            addToBackStack = true
        )
    }

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    override fun getCurrentImageList(): RealmList<String> {
        return imageList
    }

    private fun handleImageSelection(url: Uri?) {
        if (url == null) {
            return
        }

        var path: String? = getRealPathFromURI(this, url)
        if (TextUtils.isEmpty(path)) {
            path = getImagePath(this, url)
        }

        if (path == null) {
            return
        }

        val jsonObject = JsonObject()
        jsonObject.addProperty("imageUrl", path)
        jsonObject.addProperty("fileName", getFileNameFromUrl(path))
        imageList.add(gson.toJson(jsonObject))

        try {
            showSelectedImages()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun showSelectedImages() {
        llImage?.removeAllViews()
        llImage?.visibility = View.VISIBLE
        for (img in imageList) {
            val ob = gson.fromJson(img, JsonObject::class.java)
            val inflater = LayoutInflater.from(this).inflate(R.layout.image_thumb, llImage, false)
            val imgView = inflater.findViewById<ImageView>(R.id.thumb)
            Glide.with(this)
                .load(File(getString("imageUrl", ob)))
                .placeholder(R.drawable.ic_loading)
                .error(R.drawable.ic_loading)
                .into(imgView)
            llImage?.addView(inflater)
        }
        newsAdapter.setImageList(imageList)
    }


    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == android.R.id.home) finish()
        return super.onOptionsItemSelected(item)
    }

    override fun onDestroy() {
        super.onDestroy()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/news/GrandChildAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.news

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.utilities.DiffUtils

class GrandChildAdapter(private val section: String, private val onClick: (RealmMyTeam) -> Unit) :
    ListAdapter<RealmMyTeam, GrandChildAdapter.GrandChildViewHolder>(
        DiffUtils.itemCallback<RealmMyTeam>(
            { old, new -> old._id == new._id },
            { old, new -> old.name == new.name }
        )
    ) {
    inner class GrandChildViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val textView: TextView = itemView.findViewById(R.id.textView)
        private val teamIcon: ImageView = itemView.findViewById(R.id.teamIcon)

        fun bind(item: RealmMyTeam) {
            textView.text = item.name
            if (section == itemView.context.getString(R.string.teams)) {
                teamIcon.setImageResource(R.drawable.team)
            } else {
                teamIcon.setImageResource(R.drawable.business)
            }
            itemView.setOnClickListener { onClick(item) }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): GrandChildViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.expandable_list_grand_child_item, parent, false)
        return GrandChildViewHolder(view)
    }

    override fun onBindViewHolder(holder: GrandChildViewHolder, position: Int) {
        holder.bind(getItem(position))
    }
}
=======
package org.ole.planet.myplanet.ui.news


import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.utilities.DiffUtils

class GrandChildAdapter(private val section: String, private val onClick: (RealmMyTeam) -> Unit) :
    ListAdapter<RealmMyTeam, GrandChildAdapter.GrandChildViewHolder>(
        DiffUtils.itemCallback<RealmMyTeam>(
            { old, new -> old._id == new._id },
            { old, new -> old.name == new.name }
        )
    ) {
    inner class GrandChildViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val textView: TextView = itemView.findViewById(R.id.textView)
        private val teamIcon: ImageView = itemView.findViewById(R.id.teamIcon)

        fun bind(item: RealmMyTeam) {
            textView.text = item.name
            if (section == itemView.context.getString(R.string.teams)) {
                teamIcon.setImageResource(R.drawable.team)
            } else {
                teamIcon.setImageResource(R.drawable.business)
            }
            itemView.setOnClickListener { onClick(item) }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): GrandChildViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.expandable_list_grand_child_item, parent, false)
        return GrandChildViewHolder(view)
    }

    override fun onBindViewHolder(holder: GrandChildViewHolder, position: Int) {
        holder.bind(getItem(position))
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/news/NewsActions.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.news

import android.content.Context
import android.view.Gravity
import android.view.View
import android.view.ViewGroup
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.google.android.material.textfield.TextInputLayout
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import java.io.File
import java.util.Locale
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmNews.Companion.createNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.team.teamMember.MemberDetailFragment
import org.ole.planet.myplanet.utilities.JsonUtils

object NewsActions {
    private val imagesToRemove = mutableSetOf<String>()

    data class EditDialogComponents(
        val view: View,
        val editText: EditText,
        val inputLayout: TextInputLayout,
        val imageLayout: ViewGroup
    )

    fun createEditDialogComponents(
        context: Context,
        listener: AdapterNews.OnNewsItemClickListener?
    ): EditDialogComponents {
        val v = android.view.LayoutInflater.from(context).inflate(R.layout.alert_input, null)
        val tlInput = v.findViewById<TextInputLayout>(R.id.tl_input)
        val et = v.findViewById<EditText>(R.id.et_input)
        val llImage = v.findViewById<ViewGroup>(R.id.ll_alert_image)
        v.findViewById<View>(R.id.add_news_image).setOnClickListener { listener?.addImage(llImage) }
        return EditDialogComponents(v, et, tlInput, llImage)
    }

    private fun loadExistingImages(context: Context, news: RealmNews?, imageLayout: ViewGroup) {
        imagesToRemove.clear()
        imageLayout.removeAllViews()

        val imageUrls = news?.imageUrls
        if (!imageUrls.isNullOrEmpty()) {
            imageUrls.forEach { imageUrl ->
                try {
                    val imgObject = Gson().fromJson(imageUrl, JsonObject::class.java)
                    val path = JsonUtils.getString("imageUrl", imgObject)
                    if (path.isNotEmpty()) {
                        addImageWithRemoveIcon(context, path, imageLayout)
                    }
                } catch (_: Exception) {
                }
            }
        }
    }

    private fun addImageWithRemoveIcon(context: Context, imagePath: String, imageLayout: ViewGroup) {
        val frameLayout = FrameLayout(context).apply {
            layoutParams = ViewGroup.MarginLayoutParams(
                dpToPx(context, 100),
                dpToPx(context, 100)
            ).apply {
                setMargins(dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4))
            }
        }

        val imageView = ImageView(context).apply {
            layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.MATCH_PARENT
            )
            scaleType = ImageView.ScaleType.CENTER_CROP
        }

        val request = Glide.with(context)
        val target = if (imagePath.lowercase(Locale.getDefault()).endsWith(".gif")) {
            request.asGif().load(if (File(imagePath).exists()) File(imagePath) else imagePath)
        } else {
            request.load(if (File(imagePath).exists()) File(imagePath) else imagePath)
        }
        target.placeholder(R.drawable.ic_loading)
            .error(R.drawable.ic_loading)
            .into(imageView)

        val removeIcon = ImageView(context).apply {
            layoutParams = FrameLayout.LayoutParams(
                dpToPx(context, 24),
                dpToPx(context, 24)
            ).apply {
                gravity = Gravity.TOP or Gravity.END
                setMargins(dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4))
            }
            setImageResource(R.drawable.baseline_close_24)
            background = ContextCompat.getDrawable(context, R.drawable.rounded_background)
            setPadding(dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4))
            setOnClickListener {
                imagesToRemove.add(imagePath)
                (parent as? ViewGroup)?.let { parentView ->
                    (parentView.parent as? ViewGroup)?.removeView(parentView)
                }
            }
        }

        frameLayout.addView(imageView)
        frameLayout.addView(removeIcon)
        imageLayout.addView(frameLayout)
    }

    private fun dpToPx(context: Context, dp: Int): Int {
        return (dp * context.resources.displayMetrics.density).toInt()
    }

    fun handlePositiveButton(
        dialog: AlertDialog,
        isEdit: Boolean,
        components: EditDialogComponents,
        news: RealmNews?,
        realm: Realm,
        currentUser: RealmUserModel?,
        imageList: RealmList<String>?,
        listener: AdapterNews.OnNewsItemClickListener?
    ) {
        val s = components.editText.text.toString().trim()
        if (s.isEmpty()) {
            components.inputLayout.error = dialog.context.getString(R.string.please_enter_message)
            return
        }
        if (isEdit) {
            editPost(realm, s, news, imageList)
        } else {
            postReply(realm, s, news, currentUser, imageList)
        }
        dialog.dismiss()
        listener?.clearImages()
        listener?.onDataChanged()
    }

    fun showEditAlert(
        context: Context,
        realm: Realm,
        id: String?,
        isEdit: Boolean,
        currentUser: RealmUserModel?,
        listener: AdapterNews.OnNewsItemClickListener?,
        viewHolder: RecyclerView.ViewHolder,
        updateReplyButton: (RecyclerView.ViewHolder, RealmNews?, Int) -> Unit = { _, _, _ -> }
    ) {
        val components = createEditDialogComponents(context, listener)
        val message = components.view.findViewById<TextView>(R.id.cust_msg)
        message.text = context.getString(if (isEdit) R.string.edit_post else R.string.reply)
        val icon = components.view.findViewById<ImageView>(R.id.alert_icon)
        icon.setImageResource(R.drawable.ic_edit)

        val news = realm.where(RealmNews::class.java).equalTo("id", id).findFirst()
        if (isEdit) {
            components.editText.setText(context.getString(R.string.message_placeholder, news?.message))
            loadExistingImages(context, news, components.imageLayout)
        }
        val dialog = AlertDialog.Builder(context, R.style.ReplyAlertDialog)
            .setView(components.view)
            .setPositiveButton(R.string.button_submit, null)
            .setNegativeButton(R.string.cancel) { d, _ -> d.dismiss() }
            .create()
        dialog.show()
        dialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener {
            val currentImageList = listener?.getCurrentImageList()
            handlePositiveButton(dialog, isEdit, components, news, realm, currentUser, currentImageList, listener)
            updateReplyButton(viewHolder,news,viewHolder.bindingAdapterPosition)
        }
    }

    private fun postReply(
        realm: Realm,
        s: String?,
        news: RealmNews?,
        currentUser: RealmUserModel?,
        imageList: RealmList<String>?
    ) {
        val shouldCommit = !realm.isInTransaction
        if (shouldCommit) realm.beginTransaction()
        val map = HashMap<String?, String>()
        map["message"] = s ?: ""
        map["viewableBy"] = news?.viewableBy ?: ""
        map["viewableId"] = news?.viewableId ?: ""
        map["replyTo"] = news?.id ?: ""
        map["messageType"] = news?.messageType ?: ""
        map["messagePlanetCode"] = news?.messagePlanetCode ?: ""
        map["viewIn"] = news?.viewIn ?: ""
        currentUser?.let { createNews(map, realm, it, imageList, true) }
        if (shouldCommit) realm.commitTransaction()
    }

    private fun editPost(realm: Realm, s: String, news: RealmNews?, imageList: RealmList<String>?) {
        if (s.isEmpty()) return
        if (!realm.isInTransaction) realm.beginTransaction()

        if (imagesToRemove.isNotEmpty()) {
            news?.imageUrls?.let { imageUrls ->
                val updatedUrls = imageUrls.filter { imageUrlJson ->
                    try {
                        val imgObject = Gson().fromJson(imageUrlJson, JsonObject::class.java)
                        val path = JsonUtils.getString("imageUrl", imgObject)
                        !imagesToRemove.contains(path)
                    } catch (_: Exception) {
                        true
                    }
                }
                news.imageUrls?.clear()
                news.imageUrls?.addAll(updatedUrls)
            }
            imagesToRemove.clear()
        }

        imageList?.forEach { news?.imageUrls?.add(it) }
        news?.updateMessage(s)
        realm.commitTransaction()
    }

    fun showMemberDetails(
        userModel: RealmUserModel?,
        profileDbHandler: UserProfileDbHandler
    ): MemberDetailFragment? {
        if (userModel == null) return null
        val userName = "${userModel.firstName} ${userModel.lastName}".trim().ifBlank { userModel.name }
        val fragment = MemberDetailFragment.newInstance(
            userName.toString(),
            userModel.email.toString(),
            userModel.dob.toString().substringBefore("T"),
            userModel.language.toString(),
            userModel.phoneNumber.toString(),
            profileDbHandler.getOfflineVisits(userModel).toString(),
            profileDbHandler.getLastVisit(userModel),
            "${userModel.firstName} ${userModel.lastName}",
            userModel.level.toString(),
            userModel.userImage
        )
        return fragment
    }

    fun deletePost(
        realm: Realm,
        news: RealmNews?,
        list: MutableList<RealmNews?>,
        teamName: String,
        listener: AdapterNews.OnNewsItemClickListener? = null
    ) {
        val ar = Gson().fromJson(news?.viewIn, JsonArray::class.java)
        if (!realm.isInTransaction) realm.beginTransaction()
        val position = list.indexOf(news)
        if (position != -1) {
            list.removeAt(position)
        }
        if (teamName.isNotEmpty() || ar.size() < 2) {
            news?.let { newsItem ->
                deleteChildPosts(realm, newsItem.id, list)

                val managedNews = if (newsItem.isManaged) {
                    newsItem
                } else {
                    realm.where(RealmNews::class.java)
                        .equalTo("id", newsItem.id)
                        .findFirst()
                }

                managedNews?.deleteFromRealm()
            }
        } else {
            news?.let { newsItem ->
                val filtered = JsonArray().apply {
                    ar.forEach { elem ->
                        if (!elem.asJsonObject.has("sharedDate")) {
                            add(elem)
                        }
                    }
                }

                val managedNews = if (newsItem.isManaged) {
                    newsItem
                } else {
                    realm.where(RealmNews::class.java)
                        .equalTo("id", newsItem.id)
                        .findFirst()
                }

                managedNews?.viewIn = Gson().toJson(filtered)
            }
        }
        realm.commitTransaction()
        listener?.onDataChanged()
    }

    private fun deleteChildPosts(
        realm: Realm,
        parentId: String?,
        list: MutableList<RealmNews?>
    ) {
        if (parentId == null) return
        val children = realm.where(RealmNews::class.java)
            .equalTo("replyTo", parentId)
            .findAll()
        children.forEach { child ->
            deleteChildPosts(realm, child.id, list)
            val idx = list.indexOf(child)
            if (idx != -1) list.removeAt(idx)
            child.deleteFromRealm()
        }
    }
}
=======
package org.ole.planet.myplanet.ui.news


import android.content.Context
import android.view.Gravity
import android.view.View
import android.view.ViewGroup
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.google.android.material.textfield.TextInputLayout
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import java.io.File
import java.util.Locale
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmNews.Companion.createNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.team.teamMember.MemberDetailFragment
import org.ole.planet.myplanet.utilities.JsonUtils

object NewsActions {
    private val imagesToRemove = mutableSetOf<String>()

    data class EditDialogComponents(
        val view: View,
        val editText: EditText,
        val inputLayout: TextInputLayout,
        val imageLayout: ViewGroup
    )

    fun createEditDialogComponents(
        context: Context,
        listener: AdapterNews.OnNewsItemClickListener?
    ): EditDialogComponents {
        val v = android.view.LayoutInflater.from(context).inflate(R.layout.alert_input, null)
        val tlInput = v.findViewById<TextInputLayout>(R.id.tl_input)
        val et = v.findViewById<EditText>(R.id.et_input)
        val llImage = v.findViewById<ViewGroup>(R.id.ll_alert_image)
        v.findViewById<View>(R.id.add_news_image).setOnClickListener { listener?.addImage(llImage) }
        return EditDialogComponents(v, et, tlInput, llImage)
    }

    private fun loadExistingImages(context: Context, news: RealmNews?, imageLayout: ViewGroup) {
        imagesToRemove.clear()
        imageLayout.removeAllViews()

        val imageUrls = news?.imageUrls
        if (!imageUrls.isNullOrEmpty()) {
            imageUrls.forEach { imageUrl ->
                try {
                    val imgObject = Gson().fromJson(imageUrl, JsonObject::class.java)
                    val path = JsonUtils.getString("imageUrl", imgObject)
                    if (path.isNotEmpty()) {
                        addImageWithRemoveIcon(context, path, imageLayout)
                    }
                } catch (_: Exception) {
                }
            }
        }
    }

    private fun addImageWithRemoveIcon(context: Context, imagePath: String, imageLayout: ViewGroup) {
        val frameLayout = FrameLayout(context).apply {
            layoutParams = ViewGroup.MarginLayoutParams(
                dpToPx(context, 100),
                dpToPx(context, 100)
            ).apply {
                setMargins(dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4))
            }
        }

        val imageView = ImageView(context).apply {
            layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.MATCH_PARENT
            )
            scaleType = ImageView.ScaleType.CENTER_CROP
        }

        val request = Glide.with(context)
        val target = if (imagePath.lowercase(Locale.getDefault()).endsWith(".gif")) {
            request.asGif().load(if (File(imagePath).exists()) File(imagePath) else imagePath)
        } else {
            request.load(if (File(imagePath).exists()) File(imagePath) else imagePath)
        }
        target.placeholder(R.drawable.ic_loading)
            .error(R.drawable.ic_loading)
            .into(imageView)

        val removeIcon = ImageView(context).apply {
            layoutParams = FrameLayout.LayoutParams(
                dpToPx(context, 24),
                dpToPx(context, 24)
            ).apply {
                gravity = Gravity.TOP or Gravity.END
                setMargins(dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4))
            }
            setImageResource(R.drawable.baseline_close_24)
            background = ContextCompat.getDrawable(context, R.drawable.rounded_background)
            setPadding(dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4), dpToPx(context, 4))
            setOnClickListener {
                imagesToRemove.add(imagePath)
                (parent as? ViewGroup)?.let { parentView ->
                    (parentView.parent as? ViewGroup)?.removeView(parentView)
                }
            }
        }

        frameLayout.addView(imageView)
        frameLayout.addView(removeIcon)
        imageLayout.addView(frameLayout)
    }

    private fun dpToPx(context: Context, dp: Int): Int {
        return (dp * context.resources.displayMetrics.density).toInt()
    }

    fun handlePositiveButton(
        dialog: AlertDialog,
        isEdit: Boolean,
        components: EditDialogComponents,
        news: RealmNews?,
        realm: Realm,
        currentUser: RealmUserModel?,
        imageList: RealmList<String>?,
        listener: AdapterNews.OnNewsItemClickListener?
    ) {
        val s = components.editText.text.toString().trim()
        if (s.isEmpty()) {
            components.inputLayout.error = dialog.context.getString(R.string.please_enter_message)
            return
        }
        if (isEdit) {
            editPost(realm, s, news, imageList)
        } else {
            postReply(realm, s, news, currentUser, imageList)
        }
        dialog.dismiss()
        listener?.clearImages()
        listener?.onDataChanged()
    }

    fun showEditAlert(
        context: Context,
        realm: Realm,
        id: String?,
        isEdit: Boolean,
        currentUser: RealmUserModel?,
        listener: AdapterNews.OnNewsItemClickListener?,
        viewHolder: RecyclerView.ViewHolder,
        updateReplyButton: (RecyclerView.ViewHolder, RealmNews?, Int) -> Unit = { _, _, _ -> }
    ) {
        val components = createEditDialogComponents(context, listener)
        val message = components.view.findViewById<TextView>(R.id.cust_msg)
        message.text = context.getString(if (isEdit) R.string.edit_post else R.string.reply)
        val icon = components.view.findViewById<ImageView>(R.id.alert_icon)
        icon.setImageResource(R.drawable.ic_edit)

        val news = realm.where(RealmNews::class.java).equalTo("id", id).findFirst()
        if (isEdit) {
            components.editText.setText(context.getString(R.string.message_placeholder, news?.message))
            loadExistingImages(context, news, components.imageLayout)
        }
        val dialog = AlertDialog.Builder(context, R.style.ReplyAlertDialog)
            .setView(components.view)
            .setPositiveButton(R.string.button_submit, null)
            .setNegativeButton(R.string.cancel) { d, _ -> d.dismiss() }
            .create()
        dialog.show()
        dialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener {
            val currentImageList = listener?.getCurrentImageList()
            handlePositiveButton(dialog, isEdit, components, news, realm, currentUser, currentImageList, listener)
            updateReplyButton(viewHolder,news,viewHolder.bindingAdapterPosition)
        }
    }

    private fun postReply(
        realm: Realm,
        s: String?,
        news: RealmNews?,
        currentUser: RealmUserModel?,
        imageList: RealmList<String>?
    ) {
        val shouldCommit = !realm.isInTransaction
        if (shouldCommit) realm.beginTransaction()
        val map = HashMap<String?, String>()
        map["message"] = s ?: ""
        map["viewableBy"] = news?.viewableBy ?: ""
        map["viewableId"] = news?.viewableId ?: ""
        map["replyTo"] = news?.id ?: ""
        map["messageType"] = news?.messageType ?: ""
        map["messagePlanetCode"] = news?.messagePlanetCode ?: ""
        map["viewIn"] = news?.viewIn ?: ""
        currentUser?.let { createNews(map, realm, it, imageList, true) }
        if (shouldCommit) realm.commitTransaction()
    }

    private fun editPost(realm: Realm, s: String, news: RealmNews?, imageList: RealmList<String>?) {
        if (s.isEmpty()) return
        if (!realm.isInTransaction) realm.beginTransaction()

        if (imagesToRemove.isNotEmpty()) {
            news?.imageUrls?.let { imageUrls ->
                val updatedUrls = imageUrls.filter { imageUrlJson ->
                    try {
                        val imgObject = Gson().fromJson(imageUrlJson, JsonObject::class.java)
                        val path = JsonUtils.getString("imageUrl", imgObject)
                        !imagesToRemove.contains(path)
                    } catch (_: Exception) {
                        true
                    }
                }
                news.imageUrls?.clear()
                news.imageUrls?.addAll(updatedUrls)
            }
            imagesToRemove.clear()
        }

        imageList?.forEach { news?.imageUrls?.add(it) }
        news?.updateMessage(s)
        realm.commitTransaction()
    }

    fun showMemberDetails(
        userModel: RealmUserModel?,
        profileDbHandler: UserProfileDbHandler
    ): MemberDetailFragment? {
        if (userModel == null) return null
        val userName = "${userModel.firstName} ${userModel.lastName}".trim().ifBlank { userModel.name }
        val fragment = MemberDetailFragment.newInstance(
            userName.toString(),
            userModel.email.toString(),
            userModel.dob.toString().substringBefore("T"),
            userModel.language.toString(),
            userModel.phoneNumber.toString(),
            profileDbHandler.getOfflineVisits(userModel).toString(),
            profileDbHandler.getLastVisit(userModel),
            "${userModel.firstName} ${userModel.lastName}",
            userModel.level.toString(),
            userModel.userImage
        )
        return fragment
    }

    fun deletePost(
        realm: Realm,
        news: RealmNews?,
        list: MutableList<RealmNews?>,
        teamName: String,
        listener: AdapterNews.OnNewsItemClickListener? = null
    ) {
        val ar = Gson().fromJson(news?.viewIn, JsonArray::class.java)
        if (!realm.isInTransaction) realm.beginTransaction()
        val position = list.indexOf(news)
        if (position != -1) {
            list.removeAt(position)
        }
        if (teamName.isNotEmpty() || ar.size() < 2) {
            news?.let { newsItem ->
                deleteChildPosts(realm, newsItem.id, list)

                val managedNews = if (newsItem.isManaged) {
                    newsItem
                } else {
                    realm.where(RealmNews::class.java)
                        .equalTo("id", newsItem.id)
                        .findFirst()
                }

                managedNews?.deleteFromRealm()
            }
        } else {
            news?.let { newsItem ->
                val filtered = JsonArray().apply {
                    ar.forEach { elem ->
                        if (!elem.asJsonObject.has("sharedDate")) {
                            add(elem)
                        }
                    }
                }

                val managedNews = if (newsItem.isManaged) {
                    newsItem
                } else {
                    realm.where(RealmNews::class.java)
                        .equalTo("id", newsItem.id)
                        .findFirst()
                }

                managedNews?.viewIn = Gson().toJson(filtered)
            }
        }
        realm.commitTransaction()
        listener?.onDataChanged()
    }

    private fun deleteChildPosts(
        realm: Realm,
        parentId: String?,
        list: MutableList<RealmNews?>
    ) {
        if (parentId == null) return
        val children = realm.where(RealmNews::class.java)
            .equalTo("replyTo", parentId)
            .findAll()
        children.forEach { child ->
            deleteChildPosts(realm, child.id, list)
            val idx = list.indexOf(child)
            if (idx != -1) list.removeAt(idx)
            child.deleteFromRealm()
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/news/ReplyViewModel.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.news

import androidx.lifecycle.ViewModel
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.repository.NewsRepository

@HiltViewModel
class ReplyViewModel @Inject constructor(
    private val newsRepository: NewsRepository,
) : ViewModel() {

    suspend fun getNewsWithReplies(newsId: String): Pair<RealmNews?, List<RealmNews>> {
        return newsRepository.getNewsWithReplies(newsId)
    }
}
=======
package org.ole.planet.myplanet.ui.news


import androidx.lifecycle.ViewModel
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.repository.NewsRepository

@HiltViewModel
class ReplyViewModel @Inject constructor(
    private val newsRepository: NewsRepository,
) : ViewModel() {

    suspend fun getNewsWithReplies(newsId: String): Pair<RealmNews?, List<RealmNews>> {
        return newsRepository.getNewsWithReplies(newsId)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/map/OfflineMapActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.map

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.preference.PreferenceManager
import org.ole.planet.myplanet.databinding.ActivityOfflineMapBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.osmdroid.config.Configuration
import org.osmdroid.tileprovider.tilesource.TileSourceFactory
import org.osmdroid.util.GeoPoint
import org.osmdroid.views.CustomZoomButtonsController

class OfflineMapActivity : AppCompatActivity() {
    private lateinit var activityOfflineMapBinding: ActivityOfflineMapBinding
    public override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Configuration.getInstance().load(this, PreferenceManager.getDefaultSharedPreferences(this))
        activityOfflineMapBinding = ActivityOfflineMapBinding.inflate(layoutInflater)
        setContentView(activityOfflineMapBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, activityOfflineMapBinding.root)
        activityOfflineMapBinding.map.setTileSource(TileSourceFactory.MAPNIK)
        activityOfflineMapBinding.map.zoomController.setVisibility(CustomZoomButtonsController.Visibility.SHOW_AND_FADEOUT)
        activityOfflineMapBinding.map.setMultiTouchControls(true)
        val mapController = activityOfflineMapBinding.map.controller
        mapController.setZoom(15.0)
        val startPoint = GeoPoint(2.0593708, 45.236624)
        mapController.setCenter(startPoint)
    }

    public override fun onResume() {
        super.onResume()
        activityOfflineMapBinding.map.onResume() //needed for compass, my location overlays, v6.0.0 and up
    }

    public override fun onPause() {
        super.onPause()
        activityOfflineMapBinding.map.onPause() //needed for compass, my location overlays, v6.0.0 and up
    }
}
=======
package org.ole.planet.myplanet.ui.map


import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.preference.PreferenceManager
import org.ole.planet.myplanet.databinding.ActivityOfflineMapBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.osmdroid.config.Configuration
import org.osmdroid.tileprovider.tilesource.TileSourceFactory
import org.osmdroid.util.GeoPoint
import org.osmdroid.views.CustomZoomButtonsController

class OfflineMapActivity : AppCompatActivity() {
    private lateinit var activityOfflineMapBinding: ActivityOfflineMapBinding
    public override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Configuration.getInstance().load(this, PreferenceManager.getDefaultSharedPreferences(this))
        activityOfflineMapBinding = ActivityOfflineMapBinding.inflate(layoutInflater)
        setContentView(activityOfflineMapBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, activityOfflineMapBinding.root)
        activityOfflineMapBinding.map.setTileSource(TileSourceFactory.MAPNIK)
        activityOfflineMapBinding.map.zoomController.setVisibility(CustomZoomButtonsController.Visibility.SHOW_AND_FADEOUT)
        activityOfflineMapBinding.map.setMultiTouchControls(true)
        val mapController = activityOfflineMapBinding.map.controller
        mapController.setZoom(15.0)
        val startPoint = GeoPoint(2.0593708, 45.236624)
        mapController.setCenter(startPoint)
    }

    public override fun onResume() {
        super.onResume()
        activityOfflineMapBinding.map.onResume() //needed for compass, my location overlays, v6.0.0 and up
    }

    public override fun onPause() {
        super.onPause()
        activityOfflineMapBinding.map.onPause() //needed for compass, my location overlays, v6.0.0 and up
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/survey/SurveyFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.survey

import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ArrayAdapter
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment
import org.ole.planet.myplanet.callback.SurveyAdoptListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.databinding.FragmentSurveyBinding
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.repository.SurveyRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.ui.sync.RealtimeSyncHelper
import org.ole.planet.myplanet.ui.sync.RealtimeSyncMixin
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager

@AndroidEntryPoint
class SurveyFragment : BaseRecyclerFragment<RealmStepExam?>(), SurveyAdoptListener, RealtimeSyncMixin {
    private var _binding: FragmentSurveyBinding? = null
    private val binding get() = _binding!!
    private lateinit var adapter: AdapterSurvey
    private var isTeam: Boolean = false
    private var teamId: String? = null
    private var currentIsTeamShareAllowed: Boolean = false
    lateinit var prefManager: SharedPrefManager
    private val serverUrlMapper = ServerUrlMapper()
    private var loadSurveysJob: Job? = null
    private var currentSurveys: List<RealmStepExam> = emptyList()
    private val surveyInfoMap = mutableMapOf<String, SurveyInfo>()
    private var textWatcher: TextWatcher? = null

    @Inject
    lateinit var syncManager: SyncManager
    @Inject
    lateinit var surveyRepository: SurveyRepository
    private lateinit var realtimeSyncHelper: RealtimeSyncHelper
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null

    override fun getLayout(): Int = R.layout.fragment_survey

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = super.onCreateView(inflater, container, savedInstanceState)
        _binding = view?.let { FragmentSurveyBinding.bind(it) }
        return view
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        isTeam = arguments?.getBoolean("isTeam", false) == true
        teamId = arguments?.getString("teamId", null)
        val userProfileModel = profileDbHandler.userModel
        adapter = AdapterSurvey(
            requireActivity(),
            mRealm,
            userProfileModel?.id,
            isTeam,
            teamId,
            this,
            settings,
            profileDbHandler,
            surveyInfoMap
        )
        prefManager = SharedPrefManager(requireContext())

        startExamSync()
    }

    private fun startExamSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isExamsSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                launchWhenViewIsReady {
                    if (!requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText("Syncing surveys...")
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                prefManager.setExamsSynced(true)
                val job = launchWhenViewIsReady {
                    customProgressDialog?.dismiss()
                    customProgressDialog = null
                    updateAdapterData(isTeamShareAllowed = false)
                }
                if (job == null) {
                    customProgressDialog?.dismiss()
                    customProgressDialog = null
                }
            }

            override fun onSyncFailed(msg: String?) {
                val job = launchWhenViewIsReady {
                    customProgressDialog?.dismiss()
                    customProgressDialog = null
                    _binding?.let { binding ->
                        Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG)
                            .setAction("Retry") { startExamSync() }
                            .show()
                    }
                }
                if (job == null) {
                    customProgressDialog?.dismiss()
                    customProgressDialog = null
                }
            }
        }, "full", listOf("exams"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    override fun onSurveyAdopted() {
        binding.rbTeamSurvey.isChecked = true
        updateAdapterData(isTeamShareAllowed = false)
    }

    override fun getAdapter(): RecyclerView.Adapter<*> = adapter

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        realtimeSyncHelper = RealtimeSyncHelper(this, this)
        realtimeSyncHelper.setupRealtimeSync()
        initializeViews()
        textWatcher = object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                applySearchFilter()
            }

            override fun afterTextChanged(s: Editable) {}
        }
        binding.layoutSearch.etSearch.addTextChangedListener(textWatcher)
        setupRecyclerView()
        setupListeners()
        updateAdapterData(isTeamShareAllowed = false)
        showHideRadioButton()
    }

    override fun onResume() {
        super.onResume()
        updateAdapterData(currentIsTeamShareAllowed)
    }

    private fun showHideRadioButton() {
        if (isTeam) {
            binding.rgSurvey.visibility = View.VISIBLE
            binding.rbTeamSurvey.isChecked = true
        }
    }

    private fun initializeViews() {
        val adapter = ArrayAdapter.createFromResource(
            requireContext(), R.array.sort_by_date, R.layout.spinner_text
        )
        adapter.setDropDownViewResource(R.layout.spinner_text)
        binding.spnSort.adapter = adapter
    }

    private fun setupRecyclerView() {
        recyclerView.setHasFixedSize(true)
        recyclerView.adapter = adapter
    }

    private fun setupListeners() {
        binding.fabAddNewSurvey.setOnClickListener {}

        var isSpinnerInitialized = false
        binding.spnSort.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(adapterView: AdapterView<*>?, view: View?, i: Int, l: Long) {
                if (!isSpinnerInitialized) {
                    isSpinnerInitialized = true
                    return
                }
                when (i) {
                    0 -> adapter.sortByDate(false)
                    1 -> adapter.sortByDate(true)
                    2 -> adapter.toggleTitleSortOrder()
                }
                recyclerView.scrollToPosition(0)
            }

            override fun onNothingSelected(adapterView: AdapterView<*>?) {}
        }

        binding.spnSort.onSameItemSelected(object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(adapterView: AdapterView<*>?, view: View?, i: Int, l: Long) {
                if (i == 2) adapter.toggleTitleSortOrder()
                recyclerView.scrollToPosition(0)
            }

            override fun onNothingSelected(parent: AdapterView<*>?) {}
        })

        binding.rbAdoptSurvey.setOnClickListener {
            updateAdapterData(isTeamShareAllowed = true)
            recyclerView.scrollToPosition(0)
        }

        binding.rbTeamSurvey.setOnClickListener {
            updateAdapterData(isTeamShareAllowed = false)
            recyclerView.scrollToPosition(0)
        }
    }

    private fun search(s: String, list: List<RealmStepExam>): List<RealmStepExam> {
        val queryParts = s.split(" ").filterNot { it.isEmpty() }
        val normalizedQuery = normalizeText(s)
        val startsWithQuery = mutableListOf<RealmStepExam>()
        val containsQuery = mutableListOf<RealmStepExam>()

        for (item in list) {
            val title = item.name?.let { normalizeText(it) } ?: continue
            if (title.startsWith(normalizedQuery, ignoreCase = true)) {
                startsWithQuery.add(item)
            } else if (queryParts.all { title.contains(normalizeText(it), ignoreCase = true) }) {
                containsQuery.add(item)
            }
        }
        return startsWithQuery + containsQuery
    }

    fun updateAdapterData(isTeamShareAllowed: Boolean? = null) {
        val useTeamShareAllowed = isTeamShareAllowed ?: currentIsTeamShareAllowed
        currentIsTeamShareAllowed = useTeamShareAllowed
        val userProfileModel = profileDbHandler.userModel
        loadSurveysJob?.cancel()
        loadSurveysJob = launchWhenViewIsReady {
            currentSurveys = when {
                isTeam && useTeamShareAllowed -> surveyRepository.getAdoptableTeamSurveys(teamId)
                isTeam -> surveyRepository.getTeamOwnedSurveys(teamId)
                else -> surveyRepository.getIndividualSurveys()
            }
            val surveyInfos = surveyRepository.getSurveyInfos(
                isTeam,
                teamId,
                userProfileModel?.id,
                currentSurveys
            )
            surveyInfoMap.clear()
            surveyInfoMap.putAll(surveyInfos)
            applySearchFilter()
        }
    }

    private fun applySearchFilter() {
        val searchText = _binding?.layoutSearch?.etSearch?.text?.toString().orEmpty()
        if (searchText.isNotEmpty()) {
            adapter.updateData(search(searchText, currentSurveys))
        } else {
            adapter.updateDataAfterSearch(currentSurveys)
        }

        updateUIState()
        recyclerView.scrollToPosition(0)
    }

    private fun updateUIState() {
        val itemCount = adapter.itemCount
        _binding?.spnSort?.visibility = if (itemCount == 0) View.GONE else View.VISIBLE
        showNoData(tvMessage, itemCount, "survey")
    }

    override fun getWatchedTables(): List<String> {
        return listOf("exams")
    }

    override fun onDataUpdated(table: String, update: TableDataUpdate) {
        if (table == "exams" && update.shouldRefreshUI) {
            updateAdapterData(isTeamShareAllowed = false)
        }
    }

    override fun getSyncRecyclerView(): RecyclerView? {
        return if (::recyclerView.isInitialized) recyclerView else null
    }

    override fun onDestroyView() {
        if (::realtimeSyncHelper.isInitialized) {
            realtimeSyncHelper.cleanup()
        }
        loadSurveysJob?.cancel()
        loadSurveysJob = null
        currentSurveys = emptyList()
        _binding?.layoutSearch?.etSearch?.removeTextChangedListener(textWatcher)
        textWatcher = null
        super.onDestroyView()
        _binding = null
    }

    private fun launchWhenViewIsReady(block: suspend CoroutineScope.() -> Unit): Job? {
        val owner = viewLifecycleOwnerLiveData.value ?: return null
        return owner.lifecycleScope.launch {
            if (!isAdded || _binding == null) return@launch
            block()
        }
    }

}
=======
package org.ole.planet.myplanet.ui.survey


import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ArrayAdapter
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment
import org.ole.planet.myplanet.callback.SurveyAdoptListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.databinding.FragmentSurveyBinding
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.repository.SurveyRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.ui.sync.RealtimeSyncHelper
import org.ole.planet.myplanet.ui.sync.RealtimeSyncMixin
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager

@AndroidEntryPoint
class SurveyFragment : BaseRecyclerFragment<RealmStepExam?>(), SurveyAdoptListener, RealtimeSyncMixin {
    private var _binding: FragmentSurveyBinding? = null
    private val binding get() = _binding!!
    private lateinit var adapter: AdapterSurvey
    private var isTeam: Boolean = false
    private var teamId: String? = null
    private var currentIsTeamShareAllowed: Boolean = false
    lateinit var prefManager: SharedPrefManager
    private val serverUrlMapper = ServerUrlMapper()
    private var loadSurveysJob: Job? = null
    private var currentSurveys: List<RealmStepExam> = emptyList()
    private val surveyInfoMap = mutableMapOf<String, SurveyInfo>()
    private var textWatcher: TextWatcher? = null

    @Inject
    lateinit var syncManager: SyncManager
    @Inject
    lateinit var surveyRepository: SurveyRepository
    private lateinit var realtimeSyncHelper: RealtimeSyncHelper
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null

    override fun getLayout(): Int = R.layout.fragment_survey

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = super.onCreateView(inflater, container, savedInstanceState)
        _binding = view?.let { FragmentSurveyBinding.bind(it) }
        return view
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        isTeam = arguments?.getBoolean("isTeam", false) == true
        teamId = arguments?.getString("teamId", null)
        val userProfileModel = profileDbHandler.userModel
        adapter = AdapterSurvey(
            requireActivity(),
            mRealm,
            userProfileModel?.id,
            isTeam,
            teamId,
            this,
            settings,
            profileDbHandler,
            surveyInfoMap
        )
        prefManager = SharedPrefManager(requireContext())

        startExamSync()
    }

    private fun startExamSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isExamsSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                launchWhenViewIsReady {
                    if (!requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText("Syncing surveys...")
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                prefManager.setExamsSynced(true)
                val job = launchWhenViewIsReady {
                    customProgressDialog?.dismiss()
                    customProgressDialog = null
                    updateAdapterData(isTeamShareAllowed = false)
                }
                if (job == null) {
                    customProgressDialog?.dismiss()
                    customProgressDialog = null
                }
            }

            override fun onSyncFailed(msg: String?) {
                val job = launchWhenViewIsReady {
                    customProgressDialog?.dismiss()
                    customProgressDialog = null
                    _binding?.let { binding ->
                        Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG)
                            .setAction("Retry") { startExamSync() }
                            .show()
                    }
                }
                if (job == null) {
                    customProgressDialog?.dismiss()
                    customProgressDialog = null
                }
            }
        }, "full", listOf("exams"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    override fun onSurveyAdopted() {
        binding.rbTeamSurvey.isChecked = true
        updateAdapterData(isTeamShareAllowed = false)
    }

    override fun getAdapter(): RecyclerView.Adapter<*> = adapter

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        realtimeSyncHelper = RealtimeSyncHelper(this, this)
        realtimeSyncHelper.setupRealtimeSync()
        initializeViews()
        textWatcher = object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                applySearchFilter()
            }

            override fun afterTextChanged(s: Editable) {}
        }
        binding.layoutSearch.etSearch.addTextChangedListener(textWatcher)
        setupRecyclerView()
        setupListeners()
        updateAdapterData(isTeamShareAllowed = false)
        showHideRadioButton()
    }

    override fun onResume() {
        super.onResume()
        updateAdapterData(currentIsTeamShareAllowed)
    }

    private fun showHideRadioButton() {
        if (isTeam) {
            binding.rgSurvey.visibility = View.VISIBLE
            binding.rbTeamSurvey.isChecked = true
        }
    }

    private fun initializeViews() {
        val adapter = ArrayAdapter.createFromResource(
            requireContext(), R.array.sort_by_date, R.layout.spinner_text
        )
        adapter.setDropDownViewResource(R.layout.spinner_text)
        binding.spnSort.adapter = adapter
    }

    private fun setupRecyclerView() {
        recyclerView.setHasFixedSize(true)
        recyclerView.adapter = adapter
    }

    private fun setupListeners() {
        binding.fabAddNewSurvey.setOnClickListener {}

        var isSpinnerInitialized = false
        binding.spnSort.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(adapterView: AdapterView<*>?, view: View?, i: Int, l: Long) {
                if (!isSpinnerInitialized) {
                    isSpinnerInitialized = true
                    return
                }
                when (i) {
                    0 -> adapter.sortByDate(false)
                    1 -> adapter.sortByDate(true)
                    2 -> adapter.toggleTitleSortOrder()
                }
                recyclerView.scrollToPosition(0)
            }

            override fun onNothingSelected(adapterView: AdapterView<*>?) {}
        }

        binding.spnSort.onSameItemSelected(object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(adapterView: AdapterView<*>?, view: View?, i: Int, l: Long) {
                if (i == 2) adapter.toggleTitleSortOrder()
                recyclerView.scrollToPosition(0)
            }

            override fun onNothingSelected(parent: AdapterView<*>?) {}
        })

        binding.rbAdoptSurvey.setOnClickListener {
            updateAdapterData(isTeamShareAllowed = true)
            recyclerView.scrollToPosition(0)
        }

        binding.rbTeamSurvey.setOnClickListener {
            updateAdapterData(isTeamShareAllowed = false)
            recyclerView.scrollToPosition(0)
        }
    }

    private fun search(s: String, list: List<RealmStepExam>): List<RealmStepExam> {
        val queryParts = s.split(" ").filterNot { it.isEmpty() }
        val normalizedQuery = normalizeText(s)
        val startsWithQuery = mutableListOf<RealmStepExam>()
        val containsQuery = mutableListOf<RealmStepExam>()

        for (item in list) {
            val title = item.name?.let { normalizeText(it) } ?: continue
            if (title.startsWith(normalizedQuery, ignoreCase = true)) {
                startsWithQuery.add(item)
            } else if (queryParts.all { title.contains(normalizeText(it), ignoreCase = true) }) {
                containsQuery.add(item)
            }
        }
        return startsWithQuery + containsQuery
    }

    fun updateAdapterData(isTeamShareAllowed: Boolean? = null) {
        val useTeamShareAllowed = isTeamShareAllowed ?: currentIsTeamShareAllowed
        currentIsTeamShareAllowed = useTeamShareAllowed
        val userProfileModel = profileDbHandler.userModel
        loadSurveysJob?.cancel()
        loadSurveysJob = launchWhenViewIsReady {
            currentSurveys = when {
                isTeam && useTeamShareAllowed -> surveyRepository.getAdoptableTeamSurveys(teamId)
                isTeam -> surveyRepository.getTeamOwnedSurveys(teamId)
                else -> surveyRepository.getIndividualSurveys()
            }
            val surveyInfos = surveyRepository.getSurveyInfos(
                isTeam,
                teamId,
                userProfileModel?.id,
                currentSurveys
            )
            surveyInfoMap.clear()
            surveyInfoMap.putAll(surveyInfos)
            applySearchFilter()
        }
    }

    private fun applySearchFilter() {
        val searchText = _binding?.layoutSearch?.etSearch?.text?.toString().orEmpty()
        if (searchText.isNotEmpty()) {
            adapter.updateData(search(searchText, currentSurveys))
        } else {
            adapter.updateDataAfterSearch(currentSurveys)
        }

        updateUIState()
        recyclerView.scrollToPosition(0)
    }

    private fun updateUIState() {
        val itemCount = adapter.itemCount
        _binding?.spnSort?.visibility = if (itemCount == 0) View.GONE else View.VISIBLE
        showNoData(tvMessage, itemCount, "survey")
    }

    override fun getWatchedTables(): List<String> {
        return listOf("exams")
    }

    override fun onDataUpdated(table: String, update: TableDataUpdate) {
        if (table == "exams" && update.shouldRefreshUI) {
            updateAdapterData(isTeamShareAllowed = false)
        }
    }

    override fun getSyncRecyclerView(): RecyclerView? {
        return if (::recyclerView.isInitialized) recyclerView else null
    }

    override fun onDestroyView() {
        if (::realtimeSyncHelper.isInitialized) {
            realtimeSyncHelper.cleanup()
        }
        loadSurveysJob?.cancel()
        loadSurveysJob = null
        currentSurveys = emptyList()
        _binding?.layoutSearch?.etSearch?.removeTextChangedListener(textWatcher)
        textWatcher = null
        super.onDestroyView()
        _binding = null
    }

    private fun launchWhenViewIsReady(block: suspend CoroutineScope.() -> Unit): Job? {
        val owner = viewLifecycleOwnerLiveData.value ?: return null
        return owner.lifecycleScope.launch {
            if (!isAdded || _binding == null) return@launch
            block()
        }
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/survey/SendSurveyFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.survey

import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ListView
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseDialogFragment
import org.ole.planet.myplanet.databinding.FragmentSendSurveyBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class SendSurveyFragment : BaseDialogFragment() {
    private lateinit var fragmentSendSurveyBinding: FragmentSendSurveyBinding
    private var users: List<RealmUserModel> = emptyList()
    @Inject
    lateinit var submissionRepository: SubmissionRepository
    @Inject
    lateinit var userRepository: UserRepository
    override val key: String
        get() = "surveyId"

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        fragmentSendSurveyBinding = FragmentSendSurveyBinding.inflate(inflater, container, false)
        if (TextUtils.isEmpty(id)) {
            dismiss()
            return fragmentSendSurveyBinding.root
        }
        fragmentSendSurveyBinding.btnCancel.setOnClickListener { dismiss() }
        return fragmentSendSurveyBinding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewLifecycleOwner.lifecycleScope.launch {
            users = userRepository.getAllUsers()
            initListView(users)
        }
        fragmentSendSurveyBinding.sendSurvey.setOnClickListener {
            viewLifecycleOwner.lifecycleScope.launch {
                for (i in fragmentSendSurveyBinding.listUsers.selectedItemsList.indices) {
                    val u = users[i]
                    submissionRepository.createSurveySubmission(id!!, u.id)
                }
                Utilities.toast(activity, getString(R.string.survey_sent_to_users))
                dismiss()
            }
        }
    }

    private fun initListView(users: List<RealmUserModel>) {
        val adapter = ArrayAdapter(requireActivity(), R.layout.rowlayout, R.id.checkBoxRowLayout, users)
        fragmentSendSurveyBinding.listUsers.choiceMode = ListView.CHOICE_MODE_MULTIPLE
        fragmentSendSurveyBinding.listUsers.adapter = adapter
    }

}
=======
package org.ole.planet.myplanet.ui.survey


import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ListView
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseDialogFragment
import org.ole.planet.myplanet.databinding.FragmentSendSurveyBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class SendSurveyFragment : BaseDialogFragment() {
    private lateinit var fragmentSendSurveyBinding: FragmentSendSurveyBinding
    private var users: List<RealmUserModel> = emptyList()
    @Inject
    lateinit var submissionRepository: SubmissionRepository
    @Inject
    lateinit var userRepository: UserRepository
    override val key: String
        get() = "surveyId"

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        fragmentSendSurveyBinding = FragmentSendSurveyBinding.inflate(inflater, container, false)
        if (TextUtils.isEmpty(id)) {
            dismiss()
            return fragmentSendSurveyBinding.root
        }
        fragmentSendSurveyBinding.btnCancel.setOnClickListener { dismiss() }
        return fragmentSendSurveyBinding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewLifecycleOwner.lifecycleScope.launch {
            users = userRepository.getAllUsers()
            initListView(users)
        }
        fragmentSendSurveyBinding.sendSurvey.setOnClickListener {
            viewLifecycleOwner.lifecycleScope.launch {
                for (i in fragmentSendSurveyBinding.listUsers.selectedItemsList.indices) {
                    val u = users[i]
                    submissionRepository.createSurveySubmission(id!!, u.id)
                }
                Utilities.toast(activity, getString(R.string.survey_sent_to_users))
                dismiss()
            }
        }
    }

    private fun initListView(users: List<RealmUserModel>) {
        val adapter = ArrayAdapter(requireActivity(), R.layout.rowlayout, R.id.checkBoxRowLayout, users)
        fragmentSendSurveyBinding.listUsers.choiceMode = ListView.CHOICE_MODE_MULTIPLE
        fragmentSendSurveyBinding.listUsers.adapter = adapter
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/survey/AdapterSurvey.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.survey

import android.content.Context
import android.content.SharedPreferences
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import io.realm.Realm
import java.util.UUID
import org.json.JSONObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.SurveyAdoptListener
import org.ole.planet.myplanet.databinding.RowSurveyBinding
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmMembershipDoc
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission

class AdapterSurvey(
    private val context: Context,
    private val mRealm: Realm,
    private val userId: String?,
    private val isTeam: Boolean,
    val teamId: String?,
    private val surveyAdoptListener: SurveyAdoptListener,
    private val settings: SharedPreferences,
    private val userProfileDbHandler: UserProfileDbHandler,
    private val surveyInfoMap: Map<String, SurveyInfo>
) : ListAdapter<RealmStepExam, AdapterSurvey.ViewHolderSurvey>(SurveyDiffCallback()) {
    private var listener: OnHomeItemClickListener? = null
    private val adoptedSurveyIds = mutableSetOf<String>()
    private var isTitleAscending = true
    private var sortStrategy: (List<RealmStepExam>) -> List<RealmStepExam> = { list ->
        sortSurveyList(false, list)
    }

    init {
        if (context is OnHomeItemClickListener) {
            listener = context
        }
    }

    fun updateData(newList: List<RealmStepExam>) {
        submitList(newList)
    }

    fun updateDataAfterSearch(newList: List<RealmStepExam>) {
        val sortedList = if (currentList.isEmpty()) {
            sortSurveyList(false, newList)
        } else {
            sortStrategy(newList)
        }
        submitList(sortedList)
    }

    private fun sortSurveyList(
        isAscend: Boolean,
        list: List<RealmStepExam>
    ): List<RealmStepExam> {
        return if (isAscend) {
            list.sortedBy { it.createdDate }
        } else {
            list.sortedByDescending { it.createdDate }
        }
    }

    fun sortByDate(isAscend: Boolean) {
        sortStrategy = { list -> sortSurveyList(isAscend, list) }
        val sortedList = sortStrategy(currentList)
        submitList(sortedList)
    }

    private fun sortSurveyListByName(
        isAscend: Boolean,
        list: List<RealmStepExam>
    ): List<RealmStepExam> {
        return if (isAscend) {
            list.sortedBy { it.name?.lowercase() }
        } else {
            list.sortedByDescending { it.name?.lowercase() }
        }
    }

    fun toggleTitleSortOrder() {
        isTitleAscending = !isTitleAscending
        sortStrategy = { list -> sortSurveyListByName(isTitleAscending, list) }
        val sortedList = sortStrategy(currentList)
        submitList(sortedList)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderSurvey {
        val binding = RowSurveyBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderSurvey(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderSurvey, position: Int) {
        holder.bind(getItem(position))
    }

    inner class ViewHolderSurvey(private val binding: RowSurveyBinding) : RecyclerView.ViewHolder(binding.root) {
        init {
            binding.startSurvey.visibility = View.VISIBLE
            binding.sendSurvey.visibility = View.GONE
            binding.sendSurvey.setOnClickListener {
                val current = getItem(bindingAdapterPosition)
                listener?.sendSurvey(current)
            }
        }

        fun bind(exam: RealmStepExam) {
            binding.apply {
                startSurvey.visibility = View.VISIBLE
                tvTitle.text = exam.name
                if (exam.description?.isNotEmpty() == true) {
                    tvDescription.visibility = View.VISIBLE
                    tvDescription.text = exam.description
                }

                fun getTeamSubmission(): RealmSubmission? {
                    return mRealm.where(RealmSubmission::class.java)
                        .equalTo("parentId", exam.id)
                        .equalTo("membershipDoc.teamId", teamId)
                        .findFirst()
                }

                var teamSubmission = getTeamSubmission()

                startSurvey.setOnClickListener {
                    teamSubmission = getTeamSubmission()

                    val shouldAdopt = exam.isTeamShareAllowed && teamSubmission?.isValid != true

                    if (shouldAdopt) {
                        adoptSurvey(exam, teamId)
                    } else {
                        AdapterMySubmission.openSurvey(listener, exam.id, false, isTeam, teamId)
                    }
                }

                val questions = mRealm.where(RealmExamQuestion::class.java).equalTo("examId", exam.id)
                    .findAll()

                if (questions.isEmpty()) {
                    sendSurvey.visibility = View.GONE
                    startSurvey.visibility = View.GONE
                }

                teamSubmission = getTeamSubmission()
                val shouldShowAdopt = exam.isTeamShareAllowed && teamSubmission?.isValid != true

                startSurvey.text = when {
                    shouldShowAdopt -> context.getString(R.string.adopt_survey)
                    exam.isFromNation -> context.getString(R.string.take_survey)
                    else -> context.getString(R.string.record_survey)
                }

                if (userId?.startsWith("guest") == true) {
                    startSurvey.visibility = View.GONE
                }

                val surveyInfo = surveyInfoMap[exam.id]
                tvNoSubmissions.text = surveyInfo?.submissionCount ?: ""
                tvDateCompleted.text = surveyInfo?.lastSubmissionDate ?: ""
                tvDate.text = surveyInfo?.creationDate ?: ""
            }
        }

        fun adoptSurvey(exam: RealmStepExam, teamId: String?) {
            val userModel = userProfileDbHandler.userModel
            val sParentCode = settings.getString("parentCode", "")
            val planetCode = settings.getString("planetCode", "")

            val parentJsonString = try {
                JSONObject().apply {
                    put("_id", exam.id)
                    put("name", exam.name)
                    put("courseId", exam.courseId ?: "")
                    put("sourcePlanet", exam.sourcePlanet ?: "")
                    put("teamShareAllowed", exam.isTeamShareAllowed)
                    put("noOfQuestions", exam.noOfQuestions)
                    put("isFromNation", exam.isFromNation)
                }.toString()
            } catch (e: Exception) {
                e.printStackTrace()
                "{}"
            }

            val userJsonString = try {
                JSONObject().apply {
                    put("doc", JSONObject().apply {
                        put("_id", userModel?.id)
                        put("name", userModel?.name)
                        put("userId", userModel?.id ?: "")
                        put("teamPlanetCode", planetCode ?: "")
                        put("status", "active")
                        put("type", "team")
                        put("createdBy", userModel?.id ?: "")
                    })

                    if (isTeam && teamId != null) {
                        put("membershipDoc", JSONObject().apply {
                            put("teamId", teamId)
                        })
                    }
                }.toString()
            } catch (e: Exception) {
                e.printStackTrace()
                "{}"
            }

            val adoptionId = "${UUID.randomUUID()}"
            val examId = exam.id
            val userId = userModel?.id

            if (mRealm.isClosed) {
                Snackbar.make(binding.root, context.getString(R.string.failed_to_adopt_survey), Snackbar.LENGTH_LONG).show()
                return
            }

            try {
                mRealm.executeTransactionAsync({ realm ->
                    val existingAdoption = if (isTeam && teamId != null) {
                        realm.where(RealmSubmission::class.java)
                            .equalTo("userId", userId)
                            .equalTo("parentId", examId)
                            .equalTo("status", "")
                            .equalTo("membershipDoc.teamId", teamId)
                            .findFirst()
                    } else {
                        realm.where(RealmSubmission::class.java)
                            .equalTo("userId", userId)
                            .equalTo("parentId", examId)
                            .equalTo("status", "")
                            .isNull("membershipDoc")
                            .findFirst()
                    }

                    if (existingAdoption == null) {
                        realm.createObject(RealmSubmission::class.java, adoptionId).apply {
                            parentId = examId
                            parent = parentJsonString
                            this.userId = userId
                            user = userJsonString
                            type = "survey"
                            status = ""
                            uploaded = false
                            source = planetCode ?: ""
                            parentCode = sParentCode ?: ""
                            startTime = System.currentTimeMillis()
                            lastUpdateTime = System.currentTimeMillis()
                            isUpdated = true

                            if (isTeam && teamId != null) {
                                membershipDoc = realm.createObject(RealmMembershipDoc::class.java).apply {
                                    this.teamId = teamId
                                }
                            }
                        }
                    }
                }, {
                    mRealm.refresh()

                    adoptedSurveyIds.add("$examId")
                    val position = currentList.indexOfFirst { it.id == examId }
                    if (position != -1) {
                        notifyItemChanged(position)
                    }

                    Snackbar.make(binding.root, context.getString(R.string.survey_adopted_successfully), Snackbar.LENGTH_LONG).show()
                    surveyAdoptListener.onSurveyAdopted()
                }, { error ->
                    Snackbar.make(binding.root, context.getString(R.string.failed_to_adopt_survey), Snackbar.LENGTH_LONG).show()
                })
            } catch (e: Exception) {
                Snackbar.make(binding.root, context.getString(R.string.failed_to_adopt_survey), Snackbar.LENGTH_LONG).show()
            }
        }
    }
}

class SurveyDiffCallback : DiffUtil.ItemCallback<RealmStepExam>() {
    override fun areItemsTheSame(oldItem: RealmStepExam, newItem: RealmStepExam): Boolean {
        return oldItem.id == newItem.id
    }

    override fun areContentsTheSame(oldItem: RealmStepExam, newItem: RealmStepExam): Boolean {
        return oldItem == newItem
    }
}
=======
package org.ole.planet.myplanet.ui.survey


import android.content.Context
import android.content.SharedPreferences
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import io.realm.Realm
import java.util.UUID
import org.json.JSONObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.SurveyAdoptListener
import org.ole.planet.myplanet.databinding.RowSurveyBinding
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmMembershipDoc
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission

class AdapterSurvey(
    private val context: Context,
    private val mRealm: Realm,
    private val userId: String?,
    private val isTeam: Boolean,
    val teamId: String?,
    private val surveyAdoptListener: SurveyAdoptListener,
    private val settings: SharedPreferences,
    private val userProfileDbHandler: UserProfileDbHandler,
    private val surveyInfoMap: Map<String, SurveyInfo>
) : ListAdapter<RealmStepExam, AdapterSurvey.ViewHolderSurvey>(SurveyDiffCallback()) {
    private var listener: OnHomeItemClickListener? = null
    private val adoptedSurveyIds = mutableSetOf<String>()
    private var isTitleAscending = true
    private var sortStrategy: (List<RealmStepExam>) -> List<RealmStepExam> = { list ->
        sortSurveyList(false, list)
    }

    init {
        if (context is OnHomeItemClickListener) {
            listener = context
        }
    }

    fun updateData(newList: List<RealmStepExam>) {
        submitList(newList)
    }

    fun updateDataAfterSearch(newList: List<RealmStepExam>) {
        val sortedList = if (currentList.isEmpty()) {
            sortSurveyList(false, newList)
        } else {
            sortStrategy(newList)
        }
        submitList(sortedList)
    }

    private fun sortSurveyList(
        isAscend: Boolean,
        list: List<RealmStepExam>
    ): List<RealmStepExam> {
        return if (isAscend) {
            list.sortedBy { it.createdDate }
        } else {
            list.sortedByDescending { it.createdDate }
        }
    }

    fun sortByDate(isAscend: Boolean) {
        sortStrategy = { list -> sortSurveyList(isAscend, list) }
        val sortedList = sortStrategy(currentList)
        submitList(sortedList)
    }

    private fun sortSurveyListByName(
        isAscend: Boolean,
        list: List<RealmStepExam>
    ): List<RealmStepExam> {
        return if (isAscend) {
            list.sortedBy { it.name?.lowercase() }
        } else {
            list.sortedByDescending { it.name?.lowercase() }
        }
    }

    fun toggleTitleSortOrder() {
        isTitleAscending = !isTitleAscending
        sortStrategy = { list -> sortSurveyListByName(isTitleAscending, list) }
        val sortedList = sortStrategy(currentList)
        submitList(sortedList)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderSurvey {
        val binding = RowSurveyBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderSurvey(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderSurvey, position: Int) {
        holder.bind(getItem(position))
    }

    inner class ViewHolderSurvey(private val binding: RowSurveyBinding) : RecyclerView.ViewHolder(binding.root) {
        init {
            binding.startSurvey.visibility = View.VISIBLE
            binding.sendSurvey.visibility = View.GONE
            binding.sendSurvey.setOnClickListener {
                val current = getItem(bindingAdapterPosition)
                listener?.sendSurvey(current)
            }
        }

        fun bind(exam: RealmStepExam) {
            binding.apply {
                startSurvey.visibility = View.VISIBLE
                tvTitle.text = exam.name
                if (exam.description?.isNotEmpty() == true) {
                    tvDescription.visibility = View.VISIBLE
                    tvDescription.text = exam.description
                }

                fun getTeamSubmission(): RealmSubmission? {
                    return mRealm.where(RealmSubmission::class.java)
                        .equalTo("parentId", exam.id)
                        .equalTo("membershipDoc.teamId", teamId)
                        .findFirst()
                }

                var teamSubmission = getTeamSubmission()

                startSurvey.setOnClickListener {
                    teamSubmission = getTeamSubmission()

                    val shouldAdopt = exam.isTeamShareAllowed && teamSubmission?.isValid != true

                    if (shouldAdopt) {
                        adoptSurvey(exam, teamId)
                    } else {
                        AdapterMySubmission.openSurvey(listener, exam.id, false, isTeam, teamId)
                    }
                }

                val questions = mRealm.where(RealmExamQuestion::class.java).equalTo("examId", exam.id)
                    .findAll()

                if (questions.isEmpty()) {
                    sendSurvey.visibility = View.GONE
                    startSurvey.visibility = View.GONE
                }

                teamSubmission = getTeamSubmission()
                val shouldShowAdopt = exam.isTeamShareAllowed && teamSubmission?.isValid != true

                startSurvey.text = when {
                    shouldShowAdopt -> context.getString(R.string.adopt_survey)
                    exam.isFromNation -> context.getString(R.string.take_survey)
                    else -> context.getString(R.string.record_survey)
                }

                if (userId?.startsWith("guest") == true) {
                    startSurvey.visibility = View.GONE
                }

                val surveyInfo = surveyInfoMap[exam.id]
                tvNoSubmissions.text = surveyInfo?.submissionCount ?: ""
                tvDateCompleted.text = surveyInfo?.lastSubmissionDate ?: ""
                tvDate.text = surveyInfo?.creationDate ?: ""
            }
        }

        fun adoptSurvey(exam: RealmStepExam, teamId: String?) {
            val userModel = userProfileDbHandler.userModel
            val sParentCode = settings.getString("parentCode", "")
            val planetCode = settings.getString("planetCode", "")

            val parentJsonString = try {
                JSONObject().apply {
                    put("_id", exam.id)
                    put("name", exam.name)
                    put("courseId", exam.courseId ?: "")
                    put("sourcePlanet", exam.sourcePlanet ?: "")
                    put("teamShareAllowed", exam.isTeamShareAllowed)
                    put("noOfQuestions", exam.noOfQuestions)
                    put("isFromNation", exam.isFromNation)
                }.toString()
            } catch (e: Exception) {
                e.printStackTrace()
                "{}"
            }

            val userJsonString = try {
                JSONObject().apply {
                    put("doc", JSONObject().apply {
                        put("_id", userModel?.id)
                        put("name", userModel?.name)
                        put("userId", userModel?.id ?: "")
                        put("teamPlanetCode", planetCode ?: "")
                        put("status", "active")
                        put("type", "team")
                        put("createdBy", userModel?.id ?: "")
                    })

                    if (isTeam && teamId != null) {
                        put("membershipDoc", JSONObject().apply {
                            put("teamId", teamId)
                        })
                    }
                }.toString()
            } catch (e: Exception) {
                e.printStackTrace()
                "{}"
            }

            val adoptionId = "${UUID.randomUUID()}"
            val examId = exam.id
            val userId = userModel?.id

            if (mRealm.isClosed) {
                Snackbar.make(binding.root, context.getString(R.string.failed_to_adopt_survey), Snackbar.LENGTH_LONG).show()
                return
            }

            try {
                mRealm.executeTransactionAsync({ realm ->
                    val existingAdoption = if (isTeam && teamId != null) {
                        realm.where(RealmSubmission::class.java)
                            .equalTo("userId", userId)
                            .equalTo("parentId", examId)
                            .equalTo("status", "")
                            .equalTo("membershipDoc.teamId", teamId)
                            .findFirst()
                    } else {
                        realm.where(RealmSubmission::class.java)
                            .equalTo("userId", userId)
                            .equalTo("parentId", examId)
                            .equalTo("status", "")
                            .isNull("membershipDoc")
                            .findFirst()
                    }

                    if (existingAdoption == null) {
                        realm.createObject(RealmSubmission::class.java, adoptionId).apply {
                            parentId = examId
                            parent = parentJsonString
                            this.userId = userId
                            user = userJsonString
                            type = "survey"
                            status = ""
                            uploaded = false
                            source = planetCode ?: ""
                            parentCode = sParentCode ?: ""
                            startTime = System.currentTimeMillis()
                            lastUpdateTime = System.currentTimeMillis()
                            isUpdated = true

                            if (isTeam && teamId != null) {
                                membershipDoc = realm.createObject(RealmMembershipDoc::class.java).apply {
                                    this.teamId = teamId
                                }
                            }
                        }
                    }
                }, {
                    mRealm.refresh()

                    adoptedSurveyIds.add("$examId")
                    val position = currentList.indexOfFirst { it.id == examId }
                    if (position != -1) {
                        notifyItemChanged(position)
                    }

                    Snackbar.make(binding.root, context.getString(R.string.survey_adopted_successfully), Snackbar.LENGTH_LONG).show()
                    surveyAdoptListener.onSurveyAdopted()
                }, { error ->
                    Snackbar.make(binding.root, context.getString(R.string.failed_to_adopt_survey), Snackbar.LENGTH_LONG).show()
                })
            } catch (e: Exception) {
                Snackbar.make(binding.root, context.getString(R.string.failed_to_adopt_survey), Snackbar.LENGTH_LONG).show()
            }
        }
    }
}

class SurveyDiffCallback : DiffUtil.ItemCallback<RealmStepExam>() {
    override fun areItemsTheSame(oldItem: RealmStepExam, newItem: RealmStepExam): Boolean {
        return oldItem.id == newItem.id
    }

    override fun areContentsTheSame(oldItem: RealmStepExam, newItem: RealmStepExam): Boolean {
        return oldItem == newItem
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/myhealth/MyHealthFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.myhealth

import android.app.DatePickerDialog
import android.content.Context.MODE_PRIVATE
import android.content.Intent
import android.content.SharedPreferences
import android.os.Bundle
import android.os.CountDownTimer
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.AdapterView.OnItemClickListener
import android.widget.AdapterView.OnItemSelectedListener
import android.widget.Button
import android.widget.EditText
import android.widget.ListView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.widget.AppCompatSpinner
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Case
import io.realm.Realm
import io.realm.Sort
import java.util.Calendar
import java.util.Locale
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.databinding.AlertHealthListBinding
import org.ole.planet.myplanet.databinding.AlertMyPersonalBinding
import org.ole.planet.myplanet.databinding.FragmentVitalSignBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyHealth
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator
import org.ole.planet.myplanet.ui.userprofile.BecomeMemberActivity
import org.ole.planet.myplanet.utilities.AndroidDecrypter
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDate
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class MyHealthFragment : Fragment() {

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    @Inject
    lateinit var syncManager: SyncManager
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var userRepository: UserRepository
    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()
    private lateinit var realtimeSyncListener: BaseRealtimeSyncListener
    private var _binding: FragmentVitalSignBinding? = null
    private val binding get() = _binding!!
    private lateinit var alertMyPersonalBinding: AlertMyPersonalBinding
    private lateinit var alertHealthListBinding: AlertHealthListBinding
    var userId: String? = null
    lateinit var mRealm: Realm
    var userModel: RealmUserModel? = null
    lateinit var userModelList: List<RealmUserModel>
    lateinit var adapter: UserListArrayAdapter
    var dialog: AlertDialog? = null
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    lateinit var prefManager: SharedPrefManager
    lateinit var settings: SharedPreferences
    private val serverUrlMapper = ServerUrlMapper()
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""
    private var textWatcher: TextWatcher? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        prefManager = SharedPrefManager(requireContext())
        settings = requireContext().getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        startHealthSync()
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentVitalSignBinding.inflate(inflater, container, false)
        mRealm = databaseService.realmInstance
        return binding.root
    }

    private fun startHealthSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isHealthSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(getString(R.string.syncing_health_data))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        refreshHealthData()
                        prefManager.setHealthSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG).setAction("Retry") { startHealthSync() }.show()
                    }
                }
            }
        }, "full", listOf("health"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun refreshHealthData() {
        if (!isAdded || requireActivity().isFinishing) return

        try {
            val currentUser = getCurrentUserProfileCopy()
            userId = if (TextUtils.isEmpty(currentUser?._id)) {
                currentUser?.id
            } else {
                currentUser?._id
            }
            getHealthRecords(userId)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        view.setBackgroundColor(ContextCompat.getColor(requireContext(), R.color.secondary_bg))
        setupRealtimeSync()
        alertMyPersonalBinding = AlertMyPersonalBinding.inflate(LayoutInflater.from(context))
        binding.txtDob.hint = "yyyy-MM-dd'"

        val allowDateEdit = false
        if(allowDateEdit) {
            binding.txtDob.setOnClickListener {
                val now = Calendar.getInstance()
                val dpd = DatePickerDialog(requireContext(), { _, year, month, dayOfMonth ->
                    val selectedDate =
                        String.format(Locale.US, "%04d-%02d-%02d", year, month + 1, dayOfMonth)
                    binding.txtDob.text = selectedDate
                }, now.get(Calendar.YEAR), now.get(Calendar.MONTH), now.get(Calendar.DAY_OF_MONTH))
                dpd.show()
            }
        } else {
            disableDobField()
        }

        binding.rvRecords.addItemDecoration(DividerItemDecoration(activity, DividerItemDecoration.VERTICAL))

        setupInitialData()
        setupButtons()
    }

    private fun setupInitialData() {
        val currentUser = getCurrentUserProfileCopy()
        userId = if (TextUtils.isEmpty(currentUser?._id)) currentUser?.id else currentUser?._id
        getHealthRecords(userId)
    }

    private fun getCurrentUserProfileCopy(): RealmUserModel? {
        return userProfileDbHandler.getUserModelCopy()
    }

    private fun setupButtons() {
        val isHealthProvider = userModel?.rolesList?.contains("health") ?: false
        binding.btnnewPatient.visibility =
            if (isHealthProvider) View.VISIBLE else View.GONE

        binding.btnnewPatient.setOnClickListener {
            if (isHealthProvider) {
                selectPatient()
            }
        }
        binding.updateHealth.visibility = View.VISIBLE

        binding.updateHealth.setOnClickListener {
            startActivity(Intent(activity, AddMyHealthActivity::class.java).putExtra("userId", userId))
        }

        binding.txtDob.text = if (TextUtils.isEmpty(userModel?.dob)) getString(R.string.birth_date) else getFormattedDate(userModel?.dob, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
    }

    private fun setupRealtimeSync() {
        realtimeSyncListener = object : BaseRealtimeSyncListener() {
            override fun onTableDataUpdated(update: TableDataUpdate) {
                if (update.table == "health" && update.shouldRefreshUI) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        refreshHealthData()
                    }
                }
            }
        }
        syncCoordinator.addListener(realtimeSyncListener)
    }

    private fun getHealthRecords(memberId: String?) {
        viewLifecycleOwner.lifecycleScope.launch {
            val normalizedId = memberId?.trim()
            userId = normalizedId
            val fetchedUser = if (normalizedId.isNullOrEmpty()) {
                null
            } else {
                withContext(Dispatchers.IO) {
                    userRepository.getUserByAnyId(normalizedId)
                }
            }
            if (!isAdded || _binding == null) {
                return@launch
            }
            userModel = fetchedUser
            binding.lblHealthName.text = userModel?.getFullName() ?: getString(R.string.empty_text)
            binding.addNewRecord.setOnClickListener {
                startActivity(Intent(activity, AddExaminationActivity::class.java).putExtra("userId", userId))
            }
            binding.updateHealth.setOnClickListener {
                startActivity(Intent(activity, AddMyHealthActivity::class.java).putExtra("userId", userId))
            }
            showRecords()
        }
    }

    private fun selectPatient() {
        userModelList = mRealm.where(RealmUserModel::class.java).sort("joinDate", Sort.DESCENDING).findAll()
        adapter = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, userModelList)
        alertHealthListBinding = AlertHealthListBinding.inflate(LayoutInflater.from(context))
        alertHealthListBinding.btnAddMember.setOnClickListener {
            startActivity(Intent(requireContext(), BecomeMemberActivity::class.java))
        }

        setTextWatcher(alertHealthListBinding.etSearch, alertHealthListBinding.btnAddMember, alertHealthListBinding.list)
        alertHealthListBinding.list.adapter = adapter
        alertHealthListBinding.list.onItemClickListener = OnItemClickListener { _: AdapterView<*>?, _: View, i: Int, _: Long ->
            val selected = alertHealthListBinding.list.adapter.getItem(i) as RealmUserModel
            userId = if (selected._id.isNullOrEmpty()) selected.id else selected._id
            getHealthRecords(userId)
            dialog?.dismiss()
        }
        sortList(alertHealthListBinding.spnSort, alertHealthListBinding.list)
        dialog = AlertDialog.Builder(requireActivity(),R.style.AlertDialogTheme)
            .setTitle(getString(R.string.select_health_member)).setView(alertHealthListBinding.root)
            .setCancelable(false).setNegativeButton(R.string.dismiss, null).create()
        dialog?.show()
    }

    private fun sortList(spnSort: AppCompatSpinner, lv: ListView) {
        spnSort.onItemSelectedListener = object : OnItemSelectedListener {
            override fun onNothingSelected(p0: AdapterView<*>?) {}

            override fun onItemSelected(p0: AdapterView<*>?, p1: View?, p2: Int, p3: Long) {
                val sort: Sort
                val sortBy: String
                when (p2) {
                    0 -> {
                        sortBy = "joinDate"
                        sort = Sort.DESCENDING
                    }
                    1 -> {
                        sortBy = "joinDate"
                        sort = Sort.ASCENDING
                    }
                    2 -> {
                        sortBy = "name"
                        sort = Sort.ASCENDING
                    }
                    else -> {
                        sortBy = "name"
                        sort = Sort.DESCENDING
                    }
                }
                userModelList = mRealm.where(RealmUserModel::class.java).sort(sortBy, sort).findAll()
                adapter = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, userModelList)
                lv.adapter = adapter
            }
        }
    }

    private fun setTextWatcher(etSearch: EditText, btnAddMember: Button, lv: ListView) {
        var timer: CountDownTimer? = null
        textWatcher = object : TextWatcher {
            override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
            override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}

            override fun afterTextChanged(editable: Editable) {
                timer?.cancel()
                timer = object : CountDownTimer(1000, 1500) {
                    override fun onTick(millisUntilFinished: Long) {}
                    override fun onFinish() {
                        val userModelList = mRealm.where(RealmUserModel::class.java)
                            .contains("firstName", editable.toString(), Case.INSENSITIVE).or()
                            .contains("lastName", editable.toString(), Case.INSENSITIVE).or()
                            .contains("name", editable.toString(), Case.INSENSITIVE)
                            .sort("joinDate", Sort.DESCENDING).findAll()

                        val adapter = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, userModelList)
                        lv.adapter = adapter
                        btnAddMember.visibility = if (adapter.count == 0) View.VISIBLE else View.GONE
                    }
                }.start()
            }
        }
        etSearch.addTextChangedListener(textWatcher)
    }

    override fun onResume() {
        super.onResume()
        showRecords()
    }

    private fun showRecords() {
        val currentUser = userModel
        if (currentUser == null) {
            binding.layoutUserDetail.visibility = View.GONE
            binding.tvMessage.visibility = View.VISIBLE
            binding.tvMessage.text = getString(R.string.health_record_not_available)
            binding.txtOtherNeed.text = getString(R.string.empty_text)
            binding.txtSpecialNeeds.text = getString(R.string.empty_text)
            binding.txtBirthPlace.text = getString(R.string.empty_text)
            binding.txtEmergencyContact.text = getString(R.string.empty_text)
            binding.rvRecords.adapter = null
            binding.rvRecords.visibility = View.GONE
            binding.tvNoRecords.visibility = View.VISIBLE
            binding.tvDataPlaceholder.visibility = View.GONE
            return
        }

        binding.layoutUserDetail.visibility = View.VISIBLE
        binding.tvMessage.visibility = View.GONE
        binding.txtFullName.text = getString(R.string.three_strings, currentUser.firstName, currentUser.middleName, currentUser.lastName)
        binding.txtEmail.text = Utilities.checkNA(currentUser.email)
        binding.txtLanguage.text = Utilities.checkNA(currentUser.language)
        binding.txtDob.text = Utilities.checkNA(currentUser.dob)
        var mh = mRealm.where(RealmMyHealthPojo::class.java).equalTo("_id", userId).findFirst()
        if (mh == null) {
            mh = mRealm.where(RealmMyHealthPojo::class.java).equalTo("userId", userId).findFirst()
        }
        if (mh != null) {
            val mm = getHealthProfile(mh)
            if (mm == null) {
                binding.rvRecords.adapter = null
                binding.tvNoRecords.visibility = View.VISIBLE
                binding.tvDataPlaceholder.visibility = View.GONE
                Utilities.toast(activity, getString(R.string.health_record_not_available))
                return
            }
            val myHealths = mm.profile
            binding.txtOtherNeed.text = Utilities.checkNA(myHealths?.notes)
            binding.txtSpecialNeeds.text = Utilities.checkNA(myHealths?.specialNeeds)
            binding.txtBirthPlace.text = Utilities.checkNA(currentUser.birthPlace)
            val contact = myHealths?.emergencyContact?.takeIf { it.isNotBlank() }
            binding.txtEmergencyContact.text = getString(
                R.string.emergency_contact_details,
                Utilities.checkNA(myHealths?.emergencyContactName),
                Utilities.checkNA(myHealths?.emergencyContactType),
                Utilities.checkNA(contact)
            ).trimIndent()

            val list = getExaminations(mm)

            if (list != null && list.isNotEmpty()) {
                binding.rvRecords.visibility = View.VISIBLE
                binding.tvNoRecords.visibility = View.GONE
                binding.tvDataPlaceholder.visibility = View.VISIBLE

                val adap = AdapterHealthExamination(requireActivity(), list, mh, currentUser)
                adap.setmRealm(mRealm)
                binding.rvRecords.apply {
                    layoutManager = LinearLayoutManager(activity, LinearLayoutManager.HORIZONTAL, false)
                    isNestedScrollingEnabled = false
                    adapter = adap
                }
                binding.rvRecords.post {
                    val lastPosition = list.size - 1
                    if (lastPosition >= 0) {
                        binding.rvRecords.scrollToPosition(lastPosition)
                    }
                }
            } else {
                binding.rvRecords.visibility = View.GONE
                binding.tvNoRecords.visibility = View.GONE
                binding.tvDataPlaceholder.visibility = View.VISIBLE
            }
        } else {
            binding.txtOtherNeed.text = getString(R.string.empty_text)
            binding.txtSpecialNeeds.text = getString(R.string.empty_text)
            binding.txtBirthPlace.text = getString(R.string.empty_text)
            binding.txtEmergencyContact.text = getString(R.string.empty_text)
            binding.rvRecords.adapter = null
            binding.rvRecords.visibility = View.GONE
            binding.tvNoRecords.visibility = View.VISIBLE
            binding.tvDataPlaceholder.visibility = View.GONE
        }
    }

    private fun getExaminations(mm: RealmMyHealth): List<RealmMyHealthPojo>? {
        val healths = mRealm.where(RealmMyHealthPojo::class.java)?.equalTo("profileId", mm.userKey)?.findAll()
        return healths
    }

    private fun getHealthProfile(mh: RealmMyHealthPojo): RealmMyHealth? {
        val json = AndroidDecrypter.decrypt(mh.data, userModel?.key, userModel?.iv)
        return if (TextUtils.isEmpty(json)) {
            null
        } else {
            try {
                Gson().fromJson(json, RealmMyHealth::class.java)
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }
    }

    private fun disableDobField() {
        binding.txtDob.isClickable = false
        binding.txtDob.isFocusable = false
        binding.txtDob.setOnClickListener(null)
    }

    override fun onDestroyView() {
        if (::realtimeSyncListener.isInitialized) {
            syncCoordinator.removeListener(realtimeSyncListener)
        }
        alertHealthListBinding.etSearch.removeTextChangedListener(textWatcher)
        textWatcher = null
        _binding = null
        super.onDestroyView()
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        if (this::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        super.onDestroy()
    }
}
=======
package org.ole.planet.myplanet.ui.myhealth


import android.app.DatePickerDialog
import android.content.Context.MODE_PRIVATE
import android.content.Intent
import android.content.SharedPreferences
import android.os.Bundle
import android.os.CountDownTimer
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.AdapterView.OnItemClickListener
import android.widget.AdapterView.OnItemSelectedListener
import android.widget.Button
import android.widget.EditText
import android.widget.ListView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.widget.AppCompatSpinner
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Case
import io.realm.Realm
import io.realm.Sort
import java.util.Calendar
import java.util.Locale
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.databinding.AlertHealthListBinding
import org.ole.planet.myplanet.databinding.AlertMyPersonalBinding
import org.ole.planet.myplanet.databinding.FragmentVitalSignBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyHealth
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator
import org.ole.planet.myplanet.ui.userprofile.BecomeMemberActivity
import org.ole.planet.myplanet.utilities.AndroidDecrypter
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDate
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class MyHealthFragment : Fragment() {

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    @Inject
    lateinit var syncManager: SyncManager
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var userRepository: UserRepository
    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()
    private lateinit var realtimeSyncListener: BaseRealtimeSyncListener
    private var _binding: FragmentVitalSignBinding? = null
    private val binding get() = _binding!!
    private lateinit var alertMyPersonalBinding: AlertMyPersonalBinding
    private lateinit var alertHealthListBinding: AlertHealthListBinding
    var userId: String? = null
    lateinit var mRealm: Realm
    var userModel: RealmUserModel? = null
    lateinit var userModelList: List<RealmUserModel>
    lateinit var adapter: UserListArrayAdapter
    var dialog: AlertDialog? = null
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    lateinit var prefManager: SharedPrefManager
    lateinit var settings: SharedPreferences
    private val serverUrlMapper = ServerUrlMapper()
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""
    private var textWatcher: TextWatcher? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        prefManager = SharedPrefManager(requireContext())
        settings = requireContext().getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        startHealthSync()
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentVitalSignBinding.inflate(inflater, container, false)
        mRealm = databaseService.realmInstance
        return binding.root
    }

    private fun startHealthSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isHealthSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(getString(R.string.syncing_health_data))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        refreshHealthData()
                        prefManager.setHealthSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG).setAction("Retry") { startHealthSync() }.show()
                    }
                }
            }
        }, "full", listOf("health"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun refreshHealthData() {
        if (!isAdded || requireActivity().isFinishing) return

        try {
            val currentUser = getCurrentUserProfileCopy()
            userId = if (TextUtils.isEmpty(currentUser?._id)) {
                currentUser?.id
            } else {
                currentUser?._id
            }
            getHealthRecords(userId)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        view.setBackgroundColor(ContextCompat.getColor(requireContext(), R.color.secondary_bg))
        setupRealtimeSync()
        alertMyPersonalBinding = AlertMyPersonalBinding.inflate(LayoutInflater.from(context))
        binding.txtDob.hint = "yyyy-MM-dd'"

        val allowDateEdit = false
        if(allowDateEdit) {
            binding.txtDob.setOnClickListener {
                val now = Calendar.getInstance()
                val dpd = DatePickerDialog(requireContext(), { _, year, month, dayOfMonth ->
                    val selectedDate =
                        String.format(Locale.US, "%04d-%02d-%02d", year, month + 1, dayOfMonth)
                    binding.txtDob.text = selectedDate
                }, now.get(Calendar.YEAR), now.get(Calendar.MONTH), now.get(Calendar.DAY_OF_MONTH))
                dpd.show()
            }
        } else {
            disableDobField()
        }

        binding.rvRecords.addItemDecoration(DividerItemDecoration(activity, DividerItemDecoration.VERTICAL))

        setupInitialData()
        setupButtons()
    }

    private fun setupInitialData() {
        val currentUser = getCurrentUserProfileCopy()
        userId = if (TextUtils.isEmpty(currentUser?._id)) currentUser?.id else currentUser?._id
        getHealthRecords(userId)
    }

    private fun getCurrentUserProfileCopy(): RealmUserModel? {
        return userProfileDbHandler.getUserModelCopy()
    }

    private fun setupButtons() {
        val isHealthProvider = userModel?.rolesList?.contains("health") ?: false
        binding.btnnewPatient.visibility =
            if (isHealthProvider) View.VISIBLE else View.GONE

        binding.btnnewPatient.setOnClickListener {
            if (isHealthProvider) {
                selectPatient()
            }
        }
        binding.updateHealth.visibility = View.VISIBLE

        binding.updateHealth.setOnClickListener {
            startActivity(Intent(activity, AddMyHealthActivity::class.java).putExtra("userId", userId))
        }

        binding.txtDob.text = if (TextUtils.isEmpty(userModel?.dob)) getString(R.string.birth_date) else getFormattedDate(userModel?.dob, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
    }

    private fun setupRealtimeSync() {
        realtimeSyncListener = object : BaseRealtimeSyncListener() {
            override fun onTableDataUpdated(update: TableDataUpdate) {
                if (update.table == "health" && update.shouldRefreshUI) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        refreshHealthData()
                    }
                }
            }
        }
        syncCoordinator.addListener(realtimeSyncListener)
    }

    private fun getHealthRecords(memberId: String?) {
        viewLifecycleOwner.lifecycleScope.launch {
            val normalizedId = memberId?.trim()
            userId = normalizedId
            val fetchedUser = if (normalizedId.isNullOrEmpty()) {
                null
            } else {
                withContext(Dispatchers.IO) {
                    userRepository.getUserByAnyId(normalizedId)
                }
            }
            if (!isAdded || _binding == null) {
                return@launch
            }
            userModel = fetchedUser
            binding.lblHealthName.text = userModel?.getFullName() ?: getString(R.string.empty_text)
            binding.addNewRecord.setOnClickListener {
                startActivity(Intent(activity, AddExaminationActivity::class.java).putExtra("userId", userId))
            }
            binding.updateHealth.setOnClickListener {
                startActivity(Intent(activity, AddMyHealthActivity::class.java).putExtra("userId", userId))
            }
            showRecords()
        }
    }

    private fun selectPatient() {
        userModelList = mRealm.where(RealmUserModel::class.java).sort("joinDate", Sort.DESCENDING).findAll()
        adapter = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, userModelList)
        alertHealthListBinding = AlertHealthListBinding.inflate(LayoutInflater.from(context))
        alertHealthListBinding.btnAddMember.setOnClickListener {
            startActivity(Intent(requireContext(), BecomeMemberActivity::class.java))
        }

        setTextWatcher(alertHealthListBinding.etSearch, alertHealthListBinding.btnAddMember, alertHealthListBinding.list)
        alertHealthListBinding.list.adapter = adapter
        alertHealthListBinding.list.onItemClickListener = OnItemClickListener { _: AdapterView<*>?, _: View, i: Int, _: Long ->
            val selected = alertHealthListBinding.list.adapter.getItem(i) as RealmUserModel
            userId = if (selected._id.isNullOrEmpty()) selected.id else selected._id
            getHealthRecords(userId)
            dialog?.dismiss()
        }
        sortList(alertHealthListBinding.spnSort, alertHealthListBinding.list)
        dialog = AlertDialog.Builder(requireActivity(),R.style.AlertDialogTheme)
            .setTitle(getString(R.string.select_health_member)).setView(alertHealthListBinding.root)
            .setCancelable(false).setNegativeButton(R.string.dismiss, null).create()
        dialog?.show()
    }

    private fun sortList(spnSort: AppCompatSpinner, lv: ListView) {
        spnSort.onItemSelectedListener = object : OnItemSelectedListener {
            override fun onNothingSelected(p0: AdapterView<*>?) {}

            override fun onItemSelected(p0: AdapterView<*>?, p1: View?, p2: Int, p3: Long) {
                val sort: Sort
                val sortBy: String
                when (p2) {
                    0 -> {
                        sortBy = "joinDate"
                        sort = Sort.DESCENDING
                    }
                    1 -> {
                        sortBy = "joinDate"
                        sort = Sort.ASCENDING
                    }
                    2 -> {
                        sortBy = "name"
                        sort = Sort.ASCENDING
                    }
                    else -> {
                        sortBy = "name"
                        sort = Sort.DESCENDING
                    }
                }
                userModelList = mRealm.where(RealmUserModel::class.java).sort(sortBy, sort).findAll()
                adapter = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, userModelList)
                lv.adapter = adapter
            }
        }
    }

    private fun setTextWatcher(etSearch: EditText, btnAddMember: Button, lv: ListView) {
        var timer: CountDownTimer? = null
        textWatcher = object : TextWatcher {
            override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
            override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}

            override fun afterTextChanged(editable: Editable) {
                timer?.cancel()
                timer = object : CountDownTimer(1000, 1500) {
                    override fun onTick(millisUntilFinished: Long) {}
                    override fun onFinish() {
                        val userModelList = mRealm.where(RealmUserModel::class.java)
                            .contains("firstName", editable.toString(), Case.INSENSITIVE).or()
                            .contains("lastName", editable.toString(), Case.INSENSITIVE).or()
                            .contains("name", editable.toString(), Case.INSENSITIVE)
                            .sort("joinDate", Sort.DESCENDING).findAll()

                        val adapter = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, userModelList)
                        lv.adapter = adapter
                        btnAddMember.visibility = if (adapter.count == 0) View.VISIBLE else View.GONE
                    }
                }.start()
            }
        }
        etSearch.addTextChangedListener(textWatcher)
    }

    override fun onResume() {
        super.onResume()
        showRecords()
    }

    private fun showRecords() {
        val currentUser = userModel
        if (currentUser == null) {
            binding.layoutUserDetail.visibility = View.GONE
            binding.tvMessage.visibility = View.VISIBLE
            binding.tvMessage.text = getString(R.string.health_record_not_available)
            binding.txtOtherNeed.text = getString(R.string.empty_text)
            binding.txtSpecialNeeds.text = getString(R.string.empty_text)
            binding.txtBirthPlace.text = getString(R.string.empty_text)
            binding.txtEmergencyContact.text = getString(R.string.empty_text)
            binding.rvRecords.adapter = null
            binding.rvRecords.visibility = View.GONE
            binding.tvNoRecords.visibility = View.VISIBLE
            binding.tvDataPlaceholder.visibility = View.GONE
            return
        }

        binding.layoutUserDetail.visibility = View.VISIBLE
        binding.tvMessage.visibility = View.GONE
        binding.txtFullName.text = getString(R.string.three_strings, currentUser.firstName, currentUser.middleName, currentUser.lastName)
        binding.txtEmail.text = Utilities.checkNA(currentUser.email)
        binding.txtLanguage.text = Utilities.checkNA(currentUser.language)
        binding.txtDob.text = Utilities.checkNA(currentUser.dob)
        var mh = mRealm.where(RealmMyHealthPojo::class.java).equalTo("_id", userId).findFirst()
        if (mh == null) {
            mh = mRealm.where(RealmMyHealthPojo::class.java).equalTo("userId", userId).findFirst()
        }
        if (mh != null) {
            val mm = getHealthProfile(mh)
            if (mm == null) {
                binding.rvRecords.adapter = null
                binding.tvNoRecords.visibility = View.VISIBLE
                binding.tvDataPlaceholder.visibility = View.GONE
                Utilities.toast(activity, getString(R.string.health_record_not_available))
                return
            }
            val myHealths = mm.profile
            binding.txtOtherNeed.text = Utilities.checkNA(myHealths?.notes)
            binding.txtSpecialNeeds.text = Utilities.checkNA(myHealths?.specialNeeds)
            binding.txtBirthPlace.text = Utilities.checkNA(currentUser.birthPlace)
            val contact = myHealths?.emergencyContact?.takeIf { it.isNotBlank() }
            binding.txtEmergencyContact.text = getString(
                R.string.emergency_contact_details,
                Utilities.checkNA(myHealths?.emergencyContactName),
                Utilities.checkNA(myHealths?.emergencyContactType),
                Utilities.checkNA(contact)
            ).trimIndent()

            val list = getExaminations(mm)

            if (list != null && list.isNotEmpty()) {
                binding.rvRecords.visibility = View.VISIBLE
                binding.tvNoRecords.visibility = View.GONE
                binding.tvDataPlaceholder.visibility = View.VISIBLE

                val adap = AdapterHealthExamination(requireActivity(), list, mh, currentUser)
                adap.setmRealm(mRealm)
                binding.rvRecords.apply {
                    layoutManager = LinearLayoutManager(activity, LinearLayoutManager.HORIZONTAL, false)
                    isNestedScrollingEnabled = false
                    adapter = adap
                }
                binding.rvRecords.post {
                    val lastPosition = list.size - 1
                    if (lastPosition >= 0) {
                        binding.rvRecords.scrollToPosition(lastPosition)
                    }
                }
            } else {
                binding.rvRecords.visibility = View.GONE
                binding.tvNoRecords.visibility = View.GONE
                binding.tvDataPlaceholder.visibility = View.VISIBLE
            }
        } else {
            binding.txtOtherNeed.text = getString(R.string.empty_text)
            binding.txtSpecialNeeds.text = getString(R.string.empty_text)
            binding.txtBirthPlace.text = getString(R.string.empty_text)
            binding.txtEmergencyContact.text = getString(R.string.empty_text)
            binding.rvRecords.adapter = null
            binding.rvRecords.visibility = View.GONE
            binding.tvNoRecords.visibility = View.VISIBLE
            binding.tvDataPlaceholder.visibility = View.GONE
        }
    }

    private fun getExaminations(mm: RealmMyHealth): List<RealmMyHealthPojo>? {
        val healths = mRealm.where(RealmMyHealthPojo::class.java)?.equalTo("profileId", mm.userKey)?.findAll()
        return healths
    }

    private fun getHealthProfile(mh: RealmMyHealthPojo): RealmMyHealth? {
        val json = AndroidDecrypter.decrypt(mh.data, userModel?.key, userModel?.iv)
        return if (TextUtils.isEmpty(json)) {
            null
        } else {
            try {
                Gson().fromJson(json, RealmMyHealth::class.java)
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }
    }

    private fun disableDobField() {
        binding.txtDob.isClickable = false
        binding.txtDob.isFocusable = false
        binding.txtDob.setOnClickListener(null)
    }

    override fun onDestroyView() {
        if (::realtimeSyncListener.isInitialized) {
            syncCoordinator.removeListener(realtimeSyncListener)
        }
        alertHealthListBinding.etSearch.removeTextChangedListener(textWatcher)
        textWatcher = null
        _binding = null
        super.onDestroyView()
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        if (this::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        super.onDestroy()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/myhealth/AddExaminationActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.myhealth

import android.content.DialogInterface
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.MenuItem
import android.view.View
import android.widget.CheckBox
import android.widget.CompoundButton
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import fisk.chipcloud.ChipCloud
import fisk.chipcloud.ChipCloudConfig
import io.realm.Realm
import java.util.Date
import java.util.Locale
import javax.inject.Inject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityAddExaminationBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyHealth
import org.ole.planet.myplanet.model.RealmMyHealth.RealmMyHealthProfile
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.myhealth.RealmExamination
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.decrypt
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.encrypt
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateIv
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateKey
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.DimenUtils.dpToPx
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.JsonUtils.getBoolean
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.TimeUtils.getAge
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class AddExaminationActivity : AppCompatActivity(), CompoundButton.OnCheckedChangeListener {
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private lateinit var binding: ActivityAddExaminationBinding
    lateinit var mRealm: Realm
    var userId: String? = null
    var user: RealmUserModel? = null
    private var currentUser: RealmUserModel? = null
    private var pojo: RealmMyHealthPojo? = null
    var health: RealmMyHealth? = null
    private var customDiag: MutableSet<String?>? = null
    private var mapConditions: HashMap<String?, Boolean>? = null
    var allowSubmission = true
    private lateinit var config: ChipCloudConfig
    private var examination: RealmMyHealthPojo? = null
    private var textWatcher: TextWatcher? = null
    private val gson = Gson()
    private fun initViews() {
        config = Utilities.getCloudConfig().selectMode(ChipCloud.SelectMode.close)
        binding.btnAddDiag.setOnClickListener {
            customDiag?.add("${binding.etOtherDiag.text}")
            binding.etOtherDiag.setText(R.string.empty_text)
            showOtherDiagnosis()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityAddExaminationBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, binding.root)
        supportActionBar?.setHomeButtonEnabled(true)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        customDiag = HashSet()
        initViews()
        currentUser = userProfileDbHandler.userModel
        mapConditions = HashMap()
        mRealm = databaseService.realmInstance
        userId = intent.getStringExtra("userId")
        pojo = mRealm.where(RealmMyHealthPojo::class.java).equalTo("_id", userId).findFirst()
        if (pojo == null) {
            pojo = mRealm.where(RealmMyHealthPojo::class.java).equalTo("userId", userId).findFirst()
        }
        user = mRealm.where(RealmUserModel::class.java).equalTo("id", userId).findFirst()
        if (user != null && (user?.key == null || user?.iv == null)) {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            user?.key = generateKey()
            user?.iv = generateIv()
            mRealm.commitTransaction()
        }
        if (pojo != null && !TextUtils.isEmpty(pojo?.data)) {
            health = gson.fromJson(decrypt(pojo?.data, user?.key, user?.iv), RealmMyHealth::class.java)
        }
        if (health == null) {
            initHealth()
        }
        initExamination()
        validateFields()
        findViewById<View>(R.id.btn_save).setOnClickListener {
            if(!allowSubmission){
                scrollToView(binding.etBloodpressure)
            }
            if (!isValidInput || !allowSubmission) {
                return@setOnClickListener
            }
            saveData()
        }
    }

    private fun initExamination() {
        if (intent.hasExtra("id")) {
            examination = mRealm.where(RealmMyHealthPojo::class.java).equalTo("_id", intent.getStringExtra("id")).findFirst()!!
            binding.etTemperature.setText(getString(R.string.float_placeholder, examination?.temperature))
            binding.etPulseRate.setText(getString(R.string.number_placeholder, examination?.pulse))
            binding.etBloodpressure.setText(getString(R.string.message_placeholder, examination?.bp))
            binding.etHeight.setText(getString(R.string.float_placeholder, examination?.height))
            binding.etWeight.setText(getString(R.string.float_placeholder, examination?.weight))
            binding.etVision.setText(examination?.vision)
            binding.etHearing.setText(examination?.hearing)
            val encrypted = user?.let { examination?.getEncryptedDataAsJson(it) }
            binding.etObservation.setText(getString(getString(R.string.note_), encrypted))
            binding.etDiag.setText(getString(getString(R.string.diagnosis), encrypted))
            binding.etTreatments.setText(getString(getString(R.string.treatments), encrypted))
            binding.etMedications.setText(getString(getString(R.string.medications), encrypted))
            binding.etImmunization.setText(getString(getString(R.string.immunizations), encrypted))
            binding.etAllergies.setText(getString(getString(R.string.allergies), encrypted))
            binding.etXray.setText(getString(getString(R.string.xrays), encrypted))
            binding.etLabtest.setText(getString(getString(R.string.tests), encrypted))
            binding.etReferrals.setText(getString(getString(R.string.referrals), encrypted))
        }
        showCheckbox(examination)
        showOtherDiagnosis()
    }

    private fun validateFields() {
        allowSubmission = true
        textWatcher = object : TextWatcher {
            override fun afterTextChanged(s: Editable) {}
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                if (!"${binding.etBloodpressure.text}".contains("/")) {
                    binding.etBloodpressure.error = getString(R.string.blood_pressure_should_be_numeric_systolic_diastolic)
                    allowSubmission = false
                } else {
                    val sysDia = "${binding.etBloodpressure.text}"
                        .trim { it <= ' ' }
                        .split("/".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
                    if (sysDia.size > 2 || sysDia.isEmpty()) {
                        binding.etBloodpressure.error = getString(R.string.blood_pressure_should_be_systolic_diastolic)
                        allowSubmission = false
                    } else {
                        try {
                            val sys = sysDia[0].toInt()
                            val dis = sysDia[1].toInt()
                            if (sys < 60 || dis < 40 || sys > 300 || dis > 200) {
                                binding.etBloodpressure.error = getString(R.string.bp_must_be_between_60_40_and_300_200)
                                allowSubmission = false
                            } else {
                                allowSubmission = true
                            }
                        } catch (e: Exception) {
                            binding.etBloodpressure.error = getString(R.string.systolic_and_diastolic_must_be_numbers)
                            allowSubmission = false
                        }
                    }
                }
            }
        }
        binding.etBloodpressure.addTextChangedListener(textWatcher)
    }

    private fun showOtherDiagnosis() {
        binding.containerOtherDiagnosis.removeAllViews()
        val chipCloud = ChipCloud(this, binding.containerOtherDiagnosis, config)
        for (s in customDiag?: emptySet()) {
            if (s.isNullOrBlank()) {
                    continue
            } else {
                    chipCloud.addChip(s)
            }
        }
        chipCloud.setDeleteListener { _: Int, s1: String? -> customDiag?.remove(s1) }
        preloadCustomDiagnosis(chipCloud)
    }

    private fun preloadCustomDiagnosis(chipCloud: ChipCloud) {
        val arr = resources.getStringArray(R.array.diagnosis_list)
        val mainList = listOf(*arr)
        if (customDiag?.isEmpty() == true && examination != null) {
            val conditions = gson.fromJson(examination?.conditions, JsonObject::class.java)
            for (s in conditions.keySet()) {
                if (!mainList.contains(s) && getBoolean(s, conditions)) {
                    chipCloud.addChip(s)
                    chipCloud.setDeleteListener { _: Int, s1: String? ->
                        customDiag?.remove(Constants.LABELS[s1])
                    }
                    customDiag?.add(s)
                }
            }
        }
    }

    private fun showCheckbox(examination: RealmMyHealthPojo?) {
        val arr = resources.getStringArray(R.array.diagnosis_list)
        binding.containerCheckbox.removeAllViews()
        for (s in arr) {
            val c = CheckBox(this)
            c.buttonTintList = ContextCompat.getColorStateList(this, R.color.daynight_textColor)
            c.setTextColor(ContextCompat.getColor(this, R.color.daynight_textColor))

            if (examination != null) {
                val conditions = gson.fromJson(examination.conditions, JsonObject::class.java)
                c.isChecked = getBoolean(s, conditions)
            }
            c.setPadding(dpToPx(8), dpToPx(8), dpToPx(8), dpToPx(8))
            c.text = s
            c.tag = s
            c.setOnCheckedChangeListener(this)
            binding.containerCheckbox.addView(c)
        }
    }

    private val otherConditions: Unit
        get() {
            for (s in customDiag?: emptySet()) {
                mapConditions?.set(s, true)
            }
        }

    private fun initHealth() {
        if (!mRealm.isInTransaction) mRealm.beginTransaction()
        health = RealmMyHealth()
        val profile = RealmMyHealthProfile()
        health?.lastExamination = Date().time
        health?.userKey = generateKey()
        health?.profile = profile
        mRealm.commitTransaction()
    }

    private fun saveData() {
        if (!mRealm.isInTransaction) mRealm.beginTransaction()
        createPojo()
        if (examination == null) {
            val userId = generateIv()
            examination = mRealm.createObject(RealmMyHealthPojo::class.java, userId)
            examination?.userId = userId
        }
        examination?.profileId = health?.userKey
        examination?.creatorId = health?.userKey
        examination?.gender = user?.gender
        examination?.age = user?.dob?.let { getAge(it) }!!
        examination?.isSelfExamination = currentUser?._id == pojo?._id
        examination?.date = Date().time
        examination?.planetCode = user?.planetCode
        val sign = RealmExamination()
        sign.allergies = "${binding.etAllergies.text}".trim { it <= ' ' }
        sign.createdBy = currentUser?._id
        examination?.bp = "${binding.etBloodpressure.text}".trim { it <= ' ' }
        examination?.setTemperature(getFloat("${binding.etTemperature.text}".trim { it <= ' ' }))
        examination?.pulse = getInt("${binding.etPulseRate.text}".trim { it <= ' ' })
        examination?.setWeight(getFloat("${binding.etWeight.text}".trim { it <= ' ' }))
        examination?.height = getFloat("${binding.etHeight.text}".trim { it <= ' ' })
        otherConditions
        examination?.conditions = gson.toJson(mapConditions)
        examination?.hearing = "${binding.etHearing.text}".trim { it <= ' ' }
        sign.immunizations = "${binding.etImmunization.text}".trim { it <= ' ' }
        sign.tests = "${binding.etLabtest.text}".trim { it <= ' ' }
        sign.xrays = "${binding.etXray.text}".trim { it <= ' ' }
        examination?.vision = "${binding.etVision.text}".trim { it <= ' ' }
        sign.treatments = "${binding.etTreatments.text}".trim { it <= ' ' }
        sign.referrals = "${binding.etReferrals.text}".trim { it <= ' ' }
        sign.notes = "${binding.etObservation.text}".trim { it <= ' ' }
        sign.diagnosis = "${binding.etDiag.text}".trim { it <= ' ' }
        sign.medications = "${binding.etMedications.text}".trim { it <= ' ' }
        examination?.date = Date().time
        examination?.isUpdated = true
        examination?.isHasInfo = hasInfo
        pojo?.isUpdated = true
        try {
            val key = user?.key ?: generateKey().also { user?.key = it }
            val iv = user?.iv ?: generateIv().also { user?.iv = it }
            examination?.data = encrypt(gson.toJson(sign), key, iv)
        } catch (e: Exception) {
            e.printStackTrace()
        }
        mRealm.commitTransaction()
        Utilities.toast(this, getString(R.string.added_successfully))
        super.finish()
    }

    private fun scrollToView(view: View) {
        binding.rootScrollView.post {
            binding.rootScrollView.smoothScrollTo(0, view.top)
            view.requestFocus()
        }
    }

    private val hasInfo: Boolean
        get() = !TextUtils.isEmpty("${binding.etAllergies.text}") ||
                !TextUtils.isEmpty("${binding.etDiag.text}") ||
                !TextUtils.isEmpty("${binding.etImmunization.text}") ||
                !TextUtils.isEmpty("${binding.etMedications.text}") ||
                !TextUtils.isEmpty("${binding.etObservation.text}") ||
                !TextUtils.isEmpty("${binding.etReferrals.text}") ||
                !TextUtils.isEmpty("${binding.etLabtest.text}") ||
                !TextUtils.isEmpty("${binding.etTreatments.text}") ||
                !TextUtils.isEmpty("${binding.etXray.text}")
    private val isValidInput: Boolean
        get() {
            val scrollView = binding.rootScrollView

            val isValidTemp = (getFloat("${binding.etTemperature.text}".trim { it <= ' ' }) in 30.0..40.0 ||
                        getFloat("${binding.etTemperature.text}".trim { it <= ' ' }) == 0f) &&
                    "${binding.etTemperature.text}".trim { it <= ' ' }.isNotEmpty()
            val isValidPulse = (getInt("${binding.etPulseRate.text}".trim { it <= ' ' }) in 40..120 ||
                    getFloat("${binding.etPulseRate.text}".trim { it <= ' ' }) == 0f) &&
                    "${binding.etPulseRate.text}".trim { it <= ' ' }.isNotEmpty()
            val isValidHeight = (getFloat("${binding.etHeight.text}".trim { it <= ' ' }) in 1.0..250.0 ||
                    getFloat("${binding.etHeight.text}".trim { it <= ' ' }) == 0f) &&
                    "${binding.etHeight.text}".trim { it <= ' ' }.isNotEmpty()
            val isValidWeight = (getFloat("${binding.etWeight.text}".trim { it <= ' ' }) in 1.0..150.0 ||
                    getFloat("${binding.etWeight.text}".trim { it <= ' ' }) == 0f) &&
                    "${binding.etWeight.text}".trim { it <= ' ' }.isNotEmpty()
            if (!isValidTemp) {
                binding.etTemperature.error = getString(R.string.invalid_input_must_be_between_30_and_40)
                scrollToView(binding.etTemperature)
                Utilities.toast(this, getString(R.string.invalid_input_must_be_between_30_and_40))
            }
            if (!isValidPulse) {
                binding.etPulseRate.error = getString(R.string.invalid_input_must_be_between_40_and_120)
                Utilities.toast(this, getString(R.string.invalid_input_must_be_between_40_and_120))
                scrollToView(binding.etPulseRate)
            }
            if (!isValidHeight) {
                binding.etHeight.error = getString(R.string.invalid_input_must_be_between_1_and_250)
                Utilities.toast(this, getString(R.string.invalid_input_must_be_between_1_and_250))
                scrollToView(binding.etHeight)
            }
            if (!isValidWeight) {
                binding.etWeight.error = getString(R.string.invalid_input_must_be_between_1_and_150)
                Utilities.toast(this, getString(R.string.invalid_input_must_be_between_1_and_150))
                scrollToView(binding.etWeight)
            }
            return isValidTemp && isValidHeight && isValidPulse && isValidWeight
        }

    //    private float getFloat(String trim) {
    //    }
    private fun getInt(trim: String): Int {
        return try {
            trim.toInt()
        } catch (e: Exception) {
            0
        }
    }

    private fun getFloat(trim: String): Float {
        return try {
            String.format(Locale.getDefault(), "%.1f", trim.toFloat()).toFloat()
        } catch (e: Exception) {
            getInt(trim).toFloat()
        }
    }

    private fun createPojo() {
        try {
            if (pojo == null) {
                pojo = mRealm.createObject(RealmMyHealthPojo::class.java, userId)
                pojo?.userId = user?._id
            }
            health?.lastExamination = Date().time
            val userKey = user?.key
            val userIv = user?.iv
            if (userKey != null && userIv != null) {
                pojo?.data = encrypt(gson.toJson(health), userKey, userIv)
            }
        } catch (e: Exception) {
            e.printStackTrace()
            Utilities.toast(this, getString(R.string.unable_to_add_health_record))
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == android.R.id.home) {
            finish()
        }
        return super.onOptionsItemSelected(item)
    }

    override fun finish() {
        val alertDialogBuilder = AlertDialog.Builder(this, R.style.AlertDialogTheme)
        alertDialogBuilder.setMessage(R.string.cancel_adding_examination)
        alertDialogBuilder.setPositiveButton(getString(R.string.yes_i_want_to_exit)) { _: DialogInterface?, _: Int -> super.finish() }
            .setNegativeButton(getString(R.string.cancel), null)
        alertDialogBuilder.show()
    }

    override fun onCheckedChanged(compoundButton: CompoundButton, b: Boolean) {
        val text = "${compoundButton.text}".trim { it <= ' ' }
        mapConditions?.set(text, b)
    }

    override fun onDestroy() {
        if (this::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        binding.etBloodpressure.removeTextChangedListener(textWatcher)
        textWatcher = null
        super.onDestroy()
    }
}
=======
package org.ole.planet.myplanet.ui.myhealth


import android.content.DialogInterface
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.MenuItem
import android.view.View
import android.widget.CheckBox
import android.widget.CompoundButton
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import fisk.chipcloud.ChipCloud
import fisk.chipcloud.ChipCloudConfig
import io.realm.Realm
import java.util.Date
import java.util.Locale
import javax.inject.Inject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityAddExaminationBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyHealth
import org.ole.planet.myplanet.model.RealmMyHealth.RealmMyHealthProfile
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.myhealth.RealmExamination
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.decrypt
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.encrypt
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateIv
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateKey
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.DimenUtils.dpToPx
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.JsonUtils.getBoolean
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.TimeUtils.getAge
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class AddExaminationActivity : AppCompatActivity(), CompoundButton.OnCheckedChangeListener {
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private lateinit var binding: ActivityAddExaminationBinding
    lateinit var mRealm: Realm
    var userId: String? = null
    var user: RealmUserModel? = null
    private var currentUser: RealmUserModel? = null
    private var pojo: RealmMyHealthPojo? = null
    var health: RealmMyHealth? = null
    private var customDiag: MutableSet<String?>? = null
    private var mapConditions: HashMap<String?, Boolean>? = null
    var allowSubmission = true
    private lateinit var config: ChipCloudConfig
    private var examination: RealmMyHealthPojo? = null
    private var textWatcher: TextWatcher? = null
    private val gson = Gson()
    private fun initViews() {
        config = Utilities.getCloudConfig().selectMode(ChipCloud.SelectMode.close)
        binding.btnAddDiag.setOnClickListener {
            customDiag?.add("${binding.etOtherDiag.text}")
            binding.etOtherDiag.setText(R.string.empty_text)
            showOtherDiagnosis()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityAddExaminationBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, binding.root)
        supportActionBar?.setHomeButtonEnabled(true)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        customDiag = HashSet()
        initViews()
        currentUser = userProfileDbHandler.userModel
        mapConditions = HashMap()
        mRealm = databaseService.realmInstance
        userId = intent.getStringExtra("userId")
        pojo = mRealm.where(RealmMyHealthPojo::class.java).equalTo("_id", userId).findFirst()
        if (pojo == null) {
            pojo = mRealm.where(RealmMyHealthPojo::class.java).equalTo("userId", userId).findFirst()
        }
        user = mRealm.where(RealmUserModel::class.java).equalTo("id", userId).findFirst()
        if (user != null && (user?.key == null || user?.iv == null)) {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            user?.key = generateKey()
            user?.iv = generateIv()
            mRealm.commitTransaction()
        }
        if (pojo != null && !TextUtils.isEmpty(pojo?.data)) {
            health = gson.fromJson(decrypt(pojo?.data, user?.key, user?.iv), RealmMyHealth::class.java)
        }
        if (health == null) {
            initHealth()
        }
        initExamination()
        validateFields()
        findViewById<View>(R.id.btn_save).setOnClickListener {
            if(!allowSubmission){
                scrollToView(binding.etBloodpressure)
            }
            if (!isValidInput || !allowSubmission) {
                return@setOnClickListener
            }
            saveData()
        }
    }

    private fun initExamination() {
        if (intent.hasExtra("id")) {
            examination = mRealm.where(RealmMyHealthPojo::class.java).equalTo("_id", intent.getStringExtra("id")).findFirst()!!
            binding.etTemperature.setText(getString(R.string.float_placeholder, examination?.temperature))
            binding.etPulseRate.setText(getString(R.string.number_placeholder, examination?.pulse))
            binding.etBloodpressure.setText(getString(R.string.message_placeholder, examination?.bp))
            binding.etHeight.setText(getString(R.string.float_placeholder, examination?.height))
            binding.etWeight.setText(getString(R.string.float_placeholder, examination?.weight))
            binding.etVision.setText(examination?.vision)
            binding.etHearing.setText(examination?.hearing)
            val encrypted = user?.let { examination?.getEncryptedDataAsJson(it) }
            binding.etObservation.setText(getString(getString(R.string.note_), encrypted))
            binding.etDiag.setText(getString(getString(R.string.diagnosis), encrypted))
            binding.etTreatments.setText(getString(getString(R.string.treatments), encrypted))
            binding.etMedications.setText(getString(getString(R.string.medications), encrypted))
            binding.etImmunization.setText(getString(getString(R.string.immunizations), encrypted))
            binding.etAllergies.setText(getString(getString(R.string.allergies), encrypted))
            binding.etXray.setText(getString(getString(R.string.xrays), encrypted))
            binding.etLabtest.setText(getString(getString(R.string.tests), encrypted))
            binding.etReferrals.setText(getString(getString(R.string.referrals), encrypted))
        }
        showCheckbox(examination)
        showOtherDiagnosis()
    }

    private fun validateFields() {
        allowSubmission = true
        textWatcher = object : TextWatcher {
            override fun afterTextChanged(s: Editable) {}
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                if (!"${binding.etBloodpressure.text}".contains("/")) {
                    binding.etBloodpressure.error = getString(R.string.blood_pressure_should_be_numeric_systolic_diastolic)
                    allowSubmission = false
                } else {
                    val sysDia = "${binding.etBloodpressure.text}"
                        .trim { it <= ' ' }
                        .split("/".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
                    if (sysDia.size > 2 || sysDia.isEmpty()) {
                        binding.etBloodpressure.error = getString(R.string.blood_pressure_should_be_systolic_diastolic)
                        allowSubmission = false
                    } else {
                        try {
                            val sys = sysDia[0].toInt()
                            val dis = sysDia[1].toInt()
                            if (sys < 60 || dis < 40 || sys > 300 || dis > 200) {
                                binding.etBloodpressure.error = getString(R.string.bp_must_be_between_60_40_and_300_200)
                                allowSubmission = false
                            } else {
                                allowSubmission = true
                            }
                        } catch (e: Exception) {
                            binding.etBloodpressure.error = getString(R.string.systolic_and_diastolic_must_be_numbers)
                            allowSubmission = false
                        }
                    }
                }
            }
        }
        binding.etBloodpressure.addTextChangedListener(textWatcher)
    }

    private fun showOtherDiagnosis() {
        binding.containerOtherDiagnosis.removeAllViews()
        val chipCloud = ChipCloud(this, binding.containerOtherDiagnosis, config)
        for (s in customDiag?: emptySet()) {
            if (s.isNullOrBlank()) {
                    continue
            } else {
                    chipCloud.addChip(s)
            }
        }
        chipCloud.setDeleteListener { _: Int, s1: String? -> customDiag?.remove(s1) }
        preloadCustomDiagnosis(chipCloud)
    }

    private fun preloadCustomDiagnosis(chipCloud: ChipCloud) {
        val arr = resources.getStringArray(R.array.diagnosis_list)
        val mainList = listOf(*arr)
        if (customDiag?.isEmpty() == true && examination != null) {
            val conditions = gson.fromJson(examination?.conditions, JsonObject::class.java)
            for (s in conditions.keySet()) {
                if (!mainList.contains(s) && getBoolean(s, conditions)) {
                    chipCloud.addChip(s)
                    chipCloud.setDeleteListener { _: Int, s1: String? ->
                        customDiag?.remove(Constants.LABELS[s1])
                    }
                    customDiag?.add(s)
                }
            }
        }
    }

    private fun showCheckbox(examination: RealmMyHealthPojo?) {
        val arr = resources.getStringArray(R.array.diagnosis_list)
        binding.containerCheckbox.removeAllViews()
        for (s in arr) {
            val c = CheckBox(this)
            c.buttonTintList = ContextCompat.getColorStateList(this, R.color.daynight_textColor)
            c.setTextColor(ContextCompat.getColor(this, R.color.daynight_textColor))

            if (examination != null) {
                val conditions = gson.fromJson(examination.conditions, JsonObject::class.java)
                c.isChecked = getBoolean(s, conditions)
            }
            c.setPadding(dpToPx(8), dpToPx(8), dpToPx(8), dpToPx(8))
            c.text = s
            c.tag = s
            c.setOnCheckedChangeListener(this)
            binding.containerCheckbox.addView(c)
        }
    }

    private val otherConditions: Unit
        get() {
            for (s in customDiag?: emptySet()) {
                mapConditions?.set(s, true)
            }
        }

    private fun initHealth() {
        if (!mRealm.isInTransaction) mRealm.beginTransaction()
        health = RealmMyHealth()
        val profile = RealmMyHealthProfile()
        health?.lastExamination = Date().time
        health?.userKey = generateKey()
        health?.profile = profile
        mRealm.commitTransaction()
    }

    private fun saveData() {
        if (!mRealm.isInTransaction) mRealm.beginTransaction()
        createPojo()
        if (examination == null) {
            val userId = generateIv()
            examination = mRealm.createObject(RealmMyHealthPojo::class.java, userId)
            examination?.userId = userId
        }
        examination?.profileId = health?.userKey
        examination?.creatorId = health?.userKey
        examination?.gender = user?.gender
        examination?.age = user?.dob?.let { getAge(it) }!!
        examination?.isSelfExamination = currentUser?._id == pojo?._id
        examination?.date = Date().time
        examination?.planetCode = user?.planetCode
        val sign = RealmExamination()
        sign.allergies = "${binding.etAllergies.text}".trim { it <= ' ' }
        sign.createdBy = currentUser?._id
        examination?.bp = "${binding.etBloodpressure.text}".trim { it <= ' ' }
        examination?.setTemperature(getFloat("${binding.etTemperature.text}".trim { it <= ' ' }))
        examination?.pulse = getInt("${binding.etPulseRate.text}".trim { it <= ' ' })
        examination?.setWeight(getFloat("${binding.etWeight.text}".trim { it <= ' ' }))
        examination?.height = getFloat("${binding.etHeight.text}".trim { it <= ' ' })
        otherConditions
        examination?.conditions = gson.toJson(mapConditions)
        examination?.hearing = "${binding.etHearing.text}".trim { it <= ' ' }
        sign.immunizations = "${binding.etImmunization.text}".trim { it <= ' ' }
        sign.tests = "${binding.etLabtest.text}".trim { it <= ' ' }
        sign.xrays = "${binding.etXray.text}".trim { it <= ' ' }
        examination?.vision = "${binding.etVision.text}".trim { it <= ' ' }
        sign.treatments = "${binding.etTreatments.text}".trim { it <= ' ' }
        sign.referrals = "${binding.etReferrals.text}".trim { it <= ' ' }
        sign.notes = "${binding.etObservation.text}".trim { it <= ' ' }
        sign.diagnosis = "${binding.etDiag.text}".trim { it <= ' ' }
        sign.medications = "${binding.etMedications.text}".trim { it <= ' ' }
        examination?.date = Date().time
        examination?.isUpdated = true
        examination?.isHasInfo = hasInfo
        pojo?.isUpdated = true
        try {
            val key = user?.key ?: generateKey().also { user?.key = it }
            val iv = user?.iv ?: generateIv().also { user?.iv = it }
            examination?.data = encrypt(gson.toJson(sign), key, iv)
        } catch (e: Exception) {
            e.printStackTrace()
        }
        mRealm.commitTransaction()
        Utilities.toast(this, getString(R.string.added_successfully))
        super.finish()
    }

    private fun scrollToView(view: View) {
        binding.rootScrollView.post {
            binding.rootScrollView.smoothScrollTo(0, view.top)
            view.requestFocus()
        }
    }

    private val hasInfo: Boolean
        get() = !TextUtils.isEmpty("${binding.etAllergies.text}") ||
                !TextUtils.isEmpty("${binding.etDiag.text}") ||
                !TextUtils.isEmpty("${binding.etImmunization.text}") ||
                !TextUtils.isEmpty("${binding.etMedications.text}") ||
                !TextUtils.isEmpty("${binding.etObservation.text}") ||
                !TextUtils.isEmpty("${binding.etReferrals.text}") ||
                !TextUtils.isEmpty("${binding.etLabtest.text}") ||
                !TextUtils.isEmpty("${binding.etTreatments.text}") ||
                !TextUtils.isEmpty("${binding.etXray.text}")
    private val isValidInput: Boolean
        get() {
            val scrollView = binding.rootScrollView

            val isValidTemp = (getFloat("${binding.etTemperature.text}".trim { it <= ' ' }) in 30.0..40.0 ||
                        getFloat("${binding.etTemperature.text}".trim { it <= ' ' }) == 0f) &&
                    "${binding.etTemperature.text}".trim { it <= ' ' }.isNotEmpty()
            val isValidPulse = (getInt("${binding.etPulseRate.text}".trim { it <= ' ' }) in 40..120 ||
                    getFloat("${binding.etPulseRate.text}".trim { it <= ' ' }) == 0f) &&
                    "${binding.etPulseRate.text}".trim { it <= ' ' }.isNotEmpty()
            val isValidHeight = (getFloat("${binding.etHeight.text}".trim { it <= ' ' }) in 1.0..250.0 ||
                    getFloat("${binding.etHeight.text}".trim { it <= ' ' }) == 0f) &&
                    "${binding.etHeight.text}".trim { it <= ' ' }.isNotEmpty()
            val isValidWeight = (getFloat("${binding.etWeight.text}".trim { it <= ' ' }) in 1.0..150.0 ||
                    getFloat("${binding.etWeight.text}".trim { it <= ' ' }) == 0f) &&
                    "${binding.etWeight.text}".trim { it <= ' ' }.isNotEmpty()
            if (!isValidTemp) {
                binding.etTemperature.error = getString(R.string.invalid_input_must_be_between_30_and_40)
                scrollToView(binding.etTemperature)
                Utilities.toast(this, getString(R.string.invalid_input_must_be_between_30_and_40))
            }
            if (!isValidPulse) {
                binding.etPulseRate.error = getString(R.string.invalid_input_must_be_between_40_and_120)
                Utilities.toast(this, getString(R.string.invalid_input_must_be_between_40_and_120))
                scrollToView(binding.etPulseRate)
            }
            if (!isValidHeight) {
                binding.etHeight.error = getString(R.string.invalid_input_must_be_between_1_and_250)
                Utilities.toast(this, getString(R.string.invalid_input_must_be_between_1_and_250))
                scrollToView(binding.etHeight)
            }
            if (!isValidWeight) {
                binding.etWeight.error = getString(R.string.invalid_input_must_be_between_1_and_150)
                Utilities.toast(this, getString(R.string.invalid_input_must_be_between_1_and_150))
                scrollToView(binding.etWeight)
            }
            return isValidTemp && isValidHeight && isValidPulse && isValidWeight
        }

    //    private float getFloat(String trim) {
    //    }
    private fun getInt(trim: String): Int {
        return try {
            trim.toInt()
        } catch (e: Exception) {
            0
        }
    }

    private fun getFloat(trim: String): Float {
        return try {
            String.format(Locale.getDefault(), "%.1f", trim.toFloat()).toFloat()
        } catch (e: Exception) {
            getInt(trim).toFloat()
        }
    }

    private fun createPojo() {
        try {
            if (pojo == null) {
                pojo = mRealm.createObject(RealmMyHealthPojo::class.java, userId)
                pojo?.userId = user?._id
            }
            health?.lastExamination = Date().time
            val userKey = user?.key
            val userIv = user?.iv
            if (userKey != null && userIv != null) {
                pojo?.data = encrypt(gson.toJson(health), userKey, userIv)
            }
        } catch (e: Exception) {
            e.printStackTrace()
            Utilities.toast(this, getString(R.string.unable_to_add_health_record))
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == android.R.id.home) {
            finish()
        }
        return super.onOptionsItemSelected(item)
    }

    override fun finish() {
        val alertDialogBuilder = AlertDialog.Builder(this, R.style.AlertDialogTheme)
        alertDialogBuilder.setMessage(R.string.cancel_adding_examination)
        alertDialogBuilder.setPositiveButton(getString(R.string.yes_i_want_to_exit)) { _: DialogInterface?, _: Int -> super.finish() }
            .setNegativeButton(getString(R.string.cancel), null)
        alertDialogBuilder.show()
    }

    override fun onCheckedChanged(compoundButton: CompoundButton, b: Boolean) {
        val text = "${compoundButton.text}".trim { it <= ' ' }
        mapConditions?.set(text, b)
    }

    override fun onDestroy() {
        if (this::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        binding.etBloodpressure.removeTextChangedListener(textWatcher)
        textWatcher = null
        super.onDestroy()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/myhealth/UserListArrayAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.myhealth

import android.app.Activity
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ImageView
import android.widget.TextView
import com.bumptech.glide.Glide
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.TimeUtils

class UserListArrayAdapter(activity: Activity, val view: Int, var list: List<RealmUserModel>) : ArrayAdapter<RealmUserModel>(activity, view, list) {
    private class ViewHolder {
        var tvName: TextView? = null
        var joined: TextView? = null
        var image: ImageView? = null
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
        val holder: ViewHolder
        var convertViewVar = convertView

        if (convertViewVar == null) {
            convertViewVar = LayoutInflater.from(context).inflate(R.layout.item_user, parent, false)
            holder = ViewHolder()
            holder.tvName = convertViewVar.findViewById(R.id.txt_name)
            holder.joined = convertViewVar.findViewById(R.id.txt_joined)
            holder.image = convertViewVar.findViewById(R.id.iv_user)
            convertViewVar.tag = holder
        } else {
            holder = convertViewVar.tag as ViewHolder
        }

        val um = getItem(position)
        holder.tvName?.text = context.getString(R.string.two_strings, um?.getFullName(), "(${um?.name})")
        if (um != null) {
            holder.joined?.text = context.getString(R.string.joined_colon, TimeUtils.formatDate(um.joinDate))
        }

        if (!TextUtils.isEmpty(um?.userImage)) {
            holder.image?.let {
                Glide.with(it.context)
                    .load(um?.userImage)
                    .placeholder(R.drawable.profile)
                    .error(R.drawable.profile)
                    .into(it)
            }
        } else {
            holder.image?.setImageResource(R.drawable.profile)
        }

        return convertViewVar!!
    }
}
=======
package org.ole.planet.myplanet.ui.myhealth


import android.app.Activity
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ImageView
import android.widget.TextView
import com.bumptech.glide.Glide
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.TimeUtils

class UserListArrayAdapter(activity: Activity, val view: Int, var list: List<RealmUserModel>) : ArrayAdapter<RealmUserModel>(activity, view, list) {
    private class ViewHolder {
        var tvName: TextView? = null
        var joined: TextView? = null
        var image: ImageView? = null
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
        val holder: ViewHolder
        var convertViewVar = convertView

        if (convertViewVar == null) {
            convertViewVar = LayoutInflater.from(context).inflate(R.layout.item_user, parent, false)
            holder = ViewHolder()
            holder.tvName = convertViewVar.findViewById(R.id.txt_name)
            holder.joined = convertViewVar.findViewById(R.id.txt_joined)
            holder.image = convertViewVar.findViewById(R.id.iv_user)
            convertViewVar.tag = holder
        } else {
            holder = convertViewVar.tag as ViewHolder
        }

        val um = getItem(position)
        holder.tvName?.text = context.getString(R.string.two_strings, um?.getFullName(), "(${um?.name})")
        if (um != null) {
            holder.joined?.text = context.getString(R.string.joined_colon, TimeUtils.formatDate(um.joinDate))
        }

        if (!TextUtils.isEmpty(um?.userImage)) {
            holder.image?.let {
                Glide.with(it.context)
                    .load(um?.userImage)
                    .placeholder(R.drawable.profile)
                    .error(R.drawable.profile)
                    .into(it)
            }
        } else {
            holder.image?.setImageResource(R.drawable.profile)
        }

        return convertViewVar!!
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/myhealth/AdapterHealthExamination.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.myhealth

import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.ViewGroup
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.core.graphics.drawable.toDrawable
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.Realm
import java.util.Date
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AlertExaminationBinding
import org.ole.planet.myplanet.databinding.RowExaminationBinding
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.myhealth.AdapterHealthExamination.ViewHolderMyHealthExamination
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities

class AdapterHealthExamination(private val context: Context, private val list: List<RealmMyHealthPojo>?, private val mh: RealmMyHealthPojo, private val userModel: RealmUserModel?) : RecyclerView.Adapter<ViewHolderMyHealthExamination>() {
    private lateinit var mRealm: Realm
    private val displayNameCache = mutableMapOf<String, String>()
    fun setmRealm(mRealm: Realm?) {
        if (mRealm != null) {
            this.mRealm = mRealm
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderMyHealthExamination {
        val rowExaminationBinding = RowExaminationBinding.inflate(
            LayoutInflater.from(context), parent, false
        )
        return ViewHolderMyHealthExamination(rowExaminationBinding)
    }

    override fun onBindViewHolder(holder: ViewHolderMyHealthExamination, position: Int) {
        val binding = holder.binding
        binding.txtTemp.text = list?.get(position)?.let { checkEmpty(it.temperature) }
        val formattedDate = list?.get(position)?.let { formatDate(it.date, "MMM dd, yyyy") }
        binding.txtDate.text = formattedDate
        binding.txtDate.tag = formattedDate
        val encrypted = userModel?.let { it1 -> list?.get(position)?.getEncryptedDataAsJson(it1) }

        val createdBy = getString("createdBy", encrypted)
        if (!TextUtils.isEmpty(createdBy) && !TextUtils.equals(createdBy, userModel?.id)) {
            val name = displayNameCache.getOrPut(createdBy) {
                val model = mRealm.where(RealmUserModel::class.java).equalTo("id", createdBy).findFirst()
                model?.getFullName() ?: createdBy.split(":".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray().getOrNull(1) ?: createdBy
            }
            binding.txtDate.text = context.getString(R.string.two_strings, binding.txtDate.text, name).trimIndent()
            holder.itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.md_grey_50))
        } else {
            binding.txtDate.text = context.getString(R.string.self_examination, binding.txtDate.text)
            holder.itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.md_green_50))
        }

        binding.txtPulse.text = list?.get(position)?.let { checkEmptyInt(it.pulse) }
        binding.txtBp.text = list?.get(position)?.bp
        binding.txtHearing.text = list?.get(position)?.hearing
        binding.txtHeight.text = list?.get(position)?.let { checkEmpty(it.height) }
        binding.txtWeight.text = list?.get(position)?.let { checkEmpty(it.weight) }
        binding.txtVision.text = list?.get(position)?.vision
        holder.itemView.setOnClickListener {
            if (encrypted != null) {
                showAlert(binding, position, encrypted)
            }
        }
    }

    private fun checkEmpty(value: Float): String {
        return if (value == 0f) "" else value.toString() + ""
    }

    private fun checkEmptyInt(value: Int): String {
        return if (value == 0) "" else value.toString() + ""
    }

    private fun showAlert(binding: RowExaminationBinding, position: Int, encrypted: JsonObject) {
        val realmExamination = list?.get(position)
        val alertExaminationBinding = AlertExaminationBinding.inflate(LayoutInflater.from(context))
        if (realmExamination != null) {
            alertExaminationBinding.tvVitals.text = context.getString(R.string.vitals_format, checkEmpty(realmExamination.temperature),
                checkEmptyInt(realmExamination.pulse), realmExamination.bp, checkEmpty(realmExamination.height),
                checkEmpty(realmExamination.weight), realmExamination.vision, realmExamination.hearing).trimIndent()
        }
        showConditions(alertExaminationBinding.tvCondition, realmExamination)
        showEncryptedData(alertExaminationBinding.tvOtherNotes, encrypted)
        val dialog = AlertDialog.Builder(context, R.style.CustomAlertDialog)
            .setTitle(binding.txtDate.tag as? CharSequence ?: binding.txtDate.text)
            .setView(alertExaminationBinding.root)
            .setPositiveButton("OK", null).create()
        val backgroundColor = ContextCompat.getColor(context, R.color.multi_select_grey)
        dialog.window?.setBackgroundDrawable(backgroundColor.toDrawable())
        val time = Date().time - 5000 * 60
        if (realmExamination != null) {
            if (realmExamination.date >= time) { dialog.setButton(DialogInterface.BUTTON_NEUTRAL, context.getString(R.string.edit)) { _: DialogInterface?, _: Int ->
                context.startActivity(Intent(context, AddExaminationActivity::class.java)
                    .putExtra("id", list[position]._id)
                    .putExtra("userId", mh._id))
            }
            }
        }
        dialog.show()
    }

    private fun showConditions(tvCondition: TextView, realmExamination: RealmMyHealthPojo?) {
        val conditionsMap = Gson().fromJson(realmExamination?.conditions, JsonObject::class.java)
        val keys = conditionsMap.keySet()
        val conditions = StringBuilder()
        for (key in keys) {
            if (conditionsMap[key].asBoolean) {
                conditions.append("$key, ")
            }
        }
        tvCondition.text = conditions
    }

    private fun showEncryptedData(tvOtherNotes: TextView, encrypted: JsonObject) {
        tvOtherNotes.text = context.getString(R.string.observations_notes_colon, Utilities.checkNA(getString("notes", encrypted)),
            Utilities.checkNA(getString("diagnosis", encrypted)), Utilities.checkNA(getString("treatments", encrypted)),
            Utilities.checkNA(getString("medications", encrypted)), Utilities.checkNA(getString("immunizations", encrypted)),
            Utilities.checkNA(getString("allergies", encrypted)), Utilities.checkNA(getString("xrays", encrypted)),
            Utilities.checkNA(getString("tests", encrypted)), Utilities.checkNA(getString("referrals", encrypted)))
    }

    override fun getItemCount(): Int {
        return list?.size ?: 0
    }

    class ViewHolderMyHealthExamination(val binding: RowExaminationBinding) : RecyclerView.ViewHolder(binding.root)
}
=======
package org.ole.planet.myplanet.ui.myhealth


import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.ViewGroup
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.core.graphics.drawable.toDrawable
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.Realm
import java.util.Date
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AlertExaminationBinding
import org.ole.planet.myplanet.databinding.RowExaminationBinding
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.myhealth.AdapterHealthExamination.ViewHolderMyHealthExamination
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities

class AdapterHealthExamination(private val context: Context, private val list: List<RealmMyHealthPojo>?, private val mh: RealmMyHealthPojo, private val userModel: RealmUserModel?) : RecyclerView.Adapter<ViewHolderMyHealthExamination>() {
    private lateinit var mRealm: Realm
    private val displayNameCache = mutableMapOf<String, String>()
    fun setmRealm(mRealm: Realm?) {
        if (mRealm != null) {
            this.mRealm = mRealm
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderMyHealthExamination {
        val rowExaminationBinding = RowExaminationBinding.inflate(
            LayoutInflater.from(context), parent, false
        )
        return ViewHolderMyHealthExamination(rowExaminationBinding)
    }

    override fun onBindViewHolder(holder: ViewHolderMyHealthExamination, position: Int) {
        val binding = holder.binding
        binding.txtTemp.text = list?.get(position)?.let { checkEmpty(it.temperature) }
        val formattedDate = list?.get(position)?.let { formatDate(it.date, "MMM dd, yyyy") }
        binding.txtDate.text = formattedDate
        binding.txtDate.tag = formattedDate
        val encrypted = userModel?.let { it1 -> list?.get(position)?.getEncryptedDataAsJson(it1) }

        val createdBy = getString("createdBy", encrypted)
        if (!TextUtils.isEmpty(createdBy) && !TextUtils.equals(createdBy, userModel?.id)) {
            val name = displayNameCache.getOrPut(createdBy) {
                val model = mRealm.where(RealmUserModel::class.java).equalTo("id", createdBy).findFirst()
                model?.getFullName() ?: createdBy.split(":".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray().getOrNull(1) ?: createdBy
            }
            binding.txtDate.text = context.getString(R.string.two_strings, binding.txtDate.text, name).trimIndent()
            holder.itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.md_grey_50))
        } else {
            binding.txtDate.text = context.getString(R.string.self_examination, binding.txtDate.text)
            holder.itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.md_green_50))
        }

        binding.txtPulse.text = list?.get(position)?.let { checkEmptyInt(it.pulse) }
        binding.txtBp.text = list?.get(position)?.bp
        binding.txtHearing.text = list?.get(position)?.hearing
        binding.txtHeight.text = list?.get(position)?.let { checkEmpty(it.height) }
        binding.txtWeight.text = list?.get(position)?.let { checkEmpty(it.weight) }
        binding.txtVision.text = list?.get(position)?.vision
        holder.itemView.setOnClickListener {
            if (encrypted != null) {
                showAlert(binding, position, encrypted)
            }
        }
    }

    private fun checkEmpty(value: Float): String {
        return if (value == 0f) "" else value.toString() + ""
    }

    private fun checkEmptyInt(value: Int): String {
        return if (value == 0) "" else value.toString() + ""
    }

    private fun showAlert(binding: RowExaminationBinding, position: Int, encrypted: JsonObject) {
        val realmExamination = list?.get(position)
        val alertExaminationBinding = AlertExaminationBinding.inflate(LayoutInflater.from(context))
        if (realmExamination != null) {
            alertExaminationBinding.tvVitals.text = context.getString(R.string.vitals_format, checkEmpty(realmExamination.temperature),
                checkEmptyInt(realmExamination.pulse), realmExamination.bp, checkEmpty(realmExamination.height),
                checkEmpty(realmExamination.weight), realmExamination.vision, realmExamination.hearing).trimIndent()
        }
        showConditions(alertExaminationBinding.tvCondition, realmExamination)
        showEncryptedData(alertExaminationBinding.tvOtherNotes, encrypted)
        val dialog = AlertDialog.Builder(context, R.style.CustomAlertDialog)
            .setTitle(binding.txtDate.tag as? CharSequence ?: binding.txtDate.text)
            .setView(alertExaminationBinding.root)
            .setPositiveButton("OK", null).create()
        val backgroundColor = ContextCompat.getColor(context, R.color.multi_select_grey)
        dialog.window?.setBackgroundDrawable(backgroundColor.toDrawable())
        val time = Date().time - 5000 * 60
        if (realmExamination != null) {
            if (realmExamination.date >= time) { dialog.setButton(DialogInterface.BUTTON_NEUTRAL, context.getString(R.string.edit)) { _: DialogInterface?, _: Int ->
                context.startActivity(Intent(context, AddExaminationActivity::class.java)
                    .putExtra("id", list[position]._id)
                    .putExtra("userId", mh._id))
            }
            }
        }
        dialog.show()
    }

    private fun showConditions(tvCondition: TextView, realmExamination: RealmMyHealthPojo?) {
        val conditionsMap = Gson().fromJson(realmExamination?.conditions, JsonObject::class.java)
        val keys = conditionsMap.keySet()
        val conditions = StringBuilder()
        for (key in keys) {
            if (conditionsMap[key].asBoolean) {
                conditions.append("$key, ")
            }
        }
        tvCondition.text = conditions
    }

    private fun showEncryptedData(tvOtherNotes: TextView, encrypted: JsonObject) {
        tvOtherNotes.text = context.getString(R.string.observations_notes_colon, Utilities.checkNA(getString("notes", encrypted)),
            Utilities.checkNA(getString("diagnosis", encrypted)), Utilities.checkNA(getString("treatments", encrypted)),
            Utilities.checkNA(getString("medications", encrypted)), Utilities.checkNA(getString("immunizations", encrypted)),
            Utilities.checkNA(getString("allergies", encrypted)), Utilities.checkNA(getString("xrays", encrypted)),
            Utilities.checkNA(getString("tests", encrypted)), Utilities.checkNA(getString("referrals", encrypted)))
    }

    override fun getItemCount(): Int {
        return list?.size ?: 0
    }

    class ViewHolderMyHealthExamination(val binding: RowExaminationBinding) : RecyclerView.ViewHolder(binding.root)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/myhealth/RealmExamination.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.myhealth

import java.io.Serializable

class RealmExamination : Serializable {
    var notes: String? = null
    var diagnosis: String? = null
    var treatments: String? = null
    var medications: String? = null
    var immunizations: String? = null
    var allergies: String? = null
    var xrays: String? = null
    var tests: String? = null
    var referrals: String? = null
    var createdBy: String? = null
}
=======
package org.ole.planet.myplanet.ui.myhealth


import java.io.Serializable

class RealmExamination : Serializable {
    var notes: String? = null
    var diagnosis: String? = null
    var treatments: String? = null
    var medications: String? = null
    var immunizations: String? = null
    var allergies: String? = null
    var xrays: String? = null
    var tests: String? = null
    var referrals: String? = null
    var createdBy: String? = null
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/myhealth/AddMyHealthActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.myhealth

import android.app.DatePickerDialog
import android.os.Bundle
import android.text.TextUtils
import android.view.MenuItem
import android.view.View
import android.widget.ArrayAdapter
import android.widget.ImageView
import android.widget.Spinner
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.google.gson.Gson
import dagger.hilt.android.AndroidEntryPoint
import java.util.Calendar
import java.util.Locale
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityAddMyHealthBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyHealth
import org.ole.planet.myplanet.model.RealmMyHealth.RealmMyHealthProfile
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.decrypt
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.encrypt
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateIv
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateKey
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class AddMyHealthActivity : AppCompatActivity() {
    private lateinit var binding: ActivityAddMyHealthBinding
    @Inject
    lateinit var databaseService: DatabaseService
    var userId: String? = null
    private var myHealth: RealmMyHealth? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityAddMyHealthBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, binding.root)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.setHomeButtonEnabled(true)
        userId = intent.getStringExtra("userId")
        findViewById<View>(R.id.btn_submit).setOnClickListener {
            createMyHealth()
            Utilities.toast(this@AddMyHealthActivity, getString(R.string.my_health_saved_successfully))
        }

        val contactTypes = resources.getStringArray(R.array.contact_type)
        val contactAdapter = ArrayAdapter(this, R.layout.become_a_member_spinner_layout, contactTypes)
        findViewById<Spinner>(R.id.spn_contact_type).adapter = contactAdapter

        initViews()
        val datePickerClickListener = View.OnClickListener {
            val now = Calendar.getInstance()
            val dpd = DatePickerDialog(this, { _, year, month, dayOfMonth ->
                val selectedDate = String.format(Locale.US, "%04d-%02d-%02d", year, month + 1, dayOfMonth)
                binding.etBirthdateLayout.editText?.setText(selectedDate)
            }, now.get(Calendar.YEAR), now.get(Calendar.MONTH), now.get(Calendar.DAY_OF_MONTH))
            dpd.datePicker.maxDate = System.currentTimeMillis()
            dpd.show()
        }
        binding.etBirthdateLayout.editText?.setOnClickListener(datePickerClickListener)
        findViewById<ImageView>(R.id.iv_date_picker).setOnClickListener(datePickerClickListener)
    }

    private fun createMyHealth() {
        lifecycleScope.launch {
            databaseService.executeTransactionAsync { realm ->
                val userModel = realm.where(RealmUserModel::class.java).equalTo("id", userId).findFirst()
                val oldProfile = myHealth?.profile
                val health = RealmMyHealthProfile()
                userModel?.firstName = "${binding.etFname.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.middleName = "${binding.etMname.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.lastName = "${binding.etLname.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.email = "${binding.etEmail.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.dob = "${binding.etBirthdateLayout.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.birthPlace = "${binding.etBirthplace.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.phoneNumber = "${binding.etPhone.editText?.text}".trim { ch -> ch <= ' ' }
                health.emergencyContactName = "${binding.etEmergency.editText?.text}".trim { ch -> ch <= ' ' }
                val emergencyContact = "${binding.etContact.editText?.text}".trim { ch -> ch <= ' ' }
                health.emergencyContact = if (TextUtils.isEmpty(emergencyContact)) {
                    oldProfile?.emergencyContact ?: ""
                } else {
                    emergencyContact
                }
                val emergencyContactType = "${binding.spnContactType.selectedItem}".trim { ch -> ch <= ' ' }
                health.emergencyContactType = if (TextUtils.isEmpty(emergencyContactType)) {
                    oldProfile?.emergencyContactType ?: ""
                } else {
                    emergencyContactType
                }
                health.specialNeeds = "${binding.etSpecialNeed.editText?.text}".trim { ch -> ch <= ' ' }
                health.notes = "${binding.etOtherNeed.editText?.text}".trim { ch -> ch <= ' ' }
                if (myHealth == null) {
                    myHealth = RealmMyHealth()
                }
                if (TextUtils.isEmpty(myHealth?.userKey)) {
                    myHealth?.userKey = generateKey()
                }
                myHealth?.profile = health
                var healthPojo = realm.where(RealmMyHealthPojo::class.java).equalTo("_id", userId).findFirst()
                if (healthPojo == null) {
                    healthPojo = realm.where(RealmMyHealthPojo::class.java).equalTo("userId", userId).findFirst()
                }
                if (healthPojo == null) {
                    healthPojo = realm.createObject(RealmMyHealthPojo::class.java, userId)
                }
                healthPojo.isUpdated = true
                healthPojo.userId = userModel?._id
                try {
                    val key = userModel?.key ?: generateKey().also { newKey -> userModel?.key = newKey }
                    val iv = userModel?.iv ?: generateIv().also { newIv -> userModel?.iv = newIv }
                    healthPojo.data = encrypt(Gson().toJson(myHealth), key, iv)
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
            finish()
        }
    }

    private fun initViews() {
        populate()
    }

    private fun populate() {
        databaseService.withRealm { realm ->
            val userModel = realm.where(RealmUserModel::class.java).equalTo("id", userId).findFirst()
            val healthPojo = realm.where(RealmMyHealthPojo::class.java).equalTo("_id", userId).findFirst()
                ?: realm.where(RealmMyHealthPojo::class.java).equalTo("userId", userId).findFirst()
            if (healthPojo != null && !TextUtils.isEmpty(healthPojo.data)) {
                myHealth = Gson().fromJson(
                    decrypt(healthPojo.data, userModel?.key, userModel?.iv),
                    RealmMyHealth::class.java
                )
                val health = myHealth?.profile
                binding.etEmergency.editText?.setText(health?.emergencyContactName)
                binding.etContact.editText?.setText(health?.emergencyContact)
                val contactTypes = resources.getStringArray(R.array.contact_type)
                val contactType = health?.emergencyContactType
                if (!contactType.isNullOrEmpty()) {
                    val index = contactTypes.indexOf(contactType)
                    if (index >= 0) {
                        binding.spnContactType.setSelection(index)
                    }
                }
                binding.etSpecialNeed.editText?.setText(health?.specialNeeds)
                binding.etOtherNeed.editText?.setText(health?.notes)
            }
            if (userModel != null) {
                binding.etFname.editText?.setText(userModel.firstName)
                binding.etMname.editText?.setText(userModel.middleName)
                binding.etLname.editText?.setText(userModel.lastName)
                binding.etEmail.editText?.setText(userModel.email)
                binding.etPhone.editText?.setText(userModel.phoneNumber)
                binding.etBirthdateLayout.editText?.setText(userModel.dob)
                binding.etBirthplace.editText?.setText(userModel.birthPlace)
            }
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == android.R.id.home) finish()
        return super.onOptionsItemSelected(item)
    }
}
=======
package org.ole.planet.myplanet.ui.myhealth


import android.app.DatePickerDialog
import android.os.Bundle
import android.text.TextUtils
import android.view.MenuItem
import android.view.View
import android.widget.ArrayAdapter
import android.widget.ImageView
import android.widget.Spinner
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.google.gson.Gson
import dagger.hilt.android.AndroidEntryPoint
import java.util.Calendar
import java.util.Locale
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityAddMyHealthBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyHealth
import org.ole.planet.myplanet.model.RealmMyHealth.RealmMyHealthProfile
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.decrypt
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.encrypt
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateIv
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateKey
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class AddMyHealthActivity : AppCompatActivity() {
    private lateinit var binding: ActivityAddMyHealthBinding
    @Inject
    lateinit var databaseService: DatabaseService
    var userId: String? = null
    private var myHealth: RealmMyHealth? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityAddMyHealthBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, binding.root)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.setHomeButtonEnabled(true)
        userId = intent.getStringExtra("userId")
        findViewById<View>(R.id.btn_submit).setOnClickListener {
            createMyHealth()
            Utilities.toast(this@AddMyHealthActivity, getString(R.string.my_health_saved_successfully))
        }

        val contactTypes = resources.getStringArray(R.array.contact_type)
        val contactAdapter = ArrayAdapter(this, R.layout.become_a_member_spinner_layout, contactTypes)
        findViewById<Spinner>(R.id.spn_contact_type).adapter = contactAdapter

        initViews()
        val datePickerClickListener = View.OnClickListener {
            val now = Calendar.getInstance()
            val dpd = DatePickerDialog(this, { _, year, month, dayOfMonth ->
                val selectedDate = String.format(Locale.US, "%04d-%02d-%02d", year, month + 1, dayOfMonth)
                binding.etBirthdateLayout.editText?.setText(selectedDate)
            }, now.get(Calendar.YEAR), now.get(Calendar.MONTH), now.get(Calendar.DAY_OF_MONTH))
            dpd.datePicker.maxDate = System.currentTimeMillis()
            dpd.show()
        }
        binding.etBirthdateLayout.editText?.setOnClickListener(datePickerClickListener)
        findViewById<ImageView>(R.id.iv_date_picker).setOnClickListener(datePickerClickListener)
    }

    private fun createMyHealth() {
        lifecycleScope.launch {
            databaseService.executeTransactionAsync { realm ->
                val userModel = realm.where(RealmUserModel::class.java).equalTo("id", userId).findFirst()
                val oldProfile = myHealth?.profile
                val health = RealmMyHealthProfile()
                userModel?.firstName = "${binding.etFname.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.middleName = "${binding.etMname.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.lastName = "${binding.etLname.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.email = "${binding.etEmail.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.dob = "${binding.etBirthdateLayout.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.birthPlace = "${binding.etBirthplace.editText?.text}".trim { ch -> ch <= ' ' }
                userModel?.phoneNumber = "${binding.etPhone.editText?.text}".trim { ch -> ch <= ' ' }
                health.emergencyContactName = "${binding.etEmergency.editText?.text}".trim { ch -> ch <= ' ' }
                val emergencyContact = "${binding.etContact.editText?.text}".trim { ch -> ch <= ' ' }
                health.emergencyContact = if (TextUtils.isEmpty(emergencyContact)) {
                    oldProfile?.emergencyContact ?: ""
                } else {
                    emergencyContact
                }
                val emergencyContactType = "${binding.spnContactType.selectedItem}".trim { ch -> ch <= ' ' }
                health.emergencyContactType = if (TextUtils.isEmpty(emergencyContactType)) {
                    oldProfile?.emergencyContactType ?: ""
                } else {
                    emergencyContactType
                }
                health.specialNeeds = "${binding.etSpecialNeed.editText?.text}".trim { ch -> ch <= ' ' }
                health.notes = "${binding.etOtherNeed.editText?.text}".trim { ch -> ch <= ' ' }
                if (myHealth == null) {
                    myHealth = RealmMyHealth()
                }
                if (TextUtils.isEmpty(myHealth?.userKey)) {
                    myHealth?.userKey = generateKey()
                }
                myHealth?.profile = health
                var healthPojo = realm.where(RealmMyHealthPojo::class.java).equalTo("_id", userId).findFirst()
                if (healthPojo == null) {
                    healthPojo = realm.where(RealmMyHealthPojo::class.java).equalTo("userId", userId).findFirst()
                }
                if (healthPojo == null) {
                    healthPojo = realm.createObject(RealmMyHealthPojo::class.java, userId)
                }
                healthPojo.isUpdated = true
                healthPojo.userId = userModel?._id
                try {
                    val key = userModel?.key ?: generateKey().also { newKey -> userModel?.key = newKey }
                    val iv = userModel?.iv ?: generateIv().also { newIv -> userModel?.iv = newIv }
                    healthPojo.data = encrypt(Gson().toJson(myHealth), key, iv)
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
            finish()
        }
    }

    private fun initViews() {
        populate()
    }

    private fun populate() {
        databaseService.withRealm { realm ->
            val userModel = realm.where(RealmUserModel::class.java).equalTo("id", userId).findFirst()
            val healthPojo = realm.where(RealmMyHealthPojo::class.java).equalTo("_id", userId).findFirst()
                ?: realm.where(RealmMyHealthPojo::class.java).equalTo("userId", userId).findFirst()
            if (healthPojo != null && !TextUtils.isEmpty(healthPojo.data)) {
                myHealth = Gson().fromJson(
                    decrypt(healthPojo.data, userModel?.key, userModel?.iv),
                    RealmMyHealth::class.java
                )
                val health = myHealth?.profile
                binding.etEmergency.editText?.setText(health?.emergencyContactName)
                binding.etContact.editText?.setText(health?.emergencyContact)
                val contactTypes = resources.getStringArray(R.array.contact_type)
                val contactType = health?.emergencyContactType
                if (!contactType.isNullOrEmpty()) {
                    val index = contactTypes.indexOf(contactType)
                    if (index >= 0) {
                        binding.spnContactType.setSelection(index)
                    }
                }
                binding.etSpecialNeed.editText?.setText(health?.specialNeeds)
                binding.etOtherNeed.editText?.setText(health?.notes)
            }
            if (userModel != null) {
                binding.etFname.editText?.setText(userModel.firstName)
                binding.etMname.editText?.setText(userModel.middleName)
                binding.etLname.editText?.setText(userModel.lastName)
                binding.etEmail.editText?.setText(userModel.email)
                binding.etPhone.editText?.setText(userModel.phoneNumber)
                binding.etBirthdateLayout.editText?.setText(userModel.dob)
                binding.etBirthplace.editText?.setText(userModel.birthPlace)
            }
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == android.R.id.home) finish()
        return super.onOptionsItemSelected(item)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/resources/ResourcesFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.resources

import android.app.AlertDialog
import android.content.Context
import android.content.Context.MODE_PRIVATE
import android.content.DialogInterface
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import fisk.chipcloud.ChipCloud
import fisk.chipcloud.ChipCloudConfig
import fisk.chipcloud.ChipDeletedListener
import java.util.Calendar
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment
import org.ole.planet.myplanet.callback.OnFilterListener
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.OnLibraryItemSelected
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.callback.TagClickListener
import org.ole.planet.myplanet.databinding.FragmentMyLibraryBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getArrayList
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getLevels
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getSubjects
import org.ole.planet.myplanet.model.RealmRating.Companion.getRatings
import org.ole.planet.myplanet.model.RealmSearchActivity
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmTag.Companion.getTagsArray
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.sync.RealtimeSyncHelper
import org.ole.planet.myplanet.ui.sync.RealtimeSyncMixin
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.DialogUtils.guestDialog
import org.ole.planet.myplanet.utilities.KeyboardUtils.setupUI
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class ResourcesFragment : BaseRecyclerFragment<RealmMyLibrary?>(), OnLibraryItemSelected,
    ChipDeletedListener, TagClickListener, OnFilterListener, RealtimeSyncMixin {
    private var _binding: FragmentMyLibraryBinding? = null
    private val binding get() = _binding!!
    private val tvAddToLib get() = binding.tvAdd
    private val tvSelected get() = binding.tvSelected
    private val etSearch get() = binding.layoutSearch.etSearch
    private val flexBoxTags get() = binding.layoutSearch.flexboxTags
    private val clearTags get() = binding.btnClearTags
    private val selectAll get() = binding.selectAll
    private val filter get() = binding.filter
    private lateinit var searchTags: MutableList<RealmTag>
    private lateinit var config: ChipCloudConfig
    private lateinit var adapterLibrary: AdapterResource
    var userModel: RealmUserModel ?= null
    var map: HashMap<String?, JsonObject>? = null
    private var confirmation: AlertDialog? = null
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    private var searchTextWatcher: TextWatcher? = null

    @Inject
    lateinit var prefManager: SharedPrefManager

    @Inject
    lateinit var syncManager: SyncManager

    @Inject
    lateinit var tagRepository: TagRepository

    @Inject
    lateinit var serverUrlMapper: ServerUrlMapper
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    private lateinit var realtimeSyncHelper: RealtimeSyncHelper

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        settings = requireActivity().getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        startResourcesSync()
    }

    override fun getLayout(): Int {
        return R.layout.fragment_my_library
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        val view = super.onCreateView(inflater, container, savedInstanceState)
        _binding = view?.let { FragmentMyLibraryBinding.bind(it) }
        return view
    }

    private fun startResourcesSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isResourcesSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(getString(R.string.syncing_resources))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        refreshResourcesData()
                        prefManager.setResourcesSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null

                        Snackbar.make(requireView(), "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG
                        ).setAction("Retry") {
                            startResourcesSync()
                        }.show()
                    }
                }
            }
        }, "full", listOf("resources"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun refreshResourcesData() {
        if (!isAdded || requireActivity().isFinishing) return

        try {
            map = getRatings(mRealm, "resource", model?.id)
            val libraryList: List<RealmMyLibrary?> = getList(RealmMyLibrary::class.java).filterIsInstance<RealmMyLibrary?>()
            val currentSearchTags = if (::searchTags.isInitialized) searchTags else emptyList()
            val searchQuery = etSearch.text?.toString()?.trim().orEmpty()
            val filteredLibraryList: List<RealmMyLibrary?> =
                if (currentSearchTags.isEmpty() && searchQuery.isEmpty()) {
                    applyFilter(libraryList.filterNotNull()).map { it }
                } else {
                    applyFilter(filterLibraryByTag(searchQuery, currentSearchTags)).map { it }
                }

            adapterLibrary.setLibraryList(filteredLibraryList)
            adapterLibrary.setRatingMap(map!!)
            checkList()
            showNoData(tvMessage, adapterLibrary.itemCount, "resources")

        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    override fun getAdapter(): RecyclerView.Adapter<*> {
        map = getRatings(mRealm, "resource", model?.id)
        val libraryList: List<RealmMyLibrary?> = getList(RealmMyLibrary::class.java).filterIsInstance<RealmMyLibrary?>()
        adapterLibrary = AdapterResource(requireActivity(), libraryList, map!!, tagRepository, profileDbHandler?.userModel)
        adapterLibrary.setRatingChangeListener(this)
        adapterLibrary.setListener(this)
        return adapterLibrary
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        isMyCourseLib = arguments?.getBoolean("isMyCourseLib", false) ?: false
        userModel = profileDbHandler?.userModel
        searchTags = ArrayList()
        config = Utilities.getCloudConfig().showClose(R.color.black_overlay)

        initializeViews()
        setupEventListeners()
        initArrays()
        hideButton()

        setupGuestUserRestrictions()

        showNoData(tvMessage, adapterLibrary.itemCount, "resources")
        clearTagsButton()
        setupUI(binding.myLibraryParentLayout, requireActivity())
        changeButtonStatus()
        additionalSetup()

        tvFragmentInfo = binding.tvFragmentInfo
        if (isMyCourseLib) tvFragmentInfo.setText(R.string.txt_myLibrary)
        checkList()

        realtimeSyncHelper = RealtimeSyncHelper(this, this)
        realtimeSyncHelper.setupRealtimeSync()
    }

    private fun initializeViews() {
        if (tvSelected.text.isNullOrEmpty()) {
            tvSelected.visibility = View.GONE
        } else {
            tvSelected.visibility = View.VISIBLE
        }
    }

    private fun setupGuestUserRestrictions() {
        if(userModel?.isGuest() == true){
            tvAddToLib.visibility = View.GONE
            selectAll.visibility = View.GONE
        }
    }

    private fun setupEventListeners() {
        setupAddToLibListener()
        setupDeleteListener()
        setupSearchTextListener()
        setupCollectionsButton()
        setupSelectAllListener()
        setupAddResourceButtonListener()
    }

    private fun setupAddToLibListener() {
        tvAddToLib.setOnClickListener {
            if ((selectedItems?.size ?: 0) > 0) {
                confirmation = createAlertDialog()
                confirmation?.show()
                addToMyList()
                selectedItems?.clear()
                tvAddToLib.isEnabled = false
                checkList()
            }
        }
    }

    private fun setupDeleteListener() {
        tvDelete?.setOnClickListener {
            AlertDialog.Builder(this.context, R.style.AlertDialogTheme)
                .setMessage(R.string.confirm_removal)
                .setPositiveButton(R.string.yes) { _, _ ->
                    deleteSelected(true)
                    val newFragment = ResourcesFragment()
                    recreateFragment(newFragment)
                }
                .setNegativeButton(R.string.no, null).show()
        }
    }

    private fun setupSearchTextListener() {
        searchTextWatcher = object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                adapterLibrary.setLibraryList(
                    applyFilter(
                        filterLibraryByTag(
                            etSearch.text.toString().trim(), searchTags
                        )
                    )
                )
                showNoData(tvMessage, adapterLibrary.itemCount, "resources")
            }

            override fun afterTextChanged(s: Editable) {}
        }
        etSearch.addTextChangedListener(searchTextWatcher)
    }

    private fun setupCollectionsButton() {
        binding.btnCollections.setOnClickListener {
            val f = CollectionsFragment.getInstance(searchTags, "resources")
            f.setListener(this@ResourcesFragment)
            f.show(childFragmentManager, "")
        }
    }

    private fun setupSelectAllListener() {
        selectAll.setOnClickListener {
            hideButton()
            val allSelected = selectedItems?.size == adapterLibrary.getLibraryList().size
            adapterLibrary.selectAllItems(!allSelected)
            if (allSelected) {
                selectAll.isChecked = false
                selectAll.text = getString(R.string.select_all)
            } else {
                selectAll.isChecked = true
                selectAll.text = getString(R.string.unselect_all)
            }
        }
    }

    private fun setupAddResourceButtonListener() {
        binding.addResource.setOnClickListener {
            if (userModel?.id?.startsWith("guest") == false) {
                AddResourceFragment().show(childFragmentManager, getString(R.string.add_res))
            } else {
                guestDialog(requireContext())
            }
        }
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) {
            homeItemClickListener = context
        }
    }

    private fun hideButton(){
        tvDelete?.isEnabled = selectedItems?.size!! != 0
        tvAddToLib.isEnabled = selectedItems?.size!! != 0
        if(selectedItems?.size!! != 0){
            if(isMyCourseLib) tvDelete?.visibility = View.VISIBLE
            else tvAddToLib.visibility = View.VISIBLE
        } else {
            if(isMyCourseLib) tvDelete?.visibility = View.GONE
            else tvAddToLib.visibility = View.GONE
        }
    }

    private fun checkList() {
        if (adapterLibrary.getLibraryList().isEmpty()) {
            selectAll.visibility = View.GONE
            etSearch.visibility = View.GONE
            tvAddToLib.visibility = View.GONE
            tvSelected.visibility = View.GONE
            binding.btnCollections.visibility = View.GONE
            filter.visibility = View.GONE
            clearTags.visibility = View.GONE
            tvDelete?.visibility = View.GONE
        } else {
            selectAll.visibility = View.VISIBLE
            etSearch.visibility = View.VISIBLE
            binding.btnCollections.visibility = View.VISIBLE
            filter.visibility = View.VISIBLE
        }
    }

    private fun initArrays() {
        subjects = HashSet()
        languages = HashSet()
        levels = HashSet()
        mediums = HashSet()
    }

    private fun createAlertDialog(): AlertDialog {
        val builder = AlertDialog.Builder(requireContext(), R.style.CustomAlertDialog)
        builder.setMessage(buildAlertMessage())
        builder.setCancelable(true)
            .setPositiveButton(R.string.go_to_mylibrary) { dialog: DialogInterface, _: Int ->
                if (userModel?.id?.startsWith("guest") == true) {
                    guestDialog(requireContext())
                } else {
                    val fragment = ResourcesFragment().apply {
                        arguments = Bundle().apply {
                            putBoolean("isMyCourseLib", true)
                        }
                    }
                    homeItemClickListener?.openMyFragment(fragment)
                }
            }
        builder.setNegativeButton(getString(R.string.ok)) { dialog: DialogInterface, _: Int ->
            dialog.cancel()
            val newFragment = ResourcesFragment()
            recreateFragment(newFragment)
        }
        builder.setOnDismissListener{
            val newFragment = ResourcesFragment()
            recreateFragment(newFragment)
        }
        return builder.create()
    }

    private fun buildAlertMessage(): String {
        var msg = getString(R.string.success_you_have_added_these_resources_to_your_mylibrary)
        if ((selectedItems?.size ?: 0) <= 5) {
            for (i in selectedItems?.indices ?: emptyList()) {
                msg += " - " + selectedItems!![i]?.title + "\n"
            }
        } else {
            for (i in 0..4) {
                msg += " - " + selectedItems?.get(i)?.title + "\n"
            }
            msg += getString(R.string.and) + ((selectedItems?.size ?: 0) - 5) +
                getString(R.string.more_resource_s)
        }
        msg += getString(R.string.return_to_the_home_tab_to_access_mylibrary) +
            getString(R.string.note_you_may_still_need_to_download_the_newly_added_resources)
        return msg
    }

    private fun clearTagsButton() {
        clearTags.setOnClickListener {
            saveSearchActivity()
            searchTags.clear()
            etSearch.setText(R.string.empty_text)
            tvSelected.text = getString(R.string.empty_text)
            levels.clear()
            mediums.clear()
            subjects.clear()
            languages.clear()
            adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag("", searchTags)))
            showNoData(tvMessage, adapterLibrary.itemCount, "resources")
        }
    }

    override fun onSelectedListChange(list: MutableList<RealmMyLibrary?>) {
        selectedItems = list
        changeButtonStatus()
        hideButton()
    }

    override fun onTagClicked(realmTag: RealmTag) {
        tvSelected.visibility = View.VISIBLE
        flexBoxTags.removeAllViews()
        val chipCloud = ChipCloud(activity, flexBoxTags, config)
        chipCloud.setDeleteListener(this)
        if (!searchTags.contains(realmTag)) searchTags.add(realmTag)
        chipCloud.addChips(searchTags)
        adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag(etSearch.text.toString(), searchTags)))
        showTagText(searchTags, tvSelected)
        showNoData(tvMessage, adapterLibrary.itemCount, "resources")
    }

    override fun onTagSelected(tag: RealmTag) {
        tvSelected.visibility = View.VISIBLE
        val li: MutableList<RealmTag> = ArrayList()
        li.add(tag)
        searchTags = li
        tvSelected.text = getString(R.string.tag_selected, tag.name)
        adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag(etSearch.text.toString(), li)))
        showNoData(tvMessage, adapterLibrary.itemCount, "resources")
    }

    override fun onOkClicked(list: List<RealmTag>?) {
        if (list?.isEmpty() == true) {
            searchTags.clear()
            adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag(etSearch.text.toString(), searchTags)))
            showNoData(tvMessage, adapterLibrary.itemCount, "resources")
        } else {
            for (tag in list ?: emptyList()) {
                onTagClicked(tag)
            }
        }
    }

    private fun changeButtonStatus() {
        tvAddToLib.isEnabled = (selectedItems?.size ?: 0) > 0
        if (adapterLibrary.areAllSelected()) {
            selectAll.isChecked = true
            selectAll.text = getString(R.string.unselect_all)
        } else {
            selectAll.isChecked = false
            selectAll.text = getString(R.string.select_all)
        }
    }

    override fun chipDeleted(i: Int, s: String) {
        searchTags.removeAt(i)
        adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag(etSearch.text.toString(), searchTags)))
        showNoData(tvMessage, adapterLibrary.itemCount, "resources")
    }

    override fun filter(subjects: MutableSet<String>, languages: MutableSet<String>, mediums: MutableSet<String>, levels: MutableSet<String>) {
        this.subjects = subjects
        this.languages = languages
        this.mediums = mediums
        this.levels = levels
        adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag(etSearch.text.toString().trim { it <= ' ' }, searchTags)))
        showNoData(tvMessage, adapterLibrary.itemCount, "resources")
    }

    override fun getData(): Map<String, Set<String>> {
        val libraryList = adapterLibrary.getLibraryList().filterNotNull()
        val b: MutableMap<String, Set<String>> = HashMap()
        b["languages"] = libraryList.let { getArrayList(it, "languages").filterNotNull().toSet() }
        b["subjects"] = libraryList.let { getSubjects(it).toList().toSet() }
        b["mediums"] = getArrayList(libraryList, "mediums").filterNotNull().toSet()
        b["levels"] = getLevels(libraryList).toList().toSet()
        return b
    }

    override fun getSelectedFilter(): Map<String, Set<String>> {
        val b: MutableMap<String, Set<String>> = HashMap()
        b["languages"] = languages
        b["subjects"] = subjects
        b["mediums"] = mediums
        b["levels"] = levels
        return b
    }

    override fun onResume() {
        super.onResume()
        refreshResourcesData()
        selectAll.isChecked = false
    }

    override fun onPause() {
        super.onPause()
        saveSearchActivity()
    }

    override fun onDestroyView() {
        etSearch.removeTextChangedListener(searchTextWatcher)
        searchTextWatcher = null

        if (confirmation?.isShowing == true) {
            confirmation?.dismiss()
        }
        confirmation = null

        if (customProgressDialog?.isShowing() == true) {
            customProgressDialog?.dismiss()
        }
        customProgressDialog = null

        if (::realtimeSyncHelper.isInitialized) {
            realtimeSyncHelper.cleanup()
        }

        _binding = null
        super.onDestroyView()
    }

    private fun filterApplied(): Boolean {
        return !(subjects.isEmpty() && languages.isEmpty()
                && mediums.isEmpty() && levels.isEmpty()
                && searchTags.isEmpty() && "${etSearch.text}".isEmpty())
    }

    private fun saveSearchActivity() {
        if (!filterApplied()) {
            return
        }

        val userName = model?.name ?: return
        val planetCode = model?.planetCode ?: return
        val parentCode = model?.parentCode ?: return
        val searchText = etSearch.text?.toString().orEmpty()
        val filter = JsonObject().apply {
            add("tags", getTagsArray(searchTags))
            add("subjects", getJsonArrayFromList(subjects))
            add("language", getJsonArrayFromList(languages))
            add("level", getJsonArrayFromList(levels))
            add("mediaType", getJsonArrayFromList(mediums))
        }
        val filterPayload = Gson().toJson(filter)
        val createdAt = Calendar.getInstance().timeInMillis
        val activityId = UUID.randomUUID().toString()

        lifecycleScope.launch {
            databaseService.executeTransactionAsync { realm ->
                val activity = realm.createObject(RealmSearchActivity::class.java, activityId)
                activity.user = userName
                activity.time = createdAt
                activity.createdOn = planetCode
                activity.parentCode = parentCode
                activity.text = searchText
                activity.type = "resources"
                activity.filter = filterPayload
            }
        }
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        super.onDestroy()
    }

    private fun recreateFragment(fragment: Fragment) {
        if (isAdded && activity != null && !requireActivity().isFinishing) {
            if (isMyCourseLib) {
                val args = Bundle().apply {
                    putBoolean("isMyCourseLib", true)
                }
                fragment.arguments = args
            }
            NavigationHelper.replaceFragment(
                parentFragmentManager,
                R.id.fragment_container,
                fragment,
                addToBackStack = true
            )
        }
    }

    private fun additionalSetup() {
        val bottomSheet = binding.cardFilter
        filter.setOnClickListener {
            bottomSheet.visibility = if (bottomSheet.isVisible) View.GONE else View.VISIBLE
        }
        binding.filterCategories.setOnClickListener {
            val f = ResourcesFilterFragment()
            f.setListener(this)
            f.show(childFragmentManager, "")
            bottomSheet.visibility = View.GONE
        }
        binding.orderByDateButton.setOnClickListener { adapterLibrary.toggleSortOrder() }
        binding.orderByTitleButton.setOnClickListener { adapterLibrary.toggleTitleSortOrder() }
    }

    override fun getWatchedTables(): List<String> {
        return listOf("resources")
    }

    override fun onDataUpdated(table: String, update: TableDataUpdate) {
        if (table == "resources" && update.shouldRefreshUI) {
            refreshResourcesData()
        }
    }

    override fun getSyncRecyclerView(): RecyclerView? {
        return if (::recyclerView.isInitialized) recyclerView else null
    }

}
=======
package org.ole.planet.myplanet.ui.resources


import android.app.AlertDialog
import android.content.Context
import android.content.Context.MODE_PRIVATE
import android.content.DialogInterface
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import fisk.chipcloud.ChipCloud
import fisk.chipcloud.ChipCloudConfig
import fisk.chipcloud.ChipDeletedListener
import java.util.Calendar
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment
import org.ole.planet.myplanet.callback.OnFilterListener
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.OnLibraryItemSelected
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.callback.TagClickListener
import org.ole.planet.myplanet.databinding.FragmentMyLibraryBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getArrayList
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getLevels
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getSubjects
import org.ole.planet.myplanet.model.RealmRating.Companion.getRatings
import org.ole.planet.myplanet.model.RealmSearchActivity
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmTag.Companion.getTagsArray
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.sync.RealtimeSyncHelper
import org.ole.planet.myplanet.ui.sync.RealtimeSyncMixin
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.DialogUtils.guestDialog
import org.ole.planet.myplanet.utilities.KeyboardUtils.setupUI
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class ResourcesFragment : BaseRecyclerFragment<RealmMyLibrary?>(), OnLibraryItemSelected,
    ChipDeletedListener, TagClickListener, OnFilterListener, RealtimeSyncMixin {
    private var _binding: FragmentMyLibraryBinding? = null
    private val binding get() = _binding!!
    private val tvAddToLib get() = binding.tvAdd
    private val tvSelected get() = binding.tvSelected
    private val etSearch get() = binding.layoutSearch.etSearch
    private val flexBoxTags get() = binding.layoutSearch.flexboxTags
    private val clearTags get() = binding.btnClearTags
    private val selectAll get() = binding.selectAll
    private val filter get() = binding.filter
    private lateinit var searchTags: MutableList<RealmTag>
    private lateinit var config: ChipCloudConfig
    private lateinit var adapterLibrary: AdapterResource
    var userModel: RealmUserModel ?= null
    var map: HashMap<String?, JsonObject>? = null
    private var confirmation: AlertDialog? = null
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    private var searchTextWatcher: TextWatcher? = null

    @Inject
    lateinit var prefManager: SharedPrefManager

    @Inject
    lateinit var syncManager: SyncManager

    @Inject
    lateinit var tagRepository: TagRepository

    @Inject
    lateinit var serverUrlMapper: ServerUrlMapper
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    private lateinit var realtimeSyncHelper: RealtimeSyncHelper

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        settings = requireActivity().getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        startResourcesSync()
    }

    override fun getLayout(): Int {
        return R.layout.fragment_my_library
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        val view = super.onCreateView(inflater, container, savedInstanceState)
        _binding = view?.let { FragmentMyLibraryBinding.bind(it) }
        return view
    }

    private fun startResourcesSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isResourcesSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(getString(R.string.syncing_resources))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        refreshResourcesData()
                        prefManager.setResourcesSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null

                        Snackbar.make(requireView(), "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG
                        ).setAction("Retry") {
                            startResourcesSync()
                        }.show()
                    }
                }
            }
        }, "full", listOf("resources"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun refreshResourcesData() {
        if (!isAdded || requireActivity().isFinishing) return

        try {
            map = getRatings(mRealm, "resource", model?.id)
            val libraryList: List<RealmMyLibrary?> = getList(RealmMyLibrary::class.java).filterIsInstance<RealmMyLibrary?>()
            val currentSearchTags = if (::searchTags.isInitialized) searchTags else emptyList()
            val searchQuery = etSearch.text?.toString()?.trim().orEmpty()
            val filteredLibraryList: List<RealmMyLibrary?> =
                if (currentSearchTags.isEmpty() && searchQuery.isEmpty()) {
                    applyFilter(libraryList.filterNotNull()).map { it }
                } else {
                    applyFilter(filterLibraryByTag(searchQuery, currentSearchTags)).map { it }
                }

            adapterLibrary.setLibraryList(filteredLibraryList)
            adapterLibrary.setRatingMap(map!!)
            checkList()
            showNoData(tvMessage, adapterLibrary.itemCount, "resources")

        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    override fun getAdapter(): RecyclerView.Adapter<*> {
        map = getRatings(mRealm, "resource", model?.id)
        val libraryList: List<RealmMyLibrary?> = getList(RealmMyLibrary::class.java).filterIsInstance<RealmMyLibrary?>()
        adapterLibrary = AdapterResource(requireActivity(), libraryList, map!!, tagRepository, profileDbHandler?.userModel)
        adapterLibrary.setRatingChangeListener(this)
        adapterLibrary.setListener(this)
        return adapterLibrary
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        isMyCourseLib = arguments?.getBoolean("isMyCourseLib", false) ?: false
        userModel = profileDbHandler?.userModel
        searchTags = ArrayList()
        config = Utilities.getCloudConfig().showClose(R.color.black_overlay)

        initializeViews()
        setupEventListeners()
        initArrays()
        hideButton()

        setupGuestUserRestrictions()

        showNoData(tvMessage, adapterLibrary.itemCount, "resources")
        clearTagsButton()
        setupUI(binding.myLibraryParentLayout, requireActivity())
        changeButtonStatus()
        additionalSetup()

        tvFragmentInfo = binding.tvFragmentInfo
        if (isMyCourseLib) tvFragmentInfo.setText(R.string.txt_myLibrary)
        checkList()

        realtimeSyncHelper = RealtimeSyncHelper(this, this)
        realtimeSyncHelper.setupRealtimeSync()
    }

    private fun initializeViews() {
        if (tvSelected.text.isNullOrEmpty()) {
            tvSelected.visibility = View.GONE
        } else {
            tvSelected.visibility = View.VISIBLE
        }
    }

    private fun setupGuestUserRestrictions() {
        if(userModel?.isGuest() == true){
            tvAddToLib.visibility = View.GONE
            selectAll.visibility = View.GONE
        }
    }

    private fun setupEventListeners() {
        setupAddToLibListener()
        setupDeleteListener()
        setupSearchTextListener()
        setupCollectionsButton()
        setupSelectAllListener()
        setupAddResourceButtonListener()
    }

    private fun setupAddToLibListener() {
        tvAddToLib.setOnClickListener {
            if ((selectedItems?.size ?: 0) > 0) {
                confirmation = createAlertDialog()
                confirmation?.show()
                addToMyList()
                selectedItems?.clear()
                tvAddToLib.isEnabled = false
                checkList()
            }
        }
    }

    private fun setupDeleteListener() {
        tvDelete?.setOnClickListener {
            AlertDialog.Builder(this.context, R.style.AlertDialogTheme)
                .setMessage(R.string.confirm_removal)
                .setPositiveButton(R.string.yes) { _, _ ->
                    deleteSelected(true)
                    val newFragment = ResourcesFragment()
                    recreateFragment(newFragment)
                }
                .setNegativeButton(R.string.no, null).show()
        }
    }

    private fun setupSearchTextListener() {
        searchTextWatcher = object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                adapterLibrary.setLibraryList(
                    applyFilter(
                        filterLibraryByTag(
                            etSearch.text.toString().trim(), searchTags
                        )
                    )
                )
                showNoData(tvMessage, adapterLibrary.itemCount, "resources")
            }

            override fun afterTextChanged(s: Editable) {}
        }
        etSearch.addTextChangedListener(searchTextWatcher)
    }

    private fun setupCollectionsButton() {
        binding.btnCollections.setOnClickListener {
            val f = CollectionsFragment.getInstance(searchTags, "resources")
            f.setListener(this@ResourcesFragment)
            f.show(childFragmentManager, "")
        }
    }

    private fun setupSelectAllListener() {
        selectAll.setOnClickListener {
            hideButton()
            val allSelected = selectedItems?.size == adapterLibrary.getLibraryList().size
            adapterLibrary.selectAllItems(!allSelected)
            if (allSelected) {
                selectAll.isChecked = false
                selectAll.text = getString(R.string.select_all)
            } else {
                selectAll.isChecked = true
                selectAll.text = getString(R.string.unselect_all)
            }
        }
    }

    private fun setupAddResourceButtonListener() {
        binding.addResource.setOnClickListener {
            if (userModel?.id?.startsWith("guest") == false) {
                AddResourceFragment().show(childFragmentManager, getString(R.string.add_res))
            } else {
                guestDialog(requireContext())
            }
        }
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) {
            homeItemClickListener = context
        }
    }

    private fun hideButton(){
        tvDelete?.isEnabled = selectedItems?.size!! != 0
        tvAddToLib.isEnabled = selectedItems?.size!! != 0
        if(selectedItems?.size!! != 0){
            if(isMyCourseLib) tvDelete?.visibility = View.VISIBLE
            else tvAddToLib.visibility = View.VISIBLE
        } else {
            if(isMyCourseLib) tvDelete?.visibility = View.GONE
            else tvAddToLib.visibility = View.GONE
        }
    }

    private fun checkList() {
        if (adapterLibrary.getLibraryList().isEmpty()) {
            selectAll.visibility = View.GONE
            etSearch.visibility = View.GONE
            tvAddToLib.visibility = View.GONE
            tvSelected.visibility = View.GONE
            binding.btnCollections.visibility = View.GONE
            filter.visibility = View.GONE
            clearTags.visibility = View.GONE
            tvDelete?.visibility = View.GONE
        } else {
            selectAll.visibility = View.VISIBLE
            etSearch.visibility = View.VISIBLE
            binding.btnCollections.visibility = View.VISIBLE
            filter.visibility = View.VISIBLE
        }
    }

    private fun initArrays() {
        subjects = HashSet()
        languages = HashSet()
        levels = HashSet()
        mediums = HashSet()
    }

    private fun createAlertDialog(): AlertDialog {
        val builder = AlertDialog.Builder(requireContext(), R.style.CustomAlertDialog)
        builder.setMessage(buildAlertMessage())
        builder.setCancelable(true)
            .setPositiveButton(R.string.go_to_mylibrary) { dialog: DialogInterface, _: Int ->
                if (userModel?.id?.startsWith("guest") == true) {
                    guestDialog(requireContext())
                } else {
                    val fragment = ResourcesFragment().apply {
                        arguments = Bundle().apply {
                            putBoolean("isMyCourseLib", true)
                        }
                    }
                    homeItemClickListener?.openMyFragment(fragment)
                }
            }
        builder.setNegativeButton(getString(R.string.ok)) { dialog: DialogInterface, _: Int ->
            dialog.cancel()
            val newFragment = ResourcesFragment()
            recreateFragment(newFragment)
        }
        builder.setOnDismissListener{
            val newFragment = ResourcesFragment()
            recreateFragment(newFragment)
        }
        return builder.create()
    }

    private fun buildAlertMessage(): String {
        var msg = getString(R.string.success_you_have_added_these_resources_to_your_mylibrary)
        if ((selectedItems?.size ?: 0) <= 5) {
            for (i in selectedItems?.indices ?: emptyList()) {
                msg += " - " + selectedItems!![i]?.title + "\n"
            }
        } else {
            for (i in 0..4) {
                msg += " - " + selectedItems?.get(i)?.title + "\n"
            }
            msg += getString(R.string.and) + ((selectedItems?.size ?: 0) - 5) +
                getString(R.string.more_resource_s)
        }
        msg += getString(R.string.return_to_the_home_tab_to_access_mylibrary) +
            getString(R.string.note_you_may_still_need_to_download_the_newly_added_resources)
        return msg
    }

    private fun clearTagsButton() {
        clearTags.setOnClickListener {
            saveSearchActivity()
            searchTags.clear()
            etSearch.setText(R.string.empty_text)
            tvSelected.text = getString(R.string.empty_text)
            levels.clear()
            mediums.clear()
            subjects.clear()
            languages.clear()
            adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag("", searchTags)))
            showNoData(tvMessage, adapterLibrary.itemCount, "resources")
        }
    }

    override fun onSelectedListChange(list: MutableList<RealmMyLibrary?>) {
        selectedItems = list
        changeButtonStatus()
        hideButton()
    }

    override fun onTagClicked(realmTag: RealmTag) {
        tvSelected.visibility = View.VISIBLE
        flexBoxTags.removeAllViews()
        val chipCloud = ChipCloud(activity, flexBoxTags, config)
        chipCloud.setDeleteListener(this)
        if (!searchTags.contains(realmTag)) searchTags.add(realmTag)
        chipCloud.addChips(searchTags)
        adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag(etSearch.text.toString(), searchTags)))
        showTagText(searchTags, tvSelected)
        showNoData(tvMessage, adapterLibrary.itemCount, "resources")
    }

    override fun onTagSelected(tag: RealmTag) {
        tvSelected.visibility = View.VISIBLE
        val li: MutableList<RealmTag> = ArrayList()
        li.add(tag)
        searchTags = li
        tvSelected.text = getString(R.string.tag_selected, tag.name)
        adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag(etSearch.text.toString(), li)))
        showNoData(tvMessage, adapterLibrary.itemCount, "resources")
    }

    override fun onOkClicked(list: List<RealmTag>?) {
        if (list?.isEmpty() == true) {
            searchTags.clear()
            adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag(etSearch.text.toString(), searchTags)))
            showNoData(tvMessage, adapterLibrary.itemCount, "resources")
        } else {
            for (tag in list ?: emptyList()) {
                onTagClicked(tag)
            }
        }
    }

    private fun changeButtonStatus() {
        tvAddToLib.isEnabled = (selectedItems?.size ?: 0) > 0
        if (adapterLibrary.areAllSelected()) {
            selectAll.isChecked = true
            selectAll.text = getString(R.string.unselect_all)
        } else {
            selectAll.isChecked = false
            selectAll.text = getString(R.string.select_all)
        }
    }

    override fun chipDeleted(i: Int, s: String) {
        searchTags.removeAt(i)
        adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag(etSearch.text.toString(), searchTags)))
        showNoData(tvMessage, adapterLibrary.itemCount, "resources")
    }

    override fun filter(subjects: MutableSet<String>, languages: MutableSet<String>, mediums: MutableSet<String>, levels: MutableSet<String>) {
        this.subjects = subjects
        this.languages = languages
        this.mediums = mediums
        this.levels = levels
        adapterLibrary.setLibraryList(applyFilter(filterLibraryByTag(etSearch.text.toString().trim { it <= ' ' }, searchTags)))
        showNoData(tvMessage, adapterLibrary.itemCount, "resources")
    }

    override fun getData(): Map<String, Set<String>> {
        val libraryList = adapterLibrary.getLibraryList().filterNotNull()
        val b: MutableMap<String, Set<String>> = HashMap()
        b["languages"] = libraryList.let { getArrayList(it, "languages").filterNotNull().toSet() }
        b["subjects"] = libraryList.let { getSubjects(it).toList().toSet() }
        b["mediums"] = getArrayList(libraryList, "mediums").filterNotNull().toSet()
        b["levels"] = getLevels(libraryList).toList().toSet()
        return b
    }

    override fun getSelectedFilter(): Map<String, Set<String>> {
        val b: MutableMap<String, Set<String>> = HashMap()
        b["languages"] = languages
        b["subjects"] = subjects
        b["mediums"] = mediums
        b["levels"] = levels
        return b
    }

    override fun onResume() {
        super.onResume()
        refreshResourcesData()
        selectAll.isChecked = false
    }

    override fun onPause() {
        super.onPause()
        saveSearchActivity()
    }

    override fun onDestroyView() {
        etSearch.removeTextChangedListener(searchTextWatcher)
        searchTextWatcher = null

        if (confirmation?.isShowing == true) {
            confirmation?.dismiss()
        }
        confirmation = null

        if (customProgressDialog?.isShowing() == true) {
            customProgressDialog?.dismiss()
        }
        customProgressDialog = null

        if (::realtimeSyncHelper.isInitialized) {
            realtimeSyncHelper.cleanup()
        }

        _binding = null
        super.onDestroyView()
    }

    private fun filterApplied(): Boolean {
        return !(subjects.isEmpty() && languages.isEmpty()
                && mediums.isEmpty() && levels.isEmpty()
                && searchTags.isEmpty() && "${etSearch.text}".isEmpty())
    }

    private fun saveSearchActivity() {
        if (!filterApplied()) {
            return
        }

        val userName = model?.name ?: return
        val planetCode = model?.planetCode ?: return
        val parentCode = model?.parentCode ?: return
        val searchText = etSearch.text?.toString().orEmpty()
        val filter = JsonObject().apply {
            add("tags", getTagsArray(searchTags))
            add("subjects", getJsonArrayFromList(subjects))
            add("language", getJsonArrayFromList(languages))
            add("level", getJsonArrayFromList(levels))
            add("mediaType", getJsonArrayFromList(mediums))
        }
        val filterPayload = Gson().toJson(filter)
        val createdAt = Calendar.getInstance().timeInMillis
        val activityId = UUID.randomUUID().toString()

        lifecycleScope.launch {
            databaseService.executeTransactionAsync { realm ->
                val activity = realm.createObject(RealmSearchActivity::class.java, activityId)
                activity.user = userName
                activity.time = createdAt
                activity.createdOn = planetCode
                activity.parentCode = parentCode
                activity.text = searchText
                activity.type = "resources"
                activity.filter = filterPayload
            }
        }
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        super.onDestroy()
    }

    private fun recreateFragment(fragment: Fragment) {
        if (isAdded && activity != null && !requireActivity().isFinishing) {
            if (isMyCourseLib) {
                val args = Bundle().apply {
                    putBoolean("isMyCourseLib", true)
                }
                fragment.arguments = args
            }
            NavigationHelper.replaceFragment(
                parentFragmentManager,
                R.id.fragment_container,
                fragment,
                addToBackStack = true
            )
        }
    }

    private fun additionalSetup() {
        val bottomSheet = binding.cardFilter
        filter.setOnClickListener {
            bottomSheet.visibility = if (bottomSheet.isVisible) View.GONE else View.VISIBLE
        }
        binding.filterCategories.setOnClickListener {
            val f = ResourcesFilterFragment()
            f.setListener(this)
            f.show(childFragmentManager, "")
            bottomSheet.visibility = View.GONE
        }
        binding.orderByDateButton.setOnClickListener { adapterLibrary.toggleSortOrder() }
        binding.orderByTitleButton.setOnClickListener { adapterLibrary.toggleTitleSortOrder() }
    }

    override fun getWatchedTables(): List<String> {
        return listOf("resources")
    }

    override fun onDataUpdated(table: String, update: TableDataUpdate) {
        if (table == "resources" && update.shouldRefreshUI) {
            refreshResourcesData()
        }
    }

    override fun getSyncRecyclerView(): RecyclerView? {
        return if (::recyclerView.isInitialized) recyclerView else null
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/resources/ResourcesFilterFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.resources

import android.animation.Animator
import android.animation.AnimatorListenerAdapter
import android.animation.ValueAnimator
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AbsListView
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.ListView
import android.widget.TextView
import androidx.core.view.isGone
import androidx.fragment.app.DialogFragment
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnFilterListener
import org.ole.planet.myplanet.databinding.FragmentLibraryFilterBinding

class ResourcesFilterFragment : DialogFragment(), AdapterView.OnItemClickListener {
    private var _binding: FragmentLibraryFilterBinding? = null
    private val binding get() = _binding!!
    var languages: Set<String>? = null
    var subjects: Set<String>? = null
    var mediums: Set<String>? = null
    var levels: Set<String>? = null
    private var filterListener: OnFilterListener? = null
    private var selectedLang: MutableSet<String> = HashSet()
    private var selectedSubs: MutableSet<String> = HashSet()
    private var selectedMeds: MutableSet<String> = HashSet()
    private var selectedLvls: MutableSet<String> = HashSet()
    private var isSubjectsExpanded = false
    private var isLanguagesExpanded = false
    private var isMediumsExpanded = false
    private var isLevelsExpanded = false

    fun setListener(listener: OnFilterListener?) {
        this.filterListener = listener
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentLibraryFilterBinding.inflate(inflater, container, false)
        binding.listMedium.onItemClickListener = this
        binding.listLang.onItemClickListener = this
        binding.listLevel.onItemClickListener = this
        binding.listSub.onItemClickListener = this
        binding.ivClose.setOnClickListener { dismiss() }
        binding.subjectsLayout.setOnClickListener {
            toggleSection(
                binding.expandableLayoutSubjects,
                binding.listSub,
                binding.subjectsLayout
            )
            isSubjectsExpanded = !isSubjectsExpanded
        }
        binding.languagesLayout.setOnClickListener {
            toggleSection(
                binding.expandableLayoutLanguages,
                binding.listLang,
                binding.languagesLayout
            )
            isLanguagesExpanded = !isLanguagesExpanded
        }
        binding.mediumsLayout.setOnClickListener {
            toggleSection(
                binding.expandableLayoutMediums,
                binding.listMedium,
                binding.mediumsLayout
            )
            isMediumsExpanded = !isMediumsExpanded
        }
        binding.levelsLayout.setOnClickListener {
            toggleSection(
                binding.expandableLayoutLevels,
                binding.listLevel,
                binding.levelsLayout
            )
            isLevelsExpanded = !isLevelsExpanded
        }
        return binding.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        initList()
    }

    override fun onStart() {
        super.onStart()
        dialog?.window?.let { window ->
            val params = window.attributes
            params.width = (resources.displayMetrics.widthPixels * 0.9).toInt()
            params.height = ViewGroup.LayoutParams.WRAP_CONTENT
            window.attributes = params
        }
    }

    private fun initList() {
        languages = filterListener?.getData()?.get("languages")
        subjects = filterListener?.getData()?.get("subjects")
        mediums = filterListener?.getData()?.get("mediums")
        levels = filterListener?.getData()?.get("levels")
        selectedLvls = filterListener?.getSelectedFilter()?.get("levels") as MutableSet<String>
        selectedSubs = filterListener?.getSelectedFilter()?.get("subjects") as MutableSet<String>
        selectedMeds = filterListener?.getSelectedFilter()?.get("mediums") as MutableSet<String>
        selectedLang = filterListener?.getSelectedFilter()?.get("languages") as MutableSet<String>
        setAdapter(binding.listLevel, levels, selectedLvls)
        setAdapter(binding.listLang, languages, selectedLang)
        setAdapter(binding.listMedium, mediums, selectedMeds)
        setAdapter(binding.listSub, subjects, selectedSubs)
    }

    private fun setAdapter(listView: ListView, ar: Set<String>?, set: Set<String>) {
        val arr = ar?.let { ArrayList(it) }
        listView.choiceMode = AbsListView.CHOICE_MODE_MULTIPLE
        listView.adapter = ArrayAdapter(requireActivity(), R.layout.rowlayout, R.id.checkBoxRowLayout, arr!!)
        for (i in arr.indices) {
                listView.setItemChecked(i, set.contains(arr[i]))
            }
    }

    override fun onItemClick(adapterView: AdapterView<*>, view: View, i: Int, l: Long) {
        if (filterListener != null) {
            val s = adapterView.getItemAtPosition(i) as String
            when (adapterView.id) {
                R.id.list_lang -> { addToList(s, selectedLang) }
                R.id.list_sub -> addToList(s, selectedSubs)
                R.id.list_level -> addToList(s, selectedLvls)
                R.id.list_medium -> addToList(s, selectedMeds)
            }
            filterListener?.filter(selectedSubs, selectedLang, selectedMeds, selectedLvls)
            initList()
        }
    }

    private fun addToList(s: String, list: MutableSet<String>) {
        if (list.contains(s)) list.remove(s) else list.add(s)
    }

    private fun toggleSection(section: View, listView: ListView, headerTextView: TextView) {
        if (section.isGone) {
            expand(section, listView, headerTextView)
        } else {
            collapse(section, headerTextView)
        }
    }

    private fun expand(view: View, listView: ListView, headerTextView: TextView) {
        val count = listView.adapter.count
        val itemHeight = 100
        val topPadding = 80
        val targetHeight = if(count < 6){
            count * itemHeight + topPadding
        } else {
            5 * itemHeight + topPadding
        }
        view.layoutParams.height = 0
        view.visibility = View.VISIBLE
        val animator = slideAnimator(view, 0, targetHeight)
        animator.start()
        rotateDrawable(headerTextView, 180f)
    }

    private fun collapse(view: View, headerTextView: TextView) {
        val finalHeight = view.height
        val animator = slideAnimator(view, finalHeight, 0)
        animator.addListener(object : AnimatorListenerAdapter() {
            override fun onAnimationEnd(animation: Animator) {
                view.visibility = View.GONE
            }
        })
        animator.start()
        rotateDrawable(headerTextView, 0f)
    }

    private fun slideAnimator(view: View, start: Int, end: Int): ValueAnimator {
        val animator = ValueAnimator.ofInt(start, end)
        animator.duration = 300
        animator.addUpdateListener { valueAnimator ->
            val value = valueAnimator.animatedValue as Int
            val layoutParams = view.layoutParams
            layoutParams.height = value
            view.layoutParams = layoutParams
        }
        return animator
    }

    private fun rotateDrawable(textView: TextView, rotation: Float) {
        val drawableRes = if (rotation == 180f) R.drawable.outline_keyboard_arrow_up_24 else R.drawable.down_arrow
        textView.setCompoundDrawablesWithIntrinsicBounds(0, 0, drawableRes, 0)
    }
}
=======
package org.ole.planet.myplanet.ui.resources


import android.animation.Animator
import android.animation.AnimatorListenerAdapter
import android.animation.ValueAnimator
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AbsListView
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.ListView
import android.widget.TextView
import androidx.core.view.isGone
import androidx.fragment.app.DialogFragment
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnFilterListener
import org.ole.planet.myplanet.databinding.FragmentLibraryFilterBinding

class ResourcesFilterFragment : DialogFragment(), AdapterView.OnItemClickListener {
    private var _binding: FragmentLibraryFilterBinding? = null
    private val binding get() = _binding!!
    var languages: Set<String>? = null
    var subjects: Set<String>? = null
    var mediums: Set<String>? = null
    var levels: Set<String>? = null
    private var filterListener: OnFilterListener? = null
    private var selectedLang: MutableSet<String> = HashSet()
    private var selectedSubs: MutableSet<String> = HashSet()
    private var selectedMeds: MutableSet<String> = HashSet()
    private var selectedLvls: MutableSet<String> = HashSet()
    private var isSubjectsExpanded = false
    private var isLanguagesExpanded = false
    private var isMediumsExpanded = false
    private var isLevelsExpanded = false

    fun setListener(listener: OnFilterListener?) {
        this.filterListener = listener
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentLibraryFilterBinding.inflate(inflater, container, false)
        binding.listMedium.onItemClickListener = this
        binding.listLang.onItemClickListener = this
        binding.listLevel.onItemClickListener = this
        binding.listSub.onItemClickListener = this
        binding.ivClose.setOnClickListener { dismiss() }
        binding.subjectsLayout.setOnClickListener {
            toggleSection(
                binding.expandableLayoutSubjects,
                binding.listSub,
                binding.subjectsLayout
            )
            isSubjectsExpanded = !isSubjectsExpanded
        }
        binding.languagesLayout.setOnClickListener {
            toggleSection(
                binding.expandableLayoutLanguages,
                binding.listLang,
                binding.languagesLayout
            )
            isLanguagesExpanded = !isLanguagesExpanded
        }
        binding.mediumsLayout.setOnClickListener {
            toggleSection(
                binding.expandableLayoutMediums,
                binding.listMedium,
                binding.mediumsLayout
            )
            isMediumsExpanded = !isMediumsExpanded
        }
        binding.levelsLayout.setOnClickListener {
            toggleSection(
                binding.expandableLayoutLevels,
                binding.listLevel,
                binding.levelsLayout
            )
            isLevelsExpanded = !isLevelsExpanded
        }
        return binding.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        initList()
    }

    override fun onStart() {
        super.onStart()
        dialog?.window?.let { window ->
            val params = window.attributes
            params.width = (resources.displayMetrics.widthPixels * 0.9).toInt()
            params.height = ViewGroup.LayoutParams.WRAP_CONTENT
            window.attributes = params
        }
    }

    private fun initList() {
        languages = filterListener?.getData()?.get("languages")
        subjects = filterListener?.getData()?.get("subjects")
        mediums = filterListener?.getData()?.get("mediums")
        levels = filterListener?.getData()?.get("levels")
        selectedLvls = filterListener?.getSelectedFilter()?.get("levels") as MutableSet<String>
        selectedSubs = filterListener?.getSelectedFilter()?.get("subjects") as MutableSet<String>
        selectedMeds = filterListener?.getSelectedFilter()?.get("mediums") as MutableSet<String>
        selectedLang = filterListener?.getSelectedFilter()?.get("languages") as MutableSet<String>
        setAdapter(binding.listLevel, levels, selectedLvls)
        setAdapter(binding.listLang, languages, selectedLang)
        setAdapter(binding.listMedium, mediums, selectedMeds)
        setAdapter(binding.listSub, subjects, selectedSubs)
    }

    private fun setAdapter(listView: ListView, ar: Set<String>?, set: Set<String>) {
        val arr = ar?.let { ArrayList(it) }
        listView.choiceMode = AbsListView.CHOICE_MODE_MULTIPLE
        listView.adapter = ArrayAdapter(requireActivity(), R.layout.rowlayout, R.id.checkBoxRowLayout, arr!!)
        for (i in arr.indices) {
                listView.setItemChecked(i, set.contains(arr[i]))
            }
    }

    override fun onItemClick(adapterView: AdapterView<*>, view: View, i: Int, l: Long) {
        if (filterListener != null) {
            val s = adapterView.getItemAtPosition(i) as String
            when (adapterView.id) {
                R.id.list_lang -> { addToList(s, selectedLang) }
                R.id.list_sub -> addToList(s, selectedSubs)
                R.id.list_level -> addToList(s, selectedLvls)
                R.id.list_medium -> addToList(s, selectedMeds)
            }
            filterListener?.filter(selectedSubs, selectedLang, selectedMeds, selectedLvls)
            initList()
        }
    }

    private fun addToList(s: String, list: MutableSet<String>) {
        if (list.contains(s)) list.remove(s) else list.add(s)
    }

    private fun toggleSection(section: View, listView: ListView, headerTextView: TextView) {
        if (section.isGone) {
            expand(section, listView, headerTextView)
        } else {
            collapse(section, headerTextView)
        }
    }

    private fun expand(view: View, listView: ListView, headerTextView: TextView) {
        val count = listView.adapter.count
        val itemHeight = 100
        val topPadding = 80
        val targetHeight = if(count < 6){
            count * itemHeight + topPadding
        } else {
            5 * itemHeight + topPadding
        }
        view.layoutParams.height = 0
        view.visibility = View.VISIBLE
        val animator = slideAnimator(view, 0, targetHeight)
        animator.start()
        rotateDrawable(headerTextView, 180f)
    }

    private fun collapse(view: View, headerTextView: TextView) {
        val finalHeight = view.height
        val animator = slideAnimator(view, finalHeight, 0)
        animator.addListener(object : AnimatorListenerAdapter() {
            override fun onAnimationEnd(animation: Animator) {
                view.visibility = View.GONE
            }
        })
        animator.start()
        rotateDrawable(headerTextView, 0f)
    }

    private fun slideAnimator(view: View, start: Int, end: Int): ValueAnimator {
        val animator = ValueAnimator.ofInt(start, end)
        animator.duration = 300
        animator.addUpdateListener { valueAnimator ->
            val value = valueAnimator.animatedValue as Int
            val layoutParams = view.layoutParams
            layoutParams.height = value
            view.layoutParams = layoutParams
        }
        return animator
    }

    private fun rotateDrawable(textView: TextView, rotation: Float) {
        val drawableRes = if (rotation == 180f) R.drawable.outline_keyboard_arrow_up_24 else R.drawable.down_arrow
        textView.setCompoundDrawablesWithIntrinsicBounds(0, 0, drawableRes, 0)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/resources/AdapterResource.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.resources

import android.content.Context
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView
import com.google.android.flexbox.FlexboxLayout
import com.google.gson.JsonObject
import fisk.chipcloud.ChipCloud
import fisk.chipcloud.ChipCloudConfig
import java.util.Locale
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.OnLibraryItemSelected
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.RowLibraryBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.utilities.CourseRatingUtils
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities

class AdapterResource(
    private val context: Context,
    private var libraryList: List<RealmMyLibrary?>,
    private var ratingMap: HashMap<String?, JsonObject>,
    private val tagRepository: TagRepository,
    private val userModel: RealmUserModel?
) : RecyclerView.Adapter<RecyclerView.ViewHolder>() {
    private val selectedItems: MutableList<RealmMyLibrary?> = ArrayList()
    private var listener: OnLibraryItemSelected? = null
    private val config: ChipCloudConfig = Utilities.getCloudConfig().selectMode(ChipCloud.SelectMode.single)
    private var homeItemClickListener: OnHomeItemClickListener? = null
    private var ratingChangeListener: OnRatingChangeListener? = null
    private var isAscending = true
    private var isTitleAscending = false
    private val tagCache: MutableMap<String, List<RealmTag>> = mutableMapOf()
    private val tagRequestsInProgress: MutableSet<String> = mutableSetOf()

    companion object {
        private const val TAGS_PAYLOAD = "payload_tags"
        private const val RATING_PAYLOAD = "payload_rating"
        private const val SELECTION_PAYLOAD = "payload_selection"
    }

    init {
        if (context is OnHomeItemClickListener) {
            homeItemClickListener = context
        }
    }

    fun setRatingChangeListener(ratingChangeListener: OnRatingChangeListener?) {
        this.ratingChangeListener = ratingChangeListener
    }

    fun getLibraryList(): List<RealmMyLibrary?> {
        return libraryList
    }

    fun setLibraryList(libraryList: List<RealmMyLibrary?>) {
        updateList(libraryList)
    }

    fun setListener(listener: OnLibraryItemSelected?) {
        this.listener = listener
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val rowLibraryBinding =
            RowLibraryBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderLibrary(rowLibraryBinding)
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder is ViewHolderLibrary) {
            val library = libraryList.getOrNull(position) ?: return
            holder.bind()
            holder.rowLibraryBinding.title.text = library.title ?: ""
            setMarkdownText(holder.rowLibraryBinding.description, library.description ?: "")
            holder.rowLibraryBinding.description.setOnClickListener {
                openLibrary(library)
            }
            holder.rowLibraryBinding.timesRated.text = context.getString(R.string.num_total, library.timesRated)
            holder.rowLibraryBinding.checkbox.isChecked = selectedItems.contains(library)
            val selectedText = context.getString(R.string.selected)
            val libraryTitle = library.title.orEmpty()
            holder.rowLibraryBinding.checkbox.contentDescription =
                if (libraryTitle.isNotEmpty()) "$selectedText $libraryTitle" else selectedText
            holder.rowLibraryBinding.rating.text =
                if (TextUtils.isEmpty(library.averageRating)) {
                    "0.0"
                } else {
                    String.format(Locale.getDefault(), "%.1f", library.averageRating?.toDouble())
                }
            holder.rowLibraryBinding.tvDate.text = library.createdDate?.let { formatDate(it, "MMM dd, yyyy") }
            displayTagCloud(holder, position)
            holder.itemView.setOnClickListener {
                openLibrary(library)
            }
            if (library.isResourceOffline() == true) {
                holder.rowLibraryBinding.ivDownloaded.visibility = View.INVISIBLE
            } else {
                holder.rowLibraryBinding.ivDownloaded.visibility = View.VISIBLE
            }
            holder.rowLibraryBinding.ivDownloaded.contentDescription =
                if (library.isResourceOffline() == true) {
                    context.getString(R.string.view)
                } else {
                    context.getString(R.string.download)
                }
            bindRating(holder, library)

            if (userModel?.isGuest() == false) {
                holder.rowLibraryBinding.checkbox.setOnClickListener { view: View ->
                    holder.rowLibraryBinding.checkbox.contentDescription =
                        context.getString(R.string.select_res_course, library.title ?: "")
                    val isChecked = (view as CheckBox).isChecked
                    if (isChecked) {
                        if (!selectedItems.contains(library)) {
                            selectedItems.add(library)
                        }
                    } else {
                        selectedItems.remove(library)
                    }
                    if (listener != null) listener?.onSelectedListChange(selectedItems)
                }
            } else {
                holder.rowLibraryBinding.checkbox.visibility = View.GONE
            }
        }
    }

    fun areAllSelected(): Boolean {
        return selectedItems.size == libraryList.size
    }

    fun selectAllItems(selectAll: Boolean) {
        if (selectAll) {
            selectedItems.clear()
            selectedItems.addAll(libraryList)
        } else {
            selectedItems.clear()
        }
        notifyItemRangeChanged(0, libraryList.size, SELECTION_PAYLOAD)
        if (listener != null) {
            listener?.onSelectedListChange(selectedItems)
        }
    }

    private fun openLibrary(library: RealmMyLibrary?) {
        homeItemClickListener?.openLibraryDetailFragment(library)
    }

    override fun onBindViewHolder(
        holder: RecyclerView.ViewHolder,
        position: Int,
        payloads: MutableList<Any>
    ) {
        if (holder is ViewHolderLibrary && payloads.isNotEmpty()) {
            val library = libraryList.getOrNull(position) ?: return
            var handled = false
            if (payloads.contains(TAGS_PAYLOAD)) {
                val resourceId = library.id
                if (resourceId != null) {
                    val tags = tagCache[resourceId].orEmpty()
                    renderTagCloud(holder.rowLibraryBinding.flexboxDrawable, tags)
                    handled = true
                }
            }
            if (payloads.contains(RATING_PAYLOAD)) {
                bindRating(holder, library)
                handled = true
            }
            if (payloads.contains(SELECTION_PAYLOAD)) {
                holder.rowLibraryBinding.checkbox.isChecked = selectedItems.contains(library)
                handled = true
            }
            if (!handled) {
                super.onBindViewHolder(holder, position, payloads)
            }
        } else {
            super.onBindViewHolder(holder, position, payloads)
        }
    }

    private fun displayTagCloud(holder: ViewHolderLibrary, position: Int) {
        val flexboxDrawable = holder.rowLibraryBinding.flexboxDrawable
        val resourceId = libraryList.getOrNull(position)?.id
        if (resourceId == null) {
            flexboxDrawable.removeAllViews()
            return
        }

        val cachedTags = tagCache[resourceId]
        if (cachedTags != null) {
            renderTagCloud(flexboxDrawable, cachedTags)
            return
        }

        flexboxDrawable.removeAllViews()

        val lifecycleOwner = context as? LifecycleOwner ?: return
        if (!tagRequestsInProgress.add(resourceId)) {
            return
        }
        lifecycleOwner.lifecycleScope.launch {
            try {
                val tags = withContext(Dispatchers.IO) {
                    tagRepository.getTagsForResource(resourceId)
                }
                tagCache[resourceId] = tags

                if (isActive) {
                    val adapterPosition = holder.bindingAdapterPosition
                    if (adapterPosition != RecyclerView.NO_POSITION) {
                        val currentResourceId = libraryList.getOrNull(adapterPosition)?.id
                        if (currentResourceId == resourceId) {
                            renderTagCloud(holder.rowLibraryBinding.flexboxDrawable, tags)
                        }
                    }
                }
            } finally {
                tagRequestsInProgress.remove(resourceId)
            }
        }
    }

    private fun renderTagCloud(flexboxDrawable: FlexboxLayout, tags: List<RealmTag>) {
        flexboxDrawable.removeAllViews()
        if (tags.isEmpty()) {
            return
        }
        val chipCloud = ChipCloud(context, flexboxDrawable, config)
        tags.forEach { tag ->
            try {
                chipCloud.addChip(tag.name ?: "--")
            } catch (err: Exception) {
                chipCloud.addChip("--")
            }
        }
        chipCloud.setListener { index: Int, _: Boolean, isSelected: Boolean ->
            if (isSelected) {
                tags.getOrNull(index)?.let { selectedTag ->
                    listener?.onTagClicked(selectedTag)
                }
            }
        }
    }

    fun toggleTitleSortOrder() {
        isTitleAscending = !isTitleAscending
        updateList(sortLibraryListByTitle())
    }

    fun toggleSortOrder() {
        isAscending = !isAscending
        updateList(sortLibraryList())
    }

    private fun sortLibraryListByTitle(): List<RealmMyLibrary?> {
        return if (isTitleAscending) {
            libraryList.sortedBy { it?.title?.lowercase(Locale.ROOT) }
        } else {
            libraryList.sortedByDescending { it?.title?.lowercase(Locale.ROOT) }
        }
    }

    private fun sortLibraryList(): List<RealmMyLibrary?> {
        return if (isAscending) {
            libraryList.sortedBy { it?.createdDate }
        } else {
            libraryList.sortedByDescending { it?.createdDate }
        }
    }

    override fun getItemCount(): Int {
        return libraryList.size
    }

    private fun updateList(newList: List<RealmMyLibrary?>) {
        val diffResult = DiffUtils.calculateDiff(
            libraryList,
            newList,
            areItemsTheSame = { old, new -> old?.id == new?.id },
            areContentsTheSame = { old, new ->
                old?.title == new?.title &&
                        old?.description == new?.description &&
                        old?.createdDate == new?.createdDate &&
                        old?.averageRating == new?.averageRating &&
                        old?.timesRated == new?.timesRated
            },
            getChangePayload = { old, new ->
                val ratingChanged = old?.averageRating != new?.averageRating || old?.timesRated != new?.timesRated
                val otherContentChanged = old?.title != new?.title ||
                        old?.description != new?.description ||
                        old?.createdDate != new?.createdDate

                if (ratingChanged && !otherContentChanged) {
                    RATING_PAYLOAD
                } else {
                    null
                }
            }
        )
        libraryList = newList
        diffResult.dispatchUpdatesTo(this)
    }

    fun setRatingMap(newRatingMap: HashMap<String?, JsonObject>) {
        val updatedResourceIds = mutableSetOf<String?>()

        newRatingMap.forEach { (resourceId, newRating) ->
            if (ratingMap[resourceId] != newRating) {
                updatedResourceIds.add(resourceId)
            }
        }

        ratingMap.keys.filterNot { newRatingMap.containsKey(it) }.forEach { removedKey ->
            updatedResourceIds.add(removedKey)
        }

        ratingMap.clear()
        ratingMap.putAll(newRatingMap)

        updatedResourceIds.forEach { resourceId ->
            if (resourceId.isNullOrEmpty()) {
                return@forEach
            }
            val index = libraryList.indexOfFirst { it?.resourceId == resourceId }
            if (index != -1) {
                notifyItemChanged(index, RATING_PAYLOAD)
            }
        }
    }

    private fun bindRating(holder: ViewHolderLibrary, library: RealmMyLibrary) {
        if (ratingMap.containsKey(library.resourceId)) {
            val ratingData = ratingMap[library.resourceId]
            CourseRatingUtils.showRating(
                context,
                ratingData,
                holder.rowLibraryBinding.rating,
                holder.rowLibraryBinding.timesRated,
                holder.rowLibraryBinding.ratingBar
            )
        } else {
            val averageRating = library.averageRating?.toFloatOrNull() ?: 0f
            holder.rowLibraryBinding.rating.text = String.format(Locale.getDefault(), "%.2f", averageRating)
            holder.rowLibraryBinding.timesRated.text =
                context.getString(R.string.rating_count_format, library.timesRated ?: 0)
            holder.rowLibraryBinding.ratingBar.rating = averageRating
        }
    }

    internal inner class ViewHolderLibrary(val rowLibraryBinding: RowLibraryBinding) :
        RecyclerView.ViewHolder(rowLibraryBinding.root) {
            init {
                rowLibraryBinding.ratingBar.setOnTouchListener { _: View?, event: MotionEvent ->
                    if (event.action == MotionEvent.ACTION_UP) {
                        val adapterPosition = bindingAdapterPosition
                        if (adapterPosition != RecyclerView.NO_POSITION) {
                            val library = libraryList.getOrNull(adapterPosition)
                            if (userModel?.isGuest() == false) {
                                homeItemClickListener?.showRatingDialog(
                                    "resource",
                                    library?.resourceId,
                                    library?.title,
                                    ratingChangeListener
                                )
                            }
                        }
                    }
                    true
                }
            }

        fun bind() {}
    }
}
=======
package org.ole.planet.myplanet.ui.resources


import android.content.Context
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView
import com.google.android.flexbox.FlexboxLayout
import com.google.gson.JsonObject
import fisk.chipcloud.ChipCloud
import fisk.chipcloud.ChipCloudConfig
import java.util.Locale
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.OnLibraryItemSelected
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.RowLibraryBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.utilities.CourseRatingUtils
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities

class AdapterResource(
    private val context: Context,
    private var libraryList: List<RealmMyLibrary?>,
    private var ratingMap: HashMap<String?, JsonObject>,
    private val tagRepository: TagRepository,
    private val userModel: RealmUserModel?
) : RecyclerView.Adapter<RecyclerView.ViewHolder>() {
    private val selectedItems: MutableList<RealmMyLibrary?> = ArrayList()
    private var listener: OnLibraryItemSelected? = null
    private val config: ChipCloudConfig = Utilities.getCloudConfig().selectMode(ChipCloud.SelectMode.single)
    private var homeItemClickListener: OnHomeItemClickListener? = null
    private var ratingChangeListener: OnRatingChangeListener? = null
    private var isAscending = true
    private var isTitleAscending = false
    private val tagCache: MutableMap<String, List<RealmTag>> = mutableMapOf()
    private val tagRequestsInProgress: MutableSet<String> = mutableSetOf()

    companion object {
        private const val TAGS_PAYLOAD = "payload_tags"
        private const val RATING_PAYLOAD = "payload_rating"
        private const val SELECTION_PAYLOAD = "payload_selection"
    }

    init {
        if (context is OnHomeItemClickListener) {
            homeItemClickListener = context
        }
    }

    fun setRatingChangeListener(ratingChangeListener: OnRatingChangeListener?) {
        this.ratingChangeListener = ratingChangeListener
    }

    fun getLibraryList(): List<RealmMyLibrary?> {
        return libraryList
    }

    fun setLibraryList(libraryList: List<RealmMyLibrary?>) {
        updateList(libraryList)
    }

    fun setListener(listener: OnLibraryItemSelected?) {
        this.listener = listener
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val rowLibraryBinding =
            RowLibraryBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderLibrary(rowLibraryBinding)
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder is ViewHolderLibrary) {
            val library = libraryList.getOrNull(position) ?: return
            holder.bind()
            holder.rowLibraryBinding.title.text = library.title ?: ""
            setMarkdownText(holder.rowLibraryBinding.description, library.description ?: "")
            holder.rowLibraryBinding.description.setOnClickListener {
                openLibrary(library)
            }
            holder.rowLibraryBinding.timesRated.text = context.getString(R.string.num_total, library.timesRated)
            holder.rowLibraryBinding.checkbox.isChecked = selectedItems.contains(library)
            val selectedText = context.getString(R.string.selected)
            val libraryTitle = library.title.orEmpty()
            holder.rowLibraryBinding.checkbox.contentDescription =
                if (libraryTitle.isNotEmpty()) "$selectedText $libraryTitle" else selectedText
            holder.rowLibraryBinding.rating.text =
                if (TextUtils.isEmpty(library.averageRating)) {
                    "0.0"
                } else {
                    String.format(Locale.getDefault(), "%.1f", library.averageRating?.toDouble())
                }
            holder.rowLibraryBinding.tvDate.text = library.createdDate?.let { formatDate(it, "MMM dd, yyyy") }
            displayTagCloud(holder, position)
            holder.itemView.setOnClickListener {
                openLibrary(library)
            }
            if (library.isResourceOffline() == true) {
                holder.rowLibraryBinding.ivDownloaded.visibility = View.INVISIBLE
            } else {
                holder.rowLibraryBinding.ivDownloaded.visibility = View.VISIBLE
            }
            holder.rowLibraryBinding.ivDownloaded.contentDescription =
                if (library.isResourceOffline() == true) {
                    context.getString(R.string.view)
                } else {
                    context.getString(R.string.download)
                }
            bindRating(holder, library)

            if (userModel?.isGuest() == false) {
                holder.rowLibraryBinding.checkbox.setOnClickListener { view: View ->
                    holder.rowLibraryBinding.checkbox.contentDescription =
                        context.getString(R.string.select_res_course, library.title ?: "")
                    val isChecked = (view as CheckBox).isChecked
                    if (isChecked) {
                        if (!selectedItems.contains(library)) {
                            selectedItems.add(library)
                        }
                    } else {
                        selectedItems.remove(library)
                    }
                    if (listener != null) listener?.onSelectedListChange(selectedItems)
                }
            } else {
                holder.rowLibraryBinding.checkbox.visibility = View.GONE
            }
        }
    }

    fun areAllSelected(): Boolean {
        return selectedItems.size == libraryList.size
    }

    fun selectAllItems(selectAll: Boolean) {
        if (selectAll) {
            selectedItems.clear()
            selectedItems.addAll(libraryList)
        } else {
            selectedItems.clear()
        }
        notifyItemRangeChanged(0, libraryList.size, SELECTION_PAYLOAD)
        if (listener != null) {
            listener?.onSelectedListChange(selectedItems)
        }
    }

    private fun openLibrary(library: RealmMyLibrary?) {
        homeItemClickListener?.openLibraryDetailFragment(library)
    }

    override fun onBindViewHolder(
        holder: RecyclerView.ViewHolder,
        position: Int,
        payloads: MutableList<Any>
    ) {
        if (holder is ViewHolderLibrary && payloads.isNotEmpty()) {
            val library = libraryList.getOrNull(position) ?: return
            var handled = false
            if (payloads.contains(TAGS_PAYLOAD)) {
                val resourceId = library.id
                if (resourceId != null) {
                    val tags = tagCache[resourceId].orEmpty()
                    renderTagCloud(holder.rowLibraryBinding.flexboxDrawable, tags)
                    handled = true
                }
            }
            if (payloads.contains(RATING_PAYLOAD)) {
                bindRating(holder, library)
                handled = true
            }
            if (payloads.contains(SELECTION_PAYLOAD)) {
                holder.rowLibraryBinding.checkbox.isChecked = selectedItems.contains(library)
                handled = true
            }
            if (!handled) {
                super.onBindViewHolder(holder, position, payloads)
            }
        } else {
            super.onBindViewHolder(holder, position, payloads)
        }
    }

    private fun displayTagCloud(holder: ViewHolderLibrary, position: Int) {
        val flexboxDrawable = holder.rowLibraryBinding.flexboxDrawable
        val resourceId = libraryList.getOrNull(position)?.id
        if (resourceId == null) {
            flexboxDrawable.removeAllViews()
            return
        }

        val cachedTags = tagCache[resourceId]
        if (cachedTags != null) {
            renderTagCloud(flexboxDrawable, cachedTags)
            return
        }

        flexboxDrawable.removeAllViews()

        val lifecycleOwner = context as? LifecycleOwner ?: return
        if (!tagRequestsInProgress.add(resourceId)) {
            return
        }
        lifecycleOwner.lifecycleScope.launch {
            try {
                val tags = withContext(Dispatchers.IO) {
                    tagRepository.getTagsForResource(resourceId)
                }
                tagCache[resourceId] = tags

                if (isActive) {
                    val adapterPosition = holder.bindingAdapterPosition
                    if (adapterPosition != RecyclerView.NO_POSITION) {
                        val currentResourceId = libraryList.getOrNull(adapterPosition)?.id
                        if (currentResourceId == resourceId) {
                            renderTagCloud(holder.rowLibraryBinding.flexboxDrawable, tags)
                        }
                    }
                }
            } finally {
                tagRequestsInProgress.remove(resourceId)
            }
        }
    }

    private fun renderTagCloud(flexboxDrawable: FlexboxLayout, tags: List<RealmTag>) {
        flexboxDrawable.removeAllViews()
        if (tags.isEmpty()) {
            return
        }
        val chipCloud = ChipCloud(context, flexboxDrawable, config)
        tags.forEach { tag ->
            try {
                chipCloud.addChip(tag.name ?: "--")
            } catch (err: Exception) {
                chipCloud.addChip("--")
            }
        }
        chipCloud.setListener { index: Int, _: Boolean, isSelected: Boolean ->
            if (isSelected) {
                tags.getOrNull(index)?.let { selectedTag ->
                    listener?.onTagClicked(selectedTag)
                }
            }
        }
    }

    fun toggleTitleSortOrder() {
        isTitleAscending = !isTitleAscending
        updateList(sortLibraryListByTitle())
    }

    fun toggleSortOrder() {
        isAscending = !isAscending
        updateList(sortLibraryList())
    }

    private fun sortLibraryListByTitle(): List<RealmMyLibrary?> {
        return if (isTitleAscending) {
            libraryList.sortedBy { it?.title?.lowercase(Locale.ROOT) }
        } else {
            libraryList.sortedByDescending { it?.title?.lowercase(Locale.ROOT) }
        }
    }

    private fun sortLibraryList(): List<RealmMyLibrary?> {
        return if (isAscending) {
            libraryList.sortedBy { it?.createdDate }
        } else {
            libraryList.sortedByDescending { it?.createdDate }
        }
    }

    override fun getItemCount(): Int {
        return libraryList.size
    }

    private fun updateList(newList: List<RealmMyLibrary?>) {
        val diffResult = DiffUtils.calculateDiff(
            libraryList,
            newList,
            areItemsTheSame = { old, new -> old?.id == new?.id },
            areContentsTheSame = { old, new ->
                old?.title == new?.title &&
                        old?.description == new?.description &&
                        old?.createdDate == new?.createdDate &&
                        old?.averageRating == new?.averageRating &&
                        old?.timesRated == new?.timesRated
            },
            getChangePayload = { old, new ->
                val ratingChanged = old?.averageRating != new?.averageRating || old?.timesRated != new?.timesRated
                val otherContentChanged = old?.title != new?.title ||
                        old?.description != new?.description ||
                        old?.createdDate != new?.createdDate

                if (ratingChanged && !otherContentChanged) {
                    RATING_PAYLOAD
                } else {
                    null
                }
            }
        )
        libraryList = newList
        diffResult.dispatchUpdatesTo(this)
    }

    fun setRatingMap(newRatingMap: HashMap<String?, JsonObject>) {
        val updatedResourceIds = mutableSetOf<String?>()

        newRatingMap.forEach { (resourceId, newRating) ->
            if (ratingMap[resourceId] != newRating) {
                updatedResourceIds.add(resourceId)
            }
        }

        ratingMap.keys.filterNot { newRatingMap.containsKey(it) }.forEach { removedKey ->
            updatedResourceIds.add(removedKey)
        }

        ratingMap.clear()
        ratingMap.putAll(newRatingMap)

        updatedResourceIds.forEach { resourceId ->
            if (resourceId.isNullOrEmpty()) {
                return@forEach
            }
            val index = libraryList.indexOfFirst { it?.resourceId == resourceId }
            if (index != -1) {
                notifyItemChanged(index, RATING_PAYLOAD)
            }
        }
    }

    private fun bindRating(holder: ViewHolderLibrary, library: RealmMyLibrary) {
        if (ratingMap.containsKey(library.resourceId)) {
            val ratingData = ratingMap[library.resourceId]
            CourseRatingUtils.showRating(
                context,
                ratingData,
                holder.rowLibraryBinding.rating,
                holder.rowLibraryBinding.timesRated,
                holder.rowLibraryBinding.ratingBar
            )
        } else {
            val averageRating = library.averageRating?.toFloatOrNull() ?: 0f
            holder.rowLibraryBinding.rating.text = String.format(Locale.getDefault(), "%.2f", averageRating)
            holder.rowLibraryBinding.timesRated.text =
                context.getString(R.string.rating_count_format, library.timesRated ?: 0)
            holder.rowLibraryBinding.ratingBar.rating = averageRating
        }
    }

    internal inner class ViewHolderLibrary(val rowLibraryBinding: RowLibraryBinding) :
        RecyclerView.ViewHolder(rowLibraryBinding.root) {
            init {
                rowLibraryBinding.ratingBar.setOnTouchListener { _: View?, event: MotionEvent ->
                    if (event.action == MotionEvent.ACTION_UP) {
                        val adapterPosition = bindingAdapterPosition
                        if (adapterPosition != RecyclerView.NO_POSITION) {
                            val library = libraryList.getOrNull(adapterPosition)
                            if (userModel?.isGuest() == false) {
                                homeItemClickListener?.showRatingDialog(
                                    "resource",
                                    library?.resourceId,
                                    library?.title,
                                    ratingChangeListener
                                )
                            }
                        }
                    }
                    true
                }
            }

        fun bind() {}
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/resources/TagExpandableAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.resources

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseExpandableListAdapter
import android.widget.CheckBox
import androidx.appcompat.widget.AppCompatImageView
import androidx.core.content.ContextCompat
import kotlin.collections.HashMap
import kotlin.collections.List
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowAdapterNavigationChildBinding
import org.ole.planet.myplanet.databinding.RowAdapterNavigationParentBinding
import org.ole.planet.myplanet.model.RealmTag

class TagExpandableAdapter(private var tagList: List<RealmTag>, private val childMap: HashMap<String, List<RealmTag>>, private val selectedItemsList: ArrayList<RealmTag>) : BaseExpandableListAdapter() {
    private var clickListener: OnClickTagItem? = null
    private var isSelectMultiple = false

    fun setSelectMultiple(selectMultiple: Boolean) {
        isSelectMultiple = selectMultiple
    }

    override fun getGroupCount(): Int {
        return tagList.size
    }

    override fun getChildrenCount(groupPosition: Int): Int {
        return childMap[tagList[groupPosition].id]?.size ?: 0
    }

    override fun getGroup(groupPosition: Int): Any {
        return tagList[groupPosition]
    }

    override fun getChild(groupPosition: Int, childPosition: Int): Any? {
        return childMap[tagList[groupPosition].id]?.get(childPosition)
    }

    override fun getGroupId(groupPosition: Int): Long {
        return groupPosition.toLong()
    }

    override fun getChildId(groupPosition: Int, childPosition: Int): Long {
        return childPosition.toLong()
    }

    override fun hasStableIds(): Boolean {
        return false
    }

    override fun getGroupView(groupPosition: Int, isExpanded: Boolean, convertView: View?, parent: ViewGroup?): View {
        val headerTitle = tagList[groupPosition].name
        val binding: RowAdapterNavigationParentBinding
        val view: View

        if (convertView == null) {
            binding = RowAdapterNavigationParentBinding.inflate(LayoutInflater.from(parent?.context), parent, false)
            view = binding.root
            view.tag = binding
        } else {
            binding = convertView.tag as RowAdapterNavigationParentBinding
            view = convertView
        }

        binding.tvDrawerTitle1.text = headerTitle
        createCheckbox(view, tagList[groupPosition])
        binding.tvDrawerTitle.text = headerTitle

        if (!childMap.containsKey(tagList[groupPosition].id)) {
            binding.tvDrawerTitle1.visibility = View.VISIBLE
            binding.tvDrawerTitle.visibility = View.GONE
            binding.ivIndicators.visibility = View.GONE
            binding.tvDrawerTitle1.setOnClickListener { clickListener?.onTagClicked(tagList[groupPosition]) }
        } else {
            binding.tvDrawerTitle.visibility = View.VISIBLE
            binding.tvDrawerTitle1.setOnClickListener(null)
            binding.tvDrawerTitle1.visibility = View.GONE
            binding.ivIndicators.visibility = View.VISIBLE
            setExpandedIcon(isExpanded, binding.ivIndicators)
            binding.tvDrawerTitle.setOnClickListener { clickListener?.onTagClicked(tagList[groupPosition]) }
        }

        return view
    }

    private fun setExpandedIcon(isExpanded: Boolean, ivIndicator: AppCompatImageView) {
        ivIndicator.setImageResource(if (isExpanded) R.drawable.ic_keyboard_arrow_up_black_24dp else R.drawable.ic_keyboard_arrow_down_black_24dp)
    }

    private fun createCheckbox(convertView: View, tag: RealmTag) {
        val checkBox = convertView.findViewById<CheckBox>(R.id.checkbox)
        checkBox.visibility = if (isSelectMultiple) View.VISIBLE else View.GONE
        checkBox.isChecked = selectedItemsList.contains(tag)
        checkBox.setOnCheckedChangeListener { _, _ -> clickListener?.onCheckboxTagSelected(tag) }
    }

    override fun getChildView(groupPosition: Int, childPosition: Int, isLastChild: Boolean, convertView: View?, parent: ViewGroup?): View {
        val tag = getChild(groupPosition, childPosition) as RealmTag
        val binding: RowAdapterNavigationChildBinding
        val view: View

        if (convertView == null) {
            binding = RowAdapterNavigationChildBinding.inflate(LayoutInflater.from(parent?.context), parent, false)
            view = binding.root
            view.tag = binding
        } else {
            binding = convertView.tag as RowAdapterNavigationChildBinding
            view = convertView
        }

        createCheckbox(view, tag)
        binding.tvDrawerTitle.text = tag.name
        binding.root.setBackgroundColor(ContextCompat.getColor(parent?.context!!, R.color.multi_select_grey))
        binding.tvDrawerTitle.setTextColor(ContextCompat.getColor(parent.context, R.color.daynight_textColor))
        binding.tvDrawerTitle.setOnClickListener { clickListener?.onTagClicked(tag) }

        return view
    }

    override fun isChildSelectable(groupPosition: Int, childPosition: Int): Boolean {
        return false
    }

    fun setClickListener(clickListener: OnClickTagItem) {
        this.clickListener = clickListener
    }

    fun setTagList(filteredList: List<RealmTag>) {
        tagList = filteredList
        notifyDataSetChanged()
    }

    interface OnClickTagItem {
        fun onTagClicked(tag: RealmTag)
        fun onCheckboxTagSelected(tags: RealmTag)
    }
}
=======
package org.ole.planet.myplanet.ui.resources


import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseExpandableListAdapter
import android.widget.CheckBox
import androidx.appcompat.widget.AppCompatImageView
import androidx.core.content.ContextCompat
import kotlin.collections.HashMap
import kotlin.collections.List
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowAdapterNavigationChildBinding
import org.ole.planet.myplanet.databinding.RowAdapterNavigationParentBinding
import org.ole.planet.myplanet.model.RealmTag

class TagExpandableAdapter(private var tagList: List<RealmTag>, private val childMap: HashMap<String, List<RealmTag>>, private val selectedItemsList: ArrayList<RealmTag>) : BaseExpandableListAdapter() {
    private var clickListener: OnClickTagItem? = null
    private var isSelectMultiple = false

    fun setSelectMultiple(selectMultiple: Boolean) {
        isSelectMultiple = selectMultiple
    }

    override fun getGroupCount(): Int {
        return tagList.size
    }

    override fun getChildrenCount(groupPosition: Int): Int {
        return childMap[tagList[groupPosition].id]?.size ?: 0
    }

    override fun getGroup(groupPosition: Int): Any {
        return tagList[groupPosition]
    }

    override fun getChild(groupPosition: Int, childPosition: Int): Any? {
        return childMap[tagList[groupPosition].id]?.get(childPosition)
    }

    override fun getGroupId(groupPosition: Int): Long {
        return groupPosition.toLong()
    }

    override fun getChildId(groupPosition: Int, childPosition: Int): Long {
        return childPosition.toLong()
    }

    override fun hasStableIds(): Boolean {
        return false
    }

    override fun getGroupView(groupPosition: Int, isExpanded: Boolean, convertView: View?, parent: ViewGroup?): View {
        val headerTitle = tagList[groupPosition].name
        val binding: RowAdapterNavigationParentBinding
        val view: View

        if (convertView == null) {
            binding = RowAdapterNavigationParentBinding.inflate(LayoutInflater.from(parent?.context), parent, false)
            view = binding.root
            view.tag = binding
        } else {
            binding = convertView.tag as RowAdapterNavigationParentBinding
            view = convertView
        }

        binding.tvDrawerTitle1.text = headerTitle
        createCheckbox(view, tagList[groupPosition])
        binding.tvDrawerTitle.text = headerTitle

        if (!childMap.containsKey(tagList[groupPosition].id)) {
            binding.tvDrawerTitle1.visibility = View.VISIBLE
            binding.tvDrawerTitle.visibility = View.GONE
            binding.ivIndicators.visibility = View.GONE
            binding.tvDrawerTitle1.setOnClickListener { clickListener?.onTagClicked(tagList[groupPosition]) }
        } else {
            binding.tvDrawerTitle.visibility = View.VISIBLE
            binding.tvDrawerTitle1.setOnClickListener(null)
            binding.tvDrawerTitle1.visibility = View.GONE
            binding.ivIndicators.visibility = View.VISIBLE
            setExpandedIcon(isExpanded, binding.ivIndicators)
            binding.tvDrawerTitle.setOnClickListener { clickListener?.onTagClicked(tagList[groupPosition]) }
        }

        return view
    }

    private fun setExpandedIcon(isExpanded: Boolean, ivIndicator: AppCompatImageView) {
        ivIndicator.setImageResource(if (isExpanded) R.drawable.ic_keyboard_arrow_up_black_24dp else R.drawable.ic_keyboard_arrow_down_black_24dp)
    }

    private fun createCheckbox(convertView: View, tag: RealmTag) {
        val checkBox = convertView.findViewById<CheckBox>(R.id.checkbox)
        checkBox.visibility = if (isSelectMultiple) View.VISIBLE else View.GONE
        checkBox.isChecked = selectedItemsList.contains(tag)
        checkBox.setOnCheckedChangeListener { _, _ -> clickListener?.onCheckboxTagSelected(tag) }
    }

    override fun getChildView(groupPosition: Int, childPosition: Int, isLastChild: Boolean, convertView: View?, parent: ViewGroup?): View {
        val tag = getChild(groupPosition, childPosition) as RealmTag
        val binding: RowAdapterNavigationChildBinding
        val view: View

        if (convertView == null) {
            binding = RowAdapterNavigationChildBinding.inflate(LayoutInflater.from(parent?.context), parent, false)
            view = binding.root
            view.tag = binding
        } else {
            binding = convertView.tag as RowAdapterNavigationChildBinding
            view = convertView
        }

        createCheckbox(view, tag)
        binding.tvDrawerTitle.text = tag.name
        binding.root.setBackgroundColor(ContextCompat.getColor(parent?.context!!, R.color.multi_select_grey))
        binding.tvDrawerTitle.setTextColor(ContextCompat.getColor(parent.context, R.color.daynight_textColor))
        binding.tvDrawerTitle.setOnClickListener { clickListener?.onTagClicked(tag) }

        return view
    }

    override fun isChildSelectable(groupPosition: Int, childPosition: Int): Boolean {
        return false
    }

    fun setClickListener(clickListener: OnClickTagItem) {
        this.clickListener = clickListener
    }

    fun setTagList(filteredList: List<RealmTag>) {
        tagList = filteredList
        notifyDataSetChanged()
    }

    interface OnClickTagItem {
        fun onTagClicked(tag: RealmTag)
        fun onCheckboxTagSelected(tags: RealmTag)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/resources/AddResourceActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.resources

import android.content.Context
import android.content.DialogInterface
import android.os.Bundle
import android.view.MenuItem
import android.view.View
import android.widget.ArrayAdapter
import android.widget.EditText
import android.widget.ListView
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import io.realm.RealmList
import java.util.Calendar
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityAddResourceBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.LibraryRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.CheckboxListView
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.Utilities.toast

@AndroidEntryPoint
class AddResourceActivity : AppCompatActivity() {
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    @Inject
    lateinit var libraryRepository: LibraryRepository
    private lateinit var binding: ActivityAddResourceBinding
    var userModel: RealmUserModel? = null
    var subjects: RealmList<String>? = null
    var levels: RealmList<String>? = null
    private var resourceFor: RealmList<String>? = null
    private var resourceUrl: String? = null

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(base))
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        binding = ActivityAddResourceBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, binding.root)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.setHomeButtonEnabled(true)
        userModel = userProfileDbHandler.userModel
        resourceUrl = intent.getStringExtra("resource_local_url")
        levels = RealmList()
        subjects = RealmList()
        resourceFor = RealmList()
        initializeViews()
    }

    private fun initializeViews() {
        val etYear = findViewById<EditText>(R.id.et_year)
        val currentYear = Calendar.getInstance().get(Calendar.YEAR)
        etYear.setText(currentYear.toString())
        binding.fileUrl.text = getString(R.string.file, resourceUrl)
        binding.tvAddedBy.text = userModel?.name
        binding.tvLevels.setOnClickListener { view: View ->
            showMultiSelectList(resources.getStringArray(R.array.array_levels), levels, view,getString(R.string.levels))
        }
        binding.tvSubject.setOnClickListener { view: View ->
            showMultiSelectList(resources.getStringArray(R.array.array_subjects), subjects, view,getString(R.string.subject))
        }
        binding.tvResourceFor.setOnClickListener { view: View ->
            showMultiSelectList(resources.getStringArray(R.array.array_resource_for), resourceFor, view,getString(R.string.resource_for))
        }
        binding.btnSubmit.setOnClickListener { saveResource() }
        binding.btnCancel.setOnClickListener { finish() }
    }

    private fun saveResource() {
        val title = binding.etTitle.text.toString().trim { it <= ' ' }
        if (!validate(title)) return
        val id = UUID.randomUUID().toString()
        val resource = RealmMyLibrary().apply {
            this.id = id
            this.title = title
            createResource(this, id)
            setUserId(userModel?.id)
        }
        lifecycleScope.launch {
            libraryRepository.saveLibraryItem(resource)
            libraryRepository.markResourceAdded(userModel?.id, id)
            toast(this@AddResourceActivity, getString(R.string.added_to_my_library))
            finish()
        }
    }

    private fun createResource(resource: RealmMyLibrary, id: String) {
        resource.addedBy = binding.tvAddedBy.text.toString().trim { it <= ' ' }
        resource.author = binding.etAuthor.text.toString().trim { it <= ' ' }
        resource.resourceId = id
        resource.year = binding.etYear.text.toString().trim { it <= ' ' }
        resource.description = binding.etDescription.text.toString().trim { it <= ' ' }
        resource.publisher = binding.etPublisher.text.toString().trim { it <= ' ' }
        resource.linkToLicense = binding.etLinkToLicense.text.toString().trim { it <= ' ' }
        resource.openWith = binding.spnOpenWith.selectedItem.toString()
        resource.language = binding.spnLang.selectedItem.toString()
        resource.mediaType = binding.spnMedia.selectedItem.toString()
        resource.resourceType = binding.spnResourceType.selectedItem.toString()
        resource.subject = subjects
        resource.setUserId(RealmList())
        resource.level = levels
        resource.createdDate = Calendar.getInstance().timeInMillis
        resource.resourceFor = resourceFor
        resource.resourceLocalAddress = resourceUrl
        resource.resourceOffline = true
        resource.filename = resourceUrl?.let { it.substring(it.lastIndexOf("/")) }
    }

    private fun validate(title: String): Boolean {
        if (title.isEmpty()) {
            binding.tlTitle.error = getString(R.string.title_is_required)
            return false
        }
        val description = binding.etDescription.text.toString().trim()
        if (description.isEmpty()) {
            binding.etDescription.error = getString(R.string.description_is_required)
            return false
        }
        if (levels?.isEmpty() == true) {
            toast(this, getString(R.string.level_is_required))
            return false
        }
        if (subjects?.isEmpty() == true) {
            toast(this, getString(R.string.subject_is_required))
            return false
        }
        return true
    }
    private fun showMultiSelectList(list: Array<String>, items: MutableList<String>?, view: View, title: String) {
        val listView = CheckboxListView(this)
        val adapter = ArrayAdapter(this, R.layout.rowlayout, R.id.checkBoxRowLayout, list)
        listView.choiceMode = ListView.CHOICE_MODE_MULTIPLE
        listView.adapter = adapter

        items?.forEach { selectedItem ->
            val index = list.indexOf(selectedItem)
            if (index >= 0) {
                listView.setItemChecked(index, true)
            }
        }

        AlertDialog.Builder(this, R.style.AlertDialogTheme).setView(listView).setPositiveButton(R.string.ok) { _: DialogInterface?, _: Int ->
            val selected = listView.checkedItemPositions
            items?.clear()
            var selection = ""
            for (i in 0 until listView.count) {
                if (selected[i]) {
                    val s = list[i]
                    selection += "$s, "
                    items?.add(s)
                }
            }
            if (selection.isEmpty()) {
                (view as TextView).text = title
            } else {
                (view as TextView).text = selection.trimEnd(',', ' ')
            }
        }.setNegativeButton(R.string.dismiss, null).show()
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            android.R.id.home -> {
                val currentFragment = supportFragmentManager.findFragmentById(R.id.fragment_container)
                if (currentFragment is ResourceDetailFragment) {
                    finish()
                }else {
                    showExitConfirmationDialog()
                }
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
    }

    private fun showExitConfirmationDialog() {
        AlertDialog.Builder(this,R.style.AlertDialogTheme)
            .setMessage(R.string.are_you_sure_you_want_to_exit_your_data_will_be_lost)
            .setPositiveButton(R.string.yes_i_want_to_exit) { _, _ ->
                finish()
            }
            .setNegativeButton(R.string.no, null)
            .show()
    }
}
=======
package org.ole.planet.myplanet.ui.resources


import android.content.Context
import android.content.DialogInterface
import android.os.Bundle
import android.view.MenuItem
import android.view.View
import android.widget.ArrayAdapter
import android.widget.EditText
import android.widget.ListView
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import io.realm.RealmList
import java.util.Calendar
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityAddResourceBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.LibraryRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.CheckboxListView
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.Utilities.toast

@AndroidEntryPoint
class AddResourceActivity : AppCompatActivity() {
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    @Inject
    lateinit var libraryRepository: LibraryRepository
    private lateinit var binding: ActivityAddResourceBinding
    var userModel: RealmUserModel? = null
    var subjects: RealmList<String>? = null
    var levels: RealmList<String>? = null
    private var resourceFor: RealmList<String>? = null
    private var resourceUrl: String? = null

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(base))
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        binding = ActivityAddResourceBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, binding.root)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.setHomeButtonEnabled(true)
        userModel = userProfileDbHandler.userModel
        resourceUrl = intent.getStringExtra("resource_local_url")
        levels = RealmList()
        subjects = RealmList()
        resourceFor = RealmList()
        initializeViews()
    }

    private fun initializeViews() {
        val etYear = findViewById<EditText>(R.id.et_year)
        val currentYear = Calendar.getInstance().get(Calendar.YEAR)
        etYear.setText(currentYear.toString())
        binding.fileUrl.text = getString(R.string.file, resourceUrl)
        binding.tvAddedBy.text = userModel?.name
        binding.tvLevels.setOnClickListener { view: View ->
            showMultiSelectList(resources.getStringArray(R.array.array_levels), levels, view,getString(R.string.levels))
        }
        binding.tvSubject.setOnClickListener { view: View ->
            showMultiSelectList(resources.getStringArray(R.array.array_subjects), subjects, view,getString(R.string.subject))
        }
        binding.tvResourceFor.setOnClickListener { view: View ->
            showMultiSelectList(resources.getStringArray(R.array.array_resource_for), resourceFor, view,getString(R.string.resource_for))
        }
        binding.btnSubmit.setOnClickListener { saveResource() }
        binding.btnCancel.setOnClickListener { finish() }
    }

    private fun saveResource() {
        val title = binding.etTitle.text.toString().trim { it <= ' ' }
        if (!validate(title)) return
        val id = UUID.randomUUID().toString()
        val resource = RealmMyLibrary().apply {
            this.id = id
            this.title = title
            createResource(this, id)
            setUserId(userModel?.id)
        }
        lifecycleScope.launch {
            libraryRepository.saveLibraryItem(resource)
            libraryRepository.markResourceAdded(userModel?.id, id)
            toast(this@AddResourceActivity, getString(R.string.added_to_my_library))
            finish()
        }
    }

    private fun createResource(resource: RealmMyLibrary, id: String) {
        resource.addedBy = binding.tvAddedBy.text.toString().trim { it <= ' ' }
        resource.author = binding.etAuthor.text.toString().trim { it <= ' ' }
        resource.resourceId = id
        resource.year = binding.etYear.text.toString().trim { it <= ' ' }
        resource.description = binding.etDescription.text.toString().trim { it <= ' ' }
        resource.publisher = binding.etPublisher.text.toString().trim { it <= ' ' }
        resource.linkToLicense = binding.etLinkToLicense.text.toString().trim { it <= ' ' }
        resource.openWith = binding.spnOpenWith.selectedItem.toString()
        resource.language = binding.spnLang.selectedItem.toString()
        resource.mediaType = binding.spnMedia.selectedItem.toString()
        resource.resourceType = binding.spnResourceType.selectedItem.toString()
        resource.subject = subjects
        resource.setUserId(RealmList())
        resource.level = levels
        resource.createdDate = Calendar.getInstance().timeInMillis
        resource.resourceFor = resourceFor
        resource.resourceLocalAddress = resourceUrl
        resource.resourceOffline = true
        resource.filename = resourceUrl?.let { it.substring(it.lastIndexOf("/")) }
    }

    private fun validate(title: String): Boolean {
        if (title.isEmpty()) {
            binding.tlTitle.error = getString(R.string.title_is_required)
            return false
        }
        val description = binding.etDescription.text.toString().trim()
        if (description.isEmpty()) {
            binding.etDescription.error = getString(R.string.description_is_required)
            return false
        }
        if (levels?.isEmpty() == true) {
            toast(this, getString(R.string.level_is_required))
            return false
        }
        if (subjects?.isEmpty() == true) {
            toast(this, getString(R.string.subject_is_required))
            return false
        }
        return true
    }
    private fun showMultiSelectList(list: Array<String>, items: MutableList<String>?, view: View, title: String) {
        val listView = CheckboxListView(this)
        val adapter = ArrayAdapter(this, R.layout.rowlayout, R.id.checkBoxRowLayout, list)
        listView.choiceMode = ListView.CHOICE_MODE_MULTIPLE
        listView.adapter = adapter

        items?.forEach { selectedItem ->
            val index = list.indexOf(selectedItem)
            if (index >= 0) {
                listView.setItemChecked(index, true)
            }
        }

        AlertDialog.Builder(this, R.style.AlertDialogTheme).setView(listView).setPositiveButton(R.string.ok) { _: DialogInterface?, _: Int ->
            val selected = listView.checkedItemPositions
            items?.clear()
            var selection = ""
            for (i in 0 until listView.count) {
                if (selected[i]) {
                    val s = list[i]
                    selection += "$s, "
                    items?.add(s)
                }
            }
            if (selection.isEmpty()) {
                (view as TextView).text = title
            } else {
                (view as TextView).text = selection.trimEnd(',', ' ')
            }
        }.setNegativeButton(R.string.dismiss, null).show()
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            android.R.id.home -> {
                val currentFragment = supportFragmentManager.findFragmentById(R.id.fragment_container)
                if (currentFragment is ResourceDetailFragment) {
                    finish()
                }else {
                    showExitConfirmationDialog()
                }
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
    }

    private fun showExitConfirmationDialog() {
        AlertDialog.Builder(this,R.style.AlertDialogTheme)
            .setMessage(R.string.are_you_sure_you_want_to_exit_your_data_will_be_lost)
            .setPositiveButton(R.string.yes_i_want_to_exit) { _, _ ->
                finish()
            }
            .setNegativeButton(R.string.no, null)
            .show()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/resources/AddResourceFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.resources

import android.Manifest
import android.app.Dialog
import android.content.ContentValues
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.provider.MediaStore
import android.provider.Settings
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.TextView
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.core.graphics.drawable.toDrawable
import androidx.lifecycle.lifecycleScope
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.google.android.material.floatingactionbutton.FloatingActionButton
import dagger.hilt.android.AndroidEntryPoint
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AlertSoundRecorderBinding
import org.ole.planet.myplanet.databinding.FragmentAddResourceBinding
import org.ole.planet.myplanet.repository.MyPersonalRepository
import org.ole.planet.myplanet.service.AudioRecorderService
import org.ole.planet.myplanet.service.AudioRecorderService.AudioRecordListener
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class AddResourceFragment : BottomSheetDialogFragment() {
    private var _binding: FragmentAddResourceBinding? = null
    private val binding get() = _binding!!
    var tvTime: TextView? = null
    var floatingActionButton: FloatingActionButton? = null
    private var audioRecorderService: AudioRecorderService? = null
    private var photoURI: Uri? = null
    private var videoUri: Uri? = null
    private lateinit var captureImageLauncher: ActivityResultLauncher<Uri>
    private lateinit var captureVideoLauncher: ActivityResultLauncher<Uri>
    private lateinit var openFolderLauncher: ActivityResultLauncher<String>
    private lateinit var requestCameraLauncher: ActivityResultLauncher<String>
    private var type: Int = 0
    @Inject
    lateinit var myPersonalRepository: MyPersonalRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            type = requireArguments().getInt("type", 0)
        }

        captureImageLauncher = registerForActivityResult(ActivityResultContracts.TakePicture()) { isSuccess ->
            if (isSuccess) {
                handleUri(photoURI, REQUEST_CAPTURE_PICTURE)
            }
        }

        captureVideoLauncher = registerForActivityResult(ActivityResultContracts.CaptureVideo()) { isSuccess ->
            if (isSuccess) {
                handleUri(videoUri, REQUEST_VIDEO_CAPTURE)
            }
        }

        openFolderLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
            if (uri != null) {
                handleUri(uri, REQUEST_FILE_SELECTION)
            } else {
                Utilities.toast(activity, "no file selected")
            }
        }
        audioRecorderService = AudioRecorderService()
        audioRecorderService?.setCaller(this, requireContext())
        requestCameraLauncher = registerForActivityResult(
            ActivityResultContracts.RequestPermission()
        ) { isGranted ->
            if (isGranted) {
                takePhoto()
            } else {
                if (!shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) {
                    AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
                        .setTitle(R.string.permission_required)
                        .setMessage(R.string.camera_permission_required)
                        .setPositiveButton(R.string.settings) { dialog, _ ->
                            dialog.dismiss()
                            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                            val uri: Uri = Uri.fromParts("package", requireContext().packageName, null)
                            intent.data = uri
                            startActivity(intent)
                        }
                        .setNegativeButton(R.string.cancel) { dialog, _ -> dialog.dismiss() }
                        .show()
                } else {
                    Utilities.toast(requireContext(), "camera permission is required.")
                }
            }
        }
    }

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val bottomSheetDialog = super.onCreateDialog(savedInstanceState) as BottomSheetDialog
        bottomSheetDialog.setOnShowListener { d: DialogInterface ->
            val dialog = d as BottomSheetDialog
            val bottomSheet = dialog.findViewById<FrameLayout>(com.google.android.material.R.id.design_bottom_sheet)
            bottomSheet?.let {
                BottomSheetBehavior.from(it).state = BottomSheetBehavior.STATE_EXPANDED
                BottomSheetBehavior.from(it).skipCollapsed = true
                BottomSheetBehavior.from(it).setHideable(true)
            }
        }
        return bottomSheetDialog
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentAddResourceBinding.inflate(inflater, container, false)
        binding.llRecordVideo.setOnClickListener { dispatchTakeVideoIntent() }
        binding.llRecordAudio.setOnClickListener { showAudioRecordAlert() }
        binding.llCaptureImage.setOnClickListener { takePhoto() }
        binding.llDraft.setOnClickListener { openFolderLauncher.launch("*/*") }
        return binding.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    private fun showAudioRecordAlert() {
        val alertSoundRecorderBinding = AlertSoundRecorderBinding.inflate(LayoutInflater.from(activity))
        tvTime = alertSoundRecorderBinding.tvTime
        floatingActionButton = alertSoundRecorderBinding.fabRecord
        val titleTextView = TextView(requireContext()).apply {
            text = resources.getString(R.string.record_audio)
            setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
            textSize = 20f
            setPadding(20, 20, 20, 20)
            gravity = Gravity.CENTER
        }
        val dialog = AlertDialog.Builder(requireActivity())
            .setCustomTitle(titleTextView)
            .setView(alertSoundRecorderBinding.root)
            .setCancelable(false)
            .create()
        dialog.window?.setBackgroundDrawable(
            ContextCompat.getColor(
                requireContext(),
                R.color.card_bg
            ).toDrawable())

        createAudioRecorderService(dialog)
        alertSoundRecorderBinding.fabRecord.setOnClickListener { audioRecorderService?.onRecordClicked() }
        dialog.setButton(AlertDialog.BUTTON_POSITIVE, getString(R.string.dismiss)) { _: DialogInterface?, _: Int ->
            if (audioRecorderService != null && audioRecorderService?.isRecording() == true) {
                audioRecorderService?.forceStop()
            }
            dialog.dismiss()
        }
        dialog.show()
    }

    private fun createAudioRecorderService(dialog: AlertDialog) {
        audioRecorderService?.setAudioRecordListener(object : AudioRecordListener {
            override fun onRecordStarted() {
                tvTime?.setText(R.string.recording_audio)
                floatingActionButton?.setImageResource(R.drawable.ic_stop)
            }

            override fun onRecordStopped(outputFile: String?) {
                tvTime?.text = getString(R.string.empty_text)
                dialog.dismiss()
                processResource(outputFile)
                floatingActionButton?.setImageResource(R.drawable.ic_mic)
            }

            override fun onError(error: String?) {
                Utilities.toast(activity, error)
            }
        })
    }

    private fun dispatchTakeVideoIntent() {
        if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.CAMERA)
            != PackageManager.PERMISSION_GRANTED){
            requestCameraLauncher.launch(Manifest.permission.CAMERA)
            return
        }
        val takeVideoIntent = Intent(MediaStore.ACTION_VIDEO_CAPTURE)
        videoUri = createVideoFileUri()
        takeVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, videoUri)
        captureVideoLauncher.launch(videoUri)
    }

    private fun createVideoFileUri(): Uri? {
        val values = ContentValues()
        values.put(MediaStore.Video.Media.TITLE, "Video_" + UUID.randomUUID().toString())
        values.put(MediaStore.Video.Media.MIME_TYPE, "video/mp4")
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            values.put(MediaStore.Video.Media.RELATIVE_PATH, Environment.DIRECTORY_MOVIES + "/ole/video")
        }
        videoUri = requireActivity().contentResolver.insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values)
        return videoUri
    }

    private fun takePhoto() {
        if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.CAMERA)
            != PackageManager.PERMISSION_GRANTED){
            requestCameraLauncher.launch(Manifest.permission.CAMERA)
            return
        }
        val values = ContentValues().apply {
            put(MediaStore.Images.Media.TITLE, "Photo_" + UUID.randomUUID().toString())
            put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + "/ole/photo")
            }
        }
        photoURI = requireActivity().contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)
        photoURI?.let { captureImageLauncher.launch(it) }
    }

    private fun handleUri(uri: Uri?, requestCode: Int) {
        val path = when (requestCode) {
            REQUEST_CAPTURE_PICTURE, REQUEST_VIDEO_CAPTURE ->
                FileUtils.getRealPathFromURI(requireContext(), uri)
            REQUEST_FILE_SELECTION -> FileUtils.getPathFromURI(requireContext(), uri)
            else -> null
        }
        processResource(path)
    }

    private fun processResource(path: String?) {
        if (!path.isNullOrEmpty()) {
            addResource(path)
        } else {
            Utilities.toast(activity, getString(R.string.invalid_resource_url))
        }
    }


    private fun addResource(path: String?) {
        if (type == 0) {
            startActivity(Intent(activity, AddResourceActivity::class.java).putExtra("resource_local_url", path))
        } else {
            val userModel = userProfileDbHandler.userModel ?: return
            showAlert(requireContext(), path, myPersonalRepository, userModel.id, userModel.name, viewLifecycleOwner.lifecycleScope) {
                dismiss()
            }
        }
    }

    companion object {
        const val REQUEST_VIDEO_CAPTURE = 1
        const val REQUEST_CAPTURE_PICTURE = 2
        const val REQUEST_FILE_SELECTION = 3
        fun showAlert(
            context: Context,
            path: String?,
            repository: MyPersonalRepository,
            userId: String?,
            userName: String?,
            scope: CoroutineScope,
            onDismiss: () -> Unit
        ) {
            val v = LayoutInflater.from(context).inflate(R.layout.alert_my_personal, null)
            val etTitle = v.findViewById<EditText>(R.id.et_title)
            val etDesc = v.findViewById<EditText>(R.id.et_description)
            val dialog = AlertDialog.Builder(context, R.style.AlertDialogTheme)
                .setTitle(R.string.enter_resource_detail)
                .setView(v)
                .setPositiveButton(R.string.save, null)
                .setNegativeButton(R.string.dismiss, null)
                .create()

            dialog.setOnShowListener {
                val positiveButton = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
                positiveButton.setOnClickListener {
                    val title = etTitle.text.toString().trim { it <= ' ' }
                    if (title.isEmpty()) {
                        Utilities.toast(context, context.getString(R.string.title_is_required))
                        return@setOnClickListener
                    }
                    val desc = etDesc.text.toString().trim { it <= ' ' }
                    positiveButton.isEnabled = false
                    scope.launch(Dispatchers.IO) {
                        repository.savePersonalResource(title, userId, userName, path, desc)
                        withContext(Dispatchers.Main) {
                            Utilities.toast(context, context.getString(R.string.resource_saved_to_my_personal))
                            positiveButton.isEnabled = true
                            dialog.dismiss()
                            onDismiss.invoke()
                        }
                    }
                }
            }
            dialog.show()
        }
    }
}
=======
package org.ole.planet.myplanet.ui.resources


import android.Manifest
import android.app.Dialog
import android.content.ContentValues
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.provider.MediaStore
import android.provider.Settings
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.TextView
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.core.graphics.drawable.toDrawable
import androidx.lifecycle.lifecycleScope
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.google.android.material.floatingactionbutton.FloatingActionButton
import dagger.hilt.android.AndroidEntryPoint
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AlertSoundRecorderBinding
import org.ole.planet.myplanet.databinding.FragmentAddResourceBinding
import org.ole.planet.myplanet.repository.MyPersonalRepository
import org.ole.planet.myplanet.service.AudioRecorderService
import org.ole.planet.myplanet.service.AudioRecorderService.AudioRecordListener
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class AddResourceFragment : BottomSheetDialogFragment() {
    private var _binding: FragmentAddResourceBinding? = null
    private val binding get() = _binding!!
    var tvTime: TextView? = null
    var floatingActionButton: FloatingActionButton? = null
    private var audioRecorderService: AudioRecorderService? = null
    private var photoURI: Uri? = null
    private var videoUri: Uri? = null
    private lateinit var captureImageLauncher: ActivityResultLauncher<Uri>
    private lateinit var captureVideoLauncher: ActivityResultLauncher<Uri>
    private lateinit var openFolderLauncher: ActivityResultLauncher<String>
    private lateinit var requestCameraLauncher: ActivityResultLauncher<String>
    private var type: Int = 0
    @Inject
    lateinit var myPersonalRepository: MyPersonalRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            type = requireArguments().getInt("type", 0)
        }

        captureImageLauncher = registerForActivityResult(ActivityResultContracts.TakePicture()) { isSuccess ->
            if (isSuccess) {
                handleUri(photoURI, REQUEST_CAPTURE_PICTURE)
            }
        }

        captureVideoLauncher = registerForActivityResult(ActivityResultContracts.CaptureVideo()) { isSuccess ->
            if (isSuccess) {
                handleUri(videoUri, REQUEST_VIDEO_CAPTURE)
            }
        }

        openFolderLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
            if (uri != null) {
                handleUri(uri, REQUEST_FILE_SELECTION)
            } else {
                Utilities.toast(activity, "no file selected")
            }
        }
        audioRecorderService = AudioRecorderService()
        audioRecorderService?.setCaller(this, requireContext())
        requestCameraLauncher = registerForActivityResult(
            ActivityResultContracts.RequestPermission()
        ) { isGranted ->
            if (isGranted) {
                takePhoto()
            } else {
                if (!shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) {
                    AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
                        .setTitle(R.string.permission_required)
                        .setMessage(R.string.camera_permission_required)
                        .setPositiveButton(R.string.settings) { dialog, _ ->
                            dialog.dismiss()
                            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                            val uri: Uri = Uri.fromParts("package", requireContext().packageName, null)
                            intent.data = uri
                            startActivity(intent)
                        }
                        .setNegativeButton(R.string.cancel) { dialog, _ -> dialog.dismiss() }
                        .show()
                } else {
                    Utilities.toast(requireContext(), "camera permission is required.")
                }
            }
        }
    }

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val bottomSheetDialog = super.onCreateDialog(savedInstanceState) as BottomSheetDialog
        bottomSheetDialog.setOnShowListener { d: DialogInterface ->
            val dialog = d as BottomSheetDialog
            val bottomSheet = dialog.findViewById<FrameLayout>(com.google.android.material.R.id.design_bottom_sheet)
            bottomSheet?.let {
                BottomSheetBehavior.from(it).state = BottomSheetBehavior.STATE_EXPANDED
                BottomSheetBehavior.from(it).skipCollapsed = true
                BottomSheetBehavior.from(it).setHideable(true)
            }
        }
        return bottomSheetDialog
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentAddResourceBinding.inflate(inflater, container, false)
        binding.llRecordVideo.setOnClickListener { dispatchTakeVideoIntent() }
        binding.llRecordAudio.setOnClickListener { showAudioRecordAlert() }
        binding.llCaptureImage.setOnClickListener { takePhoto() }
        binding.llDraft.setOnClickListener { openFolderLauncher.launch("*/*") }
        return binding.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    private fun showAudioRecordAlert() {
        val alertSoundRecorderBinding = AlertSoundRecorderBinding.inflate(LayoutInflater.from(activity))
        tvTime = alertSoundRecorderBinding.tvTime
        floatingActionButton = alertSoundRecorderBinding.fabRecord
        val titleTextView = TextView(requireContext()).apply {
            text = resources.getString(R.string.record_audio)
            setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
            textSize = 20f
            setPadding(20, 20, 20, 20)
            gravity = Gravity.CENTER
        }
        val dialog = AlertDialog.Builder(requireActivity())
            .setCustomTitle(titleTextView)
            .setView(alertSoundRecorderBinding.root)
            .setCancelable(false)
            .create()
        dialog.window?.setBackgroundDrawable(
            ContextCompat.getColor(
                requireContext(),
                R.color.card_bg
            ).toDrawable())

        createAudioRecorderService(dialog)
        alertSoundRecorderBinding.fabRecord.setOnClickListener { audioRecorderService?.onRecordClicked() }
        dialog.setButton(AlertDialog.BUTTON_POSITIVE, getString(R.string.dismiss)) { _: DialogInterface?, _: Int ->
            if (audioRecorderService != null && audioRecorderService?.isRecording() == true) {
                audioRecorderService?.forceStop()
            }
            dialog.dismiss()
        }
        dialog.show()
    }

    private fun createAudioRecorderService(dialog: AlertDialog) {
        audioRecorderService?.setAudioRecordListener(object : AudioRecordListener {
            override fun onRecordStarted() {
                tvTime?.setText(R.string.recording_audio)
                floatingActionButton?.setImageResource(R.drawable.ic_stop)
            }

            override fun onRecordStopped(outputFile: String?) {
                tvTime?.text = getString(R.string.empty_text)
                dialog.dismiss()
                processResource(outputFile)
                floatingActionButton?.setImageResource(R.drawable.ic_mic)
            }

            override fun onError(error: String?) {
                Utilities.toast(activity, error)
            }
        })
    }

    private fun dispatchTakeVideoIntent() {
        if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.CAMERA)
            != PackageManager.PERMISSION_GRANTED){
            requestCameraLauncher.launch(Manifest.permission.CAMERA)
            return
        }
        val takeVideoIntent = Intent(MediaStore.ACTION_VIDEO_CAPTURE)
        videoUri = createVideoFileUri()
        takeVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, videoUri)
        captureVideoLauncher.launch(videoUri)
    }

    private fun createVideoFileUri(): Uri? {
        val values = ContentValues()
        values.put(MediaStore.Video.Media.TITLE, "Video_" + UUID.randomUUID().toString())
        values.put(MediaStore.Video.Media.MIME_TYPE, "video/mp4")
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            values.put(MediaStore.Video.Media.RELATIVE_PATH, Environment.DIRECTORY_MOVIES + "/ole/video")
        }
        videoUri = requireActivity().contentResolver.insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values)
        return videoUri
    }

    private fun takePhoto() {
        if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.CAMERA)
            != PackageManager.PERMISSION_GRANTED){
            requestCameraLauncher.launch(Manifest.permission.CAMERA)
            return
        }
        val values = ContentValues().apply {
            put(MediaStore.Images.Media.TITLE, "Photo_" + UUID.randomUUID().toString())
            put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + "/ole/photo")
            }
        }
        photoURI = requireActivity().contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)
        photoURI?.let { captureImageLauncher.launch(it) }
    }

    private fun handleUri(uri: Uri?, requestCode: Int) {
        val path = when (requestCode) {
            REQUEST_CAPTURE_PICTURE, REQUEST_VIDEO_CAPTURE ->
                FileUtils.getRealPathFromURI(requireContext(), uri)
            REQUEST_FILE_SELECTION -> FileUtils.getPathFromURI(requireContext(), uri)
            else -> null
        }
        processResource(path)
    }

    private fun processResource(path: String?) {
        if (!path.isNullOrEmpty()) {
            addResource(path)
        } else {
            Utilities.toast(activity, getString(R.string.invalid_resource_url))
        }
    }


    private fun addResource(path: String?) {
        if (type == 0) {
            startActivity(Intent(activity, AddResourceActivity::class.java).putExtra("resource_local_url", path))
        } else {
            val userModel = userProfileDbHandler.userModel ?: return
            showAlert(requireContext(), path, myPersonalRepository, userModel.id, userModel.name, viewLifecycleOwner.lifecycleScope) {
                dismiss()
            }
        }
    }

    companion object {
        const val REQUEST_VIDEO_CAPTURE = 1
        const val REQUEST_CAPTURE_PICTURE = 2
        const val REQUEST_FILE_SELECTION = 3
        fun showAlert(
            context: Context,
            path: String?,
            repository: MyPersonalRepository,
            userId: String?,
            userName: String?,
            scope: CoroutineScope,
            onDismiss: () -> Unit
        ) {
            val v = LayoutInflater.from(context).inflate(R.layout.alert_my_personal, null)
            val etTitle = v.findViewById<EditText>(R.id.et_title)
            val etDesc = v.findViewById<EditText>(R.id.et_description)
            val dialog = AlertDialog.Builder(context, R.style.AlertDialogTheme)
                .setTitle(R.string.enter_resource_detail)
                .setView(v)
                .setPositiveButton(R.string.save, null)
                .setNegativeButton(R.string.dismiss, null)
                .create()

            dialog.setOnShowListener {
                val positiveButton = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
                positiveButton.setOnClickListener {
                    val title = etTitle.text.toString().trim { it <= ' ' }
                    if (title.isEmpty()) {
                        Utilities.toast(context, context.getString(R.string.title_is_required))
                        return@setOnClickListener
                    }
                    val desc = etDesc.text.toString().trim { it <= ' ' }
                    positiveButton.isEnabled = false
                    scope.launch(Dispatchers.IO) {
                        repository.savePersonalResource(title, userId, userName, path, desc)
                        withContext(Dispatchers.Main) {
                            Utilities.toast(context, context.getString(R.string.resource_saved_to_my_personal))
                            positiveButton.isEnabled = true
                            dialog.dismiss()
                            onDismiss.invoke()
                        }
                    }
                }
            }
            dialog.show()
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/resources/CollectionsFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.resources

import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CompoundButton
import androidx.fragment.app.DialogFragment
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import java.util.Locale
import javax.inject.Inject
import kotlin.collections.ArrayList
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.TagClickListener
import org.ole.planet.myplanet.databinding.FragmentCollectionsBinding
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.utilities.KeyboardUtils

@AndroidEntryPoint
class CollectionsFragment : DialogFragment(), TagExpandableAdapter.OnClickTagItem, CompoundButton.OnCheckedChangeListener {
    private var _binding: FragmentCollectionsBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var tagRepository: TagRepository
    private lateinit var list: List<RealmTag>
    private var filteredList: ArrayList<RealmTag> = ArrayList()
    private lateinit var adapter: TagExpandableAdapter
    private var dbType: String? = null
    private var listener: TagClickListener? = null
    private var selectedItemsList: ArrayList<RealmTag> = ArrayList()
    private var textWatcher: TextWatcher? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NO_TITLE, R.style.AppTheme_Dialog_NoActionBar_MinWidth)
        dbType = arguments?.getString("dbType")
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentCollectionsBinding.inflate(inflater, container, false)
        KeyboardUtils.hideSoftKeyboard(requireActivity())
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setListAdapter()
        setListeners()
    }

    private fun setListeners() {
        binding.btnOk.setOnClickListener {
            listener?.onOkClicked(selectedItemsList)
            dismiss()
        }
        textWatcher = object : TextWatcher {
            override fun beforeTextChanged(charSequence: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(charSequence: CharSequence?, start: Int, before: Int, count: Int) {
                charSequence?.let { filterTags(it.toString()) }
            }
            override fun afterTextChanged(editable: Editable?) {}
        }
        binding.etFilter.addTextChangedListener(textWatcher)
    }

    private fun filterTags(charSequence: String) {
        filteredList.clear()
        if (charSequence.isEmpty()) {
            adapter.setTagList(list)
            return
        }
        list.forEach { t ->
            if (t.name?.lowercase(Locale.ROOT)?.contains(charSequence.lowercase(Locale.ROOT)) == true) {
                filteredList.add(t)
            }
        }
        adapter.setTagList(filteredList)
    }

    private fun setListAdapter() {
        viewLifecycleOwner.lifecycleScope.launch {
            list = tagRepository.getTags(dbType)
            selectedItemsList = ArrayList(recentList)
            val childMap = tagRepository.buildChildMap()
            binding.listTags.setGroupIndicator(null)
            adapter = TagExpandableAdapter(list, childMap, selectedItemsList)
            adapter.setSelectMultiple(true)
            adapter.setClickListener(this@CollectionsFragment)
            binding.listTags.setAdapter(adapter)
            binding.btnOk.visibility = View.VISIBLE
        }
    }

    override fun onTagClicked(tag: RealmTag) {
        listener?.onTagSelected(tag)
        dismiss()
    }

    override fun onCheckboxTagSelected(tags: RealmTag) {
        if (selectedItemsList.contains(tags)) {
            selectedItemsList.remove(tags)
        } else {
            selectedItemsList.add(tags)
        }
    }

    override fun onCheckedChanged(compoundButton: CompoundButton, b: Boolean) {
        MainApplication.isCollectionSwitchOn = b
        adapter.setSelectMultiple(b)
        adapter.setTagList(list)
        binding.listTags.setAdapter(adapter)
        binding.btnOk.visibility = if (b) View.VISIBLE else View.GONE
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding?.etFilter?.removeTextChangedListener(textWatcher)
        textWatcher = null
        _binding = null
    }

    companion object {
        private lateinit var recentList: MutableList<RealmTag>
        @JvmStatic
        fun getInstance(l: MutableList<RealmTag>, dbType: String): CollectionsFragment {
            recentList = l
            val f = CollectionsFragment()
            val b = Bundle()
            b.putString("dbType", dbType)
            f.arguments = b
            return f
        }
    }

    fun setListener(listener: TagClickListener) {
        this.listener = listener
    }

}
=======
package org.ole.planet.myplanet.ui.resources


import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CompoundButton
import androidx.fragment.app.DialogFragment
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import java.util.Locale
import javax.inject.Inject
import kotlin.collections.ArrayList
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.TagClickListener
import org.ole.planet.myplanet.databinding.FragmentCollectionsBinding
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.utilities.KeyboardUtils

@AndroidEntryPoint
class CollectionsFragment : DialogFragment(), TagExpandableAdapter.OnClickTagItem, CompoundButton.OnCheckedChangeListener {
    private var _binding: FragmentCollectionsBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var tagRepository: TagRepository
    private lateinit var list: List<RealmTag>
    private var filteredList: ArrayList<RealmTag> = ArrayList()
    private lateinit var adapter: TagExpandableAdapter
    private var dbType: String? = null
    private var listener: TagClickListener? = null
    private var selectedItemsList: ArrayList<RealmTag> = ArrayList()
    private var textWatcher: TextWatcher? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NO_TITLE, R.style.AppTheme_Dialog_NoActionBar_MinWidth)
        dbType = arguments?.getString("dbType")
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentCollectionsBinding.inflate(inflater, container, false)
        KeyboardUtils.hideSoftKeyboard(requireActivity())
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setListAdapter()
        setListeners()
    }

    private fun setListeners() {
        binding.btnOk.setOnClickListener {
            listener?.onOkClicked(selectedItemsList)
            dismiss()
        }
        textWatcher = object : TextWatcher {
            override fun beforeTextChanged(charSequence: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(charSequence: CharSequence?, start: Int, before: Int, count: Int) {
                charSequence?.let { filterTags(it.toString()) }
            }
            override fun afterTextChanged(editable: Editable?) {}
        }
        binding.etFilter.addTextChangedListener(textWatcher)
    }

    private fun filterTags(charSequence: String) {
        filteredList.clear()
        if (charSequence.isEmpty()) {
            adapter.setTagList(list)
            return
        }
        list.forEach { t ->
            if (t.name?.lowercase(Locale.ROOT)?.contains(charSequence.lowercase(Locale.ROOT)) == true) {
                filteredList.add(t)
            }
        }
        adapter.setTagList(filteredList)
    }

    private fun setListAdapter() {
        viewLifecycleOwner.lifecycleScope.launch {
            list = tagRepository.getTags(dbType)
            selectedItemsList = ArrayList(recentList)
            val childMap = tagRepository.buildChildMap()
            binding.listTags.setGroupIndicator(null)
            adapter = TagExpandableAdapter(list, childMap, selectedItemsList)
            adapter.setSelectMultiple(true)
            adapter.setClickListener(this@CollectionsFragment)
            binding.listTags.setAdapter(adapter)
            binding.btnOk.visibility = View.VISIBLE
        }
    }

    override fun onTagClicked(tag: RealmTag) {
        listener?.onTagSelected(tag)
        dismiss()
    }

    override fun onCheckboxTagSelected(tags: RealmTag) {
        if (selectedItemsList.contains(tags)) {
            selectedItemsList.remove(tags)
        } else {
            selectedItemsList.add(tags)
        }
    }

    override fun onCheckedChanged(compoundButton: CompoundButton, b: Boolean) {
        MainApplication.isCollectionSwitchOn = b
        adapter.setSelectMultiple(b)
        adapter.setTagList(list)
        binding.listTags.setAdapter(adapter)
        binding.btnOk.visibility = if (b) View.VISIBLE else View.GONE
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding?.etFilter?.removeTextChangedListener(textWatcher)
        textWatcher = null
        _binding = null
    }

    companion object {
        private lateinit var recentList: MutableList<RealmTag>
        @JvmStatic
        fun getInstance(l: MutableList<RealmTag>, dbType: String): CollectionsFragment {
            recentList = l
            val f = CollectionsFragment()
            val b = Bundle()
            b.putString("dbType", dbType)
            f.arguments = b
            return f
        }
    }

    fun setListener(listener: TagClickListener) {
        this.listener = listener
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/resources/ResourceDetailFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.resources

import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import android.widget.Toast
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.FragmentLibraryDetailBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.listToString
import org.ole.planet.myplanet.model.RealmRating.Companion.getRatingsById
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.FileUtils.getFileExtension
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class ResourceDetailFragment : BaseContainerFragment(), OnRatingChangeListener {
    private var _binding: FragmentLibraryDetailBinding? = null
    private val binding get() = _binding!!
    private var libraryId: String? = null
    private lateinit var library: RealmMyLibrary
    var userModel: RealmUserModel? = null
    private suspend fun fetchLibrary(libraryId: String): RealmMyLibrary? {
        return libraryRepository.getLibraryItemById(libraryId)
            ?: libraryRepository.getLibraryItemByResourceId(libraryId)
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            libraryId = requireArguments().getString("libraryId")
        }
    }

    override fun onDownloadComplete() {
        super.onDownloadComplete()
        if (!::library.isInitialized) {
            return
        }
        val binding = _binding ?: return
        viewLifecycleOwner.lifecycleScope.launch {
            if (!isAdded) {
                return@launch
            }
            val userId = profileDbHandler.userModel?.id
            try {
                val updatedLibrary = withContext(Dispatchers.IO) {
                    val backgroundLibrary = fetchLibrary(libraryId!!)
                    when {
                        backgroundLibrary == null -> null
                        backgroundLibrary.userId?.contains(userId) != true && userId != null ->
                            libraryRepository.updateUserLibrary(libraryId!!, userId, true)
                        else -> backgroundLibrary
                    }
                }
                if (updatedLibrary != null) {
                    library = updatedLibrary
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
            binding.btnDownload.setImageResource(R.drawable.ic_play)
            val currentUserId = profileDbHandler.userModel?.id
            if (currentUserId != null && library.userId?.contains(currentUserId) != true) {
                Utilities.toast(activity, getString(R.string.added_to_my_library))
                binding.btnRemove.setImageResource(R.drawable.close_x)
            }
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        super.onCreateView(inflater, container, savedInstanceState)
        _binding = FragmentLibraryDetailBinding.inflate(inflater, container, false)
        userModel = profileDbHandler.userModel
        setLoadingState(true)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewLifecycleOwner.lifecycleScope.launch {
            val id = libraryId
            if (id.isNullOrBlank()) {
                handleLibraryNotFound()
                return@launch
            }

            val fetchedLibrary = fetchLibrary(id)

            if (fetchedLibrary == null) {
                handleLibraryNotFound()
                return@launch
            }

            library = fetchedLibrary
            setLoadingState(false)
            initRatingView("resource", library.resourceId, library.title, this@ResourceDetailFragment)
            setLibraryData()
        }
    }

    private fun setLoadingState(isLoading: Boolean) {
        binding.btnDownload.isEnabled = !isLoading
        binding.btnRemove.isEnabled = !isLoading
        val alpha = if (isLoading) 0.5f else 1f
        binding.btnDownload.alpha = alpha
        binding.btnRemove.alpha = alpha
    }

    private fun handleLibraryNotFound() {
        Toast.makeText(requireContext(), "Resource not found", Toast.LENGTH_LONG).show()
        NavigationHelper.popBackStack(parentFragmentManager)
    }

    private fun setLibraryData() {
        with(binding) {
            tvTitle.text = library.title
            timesRated.text = requireContext().getString(R.string.num_total, library.timesRated)
            setTextViewVisibility(tvAuthor, llAuthor, library.author)
            setTextViewVisibility(tvPublished, llPublisher, library.publisher)
            setTextViewVisibility(tvMedia, llMedia, library.mediaType)
            setTextViewVisibility(tvSubject, llSubject, library.subjectsAsString)
            setTextViewVisibility(tvLanguage, llLanguage, library.language)
            setTextViewVisibility(tvLicense, llLicense, library.linkToLicense)
            setTextViewVisibility(tvResource, llResource, listToString(library.resourceFor))
            setTextViewVisibility(tvType, llType, library.resourceType)
        }
        viewLifecycleOwner.lifecycleScope.launch {
            if (!isAdded) {
                return@launch
            }
            try {
                withContext(Dispatchers.IO) {
                    profileDbHandler.setResourceOpenCount(library)
                }
            } catch (ex: Exception) {
                ex.printStackTrace()
            }
            try {
                onRatingChanged()
            } catch (ex: Exception) {
                ex.printStackTrace()
            }
            setupDownloadButton()
            setClickListeners()
        }
    }

    private fun setupDownloadButton() {
        val isHtmlResource = library.mediaType == "HTML"
        val shouldShowButton = isHtmlResource || !TextUtils.isEmpty(library.resourceLocalAddress)

        binding.btnDownload.visibility = if (shouldShowButton) View.VISIBLE else View.GONE
        binding.btnDownload.setImageResource(
            if (!library.resourceOffline || library.isResourceOffline()) {
                R.drawable.ic_eye
            } else {
                R.drawable.ic_download
            })
        binding.btnDownload.contentDescription =
            if (!library.resourceOffline || library.isResourceOffline()) {
                getString(R.string.view)
            } else {
                getString(R.string.download)
            }
        if (getFileExtension(library.resourceLocalAddress) == "mp4") {
            binding.btnDownload.setImageResource(R.drawable.ic_play)
        }
    }

    private fun setTextViewVisibility(textView: TextView, layout: View, text: String?) {
        if (!text.isNullOrEmpty()) {
            textView.text = text
            layout.visibility = View.VISIBLE
        } else {
            layout.visibility = View.GONE
        }
    }

    private fun setClickListeners() {
        binding.btnDownload.setOnClickListener {
            val isHtmlResource = library.mediaType == "HTML"
            if (!isHtmlResource && TextUtils.isEmpty(library.resourceLocalAddress)) {
                Toast.makeText(activity, getString(R.string.link_not_available), Toast.LENGTH_LONG).show()
                return@setOnClickListener
            }
            openResource(library)
        }
        val userId = profileDbHandler.userModel?.id
        val isAdd = userId?.let { library.userId?.contains(it) } != true
        if (userModel?.isGuest() != true) {
            binding.btnRemove.setImageResource(
                if (isAdd) {
                    R.drawable.ic_add_library
                } else {
                    R.drawable.close_x
                }
            )
            binding.btnRemove.contentDescription =
                if (isAdd) {
                    getString(R.string.add_to_mylib)
                } else {
                    getString(R.string.remove)
                }
        } else {
            binding.btnRemove.visibility = View.GONE
        }
        binding.btnRemove.setOnClickListener {
            val userId = profileDbHandler.userModel?.id
            viewLifecycleOwner.lifecycleScope.launch {
                if (!isAdded) {
                    return@launch
                }
                val updatedLibrary = withContext(Dispatchers.IO) {
                    try {
                        if (userId != null) {
                            libraryRepository.updateUserLibrary(libraryId!!, userId, isAdd)
                        } else {
                            null
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                        null
                    }
                }
                try {
                    if (updatedLibrary != null) {
                        library = updatedLibrary
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
                Utilities.toast(activity, getString(R.string.resources) + " " +
                        if (isAdd) getString(R.string.added_to_my_library)
                        else getString(R.string.removed_from_mylibrary))
                setLibraryData()
            }
        }
        binding.btnBack.setOnClickListener {
            val activity = requireActivity()
            if (activity is AddResourceActivity) {
                activity.finish()
            } else {
                NavigationHelper.popBackStack(parentFragmentManager)
            }
        }
    }

    override fun onRatingChanged() {
        val `object` = databaseService.withRealm { realm ->
            getRatingsById(realm, "resource", library.resourceId, userModel?.id)
        }
        setRatings(`object`)
    }
    override fun onDestroy() {
        try {
            if (!mRealm.isClosed) {
                mRealm.close()
            }
        } catch (_: UninitializedPropertyAccessException) {
        }
        super.onDestroy()
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.resources


import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import android.widget.Toast
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.FragmentLibraryDetailBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.listToString
import org.ole.planet.myplanet.model.RealmRating.Companion.getRatingsById
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.FileUtils.getFileExtension
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class ResourceDetailFragment : BaseContainerFragment(), OnRatingChangeListener {
    private var _binding: FragmentLibraryDetailBinding? = null
    private val binding get() = _binding!!
    private var libraryId: String? = null
    private lateinit var library: RealmMyLibrary
    var userModel: RealmUserModel? = null
    private suspend fun fetchLibrary(libraryId: String): RealmMyLibrary? {
        return libraryRepository.getLibraryItemById(libraryId)
            ?: libraryRepository.getLibraryItemByResourceId(libraryId)
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            libraryId = requireArguments().getString("libraryId")
        }
    }

    override fun onDownloadComplete() {
        super.onDownloadComplete()
        if (!::library.isInitialized) {
            return
        }
        val binding = _binding ?: return
        viewLifecycleOwner.lifecycleScope.launch {
            if (!isAdded) {
                return@launch
            }
            val userId = profileDbHandler.userModel?.id
            try {
                val updatedLibrary = withContext(Dispatchers.IO) {
                    val backgroundLibrary = fetchLibrary(libraryId!!)
                    when {
                        backgroundLibrary == null -> null
                        backgroundLibrary.userId?.contains(userId) != true && userId != null ->
                            libraryRepository.updateUserLibrary(libraryId!!, userId, true)
                        else -> backgroundLibrary
                    }
                }
                if (updatedLibrary != null) {
                    library = updatedLibrary
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
            binding.btnDownload.setImageResource(R.drawable.ic_play)
            val currentUserId = profileDbHandler.userModel?.id
            if (currentUserId != null && library.userId?.contains(currentUserId) != true) {
                Utilities.toast(activity, getString(R.string.added_to_my_library))
                binding.btnRemove.setImageResource(R.drawable.close_x)
            }
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        super.onCreateView(inflater, container, savedInstanceState)
        _binding = FragmentLibraryDetailBinding.inflate(inflater, container, false)
        userModel = profileDbHandler.userModel
        setLoadingState(true)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewLifecycleOwner.lifecycleScope.launch {
            val id = libraryId
            if (id.isNullOrBlank()) {
                handleLibraryNotFound()
                return@launch
            }

            val fetchedLibrary = fetchLibrary(id)

            if (fetchedLibrary == null) {
                handleLibraryNotFound()
                return@launch
            }

            library = fetchedLibrary
            setLoadingState(false)
            initRatingView("resource", library.resourceId, library.title, this@ResourceDetailFragment)
            setLibraryData()
        }
    }

    private fun setLoadingState(isLoading: Boolean) {
        binding.btnDownload.isEnabled = !isLoading
        binding.btnRemove.isEnabled = !isLoading
        val alpha = if (isLoading) 0.5f else 1f
        binding.btnDownload.alpha = alpha
        binding.btnRemove.alpha = alpha
    }

    private fun handleLibraryNotFound() {
        Toast.makeText(requireContext(), "Resource not found", Toast.LENGTH_LONG).show()
        NavigationHelper.popBackStack(parentFragmentManager)
    }

    private fun setLibraryData() {
        with(binding) {
            tvTitle.text = library.title
            timesRated.text = requireContext().getString(R.string.num_total, library.timesRated)
            setTextViewVisibility(tvAuthor, llAuthor, library.author)
            setTextViewVisibility(tvPublished, llPublisher, library.publisher)
            setTextViewVisibility(tvMedia, llMedia, library.mediaType)
            setTextViewVisibility(tvSubject, llSubject, library.subjectsAsString)
            setTextViewVisibility(tvLanguage, llLanguage, library.language)
            setTextViewVisibility(tvLicense, llLicense, library.linkToLicense)
            setTextViewVisibility(tvResource, llResource, listToString(library.resourceFor))
            setTextViewVisibility(tvType, llType, library.resourceType)
        }
        viewLifecycleOwner.lifecycleScope.launch {
            if (!isAdded) {
                return@launch
            }
            try {
                withContext(Dispatchers.IO) {
                    profileDbHandler.setResourceOpenCount(library)
                }
            } catch (ex: Exception) {
                ex.printStackTrace()
            }
            try {
                onRatingChanged()
            } catch (ex: Exception) {
                ex.printStackTrace()
            }
            setupDownloadButton()
            setClickListeners()
        }
    }

    private fun setupDownloadButton() {
        val isHtmlResource = library.mediaType == "HTML"
        val shouldShowButton = isHtmlResource || !TextUtils.isEmpty(library.resourceLocalAddress)

        binding.btnDownload.visibility = if (shouldShowButton) View.VISIBLE else View.GONE
        binding.btnDownload.setImageResource(
            if (!library.resourceOffline || library.isResourceOffline()) {
                R.drawable.ic_eye
            } else {
                R.drawable.ic_download
            })
        binding.btnDownload.contentDescription =
            if (!library.resourceOffline || library.isResourceOffline()) {
                getString(R.string.view)
            } else {
                getString(R.string.download)
            }
        if (getFileExtension(library.resourceLocalAddress) == "mp4") {
            binding.btnDownload.setImageResource(R.drawable.ic_play)
        }
    }

    private fun setTextViewVisibility(textView: TextView, layout: View, text: String?) {
        if (!text.isNullOrEmpty()) {
            textView.text = text
            layout.visibility = View.VISIBLE
        } else {
            layout.visibility = View.GONE
        }
    }

    private fun setClickListeners() {
        binding.btnDownload.setOnClickListener {
            val isHtmlResource = library.mediaType == "HTML"
            if (!isHtmlResource && TextUtils.isEmpty(library.resourceLocalAddress)) {
                Toast.makeText(activity, getString(R.string.link_not_available), Toast.LENGTH_LONG).show()
                return@setOnClickListener
            }
            openResource(library)
        }
        val userId = profileDbHandler.userModel?.id
        val isAdd = userId?.let { library.userId?.contains(it) } != true
        if (userModel?.isGuest() != true) {
            binding.btnRemove.setImageResource(
                if (isAdd) {
                    R.drawable.ic_add_library
                } else {
                    R.drawable.close_x
                }
            )
            binding.btnRemove.contentDescription =
                if (isAdd) {
                    getString(R.string.add_to_mylib)
                } else {
                    getString(R.string.remove)
                }
        } else {
            binding.btnRemove.visibility = View.GONE
        }
        binding.btnRemove.setOnClickListener {
            val userId = profileDbHandler.userModel?.id
            viewLifecycleOwner.lifecycleScope.launch {
                if (!isAdded) {
                    return@launch
                }
                val updatedLibrary = withContext(Dispatchers.IO) {
                    try {
                        if (userId != null) {
                            libraryRepository.updateUserLibrary(libraryId!!, userId, isAdd)
                        } else {
                            null
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                        null
                    }
                }
                try {
                    if (updatedLibrary != null) {
                        library = updatedLibrary
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
                Utilities.toast(activity, getString(R.string.resources) + " " +
                        if (isAdd) getString(R.string.added_to_my_library)
                        else getString(R.string.removed_from_mylibrary))
                setLibraryData()
            }
        }
        binding.btnBack.setOnClickListener {
            val activity = requireActivity()
            if (activity is AddResourceActivity) {
                activity.finish()
            } else {
                NavigationHelper.popBackStack(parentFragmentManager)
            }
        }
    }

    override fun onRatingChanged() {
        val `object` = databaseService.withRealm { realm ->
            getRatingsById(realm, "resource", library.resourceId, userModel?.id)
        }
        setRatings(`object`)
    }
    override fun onDestroy() {
        try {
            if (!mRealm.isClosed) {
                mRealm.close()
            }
        } catch (_: UninitializedPropertyAccessException) {
        }
        super.onDestroy()
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/mypersonals/MyPersonalsFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.mypersonals

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnSelectedMyPersonal
import org.ole.planet.myplanet.databinding.AlertMyPersonalBinding
import org.ole.planet.myplanet.databinding.FragmentMyPersonalsBinding
import org.ole.planet.myplanet.model.RealmMyPersonal
import org.ole.planet.myplanet.repository.MyPersonalRepository
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.resources.AddResourceFragment
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class MyPersonalsFragment : Fragment(), OnSelectedMyPersonal {
    private var _binding: FragmentMyPersonalsBinding? = null
    private val binding get() = _binding!!
    private lateinit var pg: DialogUtils.CustomProgressDialog
    private var addResourceFragment: AddResourceFragment? = null
    private var personalAdapter: AdapterMyPersonal? = null

    @Inject
    lateinit var uploadManager: UploadManager
    @Inject
    lateinit var myPersonalRepository: MyPersonalRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMyPersonalsBinding.inflate(inflater, container, false)
        pg = DialogUtils.getCustomProgressDialog(requireContext())
        binding.rvMypersonal.layoutManager = LinearLayoutManager(activity)
        binding.addMyPersonal.setOnClickListener {
            addResourceFragment = AddResourceFragment()
            val b = Bundle()
            b.putInt("type", 1)
            addResourceFragment?.arguments = b
            addResourceFragment?.show(childFragmentManager, getString(R.string.add_resource))
        }
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setAdapter()
    }

    private fun setAdapter() {
        val model = userProfileDbHandler.userModel
        personalAdapter = AdapterMyPersonal(requireActivity(), mutableListOf())
        personalAdapter?.setListener(this)
        binding.rvMypersonal.adapter = personalAdapter
        viewLifecycleOwner.lifecycleScope.launch {
            myPersonalRepository.getPersonalResources(model?.id).collectLatest { realmMyPersonals ->
                personalAdapter?.updateList(realmMyPersonals)
                showNodata()
            }
        }
        showNodata()
    }

    private fun showNodata() {
        if (binding.rvMypersonal.adapter?.itemCount == 0) {
            binding.tvNodata.visibility = View.VISIBLE
            binding.tvNodata.setText(R.string.no_data_available_please_click_button_to_add_new_resource_in_mypersonal)
        } else {
            binding.tvNodata.visibility = View.GONE
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    override fun onUpload(personal: RealmMyPersonal?) {
        pg.setText("Please wait......")
        pg.show()
        if (personal != null) {
            uploadManager.uploadMyPersonal(personal) { s: String? ->
                if (s != null) {
                    Utilities.toast(activity, s)
                }
                pg.dismiss()
            }
        }
    }

    override fun onAddedResource() {
        // List updates are handled via repository flow
    }

    override fun onEditPersonal(personal: RealmMyPersonal) {
        val alertMyPersonalBinding = AlertMyPersonalBinding.inflate(LayoutInflater.from(requireContext()))
        alertMyPersonalBinding.etDescription.setText(personal.description)
        alertMyPersonalBinding.etTitle.setText(personal.title)
        AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
            .setTitle(R.string.edit_personal)
            .setIcon(R.drawable.ic_edit)
            .setView(alertMyPersonalBinding.root)
            .setPositiveButton(R.string.button_submit) { _, _ ->
                val title = alertMyPersonalBinding.etTitle.text.toString().trim { it <= ' ' }
                val desc = alertMyPersonalBinding.etDescription.text.toString().trim { it <= ' ' }
                if (title.isEmpty()) {
                    Utilities.toast(requireContext(), getString(R.string.please_enter_title))
                    return@setPositiveButton
                }
                val id = personal.id ?: personal._id
                if (id != null) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        myPersonalRepository.updatePersonalResource(id) { realmPersonal ->
                            realmPersonal.description = desc
                            realmPersonal.title = title
                        }
                    }
                }
            }
            .setNegativeButton(R.string.cancel, null)
            .show()
    }

    override fun onDeletePersonal(personal: RealmMyPersonal) {
        AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
            .setMessage(R.string.delete_record)
            .setPositiveButton(R.string.ok) { _, _ ->
                val id = personal.id ?: personal._id
                if (id != null) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        myPersonalRepository.deletePersonalResource(id)
                    }
                }
            }
            .setNegativeButton(R.string.cancel, null)
            .show()
    }
}
=======
package org.ole.planet.myplanet.ui.mypersonals


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnSelectedMyPersonal
import org.ole.planet.myplanet.databinding.AlertMyPersonalBinding
import org.ole.planet.myplanet.databinding.FragmentMyPersonalsBinding
import org.ole.planet.myplanet.model.RealmMyPersonal
import org.ole.planet.myplanet.repository.MyPersonalRepository
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.resources.AddResourceFragment
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class MyPersonalsFragment : Fragment(), OnSelectedMyPersonal {
    private var _binding: FragmentMyPersonalsBinding? = null
    private val binding get() = _binding!!
    private lateinit var pg: DialogUtils.CustomProgressDialog
    private var addResourceFragment: AddResourceFragment? = null
    private var personalAdapter: AdapterMyPersonal? = null

    @Inject
    lateinit var uploadManager: UploadManager
    @Inject
    lateinit var myPersonalRepository: MyPersonalRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMyPersonalsBinding.inflate(inflater, container, false)
        pg = DialogUtils.getCustomProgressDialog(requireContext())
        binding.rvMypersonal.layoutManager = LinearLayoutManager(activity)
        binding.addMyPersonal.setOnClickListener {
            addResourceFragment = AddResourceFragment()
            val b = Bundle()
            b.putInt("type", 1)
            addResourceFragment?.arguments = b
            addResourceFragment?.show(childFragmentManager, getString(R.string.add_resource))
        }
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setAdapter()
    }

    private fun setAdapter() {
        val model = userProfileDbHandler.userModel
        personalAdapter = AdapterMyPersonal(requireActivity(), mutableListOf())
        personalAdapter?.setListener(this)
        binding.rvMypersonal.adapter = personalAdapter
        viewLifecycleOwner.lifecycleScope.launch {
            myPersonalRepository.getPersonalResources(model?.id).collectLatest { realmMyPersonals ->
                personalAdapter?.updateList(realmMyPersonals)
                showNodata()
            }
        }
        showNodata()
    }

    private fun showNodata() {
        if (binding.rvMypersonal.adapter?.itemCount == 0) {
            binding.tvNodata.visibility = View.VISIBLE
            binding.tvNodata.setText(R.string.no_data_available_please_click_button_to_add_new_resource_in_mypersonal)
        } else {
            binding.tvNodata.visibility = View.GONE
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    override fun onUpload(personal: RealmMyPersonal?) {
        pg.setText("Please wait......")
        pg.show()
        if (personal != null) {
            uploadManager.uploadMyPersonal(personal) { s: String? ->
                if (s != null) {
                    Utilities.toast(activity, s)
                }
                pg.dismiss()
            }
        }
    }

    override fun onAddedResource() {
        // List updates are handled via repository flow
    }

    override fun onEditPersonal(personal: RealmMyPersonal) {
        val alertMyPersonalBinding = AlertMyPersonalBinding.inflate(LayoutInflater.from(requireContext()))
        alertMyPersonalBinding.etDescription.setText(personal.description)
        alertMyPersonalBinding.etTitle.setText(personal.title)
        AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
            .setTitle(R.string.edit_personal)
            .setIcon(R.drawable.ic_edit)
            .setView(alertMyPersonalBinding.root)
            .setPositiveButton(R.string.button_submit) { _, _ ->
                val title = alertMyPersonalBinding.etTitle.text.toString().trim { it <= ' ' }
                val desc = alertMyPersonalBinding.etDescription.text.toString().trim { it <= ' ' }
                if (title.isEmpty()) {
                    Utilities.toast(requireContext(), getString(R.string.please_enter_title))
                    return@setPositiveButton
                }
                val id = personal.id ?: personal._id
                if (id != null) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        myPersonalRepository.updatePersonalResource(id) { realmPersonal ->
                            realmPersonal.description = desc
                            realmPersonal.title = title
                        }
                    }
                }
            }
            .setNegativeButton(R.string.cancel, null)
            .show()
    }

    override fun onDeletePersonal(personal: RealmMyPersonal) {
        AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
            .setMessage(R.string.delete_record)
            .setPositiveButton(R.string.ok) { _, _ ->
                val id = personal.id ?: personal._id
                if (id != null) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        myPersonalRepository.deletePersonalResource(id)
                    }
                }
            }
            .setNegativeButton(R.string.cancel, null)
            .show()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/mypersonals/AdapterMyPersonal.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.mypersonals

import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import java.io.File
import org.ole.planet.myplanet.callback.OnSelectedMyPersonal
import org.ole.planet.myplanet.databinding.RowMyPersonalBinding
import org.ole.planet.myplanet.model.RealmMyPersonal
import org.ole.planet.myplanet.ui.mypersonals.AdapterMyPersonal.ViewHolderMyPersonal
import org.ole.planet.myplanet.ui.viewer.ImageViewerActivity
import org.ole.planet.myplanet.ui.viewer.PDFReaderActivity
import org.ole.planet.myplanet.ui.viewer.VideoPlayerActivity
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.IntentUtils.openAudioFile
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDate

class AdapterMyPersonal(private val context: Context, private var list: MutableList<RealmMyPersonal>) : RecyclerView.Adapter<ViewHolderMyPersonal>() {
    private var listener: OnSelectedMyPersonal? = null

    fun setListener(listener: OnSelectedMyPersonal?) {
        this.listener = listener
    }

    fun updateList(newList: List<RealmMyPersonal>) {
        val previousItems = list.toList()
        val diffResult = DiffUtils.calculateDiff(
            previousItems,
            newList,
            areItemsTheSame = { old, new -> old._id == new._id },
            areContentsTheSame = { old, new ->
                old.title == new.title &&
                    old.description == new.description &&
                    old.date == new.date &&
                    old.path == new.path
            }
        )
        list = newList.toMutableList()
        diffResult.dispatchUpdatesTo(this)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderMyPersonal {
        val binding = RowMyPersonalBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderMyPersonal(binding)
    }
    override fun onBindViewHolder(holder: ViewHolderMyPersonal, position: Int) {
        val binding = holder.binding
        val item = list[position]
        binding.title.text = item.title
        binding.description.text = item.description
        binding.date.text = getFormattedDate(item.date)
        binding.imgDelete.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition != RecyclerView.NO_POSITION) {
                listener?.onDeletePersonal(list[adapterPosition])
            }
        }
        binding.imgEdit.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition != RecyclerView.NO_POSITION) {
                listener?.onEditPersonal(list[adapterPosition])
            }
        }
        holder.itemView.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition != RecyclerView.NO_POSITION) {
                openResource(list[adapterPosition].path)
            }
        }
        binding.imgUpload.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition != RecyclerView.NO_POSITION && listener != null) {
                listener?.onUpload(list[adapterPosition])
            }
        }
    }
    private fun openResource(path: String?) {
        val arr = path?.split("\\.".toRegex())?.dropLastWhile { it.isEmpty() }?.toTypedArray()
        when (arr?.get(arr.size - 1)) {
            "pdf" -> context.startActivity(
                Intent(context, PDFReaderActivity::class.java).putExtra("TOUCHED_FILE", path)
            )
            "bmp", "gif", "jpg", "png", "webp" -> {
                val ii = Intent(context, ImageViewerActivity::class.java).putExtra("TOUCHED_FILE", path)
                ii.putExtra("isFullPath", true)
                context.startActivity(ii)
            }
            "aac", "mp3" -> openAudioFile(context, path)
            "mp4" -> openVideo(path)
        }
    }
    private fun openVideo(path: String?) {
        val b = Bundle()
        b.putString("videoURL", "" + Uri.fromFile(path?.let { File(it) }))
        b.putString("Auth", "" + Uri.fromFile(path?.let { File(it) }))
        b.putString("videoType", "offline")
        val i = Intent(context, VideoPlayerActivity::class.java).putExtra("TOUCHED_FILE", path)
        i.putExtras(b)
        context.startActivity(i)
    }
    override fun getItemCount(): Int {
        return list.size
    }
    class ViewHolderMyPersonal(val binding: RowMyPersonalBinding) : RecyclerView.ViewHolder(binding.root)
}
=======
package org.ole.planet.myplanet.ui.mypersonals


import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import java.io.File
import org.ole.planet.myplanet.callback.OnSelectedMyPersonal
import org.ole.planet.myplanet.databinding.RowMyPersonalBinding
import org.ole.planet.myplanet.model.RealmMyPersonal
import org.ole.planet.myplanet.ui.mypersonals.AdapterMyPersonal.ViewHolderMyPersonal
import org.ole.planet.myplanet.ui.viewer.ImageViewerActivity
import org.ole.planet.myplanet.ui.viewer.PDFReaderActivity
import org.ole.planet.myplanet.ui.viewer.VideoPlayerActivity
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.IntentUtils.openAudioFile
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDate

class AdapterMyPersonal(private val context: Context, private var list: MutableList<RealmMyPersonal>) : RecyclerView.Adapter<ViewHolderMyPersonal>() {
    private var listener: OnSelectedMyPersonal? = null

    fun setListener(listener: OnSelectedMyPersonal?) {
        this.listener = listener
    }

    fun updateList(newList: List<RealmMyPersonal>) {
        val previousItems = list.toList()
        val diffResult = DiffUtils.calculateDiff(
            previousItems,
            newList,
            areItemsTheSame = { old, new -> old._id == new._id },
            areContentsTheSame = { old, new ->
                old.title == new.title &&
                    old.description == new.description &&
                    old.date == new.date &&
                    old.path == new.path
            }
        )
        list = newList.toMutableList()
        diffResult.dispatchUpdatesTo(this)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderMyPersonal {
        val binding = RowMyPersonalBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderMyPersonal(binding)
    }
    override fun onBindViewHolder(holder: ViewHolderMyPersonal, position: Int) {
        val binding = holder.binding
        val item = list[position]
        binding.title.text = item.title
        binding.description.text = item.description
        binding.date.text = getFormattedDate(item.date)
        binding.imgDelete.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition != RecyclerView.NO_POSITION) {
                listener?.onDeletePersonal(list[adapterPosition])
            }
        }
        binding.imgEdit.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition != RecyclerView.NO_POSITION) {
                listener?.onEditPersonal(list[adapterPosition])
            }
        }
        holder.itemView.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition != RecyclerView.NO_POSITION) {
                openResource(list[adapterPosition].path)
            }
        }
        binding.imgUpload.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition != RecyclerView.NO_POSITION && listener != null) {
                listener?.onUpload(list[adapterPosition])
            }
        }
    }
    private fun openResource(path: String?) {
        val arr = path?.split("\\.".toRegex())?.dropLastWhile { it.isEmpty() }?.toTypedArray()
        when (arr?.get(arr.size - 1)) {
            "pdf" -> context.startActivity(
                Intent(context, PDFReaderActivity::class.java).putExtra("TOUCHED_FILE", path)
            )
            "bmp", "gif", "jpg", "png", "webp" -> {
                val ii = Intent(context, ImageViewerActivity::class.java).putExtra("TOUCHED_FILE", path)
                ii.putExtra("isFullPath", true)
                context.startActivity(ii)
            }
            "aac", "mp3" -> openAudioFile(context, path)
            "mp4" -> openVideo(path)
        }
    }
    private fun openVideo(path: String?) {
        val b = Bundle()
        b.putString("videoURL", "" + Uri.fromFile(path?.let { File(it) }))
        b.putString("Auth", "" + Uri.fromFile(path?.let { File(it) }))
        b.putString("videoType", "offline")
        val i = Intent(context, VideoPlayerActivity::class.java).putExtra("TOUCHED_FILE", path)
        i.putExtras(b)
        context.startActivity(i)
    }
    override fun getItemCount(): Int {
        return list.size
    }
    class ViewHolderMyPersonal(val binding: RowMyPersonalBinding) : RecyclerView.ViewHolder(binding.root)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/userprofile/BecomeMemberActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.userprofile

import android.app.DatePickerDialog
import android.content.Intent
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.widget.ArrayAdapter
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import java.util.Calendar
import java.util.Locale
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseActivity
import org.ole.planet.myplanet.callback.SecurityDataCallback
import org.ole.planet.myplanet.databinding.ActivityBecomeMemberBinding
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.sync.LoginActivity
import org.ole.planet.myplanet.utilities.AuthHelper
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DialogUtils.CustomProgressDialog
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.Utilities
import org.ole.planet.myplanet.utilities.VersionUtils

@AndroidEntryPoint
class BecomeMemberActivity : BaseActivity() {
    private lateinit var activityBecomeMemberBinding: ActivityBecomeMemberBinding
    private lateinit var mRealm: Realm
    var dob: String = ""
    var guest: Boolean = false
    private var usernameWatcher: TextWatcher? = null
    private var passwordWatcher: TextWatcher? = null

    private data class MemberInfo(
        val username: String,
        var password: String,
        val rePassword: String,
        val fName: String,
        val lName: String,
        val mName: String,
        val email: String,
        val language: String,
        val level: String,
        val phoneNumber: String,
        val birthDate: String,
        val gender: String?
    )

    private fun usernameValidationError(username: String, realm: Realm? = null): String? {
        return AuthHelper.validateUsername(this, username, realm)
    }

    private fun selectedGender(): String? = when {
        activityBecomeMemberBinding.male.isChecked -> "male"
        activityBecomeMemberBinding.female.isChecked -> "female"
        else -> null
    }

    private fun showDatePickerDialog() {
        val now = Calendar.getInstance()
        val dpd = DatePickerDialog(
            this, { _, i, i1, i2 ->
                dob = String.format(Locale.US, "%04d-%02d-%02d", i, i1 + 1, i2)
                activityBecomeMemberBinding.txtDob.text = dob
            }, now[Calendar.YEAR], now[Calendar.MONTH], now[Calendar.DAY_OF_MONTH]
        )
        dpd.setTitle(getString(R.string.select_date_of_birth))
        dpd.datePicker.maxDate = now.timeInMillis
        dpd.show()
    }

    private fun collectMemberInfo() = MemberInfo(
        activityBecomeMemberBinding.etUsername.text.toString(),
        activityBecomeMemberBinding.etPassword.text.toString(),
        activityBecomeMemberBinding.etRePassword.text.toString(),
        activityBecomeMemberBinding.etFname.text.toString(),
        activityBecomeMemberBinding.etLname.text.toString(),
        activityBecomeMemberBinding.etMname.text.toString(),
        activityBecomeMemberBinding.etEmail.text.toString(),
        activityBecomeMemberBinding.spnLang.selectedItem.toString(),
        activityBecomeMemberBinding.spnLevel.selectedItem.toString(),
        activityBecomeMemberBinding.etPhone.text.toString(),
        dob,
        selectedGender()
    )

    private fun validateMemberInfo(info: MemberInfo, realm: Realm): Boolean {
        usernameValidationError(info.username, realm)?.let {
            activityBecomeMemberBinding.etUsername.error = it
            return false
        }

        return when {
            info.password.isEmpty() -> {
                activityBecomeMemberBinding.etPassword.error = getString(R.string.please_enter_a_password)
                false
            }
            info.password != info.rePassword -> {
                activityBecomeMemberBinding.etRePassword.error = getString(R.string.password_doesn_t_match)
                false
            }
            info.email.isNotEmpty() && !Utilities.isValidEmail(info.email) -> {
                activityBecomeMemberBinding.etEmail.error = getString(R.string.invalid_email)
                false
            }
            info.gender == null -> {
                Utilities.toast(this, getString(R.string.please_select_gender))
                false
            }
            else -> true
        }
    }

    private fun buildMemberJson(info: MemberInfo) = JsonObject().apply {
        addProperty("name", info.username)
        addProperty("firstName", info.fName)
        addProperty("lastName", info.lName)
        addProperty("middleName", info.mName)
        addProperty("password", info.password)
        addProperty("isUserAdmin", false)
        addProperty("joinDate", Calendar.getInstance().timeInMillis)
        addProperty("email", info.email)
        addProperty("planetCode", settings.getString("planetCode", ""))
        addProperty("parentCode", settings.getString("parentCode", ""))
        addProperty("language", info.language)
        addProperty("level", info.level)
        addProperty("phoneNumber", info.phoneNumber)
        addProperty("birthDate", info.birthDate)
        addProperty("gender", info.gender)
        addProperty("type", "user")
        addProperty("betaEnabled", false)
        addProperty("androidId", NetworkUtils.getUniqueIdentifier())
        addProperty("uniqueAndroidId", VersionUtils.getAndroidId(MainApplication.context))
        addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(MainApplication.context))
        val roles = JsonArray().apply { add("learner") }
        add("roles", roles)
    }

    private fun addMember(info: MemberInfo, realm: Realm) {
        val obj = buildMemberJson(info)
        val customProgressDialog = CustomProgressDialog(this).apply {
            setText(getString(R.string.creating_member_account))
            show()
        }

        Service(this).becomeMember(realm, obj, object : Service.CreateUserCallback {
            override fun onSuccess(success: String) {
                runOnUiThread { Utilities.toast(this@BecomeMemberActivity, success) }
            }
        }, object : SecurityDataCallback {
            override fun onSecurityDataUpdated() {
                runOnUiThread {
                    customProgressDialog.dismiss()
                    autoLoginNewMember(info.username, info.password)
                }
            }
        })
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        mRealm = databaseService.realmInstance
        activityBecomeMemberBinding = ActivityBecomeMemberBinding.inflate(layoutInflater)
        setContentView(activityBecomeMemberBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, activityBecomeMemberBinding.root)
        supportActionBar?.setHomeButtonEnabled(true)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        val languages = resources.getStringArray(R.array.language)
        val lnAadapter = ArrayAdapter(this, R.layout.become_a_member_spinner_layout, languages)
        activityBecomeMemberBinding.spnLang.adapter = lnAadapter
        activityBecomeMemberBinding.txtDob.setOnClickListener {
            showDatePickerDialog()
        }
        val levels = resources.getStringArray(R.array.level)
        val lvAdapter  = ArrayAdapter(this, R.layout.become_a_member_spinner_layout, levels)
        activityBecomeMemberBinding.spnLevel.adapter = lvAdapter

        val username = intent.getStringExtra("username") ?: ""
        guest = intent.getBooleanExtra("guest", false)

        settings = getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        setupTextWatchers(mRealm)

        if (guest) {
            activityBecomeMemberBinding.etUsername.setText(username)
            activityBecomeMemberBinding.etUsername.isFocusable = false
        }


        activityBecomeMemberBinding.btnCancel.setOnClickListener {
            finish()
        }

        activityBecomeMemberBinding.btnSubmit.setOnClickListener {
            val info = collectMemberInfo()
            if (validateMemberInfo(info, mRealm)) {
                addMember(info, mRealm)
            }
        }
    }

    override fun onDestroy() {
        if (::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        activityBecomeMemberBinding.etUsername.removeTextChangedListener(usernameWatcher)
        activityBecomeMemberBinding.etPassword.removeTextChangedListener(passwordWatcher)
        usernameWatcher = null
        passwordWatcher = null
        super.onDestroy()
    }

    private fun autoLoginNewMember(username: String, password: String) {
        val mRealm = databaseService.realmInstance
        RealmUserModel.cleanupDuplicateUsers(mRealm) {
            mRealm.close()

            val intent = Intent(this, LoginActivity::class.java)
            intent.putExtra("username", username)
            intent.putExtra("password", password)
            intent.putExtra("auto_login", true)
            if (guest) {
                intent.putExtra("guest", guest)
            }
            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK)
            startActivity(intent)
            finish()
        }
    }

    private fun setupTextWatchers(mRealm: Realm) {
        usernameWatcher = object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}

            override fun afterTextChanged(s: Editable?) {
                val input = s?.toString() ?: ""
                val error = usernameValidationError(input, mRealm)
                if (error != null) {
                    activityBecomeMemberBinding.etUsername.error = error
                } else {
                    val lowercase = input.lowercase()
                    if (input != lowercase) {
                        activityBecomeMemberBinding.etUsername.setText(lowercase)
                        activityBecomeMemberBinding.etUsername.setSelection(lowercase.length)
                    }
                    activityBecomeMemberBinding.etUsername.error = null
                }
            }
        }
        activityBecomeMemberBinding.etUsername.addTextChangedListener(usernameWatcher)

        passwordWatcher = object : TextWatcher {
            override fun afterTextChanged(s: Editable) {
                if (activityBecomeMemberBinding.etPassword.text.toString().isEmpty()) {
                    activityBecomeMemberBinding.etRePassword.setText("")
                }
            }

            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {}
        }
        activityBecomeMemberBinding.etPassword.addTextChangedListener(passwordWatcher)
    }
}
=======
package org.ole.planet.myplanet.ui.userprofile


import android.app.DatePickerDialog
import android.content.Intent
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.widget.ArrayAdapter
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import java.util.Calendar
import java.util.Locale
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseActivity
import org.ole.planet.myplanet.callback.SecurityDataCallback
import org.ole.planet.myplanet.databinding.ActivityBecomeMemberBinding
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.sync.LoginActivity
import org.ole.planet.myplanet.utilities.AuthHelper
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DialogUtils.CustomProgressDialog
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.Utilities
import org.ole.planet.myplanet.utilities.VersionUtils

@AndroidEntryPoint
class BecomeMemberActivity : BaseActivity() {
    private lateinit var activityBecomeMemberBinding: ActivityBecomeMemberBinding
    private lateinit var mRealm: Realm
    var dob: String = ""
    var guest: Boolean = false
    private var usernameWatcher: TextWatcher? = null
    private var passwordWatcher: TextWatcher? = null

    private data class MemberInfo(
        val username: String,
        var password: String,
        val rePassword: String,
        val fName: String,
        val lName: String,
        val mName: String,
        val email: String,
        val language: String,
        val level: String,
        val phoneNumber: String,
        val birthDate: String,
        val gender: String?
    )

    private fun usernameValidationError(username: String, realm: Realm? = null): String? {
        return AuthHelper.validateUsername(this, username, realm)
    }

    private fun selectedGender(): String? = when {
        activityBecomeMemberBinding.male.isChecked -> "male"
        activityBecomeMemberBinding.female.isChecked -> "female"
        else -> null
    }

    private fun showDatePickerDialog() {
        val now = Calendar.getInstance()
        val dpd = DatePickerDialog(
            this, { _, i, i1, i2 ->
                dob = String.format(Locale.US, "%04d-%02d-%02d", i, i1 + 1, i2)
                activityBecomeMemberBinding.txtDob.text = dob
            }, now[Calendar.YEAR], now[Calendar.MONTH], now[Calendar.DAY_OF_MONTH]
        )
        dpd.setTitle(getString(R.string.select_date_of_birth))
        dpd.datePicker.maxDate = now.timeInMillis
        dpd.show()
    }

    private fun collectMemberInfo() = MemberInfo(
        activityBecomeMemberBinding.etUsername.text.toString(),
        activityBecomeMemberBinding.etPassword.text.toString(),
        activityBecomeMemberBinding.etRePassword.text.toString(),
        activityBecomeMemberBinding.etFname.text.toString(),
        activityBecomeMemberBinding.etLname.text.toString(),
        activityBecomeMemberBinding.etMname.text.toString(),
        activityBecomeMemberBinding.etEmail.text.toString(),
        activityBecomeMemberBinding.spnLang.selectedItem.toString(),
        activityBecomeMemberBinding.spnLevel.selectedItem.toString(),
        activityBecomeMemberBinding.etPhone.text.toString(),
        dob,
        selectedGender()
    )

    private fun validateMemberInfo(info: MemberInfo, realm: Realm): Boolean {
        usernameValidationError(info.username, realm)?.let {
            activityBecomeMemberBinding.etUsername.error = it
            return false
        }

        return when {
            info.password.isEmpty() -> {
                activityBecomeMemberBinding.etPassword.error = getString(R.string.please_enter_a_password)
                false
            }
            info.password != info.rePassword -> {
                activityBecomeMemberBinding.etRePassword.error = getString(R.string.password_doesn_t_match)
                false
            }
            info.email.isNotEmpty() && !Utilities.isValidEmail(info.email) -> {
                activityBecomeMemberBinding.etEmail.error = getString(R.string.invalid_email)
                false
            }
            info.gender == null -> {
                Utilities.toast(this, getString(R.string.please_select_gender))
                false
            }
            else -> true
        }
    }

    private fun buildMemberJson(info: MemberInfo) = JsonObject().apply {
        addProperty("name", info.username)
        addProperty("firstName", info.fName)
        addProperty("lastName", info.lName)
        addProperty("middleName", info.mName)
        addProperty("password", info.password)
        addProperty("isUserAdmin", false)
        addProperty("joinDate", Calendar.getInstance().timeInMillis)
        addProperty("email", info.email)
        addProperty("planetCode", settings.getString("planetCode", ""))
        addProperty("parentCode", settings.getString("parentCode", ""))
        addProperty("language", info.language)
        addProperty("level", info.level)
        addProperty("phoneNumber", info.phoneNumber)
        addProperty("birthDate", info.birthDate)
        addProperty("gender", info.gender)
        addProperty("type", "user")
        addProperty("betaEnabled", false)
        addProperty("androidId", NetworkUtils.getUniqueIdentifier())
        addProperty("uniqueAndroidId", VersionUtils.getAndroidId(MainApplication.context))
        addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(MainApplication.context))
        val roles = JsonArray().apply { add("learner") }
        add("roles", roles)
    }

    private fun addMember(info: MemberInfo, realm: Realm) {
        val obj = buildMemberJson(info)
        val customProgressDialog = CustomProgressDialog(this).apply {
            setText(getString(R.string.creating_member_account))
            show()
        }

        Service(this).becomeMember(realm, obj, object : Service.CreateUserCallback {
            override fun onSuccess(success: String) {
                runOnUiThread { Utilities.toast(this@BecomeMemberActivity, success) }
            }
        }, object : SecurityDataCallback {
            override fun onSecurityDataUpdated() {
                runOnUiThread {
                    customProgressDialog.dismiss()
                    autoLoginNewMember(info.username, info.password)
                }
            }
        })
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        mRealm = databaseService.realmInstance
        activityBecomeMemberBinding = ActivityBecomeMemberBinding.inflate(layoutInflater)
        setContentView(activityBecomeMemberBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdgeWithKeyboard(this, activityBecomeMemberBinding.root)
        supportActionBar?.setHomeButtonEnabled(true)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        val languages = resources.getStringArray(R.array.language)
        val lnAadapter = ArrayAdapter(this, R.layout.become_a_member_spinner_layout, languages)
        activityBecomeMemberBinding.spnLang.adapter = lnAadapter
        activityBecomeMemberBinding.txtDob.setOnClickListener {
            showDatePickerDialog()
        }
        val levels = resources.getStringArray(R.array.level)
        val lvAdapter  = ArrayAdapter(this, R.layout.become_a_member_spinner_layout, levels)
        activityBecomeMemberBinding.spnLevel.adapter = lvAdapter

        val username = intent.getStringExtra("username") ?: ""
        guest = intent.getBooleanExtra("guest", false)

        settings = getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        setupTextWatchers(mRealm)

        if (guest) {
            activityBecomeMemberBinding.etUsername.setText(username)
            activityBecomeMemberBinding.etUsername.isFocusable = false
        }


        activityBecomeMemberBinding.btnCancel.setOnClickListener {
            finish()
        }

        activityBecomeMemberBinding.btnSubmit.setOnClickListener {
            val info = collectMemberInfo()
            if (validateMemberInfo(info, mRealm)) {
                addMember(info, mRealm)
            }
        }
    }

    override fun onDestroy() {
        if (::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        activityBecomeMemberBinding.etUsername.removeTextChangedListener(usernameWatcher)
        activityBecomeMemberBinding.etPassword.removeTextChangedListener(passwordWatcher)
        usernameWatcher = null
        passwordWatcher = null
        super.onDestroy()
    }

    private fun autoLoginNewMember(username: String, password: String) {
        val mRealm = databaseService.realmInstance
        RealmUserModel.cleanupDuplicateUsers(mRealm) {
            mRealm.close()

            val intent = Intent(this, LoginActivity::class.java)
            intent.putExtra("username", username)
            intent.putExtra("password", password)
            intent.putExtra("auto_login", true)
            if (guest) {
                intent.putExtra("guest", guest)
            }
            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK)
            startActivity(intent)
            finish()
        }
    }

    private fun setupTextWatchers(mRealm: Realm) {
        usernameWatcher = object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}

            override fun afterTextChanged(s: Editable?) {
                val input = s?.toString() ?: ""
                val error = usernameValidationError(input, mRealm)
                if (error != null) {
                    activityBecomeMemberBinding.etUsername.error = error
                } else {
                    val lowercase = input.lowercase()
                    if (input != lowercase) {
                        activityBecomeMemberBinding.etUsername.setText(lowercase)
                        activityBecomeMemberBinding.etUsername.setSelection(lowercase.length)
                    }
                    activityBecomeMemberBinding.etUsername.error = null
                }
            }
        }
        activityBecomeMemberBinding.etUsername.addTextChangedListener(usernameWatcher)

        passwordWatcher = object : TextWatcher {
            override fun afterTextChanged(s: Editable) {
                if (activityBecomeMemberBinding.etPassword.text.toString().isEmpty()) {
                    activityBecomeMemberBinding.etRePassword.setText("")
                }
            }

            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {}
        }
        activityBecomeMemberBinding.etPassword.addTextChangedListener(passwordWatcher)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/userprofile/TeamListAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.userprofile

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.UserListItemBinding
import org.ole.planet.myplanet.model.User
import org.ole.planet.myplanet.utilities.DiffUtils

class TeamListAdapter(
    private var membersList: MutableList<User>,
    private val onItemClickListener: OnItemClickListener
) : RecyclerView.Adapter<TeamListAdapter.ViewHolder>() {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val binding = UserListItemBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolder(binding)
    }

    interface OnItemClickListener {
        fun onItemClick(user: User)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bindView(membersList[position])

        holder.itemView.setOnClickListener {
            val currentPosition = holder.bindingAdapterPosition
            if (currentPosition != RecyclerView.NO_POSITION) {
                val member = membersList[currentPosition]
                onItemClickListener.onItemClick(member)
            }
        }
    }

    override fun getItemCount(): Int {
        return membersList.size
    }

    fun updateList(newUserList: MutableList<User>) {
        val diffResult = DiffUtils.calculateDiff(
            membersList,
            newUserList,
            areItemsTheSame = { old, new -> old.name == new.name },
            areContentsTheSame = { old, new ->
                old.name == new.name &&
                    old.fullName == new.fullName &&
                    old.image == new.image
            }
        )
        membersList.clear()
        membersList.addAll(newUserList)
        diffResult.dispatchUpdatesTo(this)
    }

    fun getList(): List<User> = membersList

    class ViewHolder(private val binding: UserListItemBinding) : RecyclerView.ViewHolder(binding.root) {
        fun bindView(account: User) {
            if (account.fullName?.isEmpty() == true || account.fullName == " ") {
                binding.userNameTextView.text = account.name
            } else {
                binding.userNameTextView.text = account.fullName
            }
            Glide.with(binding.userProfile.context)
                .load(account.image)
                .placeholder(R.drawable.profile)
                .error(R.drawable.profile)
                .into(binding.userProfile)
        }
    }

}
=======
package org.ole.planet.myplanet.ui.userprofile


import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.UserListItemBinding
import org.ole.planet.myplanet.model.User
import org.ole.planet.myplanet.utilities.DiffUtils

class TeamListAdapter(
    private var membersList: MutableList<User>,
    private val onItemClickListener: OnItemClickListener
) : RecyclerView.Adapter<TeamListAdapter.ViewHolder>() {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val binding = UserListItemBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolder(binding)
    }

    interface OnItemClickListener {
        fun onItemClick(user: User)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bindView(membersList[position])

        holder.itemView.setOnClickListener {
            val currentPosition = holder.bindingAdapterPosition
            if (currentPosition != RecyclerView.NO_POSITION) {
                val member = membersList[currentPosition]
                onItemClickListener.onItemClick(member)
            }
        }
    }

    override fun getItemCount(): Int {
        return membersList.size
    }

    fun updateList(newUserList: MutableList<User>) {
        val diffResult = DiffUtils.calculateDiff(
            membersList,
            newUserList,
            areItemsTheSame = { old, new -> old.name == new.name },
            areContentsTheSame = { old, new ->
                old.name == new.name &&
                    old.fullName == new.fullName &&
                    old.image == new.image
            }
        )
        membersList.clear()
        membersList.addAll(newUserList)
        diffResult.dispatchUpdatesTo(this)
    }

    fun getList(): List<User> = membersList

    class ViewHolder(private val binding: UserListItemBinding) : RecyclerView.ViewHolder(binding.root) {
        fun bindView(account: User) {
            if (account.fullName?.isEmpty() == true || account.fullName == " ") {
                binding.userNameTextView.text = account.name
            } else {
                binding.userNameTextView.text = account.fullName
            }
            Glide.with(binding.userProfile.context)
                .load(account.image)
                .placeholder(R.drawable.profile)
                .error(R.drawable.profile)
                .into(binding.userProfile)
        }
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/userprofile/AdapterOtherInfo.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.userprofile

import android.content.Context
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.RealmList
import org.ole.planet.myplanet.databinding.RowOtherInfoBinding
import org.ole.planet.myplanet.ui.userprofile.AdapterOtherInfo.ViewHolderOtherInfo
import org.ole.planet.myplanet.utilities.JsonUtils.getString

class AdapterOtherInfo(private val context: Context, private val list: RealmList<String>) :
    RecyclerView.Adapter<ViewHolderOtherInfo>() {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderOtherInfo {
        val binding = RowOtherInfoBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        )
        return ViewHolderOtherInfo(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderOtherInfo, position: Int) {
        if (position < list.size) {
            val jsonString = list[position]
            val `object` = Gson().fromJson(jsonString, JsonObject::class.java)
            val res = """
                ${getString("name", `object`)}
                ${getString("relationship", `object`)}
                ${getString("phone", `object`)}
                ${getString("email", `object`)}
                """.trimIndent()
            holder.rowOtherInfoBinding.tvDescription.text = res
        }
    }

    override fun getItemCount(): Int {
        return list.size
    }

    class ViewHolderOtherInfo(var rowOtherInfoBinding: RowOtherInfoBinding) : RecyclerView.ViewHolder(rowOtherInfoBinding.root)
}
=======
package org.ole.planet.myplanet.ui.userprofile


import android.content.Context
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.RealmList
import org.ole.planet.myplanet.databinding.RowOtherInfoBinding
import org.ole.planet.myplanet.ui.userprofile.AdapterOtherInfo.ViewHolderOtherInfo
import org.ole.planet.myplanet.utilities.JsonUtils.getString

class AdapterOtherInfo(private val context: Context, private val list: RealmList<String>) :
    RecyclerView.Adapter<ViewHolderOtherInfo>() {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderOtherInfo {
        val binding = RowOtherInfoBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        )
        return ViewHolderOtherInfo(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderOtherInfo, position: Int) {
        if (position < list.size) {
            val jsonString = list[position]
            val `object` = Gson().fromJson(jsonString, JsonObject::class.java)
            val res = """
                ${getString("name", `object`)}
                ${getString("relationship", `object`)}
                ${getString("phone", `object`)}
                ${getString("email", `object`)}
                """.trimIndent()
            holder.rowOtherInfoBinding.tvDescription.text = res
        }
    }

    override fun getItemCount(): Int {
        return list.size
    }

    class ViewHolderOtherInfo(var rowOtherInfoBinding: RowOtherInfoBinding) : RecyclerView.ViewHolder(rowOtherInfoBinding.root)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/userprofile/EditAchievementFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.userprofile

import android.app.DatePickerDialog
import android.content.DialogInterface
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.DatePicker
import android.widget.EditText
import android.widget.ListView
import android.widget.Toast
import android.widget.Toolbar
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.widget.AppCompatTextView
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import fisk.chipcloud.ChipCloud
import io.realm.Realm
import java.util.Calendar
import java.util.Locale
import kotlin.Array
import kotlin.Int
import kotlin.String
import kotlin.arrayOf
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.databinding.AlertAddAttachmentBinding
import org.ole.planet.myplanet.databinding.AlertReferenceBinding
import org.ole.planet.myplanet.databinding.EditAttachementBinding
import org.ole.planet.myplanet.databinding.EditOtherInfoBinding
import org.ole.planet.myplanet.databinding.FragmentEditAchievementBinding
import org.ole.planet.myplanet.databinding.MyLibraryAlertdialogBinding
import org.ole.planet.myplanet.databinding.RowlayoutBinding
import org.ole.planet.myplanet.model.RealmAchievement
import org.ole.planet.myplanet.model.RealmAchievement.Companion.createReference
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.CheckboxListView
import org.ole.planet.myplanet.utilities.DialogUtils.getDialog
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDate
import org.ole.planet.myplanet.utilities.Utilities

class EditAchievementFragment : BaseContainerFragment(), DatePickerDialog.OnDateSetListener {
    private lateinit var fragmentEditAchievementBinding: FragmentEditAchievementBinding
    private lateinit var editAttachmentBinding: EditAttachementBinding
    private lateinit var editOtherInfoBinding: EditOtherInfoBinding
    private lateinit var alertReferenceBinding: AlertReferenceBinding
    private lateinit var alertAddAttachmentBinding: AlertAddAttachmentBinding
    private lateinit var myLibraryAlertdialogBinding: MyLibraryAlertdialogBinding
    private lateinit var aRealm: Realm
    var user: RealmUserModel? = null
    private var achievement: RealmAchievement? = null
    private var referenceArray: JsonArray? = null
    private var achievementArray: JsonArray? = null
    private var resourceArray: JsonArray? = null
    private var referenceDialog: AlertDialog? = null

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        fragmentEditAchievementBinding = FragmentEditAchievementBinding.inflate(inflater, container, false)
        aRealm = databaseService.realmInstance
        user = profileDbHandler.userModel
        achievementArray = JsonArray()
        initializeData()
        setListeners()
        return fragmentEditAchievementBinding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val toolbar = view.findViewById<androidx.appcompat.widget.Toolbar>(R.id.toolbar)
        toolbar.setNavigationOnClickListener {
            NavigationHelper.popBackStack(requireActivity().supportFragmentManager)
        }
    }

    private fun setListeners() {
        fragmentEditAchievementBinding.btnUpdate.setOnClickListener {
            if (!aRealm.isInTransaction) aRealm.beginTransaction()
            setUserInfo()
            setAchievementInfo()
            aRealm.commitTransaction()
            NavigationHelper.popBackStack(parentFragmentManager)
        }
        fragmentEditAchievementBinding.btnCancel.setOnClickListener {
            NavigationHelper.popBackStack(parentFragmentManager)
        }
        fragmentEditAchievementBinding.btnAchievement.setOnClickListener {
            showAddAchievementAlert(null)
        }
        fragmentEditAchievementBinding.btnOther.setOnClickListener {
            showReferenceDialog(null)
        }
        fragmentEditAchievementBinding.txtDob.setOnClickListener {
            val now = Calendar.getInstance()
            val dpd = DatePickerDialog(requireActivity(), this, now[Calendar.YEAR], now[Calendar.MONTH], now[Calendar.DAY_OF_MONTH])
            dpd.datePicker.maxDate = Calendar.getInstance().timeInMillis
            dpd.show()
        }
    }

    private fun showAchievementAndInfo() {
        val config = Utilities.getCloudConfig().selectMode(ChipCloud.SelectMode.single)
        fragmentEditAchievementBinding.llAttachment.removeAllViews()
        for (e in achievementArray!!) {
            editAttachmentBinding = EditAttachementBinding.inflate(LayoutInflater.from(activity))
            editAttachmentBinding.tvTitle.text = e.asJsonObject["title"].asString
            val flexboxLayout = editAttachmentBinding.flexbox
            flexboxLayout.removeAllViews()
            val chipCloud = ChipCloud(activity, flexboxLayout, config)
            for (element in e.asJsonObject.getAsJsonArray("resources")) {
                chipCloud.addChip(element.asJsonObject["title"].asString)
            }
            editAttachmentBinding.ivDelete.setOnClickListener {
                achievementArray?.remove(e)
                showAchievementAndInfo()
            }
            editAttachmentBinding.edit.setOnClickListener { showAddAchievementAlert(e.asJsonObject) }
            val editAttachmentView: View = editAttachmentBinding.root
            fragmentEditAchievementBinding.llAttachment.addView(editAttachmentView)
        }
    }

    private fun showReference() {
        fragmentEditAchievementBinding.llOtherInfo.removeAllViews()
        for (e in referenceArray!!) {
            editOtherInfoBinding = EditOtherInfoBinding.inflate(LayoutInflater.from(activity))
            editOtherInfoBinding.tvTitle.text = e.asJsonObject["name"].asString
            editOtherInfoBinding.ivDelete.setOnClickListener {
                referenceArray?.remove(e)
                showReference()
            }
            editOtherInfoBinding.edit.setOnClickListener { showReferenceDialog(e.asJsonObject) }
            val editOtherInfoView: View = editOtherInfoBinding.root
            fragmentEditAchievementBinding.llOtherInfo.addView(editOtherInfoView)
        }
    }

    private fun showReferenceDialog(`object`: JsonObject?) {
        alertReferenceBinding = AlertReferenceBinding.inflate(LayoutInflater.from(activity))
        val ar = arrayOf(
            alertReferenceBinding.etName,
            alertReferenceBinding.etPhone,
            alertReferenceBinding.etEmail,
            alertReferenceBinding.etRelationship
        )
        setPrevReference(ar, `object`)
        val alertReferenceView: View = alertReferenceBinding.root
        referenceDialog = getDialog(requireActivity(), getString(R.string.add_reference), alertReferenceView)
        referenceDialog?.show()
        referenceDialog?.getButton(AlertDialog.BUTTON_POSITIVE)?.setOnClickListener {
            val name = alertReferenceBinding.etName.text.toString().trim { it <= ' ' }
            if (name.isEmpty()) {
                alertReferenceBinding.tlName.error = getString(R.string.name_is_required)
                return@setOnClickListener
            }
            if (`object` != null) referenceArray?.remove(`object`)
            if (referenceArray == null) referenceArray = JsonArray()
            referenceArray?.add(createReference(name, alertReferenceBinding.etRelationship, alertReferenceBinding.etPhone, alertReferenceBinding.etEmail))
            showReference()
            referenceDialog?.dismiss()
        }
    }

    private fun setPrevReference(ar: Array<EditText>, `object`: JsonObject?) {
        if (`object` != null) {
            ar[0].setText(`object`["name"].asString)
            ar[1].setText(`object`["phone"].asString)
            ar[2].setText(`object`["email"].asString)
            ar[3].setText(`object`["relationship"].asString)
        }
    }

    var date = ""
    private fun showAddAchievementAlert(`object`: JsonObject?) {
        alertAddAttachmentBinding = AlertAddAttachmentBinding.inflate(LayoutInflater.from(activity))
        alertAddAttachmentBinding.tvDate.setOnClickListener {
            val now = Calendar.getInstance()
            val dpd = DatePickerDialog(requireActivity(), { _: DatePicker?, i: Int, i1: Int, i2: Int ->
                date = String.format(Locale.US, "%04d-%02d-%02d", i, i1 + 1, i2)
                alertAddAttachmentBinding.tvDate.text = date },
                now[Calendar.YEAR], now[Calendar.MONTH], now[Calendar.DAY_OF_MONTH])
            dpd.datePicker.maxDate = now.timeInMillis
            dpd.show()
        }
        resourceArray = JsonArray()
        val prevList = setUpOldAchievement(
            `object`,
            alertAddAttachmentBinding.etDesc,
            alertAddAttachmentBinding.etTitle,
            alertAddAttachmentBinding.tvDate as AppCompatTextView
        )
        alertAddAttachmentBinding.btnAddResources.setOnClickListener {
            showResourceListDialog(prevList)
        }
        val tintColor = ContextCompat.getColorStateList(requireContext(), R.color.daynight_textColor)
        alertAddAttachmentBinding.etDesc.backgroundTintList = tintColor
        alertAddAttachmentBinding.etTitle.backgroundTintList = tintColor
        val alertAddAttachmentView: View = alertAddAttachmentBinding.root
        AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
            .setTitle(R.string.add_achievement)
            .setIcon(R.drawable.ic_edit)
            .setView(alertAddAttachmentView)
            .setCancelable(false)
            .setPositiveButton("Submit") { _: DialogInterface?, _: Int ->
                val desc = alertAddAttachmentBinding.etDesc.text.toString().trim { it <= ' ' }
                val title = alertAddAttachmentBinding.etTitle.text.toString().trim { it <= ' ' }
                if (title.isEmpty()) {
                    Toast.makeText(activity, getString(R.string.title_is_required), Toast.LENGTH_SHORT).show()
                    return@setPositiveButton
                }
                if (`object` != null) achievementArray?.remove(`object`)
                saveAchievement(desc, title)
            }.setNegativeButton(getString(R.string.cancel), null).show()
    }

    private fun setUpOldAchievement(`object`: JsonObject?, etDescription: EditText, etTitle: EditText, tvDate: AppCompatTextView): List<String?> {
        val prevList: MutableList<String?> = ArrayList()
        if (`object` != null) {
            etTitle.setText(`object`["title"].asString)
            etDescription.setText(`object`["description"].asString)
            tvDate.text = `object`["date"].asString
            val array = `object`.getAsJsonArray("resources")
            date = `object`["date"].asString
            for (o in array) {
                prevList.add(o.asJsonObject["title"].asString)
            }
            resourceArray = `object`.getAsJsonArray("resources")
        }
        return prevList
    }

    private fun saveAchievement(desc: String, title: String) {
        val `object` = JsonObject()
        `object`.addProperty("description", desc)
        `object`.addProperty("title", title)
        `object`.addProperty("date", date)
        `object`.add("resources", resourceArray)
        achievementArray?.add(`object`)
        showAchievementAndInfo()
    }

    private fun showResourceListDialog(prevList: List<String?>) {
        val builder = AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
        builder.setTitle(R.string.select_resources)
        val list: List<RealmMyLibrary> = aRealm.where(RealmMyLibrary::class.java).findAll()
        myLibraryAlertdialogBinding = MyLibraryAlertdialogBinding.inflate(LayoutInflater.from(activity))
        val myLibraryAlertdialogView: View = myLibraryAlertdialogBinding.root
        val lv = createResourceList(myLibraryAlertdialogBinding, list, prevList)
        builder.setView(myLibraryAlertdialogView)
        builder.setPositiveButton("Ok") { _: DialogInterface?, _: Int ->
            val items = lv.selectedItemsList
            resourceArray = JsonArray()
            for (ii in items) {
                resourceArray?.add(list[ii].serializeResource())
            }
        }.setNegativeButton("Cancel", null).show()
    }

    override fun onDateSet(datePicker: DatePicker, i: Int, i1: Int, i2: Int) {
        fragmentEditAchievementBinding.txtDob.text =
            String.format(Locale.US, "%04d-%02d-%02d", i, i1 + 1, i2)
    }

    private fun initializeData() {
        val achievementId = user?.id + "@" + user?.planetCode
        achievement = aRealm.where(RealmAchievement::class.java)
            .equalTo("_id", achievementId)
            .findFirst()

        if (achievement == null) {
            lifecycleScope.launch {
                databaseService.withRealmAsync { realm ->
                    realm.executeTransaction { transactionRealm ->
                        val existing = transactionRealm.where(RealmAchievement::class.java)
                            .equalTo("_id", achievementId)
                            .findFirst()
                        if (existing == null) {
                            transactionRealm.createObject(
                                RealmAchievement::class.java,
                                achievementId
                            )
                        }
                    }
                }
                if (!isAdded) {
                    return@launch
                }
                aRealm.refresh()
                achievement = aRealm.where(RealmAchievement::class.java)
                    .equalTo("_id", achievementId)
                    .findFirst()
                populateAchievementData()
            }
        } else {
            populateAchievementData()
        }
    }

    private fun populateAchievementData() {
        achievementArray = achievement?.achievementsArray ?: achievementArray
        referenceArray = achievement?.getReferencesArray() ?: referenceArray
        fragmentEditAchievementBinding.etAchievement.setText(achievement?.achievementsHeader)
        fragmentEditAchievementBinding.etPurpose.setText(achievement?.purpose)
        fragmentEditAchievementBinding.etGoals.setText(achievement?.goals)
        fragmentEditAchievementBinding.cbSendToNation.isChecked = achievement?.sendToNation.toBoolean()
        fragmentEditAchievementBinding.txtDob.text = if (TextUtils.isEmpty(user?.dob)) getString(R.string.birth_date) else getFormattedDate(user?.dob, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
        resourceArray = JsonArray()
        fragmentEditAchievementBinding.etFname.setText(user?.firstName)
        fragmentEditAchievementBinding.etMname.setText(user?.middleName)
        fragmentEditAchievementBinding.etLname.setText(user?.lastName)
        fragmentEditAchievementBinding.etBirthplace.setText(user?.birthPlace)
        if (achievementArray != null) {
            showAchievementAndInfo()
        }
        if (referenceArray != null) {
            showReference()
        }
    }

    private fun createResourceList(myLibraryAlertdialogBinding: MyLibraryAlertdialogBinding, list: List<RealmMyLibrary>, prevList: List<String?>): CheckboxListView {
        val names = ArrayList<String?>()
        val selected: ArrayList<Int> = ArrayList()
        for (i in list.indices) {
            names.add(list[i].title)
            if (prevList.contains(list[i].title)) selected.add(i)
        }
        val adapter: ArrayAdapter<String?> = object : ArrayAdapter<String?>(requireActivity(), R.layout.item_checkbox, R.id.checkBoxRowLayout, names) {
            override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
                val rowLayoutBinding = RowlayoutBinding.inflate(LayoutInflater.from(parent.context), parent, false)
                val textView = rowLayoutBinding.root
                textView.text = getItem(position)
                textView.isChecked = myLibraryAlertdialogBinding.alertDialogListView.selectedItemsList.contains(position)
                myLibraryAlertdialogBinding.alertDialogListView.setItemChecked(position, myLibraryAlertdialogBinding.alertDialogListView.selectedItemsList.contains(position))
                return textView
            }
        }
        myLibraryAlertdialogBinding.alertDialogListView.selectedItemsList = selected
        myLibraryAlertdialogBinding.alertDialogListView.choiceMode = ListView.CHOICE_MODE_MULTIPLE
        myLibraryAlertdialogBinding.alertDialogListView.adapter = adapter
        return myLibraryAlertdialogBinding.alertDialogListView
    }

    private fun setUserInfo() {}
    private fun setAchievementInfo() {
        achievement?.achievementsHeader = fragmentEditAchievementBinding.etAchievement.text.toString().trim { it <= ' ' }
        achievement?.goals = fragmentEditAchievementBinding.etGoals.text.toString().trim { it <= ' ' }
        achievement?.purpose = fragmentEditAchievementBinding.etPurpose.text.toString().trim { it <= ' ' }
        achievement?.setAchievements(achievementArray!!)
        achievement?.setReferences(referenceArray)
        achievement?.sendToNation = fragmentEditAchievementBinding.cbSendToNation.isChecked.toString() + ""
    }

    override fun onDestroyView() {
        referenceDialog?.dismiss()
        referenceDialog = null
        super.onDestroyView()
    }

    override fun onDestroy() {
        if (this::aRealm.isInitialized && !aRealm.isClosed) {
            aRealm.close()
        }
        try {
            if (!mRealm.isClosed) {
                mRealm.close()
            }
        } catch (_: UninitializedPropertyAccessException) {
        }
        super.onDestroy()
    }
}
=======
package org.ole.planet.myplanet.ui.userprofile


import android.app.DatePickerDialog
import android.content.DialogInterface
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.DatePicker
import android.widget.EditText
import android.widget.ListView
import android.widget.Toast
import android.widget.Toolbar
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.widget.AppCompatTextView
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import fisk.chipcloud.ChipCloud
import io.realm.Realm
import java.util.Calendar
import java.util.Locale
import kotlin.Array
import kotlin.Int
import kotlin.String
import kotlin.arrayOf
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.databinding.AlertAddAttachmentBinding
import org.ole.planet.myplanet.databinding.AlertReferenceBinding
import org.ole.planet.myplanet.databinding.EditAttachementBinding
import org.ole.planet.myplanet.databinding.EditOtherInfoBinding
import org.ole.planet.myplanet.databinding.FragmentEditAchievementBinding
import org.ole.planet.myplanet.databinding.MyLibraryAlertdialogBinding
import org.ole.planet.myplanet.databinding.RowlayoutBinding
import org.ole.planet.myplanet.model.RealmAchievement
import org.ole.planet.myplanet.model.RealmAchievement.Companion.createReference
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.CheckboxListView
import org.ole.planet.myplanet.utilities.DialogUtils.getDialog
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDate
import org.ole.planet.myplanet.utilities.Utilities

class EditAchievementFragment : BaseContainerFragment(), DatePickerDialog.OnDateSetListener {
    private lateinit var fragmentEditAchievementBinding: FragmentEditAchievementBinding
    private lateinit var editAttachmentBinding: EditAttachementBinding
    private lateinit var editOtherInfoBinding: EditOtherInfoBinding
    private lateinit var alertReferenceBinding: AlertReferenceBinding
    private lateinit var alertAddAttachmentBinding: AlertAddAttachmentBinding
    private lateinit var myLibraryAlertdialogBinding: MyLibraryAlertdialogBinding
    private lateinit var aRealm: Realm
    var user: RealmUserModel? = null
    private var achievement: RealmAchievement? = null
    private var referenceArray: JsonArray? = null
    private var achievementArray: JsonArray? = null
    private var resourceArray: JsonArray? = null
    private var referenceDialog: AlertDialog? = null

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        fragmentEditAchievementBinding = FragmentEditAchievementBinding.inflate(inflater, container, false)
        aRealm = databaseService.realmInstance
        user = profileDbHandler.userModel
        achievementArray = JsonArray()
        initializeData()
        setListeners()
        return fragmentEditAchievementBinding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val toolbar = view.findViewById<androidx.appcompat.widget.Toolbar>(R.id.toolbar)
        toolbar.setNavigationOnClickListener {
            NavigationHelper.popBackStack(requireActivity().supportFragmentManager)
        }
    }

    private fun setListeners() {
        fragmentEditAchievementBinding.btnUpdate.setOnClickListener {
            if (!aRealm.isInTransaction) aRealm.beginTransaction()
            setUserInfo()
            setAchievementInfo()
            aRealm.commitTransaction()
            NavigationHelper.popBackStack(parentFragmentManager)
        }
        fragmentEditAchievementBinding.btnCancel.setOnClickListener {
            NavigationHelper.popBackStack(parentFragmentManager)
        }
        fragmentEditAchievementBinding.btnAchievement.setOnClickListener {
            showAddAchievementAlert(null)
        }
        fragmentEditAchievementBinding.btnOther.setOnClickListener {
            showReferenceDialog(null)
        }
        fragmentEditAchievementBinding.txtDob.setOnClickListener {
            val now = Calendar.getInstance()
            val dpd = DatePickerDialog(requireActivity(), this, now[Calendar.YEAR], now[Calendar.MONTH], now[Calendar.DAY_OF_MONTH])
            dpd.datePicker.maxDate = Calendar.getInstance().timeInMillis
            dpd.show()
        }
    }

    private fun showAchievementAndInfo() {
        val config = Utilities.getCloudConfig().selectMode(ChipCloud.SelectMode.single)
        fragmentEditAchievementBinding.llAttachment.removeAllViews()
        for (e in achievementArray!!) {
            editAttachmentBinding = EditAttachementBinding.inflate(LayoutInflater.from(activity))
            editAttachmentBinding.tvTitle.text = e.asJsonObject["title"].asString
            val flexboxLayout = editAttachmentBinding.flexbox
            flexboxLayout.removeAllViews()
            val chipCloud = ChipCloud(activity, flexboxLayout, config)
            for (element in e.asJsonObject.getAsJsonArray("resources")) {
                chipCloud.addChip(element.asJsonObject["title"].asString)
            }
            editAttachmentBinding.ivDelete.setOnClickListener {
                achievementArray?.remove(e)
                showAchievementAndInfo()
            }
            editAttachmentBinding.edit.setOnClickListener { showAddAchievementAlert(e.asJsonObject) }
            val editAttachmentView: View = editAttachmentBinding.root
            fragmentEditAchievementBinding.llAttachment.addView(editAttachmentView)
        }
    }

    private fun showReference() {
        fragmentEditAchievementBinding.llOtherInfo.removeAllViews()
        for (e in referenceArray!!) {
            editOtherInfoBinding = EditOtherInfoBinding.inflate(LayoutInflater.from(activity))
            editOtherInfoBinding.tvTitle.text = e.asJsonObject["name"].asString
            editOtherInfoBinding.ivDelete.setOnClickListener {
                referenceArray?.remove(e)
                showReference()
            }
            editOtherInfoBinding.edit.setOnClickListener { showReferenceDialog(e.asJsonObject) }
            val editOtherInfoView: View = editOtherInfoBinding.root
            fragmentEditAchievementBinding.llOtherInfo.addView(editOtherInfoView)
        }
    }

    private fun showReferenceDialog(`object`: JsonObject?) {
        alertReferenceBinding = AlertReferenceBinding.inflate(LayoutInflater.from(activity))
        val ar = arrayOf(
            alertReferenceBinding.etName,
            alertReferenceBinding.etPhone,
            alertReferenceBinding.etEmail,
            alertReferenceBinding.etRelationship
        )
        setPrevReference(ar, `object`)
        val alertReferenceView: View = alertReferenceBinding.root
        referenceDialog = getDialog(requireActivity(), getString(R.string.add_reference), alertReferenceView)
        referenceDialog?.show()
        referenceDialog?.getButton(AlertDialog.BUTTON_POSITIVE)?.setOnClickListener {
            val name = alertReferenceBinding.etName.text.toString().trim { it <= ' ' }
            if (name.isEmpty()) {
                alertReferenceBinding.tlName.error = getString(R.string.name_is_required)
                return@setOnClickListener
            }
            if (`object` != null) referenceArray?.remove(`object`)
            if (referenceArray == null) referenceArray = JsonArray()
            referenceArray?.add(createReference(name, alertReferenceBinding.etRelationship, alertReferenceBinding.etPhone, alertReferenceBinding.etEmail))
            showReference()
            referenceDialog?.dismiss()
        }
    }

    private fun setPrevReference(ar: Array<EditText>, `object`: JsonObject?) {
        if (`object` != null) {
            ar[0].setText(`object`["name"].asString)
            ar[1].setText(`object`["phone"].asString)
            ar[2].setText(`object`["email"].asString)
            ar[3].setText(`object`["relationship"].asString)
        }
    }

    var date = ""
    private fun showAddAchievementAlert(`object`: JsonObject?) {
        alertAddAttachmentBinding = AlertAddAttachmentBinding.inflate(LayoutInflater.from(activity))
        alertAddAttachmentBinding.tvDate.setOnClickListener {
            val now = Calendar.getInstance()
            val dpd = DatePickerDialog(requireActivity(), { _: DatePicker?, i: Int, i1: Int, i2: Int ->
                date = String.format(Locale.US, "%04d-%02d-%02d", i, i1 + 1, i2)
                alertAddAttachmentBinding.tvDate.text = date },
                now[Calendar.YEAR], now[Calendar.MONTH], now[Calendar.DAY_OF_MONTH])
            dpd.datePicker.maxDate = now.timeInMillis
            dpd.show()
        }
        resourceArray = JsonArray()
        val prevList = setUpOldAchievement(
            `object`,
            alertAddAttachmentBinding.etDesc,
            alertAddAttachmentBinding.etTitle,
            alertAddAttachmentBinding.tvDate as AppCompatTextView
        )
        alertAddAttachmentBinding.btnAddResources.setOnClickListener {
            showResourceListDialog(prevList)
        }
        val tintColor = ContextCompat.getColorStateList(requireContext(), R.color.daynight_textColor)
        alertAddAttachmentBinding.etDesc.backgroundTintList = tintColor
        alertAddAttachmentBinding.etTitle.backgroundTintList = tintColor
        val alertAddAttachmentView: View = alertAddAttachmentBinding.root
        AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
            .setTitle(R.string.add_achievement)
            .setIcon(R.drawable.ic_edit)
            .setView(alertAddAttachmentView)
            .setCancelable(false)
            .setPositiveButton("Submit") { _: DialogInterface?, _: Int ->
                val desc = alertAddAttachmentBinding.etDesc.text.toString().trim { it <= ' ' }
                val title = alertAddAttachmentBinding.etTitle.text.toString().trim { it <= ' ' }
                if (title.isEmpty()) {
                    Toast.makeText(activity, getString(R.string.title_is_required), Toast.LENGTH_SHORT).show()
                    return@setPositiveButton
                }
                if (`object` != null) achievementArray?.remove(`object`)
                saveAchievement(desc, title)
            }.setNegativeButton(getString(R.string.cancel), null).show()
    }

    private fun setUpOldAchievement(`object`: JsonObject?, etDescription: EditText, etTitle: EditText, tvDate: AppCompatTextView): List<String?> {
        val prevList: MutableList<String?> = ArrayList()
        if (`object` != null) {
            etTitle.setText(`object`["title"].asString)
            etDescription.setText(`object`["description"].asString)
            tvDate.text = `object`["date"].asString
            val array = `object`.getAsJsonArray("resources")
            date = `object`["date"].asString
            for (o in array) {
                prevList.add(o.asJsonObject["title"].asString)
            }
            resourceArray = `object`.getAsJsonArray("resources")
        }
        return prevList
    }

    private fun saveAchievement(desc: String, title: String) {
        val `object` = JsonObject()
        `object`.addProperty("description", desc)
        `object`.addProperty("title", title)
        `object`.addProperty("date", date)
        `object`.add("resources", resourceArray)
        achievementArray?.add(`object`)
        showAchievementAndInfo()
    }

    private fun showResourceListDialog(prevList: List<String?>) {
        val builder = AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
        builder.setTitle(R.string.select_resources)
        val list: List<RealmMyLibrary> = aRealm.where(RealmMyLibrary::class.java).findAll()
        myLibraryAlertdialogBinding = MyLibraryAlertdialogBinding.inflate(LayoutInflater.from(activity))
        val myLibraryAlertdialogView: View = myLibraryAlertdialogBinding.root
        val lv = createResourceList(myLibraryAlertdialogBinding, list, prevList)
        builder.setView(myLibraryAlertdialogView)
        builder.setPositiveButton("Ok") { _: DialogInterface?, _: Int ->
            val items = lv.selectedItemsList
            resourceArray = JsonArray()
            for (ii in items) {
                resourceArray?.add(list[ii].serializeResource())
            }
        }.setNegativeButton("Cancel", null).show()
    }

    override fun onDateSet(datePicker: DatePicker, i: Int, i1: Int, i2: Int) {
        fragmentEditAchievementBinding.txtDob.text =
            String.format(Locale.US, "%04d-%02d-%02d", i, i1 + 1, i2)
    }

    private fun initializeData() {
        val achievementId = user?.id + "@" + user?.planetCode
        achievement = aRealm.where(RealmAchievement::class.java)
            .equalTo("_id", achievementId)
            .findFirst()

        if (achievement == null) {
            lifecycleScope.launch {
                databaseService.withRealmAsync { realm ->
                    realm.executeTransaction { transactionRealm ->
                        val existing = transactionRealm.where(RealmAchievement::class.java)
                            .equalTo("_id", achievementId)
                            .findFirst()
                        if (existing == null) {
                            transactionRealm.createObject(
                                RealmAchievement::class.java,
                                achievementId
                            )
                        }
                    }
                }
                if (!isAdded) {
                    return@launch
                }
                aRealm.refresh()
                achievement = aRealm.where(RealmAchievement::class.java)
                    .equalTo("_id", achievementId)
                    .findFirst()
                populateAchievementData()
            }
        } else {
            populateAchievementData()
        }
    }

    private fun populateAchievementData() {
        achievementArray = achievement?.achievementsArray ?: achievementArray
        referenceArray = achievement?.getReferencesArray() ?: referenceArray
        fragmentEditAchievementBinding.etAchievement.setText(achievement?.achievementsHeader)
        fragmentEditAchievementBinding.etPurpose.setText(achievement?.purpose)
        fragmentEditAchievementBinding.etGoals.setText(achievement?.goals)
        fragmentEditAchievementBinding.cbSendToNation.isChecked = achievement?.sendToNation.toBoolean()
        fragmentEditAchievementBinding.txtDob.text = if (TextUtils.isEmpty(user?.dob)) getString(R.string.birth_date) else getFormattedDate(user?.dob, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
        resourceArray = JsonArray()
        fragmentEditAchievementBinding.etFname.setText(user?.firstName)
        fragmentEditAchievementBinding.etMname.setText(user?.middleName)
        fragmentEditAchievementBinding.etLname.setText(user?.lastName)
        fragmentEditAchievementBinding.etBirthplace.setText(user?.birthPlace)
        if (achievementArray != null) {
            showAchievementAndInfo()
        }
        if (referenceArray != null) {
            showReference()
        }
    }

    private fun createResourceList(myLibraryAlertdialogBinding: MyLibraryAlertdialogBinding, list: List<RealmMyLibrary>, prevList: List<String?>): CheckboxListView {
        val names = ArrayList<String?>()
        val selected: ArrayList<Int> = ArrayList()
        for (i in list.indices) {
            names.add(list[i].title)
            if (prevList.contains(list[i].title)) selected.add(i)
        }
        val adapter: ArrayAdapter<String?> = object : ArrayAdapter<String?>(requireActivity(), R.layout.item_checkbox, R.id.checkBoxRowLayout, names) {
            override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
                val rowLayoutBinding = RowlayoutBinding.inflate(LayoutInflater.from(parent.context), parent, false)
                val textView = rowLayoutBinding.root
                textView.text = getItem(position)
                textView.isChecked = myLibraryAlertdialogBinding.alertDialogListView.selectedItemsList.contains(position)
                myLibraryAlertdialogBinding.alertDialogListView.setItemChecked(position, myLibraryAlertdialogBinding.alertDialogListView.selectedItemsList.contains(position))
                return textView
            }
        }
        myLibraryAlertdialogBinding.alertDialogListView.selectedItemsList = selected
        myLibraryAlertdialogBinding.alertDialogListView.choiceMode = ListView.CHOICE_MODE_MULTIPLE
        myLibraryAlertdialogBinding.alertDialogListView.adapter = adapter
        return myLibraryAlertdialogBinding.alertDialogListView
    }

    private fun setUserInfo() {}
    private fun setAchievementInfo() {
        achievement?.achievementsHeader = fragmentEditAchievementBinding.etAchievement.text.toString().trim { it <= ' ' }
        achievement?.goals = fragmentEditAchievementBinding.etGoals.text.toString().trim { it <= ' ' }
        achievement?.purpose = fragmentEditAchievementBinding.etPurpose.text.toString().trim { it <= ' ' }
        achievement?.setAchievements(achievementArray!!)
        achievement?.setReferences(referenceArray)
        achievement?.sendToNation = fragmentEditAchievementBinding.cbSendToNation.isChecked.toString() + ""
    }

    override fun onDestroyView() {
        referenceDialog?.dismiss()
        referenceDialog = null
        super.onDestroyView()
    }

    override fun onDestroy() {
        if (this::aRealm.isInitialized && !aRealm.isClosed) {
            aRealm.close()
        }
        try {
            if (!mRealm.isClosed) {
                mRealm.close()
            }
        } catch (_: UninitializedPropertyAccessException) {
        }
        super.onDestroy()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/userprofile/UserProfileFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.userprofile

import android.Manifest
import android.app.Activity.RESULT_OK
import android.app.DatePickerDialog
import android.app.Dialog
import android.content.ContentValues
import android.content.Context.MODE_PRIVATE
import android.content.Intent
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.graphics.drawable.Drawable
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.provider.MediaStore
import android.provider.Settings
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.TextView
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.core.view.children
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.bumptech.glide.load.DataSource
import com.bumptech.glide.load.engine.GlideException
import com.bumptech.glide.request.RequestListener
import com.bumptech.glide.request.RequestOptions
import com.bumptech.glide.request.target.Target
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import java.lang.String.format
import java.util.ArrayList
import java.util.Calendar
import java.util.LinkedHashMap
import java.util.LinkedList
import java.util.Locale
import java.util.TimeZone
import java.util.UUID
import javax.inject.Inject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.R.array.language
import org.ole.planet.myplanet.R.array.subject_level
import org.ole.planet.myplanet.databinding.EditProfileDialogBinding
import org.ole.planet.myplanet.databinding.FragmentUserProfileBinding
import org.ole.planet.myplanet.databinding.RowStatBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class UserProfileFragment : Fragment() {
    private var _binding: FragmentUserProfileBinding? = null
    private val binding get() = _binding!!
    private lateinit var rowStatBinding: RowStatBinding
    private lateinit var settings: SharedPreferences
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private lateinit var mRealm: Realm
    private var model: RealmUserModel? = null
    private lateinit var pickImageLauncher: ActivityResultLauncher<Intent>
    private var selectedGender: String? = null
    var selectedLevel: String? = null
    var selectedLanguage: String? = null
    var date: String? = null
    private var photoURI: Uri? = null
    private lateinit var captureImageLauncher: ActivityResultLauncher<Uri>
    private lateinit var requestCameraLauncher: ActivityResultLauncher<String>

    override fun onDestroy() {
        if (this::mRealm.isInitialized) {
            mRealm.close()
        }
        super.onDestroy()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        pickImageLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == RESULT_OK && result.data != null) {
                val uri = result.data?.data ?: return@registerForActivityResult
                photoURI  = uri
                startIntent(photoURI)
                Glide.with(this)
                    .load(uri)
                    .into(binding.image)
            }
        }

        captureImageLauncher = registerForActivityResult(ActivityResultContracts.TakePicture()) { isSuccess ->
            if (isSuccess) {
                startIntent(photoURI)
                binding.image.setImageURI(photoURI)
            }
        }

        requestCameraLauncher = registerForActivityResult(
            ActivityResultContracts.RequestPermission()
        ) { isGranted ->
            if (isGranted) {
                takePhoto()
            } else {
                if (!shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) {
                    AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
                        .setTitle(R.string.permission_required)
                        .setMessage(R.string.camera_permission_required)
                        .setPositiveButton(R.string.settings) { dialog, _ ->
                            dialog.dismiss()
                            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                            val uri: Uri = Uri.fromParts("package", requireContext().packageName, null)
                            intent.data = uri
                            startActivity(intent)
                        }
                        .setNegativeButton(R.string.cancel) { dialog, _ -> dialog.dismiss() }
                        .show()
                } else {
                    Utilities.toast(requireContext(), "camera permission is required.")
                }
            }
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentUserProfileBinding.inflate(inflater, container, false)
        initializeDependencies()
        binding.btProfilePic.setOnClickListener { searchForPhoto() }
        model = userProfileDbHandler.userModel

        setupProfile()
        loadProfileImage()

        binding.btEditProfile.setOnClickListener { openEditProfileDialog() }
        configureGuestView()
        setupStatsRecycler()

        return binding.root
    }

    private fun initializeDependencies() {
        settings = requireContext().getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        mRealm = databaseService.realmInstance
        binding.rvStat.layoutManager = LinearLayoutManager(activity)
        binding.rvStat.isNestedScrollingEnabled = false
    }

    private fun setupProfile() {
        binding.txtName.text = if (!model?.firstName.isNullOrEmpty() && !model?.lastName.isNullOrEmpty()) {
            "${model?.firstName} ${model?.lastName}"
        } else {
            model?.name ?: ""
        }
        binding.txtEmail.text = getString(R.string.two_strings, getString(R.string.email_colon), Utilities.checkNA(model?.email))
        val dob = if (TextUtils.isEmpty(model?.dob)) getString(R.string.n_a) else TimeUtils.getFormattedDate(model?.dob, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
        binding.txtDob.text = getString(R.string.two_strings, getString(R.string.date_of_birth), dob)
        binding.txtGender.text = getString(R.string.gender_colon, Utilities.checkNA(model?.gender))
        binding.txtLanguage.text = getString(R.string.two_strings, getString(R.string.language_colon), Utilities.checkNA(model?.language))
        binding.txtLevel.text = getString(R.string.level_colon, Utilities.checkNA(model?.level))
    }

    private fun loadProfileImage() {
        val binding = _binding ?: return
        val profileImageUrl = model?.userImage

        if (profileImageUrl.isNullOrBlank()) {
            binding.image.setImageResource(R.drawable.profile)
            return
        }

        if (!isAdded) return

        Glide.with(this)
            .load(profileImageUrl)
            .apply(RequestOptions().placeholder(R.drawable.profile).error(R.drawable.profile))
            .listener(object : RequestListener<Drawable> {
                override fun onLoadFailed(
                    e: GlideException?,
                    model: Any?,
                    target: Target<Drawable>,
                    isFirstResource: Boolean
                ): Boolean {
                    if (!isAdded) {
                        return true
                    }
                    val currentBinding = _binding ?: return true
                    currentBinding.image.apply {
                        visibility = View.VISIBLE
                        setImageResource(R.drawable.profile)
                    }
                    return true
                }

                override fun onResourceReady(
                    resource: Drawable,
                    model: Any,
                    target: Target<Drawable>?,
                    dataSource: DataSource,
                    isFirstResource: Boolean
                ): Boolean {
                    return false
                }
            })
            .into(binding.image)
    }

    private fun openEditProfileDialog() {
        val dialog = Dialog(requireContext()).apply { setCancelable(false) }
        val binding = EditProfileDialogBinding.inflate(LayoutInflater.from(requireContext()))
        dialog.setContentView(binding.root)
        dialog.window?.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)

        populateUserFields(binding)
        setupLanguageSpinner(binding)
        setupLevelSpinner(binding)
        setupGender(binding)
        setupDatePicker(binding)
        setupSaveButton(dialog, binding)

        binding.btnCancel.setOnClickListener { dialog.dismiss() }
        dialog.show()
    }

    private fun populateUserFields(binding: EditProfileDialogBinding) {
        binding.firstName.setText(model?.firstName)
        binding.middleName.setText(model?.middleName)
        binding.lastName.setText(model?.lastName)
        binding.email.setText(model?.email)
        binding.phoneNumber.setText(model?.phoneNumber)
        val dobText = if (TextUtils.isEmpty(model?.dob)) {
            getString(R.string.n_a)
        } else {
            TimeUtils.getFormattedDate(model?.dob, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
        }
        binding.dateOfBirth.text = dobText
    }

    private fun setupLanguageSpinner(binding: EditProfileDialogBinding) {
        val languages = resources.getStringArray(language)
        val languageList: MutableList<String?> = ArrayList(listOf(*languages))
        languageList.add(0, getString(R.string.language))
        val adapter = ArrayAdapter(requireContext(), R.layout.spinner_item, languageList)
        adapter.setDropDownViewResource(R.layout.spinner_item)
        binding.language.adapter = adapter
        model?.language?.let { lang ->
            val position = languageList.indexOf(lang)
            binding.language.setSelection(if (position >= 0) position else 0)
        } ?: binding.language.setSelection(0)
        binding.language.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>, view: View?, position: Int, id: Long) {
                selectedLanguage = parent.getItemAtPosition(position).toString()
            }

            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }
    }

    private fun setupLevelSpinner(binding: EditProfileDialogBinding) {
        val levels = resources.getStringArray(subject_level).toMutableList().apply { remove("All") }
        levels.add(0, getString(R.string.select_level))
        selectedLevel = Utilities.checkNA(model?.level)
        val levelAdapter = ArrayAdapter(requireContext(), R.layout.spinner_item, levels)
        levelAdapter.setDropDownViewResource(R.layout.spinner_item)
        binding.level.adapter = levelAdapter

        val levelPosition = levels.indexOf(selectedLevel)
        if (levelPosition > 0) binding.level.setSelection(levelPosition) else binding.level.setSelection(0)

        binding.level.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>, view: View?, position: Int, id: Long) {
                selectedLevel = if (position == 0) "" else levels[position]
            }

            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }
    }

    private fun setupGender(binding: EditProfileDialogBinding) {
        when (model?.gender?.lowercase(Locale.US)) {
            "male" -> binding.rbMale.isChecked = true
            "female" -> binding.rbFemale.isChecked = true
        }
    }

    private fun setupDatePicker(binding: EditProfileDialogBinding) {
        binding.dateOfBirth.setOnClickListener {
            val now = Calendar.getInstance()
            var dobPrevious = Calendar.getInstance()
            val previousSelectedDate = date ?: model?.dob
            if(!previousSelectedDate.isNullOrEmpty()){
                val instant = TimeUtils.parseInstantFromString(previousSelectedDate)
                instant?.let {
                    dobPrevious = Calendar.getInstance(TimeZone.getTimeZone("UTC")).apply {
                        timeInMillis = it.toEpochMilli()
                    }
                }
            }

            val dpd = DatePickerDialog(
                requireContext(),
                { _, year, monthOfYear, dayOfMonth ->
                    val calendar = Calendar.getInstance()
                    calendar.set(year, monthOfYear, dayOfMonth)
                    val dobMillis = calendar.timeInMillis
                    val dobFormatted = TimeUtils.getFormattedDate(dobMillis)

                    date = format(Locale.US, "%04d-%02d-%02dT00:00:00.000Z", year, monthOfYear + 1, dayOfMonth)
                    binding.dateOfBirth.text = dobFormatted
                },
                dobPrevious.get(Calendar.YEAR),
                dobPrevious.get(Calendar.MONTH),
                dobPrevious.get(Calendar.DAY_OF_MONTH)
            )
            dpd.datePicker.maxDate = now.timeInMillis
            dpd.show()
        }
    }

    private fun setupSaveButton(dialog: Dialog, binding: EditProfileDialogBinding) {
        binding.btnSave.setOnClickListener {
            if (!validateInputs(binding)) {
                return@setOnClickListener
            }

            selectedGender = when {
                binding.rbMale.isChecked -> "male"
                binding.rbFemale.isChecked -> "female"
                else -> selectedGender
            }

            val firstName = binding.firstName.text.toString()
            val lastName = binding.lastName.text.toString()
            val middleName = binding.middleName.text.toString()
            val email = binding.email.text.toString()
            val phoneNumber = binding.phoneNumber.text.toString()
            val dob = date ?: model?.dob

            val realm = databaseService.realmInstance
            val userId = settings.getString("userId", "")

            RealmUserModel.updateUserDetails(
                realm, userId, firstName, lastName, middleName, email, phoneNumber, selectedLevel,
                selectedLanguage.takeUnless { it == getString(R.string.language) }, selectedGender, dob
            ) {
                mRealm.refresh()
                val updatedModel = userProfileDbHandler.userModel
                model = updatedModel
                updateUIWithUserData(updatedModel)
                realm.close()
                dialog.dismiss()
            }
        }
    }

    private fun validateInputs(binding: EditProfileDialogBinding): Boolean {
        return when {
            TextUtils.isEmpty(binding.firstName.text.toString().trim()) -> {
                binding.firstName.error = getString(R.string.compulsory_first_name)
                false
            }
            TextUtils.isEmpty(binding.lastName.text.toString().trim()) -> {
                binding.lastName.error = getString(R.string.compulsory_last_name)
                false
            }
            TextUtils.isEmpty(binding.email.text.toString().trim()) -> {
                binding.email.error = getString(R.string.compulsory_email)
                false
            }
            TextUtils.isEmpty(binding.phoneNumber.text.toString().trim()) -> {
                binding.phoneNumber.error = getString(R.string.compulsory_phone_number)
                false
            }
            getString(R.string.birth_date) == binding.dateOfBirth.text.toString() -> {
                binding.dateOfBirth.error = getString(R.string.compulsory_date_of_birth)
                false
            }
            binding.rdGender.checkedRadioButtonId == -1 -> {
                Snackbar.make(binding.root, getString(R.string.gender_not_picked), Snackbar.LENGTH_SHORT).show()
                false
            }
            else -> true
        }
    }
    private fun configureGuestView() {
        if (model?.id?.startsWith("guest") == true) {
            binding.btEditProfile.visibility = View.GONE
            binding.btProfilePic.visibility = View.GONE
        }
    }

    private fun createStatsMap(): LinkedHashMap<String, String?> {
        return linkedMapOf(
            getString(R.string.community_name) to Utilities.checkNA(model?.planetCode),
            getString(R.string.last_login) to userProfileDbHandler.lastVisit?.let { TimeUtils.getRelativeTime(it) },
            getString(R.string.total_visits_overall) to userProfileDbHandler.offlineVisits.toString(),
            getString(R.string.most_opened_resource) to Utilities.checkNA(userProfileDbHandler.maxOpenedResource),
            getString(R.string.number_of_resources_opened) to Utilities.checkNA(userProfileDbHandler.numberOfResourceOpen)
        )
    }

    private fun setupStatsRecycler() {
        val map = createStatsMap()
        val keys = LinkedList(map.keys)
        binding.rvStat.adapter = object : RecyclerView.Adapter<ViewHolderRowStat>() {
            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderRowStat {
                rowStatBinding = RowStatBinding.inflate(LayoutInflater.from(activity), parent, false)
                return ViewHolderRowStat(rowStatBinding)
            }

            override fun onBindViewHolder(holder: ViewHolderRowStat, position: Int) {
                rowStatBinding.tvTitle.text = keys[position]
                rowStatBinding.tvTitle.visibility = View.VISIBLE
                rowStatBinding.tvDescription.text = map[keys[position]]
                if (position % 2 == 0) {
                    rowStatBinding.root.setBackgroundColor(
                        ContextCompat.getColor(
                            requireContext(),
                            R.color.user_profile_background
                        )
                    )
                }
            }

            override fun getItemCount(): Int {
                return keys.size
            }
        }
    }

    private fun searchForPhoto() {
        val options = arrayOf(getString(R.string.capture_image), getString(R.string.select_gallery))
        val builder = AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
        builder.setTitle(getString(R.string.choose_an_option))
        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_list_item_1, options)
        builder.setAdapter(adapter) { _, which ->
            when (which) {
                0 -> takePhoto()
                1 -> pickFromGallery()
            }
        }

        val dialog = builder.create()
        dialog.setOnShowListener {
            dialog.listView.children.forEach { item ->
                (item as TextView).setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
            }
        }

        dialog.show()
    }

    private fun pickFromGallery() {
        val intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.INTERNAL_CONTENT_URI)
        pickImageLauncher.launch(intent)
    }

    private fun takePhoto() {
        if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.CAMERA)
            != PackageManager.PERMISSION_GRANTED){
            requestCameraLauncher.launch(Manifest.permission.CAMERA)
            return
        }
        val values = ContentValues().apply {
            put(MediaStore.Images.Media.TITLE, "Photo_${UUID.randomUUID()}")
            put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.Images.Media.RELATIVE_PATH, "${Environment.DIRECTORY_PICTURES}/ole/photo")
            }
        }
        photoURI = requireActivity().contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)
        photoURI?.let { captureImageLauncher.launch(it) }
    }

    private fun startIntent(uri: Uri?) {
        var path: String? = null
        path = uri?.toString()

        mRealm.let {
            if (!it.isInTransaction) {
                it.beginTransaction()
            }
            model?.userImage = path
            model?.isUpdated = true
            it.commitTransaction()
        }
    }

    private fun updateUIWithUserData(model: RealmUserModel?) {
        val currentBinding = _binding ?: return
        model?.let {
            currentBinding.txtName.text = String.format("%s %s %s", it.firstName, it.middleName, it.lastName)
            currentBinding.txtEmail.text = getString(R.string.two_strings, getString(R.string.email_colon), Utilities.checkNA(it.email))
            val dob = if (TextUtils.isEmpty(it.dob)) "N/A" else TimeUtils.getFormattedDate(it.dob, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
            currentBinding.txtDob.text = getString(R.string.two_strings, getString(R.string.date_of_birth), dob)
            currentBinding.txtGender.text = getString(R.string.gender_colon, Utilities.checkNA(it.gender))
            currentBinding.txtLanguage.text = getString(R.string.two_strings, getString(R.string.language_colon), Utilities.checkNA(it.language))
            currentBinding.txtLevel.text = getString(R.string.level_colon, Utilities.checkNA(it.level))
        }
    }

    inner class ViewHolderRowStat(rowStatBinding: RowStatBinding) : RecyclerView.ViewHolder(rowStatBinding.root)

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.userprofile


import android.Manifest
import android.app.Activity.RESULT_OK
import android.app.DatePickerDialog
import android.app.Dialog
import android.content.ContentValues
import android.content.Context.MODE_PRIVATE
import android.content.Intent
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.graphics.drawable.Drawable
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.provider.MediaStore
import android.provider.Settings
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.TextView
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.core.view.children
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.bumptech.glide.load.DataSource
import com.bumptech.glide.load.engine.GlideException
import com.bumptech.glide.request.RequestListener
import com.bumptech.glide.request.RequestOptions
import com.bumptech.glide.request.target.Target
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import java.lang.String.format
import java.util.ArrayList
import java.util.Calendar
import java.util.LinkedHashMap
import java.util.LinkedList
import java.util.Locale
import java.util.TimeZone
import java.util.UUID
import javax.inject.Inject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.R.array.language
import org.ole.planet.myplanet.R.array.subject_level
import org.ole.planet.myplanet.databinding.EditProfileDialogBinding
import org.ole.planet.myplanet.databinding.FragmentUserProfileBinding
import org.ole.planet.myplanet.databinding.RowStatBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class UserProfileFragment : Fragment() {
    private var _binding: FragmentUserProfileBinding? = null
    private val binding get() = _binding!!
    private lateinit var rowStatBinding: RowStatBinding
    private lateinit var settings: SharedPreferences
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private lateinit var mRealm: Realm
    private var model: RealmUserModel? = null
    private lateinit var pickImageLauncher: ActivityResultLauncher<Intent>
    private var selectedGender: String? = null
    var selectedLevel: String? = null
    var selectedLanguage: String? = null
    var date: String? = null
    private var photoURI: Uri? = null
    private lateinit var captureImageLauncher: ActivityResultLauncher<Uri>
    private lateinit var requestCameraLauncher: ActivityResultLauncher<String>

    override fun onDestroy() {
        if (this::mRealm.isInitialized) {
            mRealm.close()
        }
        super.onDestroy()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        pickImageLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == RESULT_OK && result.data != null) {
                val uri = result.data?.data ?: return@registerForActivityResult
                photoURI  = uri
                startIntent(photoURI)
                Glide.with(this)
                    .load(uri)
                    .into(binding.image)
            }
        }

        captureImageLauncher = registerForActivityResult(ActivityResultContracts.TakePicture()) { isSuccess ->
            if (isSuccess) {
                startIntent(photoURI)
                binding.image.setImageURI(photoURI)
            }
        }

        requestCameraLauncher = registerForActivityResult(
            ActivityResultContracts.RequestPermission()
        ) { isGranted ->
            if (isGranted) {
                takePhoto()
            } else {
                if (!shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) {
                    AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
                        .setTitle(R.string.permission_required)
                        .setMessage(R.string.camera_permission_required)
                        .setPositiveButton(R.string.settings) { dialog, _ ->
                            dialog.dismiss()
                            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                            val uri: Uri = Uri.fromParts("package", requireContext().packageName, null)
                            intent.data = uri
                            startActivity(intent)
                        }
                        .setNegativeButton(R.string.cancel) { dialog, _ -> dialog.dismiss() }
                        .show()
                } else {
                    Utilities.toast(requireContext(), "camera permission is required.")
                }
            }
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentUserProfileBinding.inflate(inflater, container, false)
        initializeDependencies()
        binding.btProfilePic.setOnClickListener { searchForPhoto() }
        model = userProfileDbHandler.userModel

        setupProfile()
        loadProfileImage()

        binding.btEditProfile.setOnClickListener { openEditProfileDialog() }
        configureGuestView()
        setupStatsRecycler()

        return binding.root
    }

    private fun initializeDependencies() {
        settings = requireContext().getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        mRealm = databaseService.realmInstance
        binding.rvStat.layoutManager = LinearLayoutManager(activity)
        binding.rvStat.isNestedScrollingEnabled = false
    }

    private fun setupProfile() {
        binding.txtName.text = if (!model?.firstName.isNullOrEmpty() && !model?.lastName.isNullOrEmpty()) {
            "${model?.firstName} ${model?.lastName}"
        } else {
            model?.name ?: ""
        }
        binding.txtEmail.text = getString(R.string.two_strings, getString(R.string.email_colon), Utilities.checkNA(model?.email))
        val dob = if (TextUtils.isEmpty(model?.dob)) getString(R.string.n_a) else TimeUtils.getFormattedDate(model?.dob, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
        binding.txtDob.text = getString(R.string.two_strings, getString(R.string.date_of_birth), dob)
        binding.txtGender.text = getString(R.string.gender_colon, Utilities.checkNA(model?.gender))
        binding.txtLanguage.text = getString(R.string.two_strings, getString(R.string.language_colon), Utilities.checkNA(model?.language))
        binding.txtLevel.text = getString(R.string.level_colon, Utilities.checkNA(model?.level))
    }

    private fun loadProfileImage() {
        val binding = _binding ?: return
        val profileImageUrl = model?.userImage

        if (profileImageUrl.isNullOrBlank()) {
            binding.image.setImageResource(R.drawable.profile)
            return
        }

        if (!isAdded) return

        Glide.with(this)
            .load(profileImageUrl)
            .apply(RequestOptions().placeholder(R.drawable.profile).error(R.drawable.profile))
            .listener(object : RequestListener<Drawable> {
                override fun onLoadFailed(
                    e: GlideException?,
                    model: Any?,
                    target: Target<Drawable>,
                    isFirstResource: Boolean
                ): Boolean {
                    if (!isAdded) {
                        return true
                    }
                    val currentBinding = _binding ?: return true
                    currentBinding.image.apply {
                        visibility = View.VISIBLE
                        setImageResource(R.drawable.profile)
                    }
                    return true
                }

                override fun onResourceReady(
                    resource: Drawable,
                    model: Any,
                    target: Target<Drawable>?,
                    dataSource: DataSource,
                    isFirstResource: Boolean
                ): Boolean {
                    return false
                }
            })
            .into(binding.image)
    }

    private fun openEditProfileDialog() {
        val dialog = Dialog(requireContext()).apply { setCancelable(false) }
        val binding = EditProfileDialogBinding.inflate(LayoutInflater.from(requireContext()))
        dialog.setContentView(binding.root)
        dialog.window?.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)

        populateUserFields(binding)
        setupLanguageSpinner(binding)
        setupLevelSpinner(binding)
        setupGender(binding)
        setupDatePicker(binding)
        setupSaveButton(dialog, binding)

        binding.btnCancel.setOnClickListener { dialog.dismiss() }
        dialog.show()
    }

    private fun populateUserFields(binding: EditProfileDialogBinding) {
        binding.firstName.setText(model?.firstName)
        binding.middleName.setText(model?.middleName)
        binding.lastName.setText(model?.lastName)
        binding.email.setText(model?.email)
        binding.phoneNumber.setText(model?.phoneNumber)
        val dobText = if (TextUtils.isEmpty(model?.dob)) {
            getString(R.string.n_a)
        } else {
            TimeUtils.getFormattedDate(model?.dob, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
        }
        binding.dateOfBirth.text = dobText
    }

    private fun setupLanguageSpinner(binding: EditProfileDialogBinding) {
        val languages = resources.getStringArray(language)
        val languageList: MutableList<String?> = ArrayList(listOf(*languages))
        languageList.add(0, getString(R.string.language))
        val adapter = ArrayAdapter(requireContext(), R.layout.spinner_item, languageList)
        adapter.setDropDownViewResource(R.layout.spinner_item)
        binding.language.adapter = adapter
        model?.language?.let { lang ->
            val position = languageList.indexOf(lang)
            binding.language.setSelection(if (position >= 0) position else 0)
        } ?: binding.language.setSelection(0)
        binding.language.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>, view: View?, position: Int, id: Long) {
                selectedLanguage = parent.getItemAtPosition(position).toString()
            }

            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }
    }

    private fun setupLevelSpinner(binding: EditProfileDialogBinding) {
        val levels = resources.getStringArray(subject_level).toMutableList().apply { remove("All") }
        levels.add(0, getString(R.string.select_level))
        selectedLevel = Utilities.checkNA(model?.level)
        val levelAdapter = ArrayAdapter(requireContext(), R.layout.spinner_item, levels)
        levelAdapter.setDropDownViewResource(R.layout.spinner_item)
        binding.level.adapter = levelAdapter

        val levelPosition = levels.indexOf(selectedLevel)
        if (levelPosition > 0) binding.level.setSelection(levelPosition) else binding.level.setSelection(0)

        binding.level.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>, view: View?, position: Int, id: Long) {
                selectedLevel = if (position == 0) "" else levels[position]
            }

            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }
    }

    private fun setupGender(binding: EditProfileDialogBinding) {
        when (model?.gender?.lowercase(Locale.US)) {
            "male" -> binding.rbMale.isChecked = true
            "female" -> binding.rbFemale.isChecked = true
        }
    }

    private fun setupDatePicker(binding: EditProfileDialogBinding) {
        binding.dateOfBirth.setOnClickListener {
            val now = Calendar.getInstance()
            var dobPrevious = Calendar.getInstance()
            val previousSelectedDate = date ?: model?.dob
            if(!previousSelectedDate.isNullOrEmpty()){
                val instant = TimeUtils.parseInstantFromString(previousSelectedDate)
                instant?.let {
                    dobPrevious = Calendar.getInstance(TimeZone.getTimeZone("UTC")).apply {
                        timeInMillis = it.toEpochMilli()
                    }
                }
            }

            val dpd = DatePickerDialog(
                requireContext(),
                { _, year, monthOfYear, dayOfMonth ->
                    val calendar = Calendar.getInstance()
                    calendar.set(year, monthOfYear, dayOfMonth)
                    val dobMillis = calendar.timeInMillis
                    val dobFormatted = TimeUtils.getFormattedDate(dobMillis)

                    date = format(Locale.US, "%04d-%02d-%02dT00:00:00.000Z", year, monthOfYear + 1, dayOfMonth)
                    binding.dateOfBirth.text = dobFormatted
                },
                dobPrevious.get(Calendar.YEAR),
                dobPrevious.get(Calendar.MONTH),
                dobPrevious.get(Calendar.DAY_OF_MONTH)
            )
            dpd.datePicker.maxDate = now.timeInMillis
            dpd.show()
        }
    }

    private fun setupSaveButton(dialog: Dialog, binding: EditProfileDialogBinding) {
        binding.btnSave.setOnClickListener {
            if (!validateInputs(binding)) {
                return@setOnClickListener
            }

            selectedGender = when {
                binding.rbMale.isChecked -> "male"
                binding.rbFemale.isChecked -> "female"
                else -> selectedGender
            }

            val firstName = binding.firstName.text.toString()
            val lastName = binding.lastName.text.toString()
            val middleName = binding.middleName.text.toString()
            val email = binding.email.text.toString()
            val phoneNumber = binding.phoneNumber.text.toString()
            val dob = date ?: model?.dob

            val realm = databaseService.realmInstance
            val userId = settings.getString("userId", "")

            RealmUserModel.updateUserDetails(
                realm, userId, firstName, lastName, middleName, email, phoneNumber, selectedLevel,
                selectedLanguage.takeUnless { it == getString(R.string.language) }, selectedGender, dob
            ) {
                mRealm.refresh()
                val updatedModel = userProfileDbHandler.userModel
                model = updatedModel
                updateUIWithUserData(updatedModel)
                realm.close()
                dialog.dismiss()
            }
        }
    }

    private fun validateInputs(binding: EditProfileDialogBinding): Boolean {
        return when {
            TextUtils.isEmpty(binding.firstName.text.toString().trim()) -> {
                binding.firstName.error = getString(R.string.compulsory_first_name)
                false
            }
            TextUtils.isEmpty(binding.lastName.text.toString().trim()) -> {
                binding.lastName.error = getString(R.string.compulsory_last_name)
                false
            }
            TextUtils.isEmpty(binding.email.text.toString().trim()) -> {
                binding.email.error = getString(R.string.compulsory_email)
                false
            }
            TextUtils.isEmpty(binding.phoneNumber.text.toString().trim()) -> {
                binding.phoneNumber.error = getString(R.string.compulsory_phone_number)
                false
            }
            getString(R.string.birth_date) == binding.dateOfBirth.text.toString() -> {
                binding.dateOfBirth.error = getString(R.string.compulsory_date_of_birth)
                false
            }
            binding.rdGender.checkedRadioButtonId == -1 -> {
                Snackbar.make(binding.root, getString(R.string.gender_not_picked), Snackbar.LENGTH_SHORT).show()
                false
            }
            else -> true
        }
    }
    private fun configureGuestView() {
        if (model?.id?.startsWith("guest") == true) {
            binding.btEditProfile.visibility = View.GONE
            binding.btProfilePic.visibility = View.GONE
        }
    }

    private fun createStatsMap(): LinkedHashMap<String, String?> {
        return linkedMapOf(
            getString(R.string.community_name) to Utilities.checkNA(model?.planetCode),
            getString(R.string.last_login) to userProfileDbHandler.lastVisit?.let { TimeUtils.getRelativeTime(it) },
            getString(R.string.total_visits_overall) to userProfileDbHandler.offlineVisits.toString(),
            getString(R.string.most_opened_resource) to Utilities.checkNA(userProfileDbHandler.maxOpenedResource),
            getString(R.string.number_of_resources_opened) to Utilities.checkNA(userProfileDbHandler.numberOfResourceOpen)
        )
    }

    private fun setupStatsRecycler() {
        val map = createStatsMap()
        val keys = LinkedList(map.keys)
        binding.rvStat.adapter = object : RecyclerView.Adapter<ViewHolderRowStat>() {
            override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderRowStat {
                rowStatBinding = RowStatBinding.inflate(LayoutInflater.from(activity), parent, false)
                return ViewHolderRowStat(rowStatBinding)
            }

            override fun onBindViewHolder(holder: ViewHolderRowStat, position: Int) {
                rowStatBinding.tvTitle.text = keys[position]
                rowStatBinding.tvTitle.visibility = View.VISIBLE
                rowStatBinding.tvDescription.text = map[keys[position]]
                if (position % 2 == 0) {
                    rowStatBinding.root.setBackgroundColor(
                        ContextCompat.getColor(
                            requireContext(),
                            R.color.user_profile_background
                        )
                    )
                }
            }

            override fun getItemCount(): Int {
                return keys.size
            }
        }
    }

    private fun searchForPhoto() {
        val options = arrayOf(getString(R.string.capture_image), getString(R.string.select_gallery))
        val builder = AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
        builder.setTitle(getString(R.string.choose_an_option))
        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_list_item_1, options)
        builder.setAdapter(adapter) { _, which ->
            when (which) {
                0 -> takePhoto()
                1 -> pickFromGallery()
            }
        }

        val dialog = builder.create()
        dialog.setOnShowListener {
            dialog.listView.children.forEach { item ->
                (item as TextView).setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
            }
        }

        dialog.show()
    }

    private fun pickFromGallery() {
        val intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.INTERNAL_CONTENT_URI)
        pickImageLauncher.launch(intent)
    }

    private fun takePhoto() {
        if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.CAMERA)
            != PackageManager.PERMISSION_GRANTED){
            requestCameraLauncher.launch(Manifest.permission.CAMERA)
            return
        }
        val values = ContentValues().apply {
            put(MediaStore.Images.Media.TITLE, "Photo_${UUID.randomUUID()}")
            put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.Images.Media.RELATIVE_PATH, "${Environment.DIRECTORY_PICTURES}/ole/photo")
            }
        }
        photoURI = requireActivity().contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)
        photoURI?.let { captureImageLauncher.launch(it) }
    }

    private fun startIntent(uri: Uri?) {
        var path: String? = null
        path = uri?.toString()

        mRealm.let {
            if (!it.isInTransaction) {
                it.beginTransaction()
            }
            model?.userImage = path
            model?.isUpdated = true
            it.commitTransaction()
        }
    }

    private fun updateUIWithUserData(model: RealmUserModel?) {
        val currentBinding = _binding ?: return
        model?.let {
            currentBinding.txtName.text = String.format("%s %s %s", it.firstName, it.middleName, it.lastName)
            currentBinding.txtEmail.text = getString(R.string.two_strings, getString(R.string.email_colon), Utilities.checkNA(it.email))
            val dob = if (TextUtils.isEmpty(it.dob)) "N/A" else TimeUtils.getFormattedDate(it.dob, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
            currentBinding.txtDob.text = getString(R.string.two_strings, getString(R.string.date_of_birth), dob)
            currentBinding.txtGender.text = getString(R.string.gender_colon, Utilities.checkNA(it.gender))
            currentBinding.txtLanguage.text = getString(R.string.two_strings, getString(R.string.language_colon), Utilities.checkNA(it.language))
            currentBinding.txtLevel.text = getString(R.string.level_colon, Utilities.checkNA(it.level))
        }
    }

    inner class ViewHolderRowStat(rowStatBinding: RowStatBinding) : RecyclerView.ViewHolder(rowStatBinding.root)

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/userprofile/AchievementFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.userprofile

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.isGone
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonElement
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmList
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.databinding.FragmentAchievementBinding
import org.ole.planet.myplanet.databinding.LayoutButtonPrimaryBinding
import org.ole.planet.myplanet.databinding.RowAchievementBinding
import org.ole.planet.myplanet.model.RealmAchievement
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.UrlUtils

@AndroidEntryPoint
class AchievementFragment : BaseContainerFragment() {
    private var _binding: FragmentAchievementBinding? = null
    private val binding get() = _binding!!
    private lateinit var aRealm: Realm
    private lateinit var realmChangeListener: io.realm.RealmChangeListener<Realm>
    var user: RealmUserModel? = null
    var listener: OnHomeItemClickListener? = null
    private var achievement: RealmAchievement? = null
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    lateinit var prefManager: SharedPrefManager
    private val serverUrlMapper = ServerUrlMapper()

    @Inject
    lateinit var syncManager: SyncManager
    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()
    private lateinit var realtimeSyncListener: BaseRealtimeSyncListener
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        prefManager = SharedPrefManager(requireContext())
        startAchievementSync()
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) listener = context
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentAchievementBinding.inflate(inflater, container, false)
        aRealm = databaseService.realmInstance
        user = profileDbHandler.userModel
        binding.btnEdit.setOnClickListener {
            if (listener != null) listener?.openCallFragment(EditAchievementFragment())
        }
        return binding.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        if (::realtimeSyncListener.isInitialized) {
            syncCoordinator.removeListener(realtimeSyncListener)
        }
        if (::realmChangeListener.isInitialized) {
            aRealm.removeChangeListener(realmChangeListener)
        }
        _binding = null
    }

    private fun startAchievementSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isAchievementsSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(getString(R.string.syncing_achievements))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        refreshAchievementData()
                        prefManager.setAchievementsSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG)
                            .setAction("Retry") { startAchievementSync() }
                            .show()
                    }
                }
            }
        }, "full", listOf("achievements"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun refreshAchievementData() {
        if (!isAdded || requireActivity().isFinishing) return

        try {
            achievement = aRealm.where(RealmAchievement::class.java)
                .equalTo("_id", user?.id + "@" + user?.planetCode)
                .findFirst()

            updateAchievementUI()

        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun updateAchievementUI() {
        if (achievement != null) {
            setupAchievementHeader(achievement!!)
            populateAchievements()
            setupReferences()
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupRealtimeSync()
        setupUserData()
        loadInitialAchievementData()
    }

    private fun setupUserData() {
        binding.tvFirstName.text = user?.firstName
        binding.tvName.text =
            String.format("%s %s %s", user?.firstName, user?.middleName, user?.lastName)
    }

    private fun loadInitialAchievementData() {
        achievement = aRealm.where(RealmAchievement::class.java)
            .equalTo("_id", user?.id + "@" + user?.planetCode)
            .findFirst()

        achievement?.let {
            updateAchievementUI()
            realmChangeListener = io.realm.RealmChangeListener {
                if (isAdded) {
                    populateAchievements()
                }
            }
            aRealm.addChangeListener(realmChangeListener)
        }
    }

    private fun setupRealtimeSync() {
        realtimeSyncListener = object : BaseRealtimeSyncListener() {
            override fun onTableDataUpdated(update: TableDataUpdate) {
                if (update.table == "achievements" && update.shouldRefreshUI) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        refreshAchievementData()
                    }
                }
            }
        }
        syncCoordinator.addListener(realtimeSyncListener)
    }

    private fun setupAchievementHeader(a: RealmAchievement) {
        binding.tvGoals.text = a.goals
        binding.tvPurpose.text = a.purpose
        binding.tvAchievementHeader.text = a.achievementsHeader
    }

    private fun populateAchievements() {
        binding.llAchievement.removeAllViews()
        achievement?.achievements?.forEach { json ->
            val element = Gson().fromJson(json, JsonElement::class.java)
            val view = if (element is JsonObject) createAchievementView(element) else null
            view?.let {
                // Ensure the view is properly detached from any previous parent
                if (it.parent != null) {
                    (it.parent as ViewGroup).removeView(it)
                }
                binding.llAchievement.addView(it)
            }
        }
    }

    private fun createAchievementView(ob: JsonObject): View {
        val binding = RowAchievementBinding.inflate(LayoutInflater.from(requireContext()))
        val desc = getString("description", ob)
        binding.tvDescription.text = desc
        binding.tvDate.text = getString("date", ob)
        binding.tvTitle.text = getString("title", ob)
        val libraries = getLibraries(ob.getAsJsonArray("resources"))

        if (desc.isNotEmpty() && libraries.isNotEmpty()) {
            binding.llRow.setOnClickListener { toggleDescription(binding) }
            binding.flexboxResources.removeAllViews()
            libraries.forEach { binding.flexboxResources.addView(createResourceButton(it)) }
        } else {
            binding.tvTitle.setCompoundDrawablesWithIntrinsicBounds(0, 0, 0, 0)
        }
        return binding.root
    }

    private fun toggleDescription(binding: RowAchievementBinding) {
        binding.llDesc.visibility = if (binding.llDesc.isGone) View.VISIBLE else View.GONE
        binding.tvTitle.setCompoundDrawablesWithIntrinsicBounds(
            0,
            0,
            if (binding.llDesc.isGone) R.drawable.ic_down else R.drawable.ic_up,
            0
        )
    }

    private fun createResourceButton(lib: RealmMyLibrary): View {
        val btnBinding = LayoutButtonPrimaryBinding.inflate(LayoutInflater.from(requireContext()))
        btnBinding.root.text = lib.title
        btnBinding.root.setCompoundDrawablesWithIntrinsicBounds(
            0,
            0,
            if (lib.isResourceOffline()) R.drawable.ic_eye else R.drawable.ic_download,
            0
        )
        btnBinding.root.setOnClickListener {
            if (lib.isResourceOffline()) {
                openResource(lib)
            } else {
                startDownload(arrayListOf(UrlUtils.getUrl(lib)))
            }
        }
        return btnBinding.root
    }

    private fun setupReferences() {
        binding.rvOtherInfo.layoutManager = LinearLayoutManager(requireContext())
        binding.rvOtherInfo.adapter =
            AdapterOtherInfo(requireContext(), achievement?.references ?: RealmList())
    }

    private fun getLibraries(array: JsonArray): List<RealmMyLibrary> {
        val libraries = ArrayList<RealmMyLibrary>()
        for (e in array) {
            val id = e.asJsonObject["_id"].asString
            val li = aRealm.where(RealmMyLibrary::class.java).equalTo("id", id).findFirst()
            if (li != null) libraries.add(li)
        }
        return libraries
    }


    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        if (this::aRealm.isInitialized && !aRealm.isClosed) {
            aRealm.close()
        }
        try {
            if (!mRealm.isClosed) {
                mRealm.close()
            }
        } catch (_: UninitializedPropertyAccessException) {
        }
        super.onDestroy()
    }
}
=======
package org.ole.planet.myplanet.ui.userprofile


import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.isGone
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonElement
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmList
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.databinding.FragmentAchievementBinding
import org.ole.planet.myplanet.databinding.LayoutButtonPrimaryBinding
import org.ole.planet.myplanet.databinding.RowAchievementBinding
import org.ole.planet.myplanet.model.RealmAchievement
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.UrlUtils

@AndroidEntryPoint
class AchievementFragment : BaseContainerFragment() {
    private var _binding: FragmentAchievementBinding? = null
    private val binding get() = _binding!!
    private lateinit var aRealm: Realm
    private lateinit var realmChangeListener: io.realm.RealmChangeListener<Realm>
    var user: RealmUserModel? = null
    var listener: OnHomeItemClickListener? = null
    private var achievement: RealmAchievement? = null
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    lateinit var prefManager: SharedPrefManager
    private val serverUrlMapper = ServerUrlMapper()

    @Inject
    lateinit var syncManager: SyncManager
    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()
    private lateinit var realtimeSyncListener: BaseRealtimeSyncListener
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        prefManager = SharedPrefManager(requireContext())
        startAchievementSync()
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) listener = context
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentAchievementBinding.inflate(inflater, container, false)
        aRealm = databaseService.realmInstance
        user = profileDbHandler.userModel
        binding.btnEdit.setOnClickListener {
            if (listener != null) listener?.openCallFragment(EditAchievementFragment())
        }
        return binding.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        if (::realtimeSyncListener.isInitialized) {
            syncCoordinator.removeListener(realtimeSyncListener)
        }
        if (::realmChangeListener.isInitialized) {
            aRealm.removeChangeListener(realmChangeListener)
        }
        _binding = null
    }

    private fun startAchievementSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isAchievementsSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(getString(R.string.syncing_achievements))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        refreshAchievementData()
                        prefManager.setAchievementsSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null
                        Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG)
                            .setAction("Retry") { startAchievementSync() }
                            .show()
                    }
                }
            }
        }, "full", listOf("achievements"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun refreshAchievementData() {
        if (!isAdded || requireActivity().isFinishing) return

        try {
            achievement = aRealm.where(RealmAchievement::class.java)
                .equalTo("_id", user?.id + "@" + user?.planetCode)
                .findFirst()

            updateAchievementUI()

        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun updateAchievementUI() {
        if (achievement != null) {
            setupAchievementHeader(achievement!!)
            populateAchievements()
            setupReferences()
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupRealtimeSync()
        setupUserData()
        loadInitialAchievementData()
    }

    private fun setupUserData() {
        binding.tvFirstName.text = user?.firstName
        binding.tvName.text =
            String.format("%s %s %s", user?.firstName, user?.middleName, user?.lastName)
    }

    private fun loadInitialAchievementData() {
        achievement = aRealm.where(RealmAchievement::class.java)
            .equalTo("_id", user?.id + "@" + user?.planetCode)
            .findFirst()

        achievement?.let {
            updateAchievementUI()
            realmChangeListener = io.realm.RealmChangeListener {
                if (isAdded) {
                    populateAchievements()
                }
            }
            aRealm.addChangeListener(realmChangeListener)
        }
    }

    private fun setupRealtimeSync() {
        realtimeSyncListener = object : BaseRealtimeSyncListener() {
            override fun onTableDataUpdated(update: TableDataUpdate) {
                if (update.table == "achievements" && update.shouldRefreshUI) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        refreshAchievementData()
                    }
                }
            }
        }
        syncCoordinator.addListener(realtimeSyncListener)
    }

    private fun setupAchievementHeader(a: RealmAchievement) {
        binding.tvGoals.text = a.goals
        binding.tvPurpose.text = a.purpose
        binding.tvAchievementHeader.text = a.achievementsHeader
    }

    private fun populateAchievements() {
        binding.llAchievement.removeAllViews()
        achievement?.achievements?.forEach { json ->
            val element = Gson().fromJson(json, JsonElement::class.java)
            val view = if (element is JsonObject) createAchievementView(element) else null
            view?.let {
                // Ensure the view is properly detached from any previous parent
                if (it.parent != null) {
                    (it.parent as ViewGroup).removeView(it)
                }
                binding.llAchievement.addView(it)
            }
        }
    }

    private fun createAchievementView(ob: JsonObject): View {
        val binding = RowAchievementBinding.inflate(LayoutInflater.from(requireContext()))
        val desc = getString("description", ob)
        binding.tvDescription.text = desc
        binding.tvDate.text = getString("date", ob)
        binding.tvTitle.text = getString("title", ob)
        val libraries = getLibraries(ob.getAsJsonArray("resources"))

        if (desc.isNotEmpty() && libraries.isNotEmpty()) {
            binding.llRow.setOnClickListener { toggleDescription(binding) }
            binding.flexboxResources.removeAllViews()
            libraries.forEach { binding.flexboxResources.addView(createResourceButton(it)) }
        } else {
            binding.tvTitle.setCompoundDrawablesWithIntrinsicBounds(0, 0, 0, 0)
        }
        return binding.root
    }

    private fun toggleDescription(binding: RowAchievementBinding) {
        binding.llDesc.visibility = if (binding.llDesc.isGone) View.VISIBLE else View.GONE
        binding.tvTitle.setCompoundDrawablesWithIntrinsicBounds(
            0,
            0,
            if (binding.llDesc.isGone) R.drawable.ic_down else R.drawable.ic_up,
            0
        )
    }

    private fun createResourceButton(lib: RealmMyLibrary): View {
        val btnBinding = LayoutButtonPrimaryBinding.inflate(LayoutInflater.from(requireContext()))
        btnBinding.root.text = lib.title
        btnBinding.root.setCompoundDrawablesWithIntrinsicBounds(
            0,
            0,
            if (lib.isResourceOffline()) R.drawable.ic_eye else R.drawable.ic_download,
            0
        )
        btnBinding.root.setOnClickListener {
            if (lib.isResourceOffline()) {
                openResource(lib)
            } else {
                startDownload(arrayListOf(UrlUtils.getUrl(lib)))
            }
        }
        return btnBinding.root
    }

    private fun setupReferences() {
        binding.rvOtherInfo.layoutManager = LinearLayoutManager(requireContext())
        binding.rvOtherInfo.adapter =
            AdapterOtherInfo(requireContext(), achievement?.references ?: RealmList())
    }

    private fun getLibraries(array: JsonArray): List<RealmMyLibrary> {
        val libraries = ArrayList<RealmMyLibrary>()
        for (e in array) {
            val id = e.asJsonObject["_id"].asString
            val li = aRealm.where(RealmMyLibrary::class.java).equalTo("id", id).findFirst()
            if (li != null) libraries.add(li)
        }
        return libraries
    }


    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        if (this::aRealm.isInitialized && !aRealm.isClosed) {
            aRealm.close()
        }
        try {
            if (!mRealm.isClosed) {
                mRealm.close()
            }
        } catch (_: UninitializedPropertyAccessException) {
        }
        super.onDestroy()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/SettingActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui

import android.app.Activity
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import androidx.preference.Preference
import androidx.preference.Preference.OnPreferenceChangeListener
import androidx.preference.Preference.OnPreferenceClickListener
import androidx.preference.PreferenceFragmentCompat
import androidx.preference.SwitchPreference
import dagger.hilt.android.AndroidEntryPoint
import java.io.File
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication.Companion.createLog
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.backgroundDownload
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.getAllLibraryList
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.di.DefaultPreferences
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.sync.SyncActivity.Companion.clearRealmDb
import org.ole.planet.myplanet.ui.sync.SyncActivity.Companion.clearSharedPref
import org.ole.planet.myplanet.ui.sync.SyncActivity.Companion.restartApp
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.DownloadUtils.downloadAllFiles
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.ThemeManager
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class SettingActivity : AppCompatActivity() {

    @Inject
    lateinit var databaseService: DatabaseService

    @Inject
    @AppPreferences
    lateinit var appPreferences: SharedPreferences

    @Inject
    @DefaultPreferences
    lateinit var defaultPreferences: SharedPreferences

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(base))
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        EdgeToEdgeUtils.setupEdgeToEdge(this, window.decorView)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        NavigationHelper.replaceFragment(supportFragmentManager, android.R.id.content, SettingFragment())
        title = getString(R.string.action_settings)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            android.R.id.home -> {
                finish()
                return true
            }
        }
        return super.onOptionsItemSelected(item)
    }

    override fun finish() {
        super.finish()
        if (openDashboard) {
            startActivity(Intent(this, DashboardActivity::class.java)
                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK))
        }
    }

    @AndroidEntryPoint
    class SettingFragment : PreferenceFragmentCompat() {
        @Inject
        lateinit var profileDbHandler: UserProfileDbHandler
        @Inject
        lateinit var databaseService: DatabaseService
        @Inject
        @DefaultPreferences
        lateinit var defaultPref: SharedPreferences
        @Inject
        @AppPreferences
        lateinit var settings: SharedPreferences
        var user: RealmUserModel? = null
        private lateinit var dialog: DialogUtils.CustomProgressDialog

        override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
            val view = super.onCreateView(inflater, container, savedInstanceState)
            view.setBackgroundColor(ContextCompat.getColor(requireContext(), R.color.secondary_bg))
            return view
        }

        override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
            requireContext().setTheme(R.style.PreferencesTheme)
            setPreferencesFromResource(R.xml.pref, rootKey)
            user = profileDbHandler.userModel
            dialog = DialogUtils.getCustomProgressDialog(requireActivity())

            setBetaToggleOn()
            setAutoSyncToggleOn()
            setImprovedSyncToggleOn()
            val lp = findPreference<Preference>("app_language")
            lp?.setOnPreferenceClickListener {
                context?.let { it1 -> languageChanger(it1) }
                true
            }

            val darkMode = findPreference<Preference>("dark_mode")
            darkMode?.setOnPreferenceClickListener {
                ThemeManager.showThemeDialog(requireActivity())
                true
            }

            // Show Available space under the "Freeup Space" preference.
            val spacePreference = findPreference<Preference>("freeup_space")
            if (spacePreference != null) {
                spacePreference.summary = "${getString(R.string.available_space_colon)} ${FileUtils.availableOverTotalMemoryFormattedString(requireContext())}"
            }

            val autoDownload = findPreference<SwitchPreference>("beta_auto_download")
            autoDownload?.onPreferenceChangeListener = OnPreferenceChangeListener { _: Preference?, _: Any? ->
                if (autoDownload.isChecked == true) {
                    defaultPref.edit { putBoolean("beta_auto_download", true) }
                    databaseService.withRealm { realm ->
                        backgroundDownload(
                            downloadAllFiles(getAllLibraryList(realm)),
                            requireContext()
                        )
                    }
                } else {
                    defaultPref.edit { putBoolean("beta_auto_download", false) }
                }
                true
            }

            val fastSync = findPreference<SwitchPreference>("beta_fast_sync")
            val isFastSync = settings.getBoolean("fastSync", false)
            fastSync?.isChecked = isFastSync
            fastSync?.onPreferenceChangeListener = OnPreferenceChangeListener { _, newValue ->
                val isChecked = newValue as Boolean
                settings.edit { putBoolean("fastSync", isChecked) }
                true
            }

            clearDataButtonInit()
        }

        private fun clearDataButtonInit() {
            val preference = findPreference<Preference>("reset_app")
            if (preference != null) {
                preference.onPreferenceClickListener = OnPreferenceClickListener {
                    AlertDialog.Builder(requireActivity()).setTitle(R.string.are_you_sure)
                        .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                            CoroutineScope(Dispatchers.Main).launch {
                                clearRealmDb()
                                clearSharedPref()
                                restartApp()
                            }
                        }.setNegativeButton(R.string.no, null).show()
                    false
                }
            }
            val prefFreeUp = findPreference<Preference>("freeup_space")
            if (prefFreeUp != null) {
                prefFreeUp.onPreferenceClickListener = OnPreferenceClickListener {
                    AlertDialog.Builder(requireActivity()).setTitle(R.string.are_you_sure_want_to_delete_all_the_files)
                        .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                            databaseService.withRealm { realm ->
                                realm.executeTransactionAsync({ bgRealm ->
                                    val libraries = bgRealm.where(RealmMyLibrary::class.java).findAll()
                                    for (library in libraries) {
                                        library.resourceOffline = false
                                    }
                                }, {
                                    val f = File(FileUtils.getOlePath(requireContext()))
                                    deleteRecursive(f)
                                    Utilities.toast(requireActivity(), getString(R.string.data_cleared))
                                }) {
                                    Utilities.toast(requireActivity(), getString(R.string.unable_to_clear_files))
                                }
                            }
                        }.setNegativeButton("No", null).show()
                    false
                }
            }
        }

        private fun deleteRecursive(fileOrDirectory: File) {
            if (fileOrDirectory.isDirectory) for (child in fileOrDirectory.listFiles()!!) deleteRecursive(child)
            fileOrDirectory.delete()
        }

        private fun setBetaToggleOn() {
            val beta = findPreference<SwitchPreference>("beta_function")

            beta?.onPreferenceChangeListener = OnPreferenceChangeListener { _: Preference?, _: Any? ->
                true
            }
        }

        private fun setAutoSyncToggleOn() {
            val autoSync = findPreference<SwitchPreference>("auto_sync_with_server")
            val autoForceWeeklySync = findPreference<SwitchPreference>("force_weekly_sync")
            val autoForceMonthlySync = findPreference<SwitchPreference>("force_monthly_sync")
            val lastSyncDate = findPreference<Preference>("lastSyncDate")
            autoSync!!.onPreferenceChangeListener = OnPreferenceChangeListener { _: Preference?, _: Any? ->
                if (autoSync.isChecked) {
                    if (autoForceWeeklySync!!.isChecked) {
                        autoForceMonthlySync!!.isChecked = false
                    } else autoForceWeeklySync.isChecked = !autoForceMonthlySync!!.isChecked
                }
                true
            }
            autoForceSync(autoSync, autoForceWeeklySync!!, autoForceMonthlySync!!)
            autoForceSync(autoSync, autoForceMonthlySync, autoForceWeeklySync)
            val syncPreferences = requireActivity().getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
            val lastSynced = syncPreferences.getLong("LastSync", 0)
            if (lastSynced == 0L) {
                lastSyncDate?.setTitle(R.string.last_synced_never)
            } else if (lastSyncDate != null) {
                lastSyncDate.title = getString(R.string.last_synced_colon) + TimeUtils.getRelativeTime(lastSynced)
            }
        }

        private fun setImprovedSyncToggleOn() {
            val improvedSyncPreference = findPreference<SwitchPreference>("beta_improved_sync")
            improvedSyncPreference?.isChecked = settings.getBoolean("useImprovedSync", false)
            improvedSyncPreference?.onPreferenceChangeListener = OnPreferenceChangeListener { _, newValue ->
                val isChecked = newValue as? Boolean ?: return@OnPreferenceChangeListener false
                settings.edit { putBoolean("useImprovedSync", isChecked) }
                val state = if (isChecked) "enabled" else "disabled"
                createLog("improved_sync_toggle", state)
                true
            }
        }

        override fun onDestroy() {
            super.onDestroy()
        }

        companion object {

            fun languageChanger(context: Context) {
                val options = arrayOf(
                    context.getString(R.string.english),
                    context.getString(R.string.spanish),
                    context.getString(R.string.somali),
                    context.getString(R.string.nepali),
                    context.getString(R.string.arabic),
                    context.getString(R.string.french)
                )
                val currentLanguage = LocaleHelper.getLanguage(context)
                val checkedItem = when (currentLanguage) {
                    "en" -> 0
                    "es" -> 1
                    "so" -> 2
                    "ne" -> 3
                    "ar" -> 4
                    "fr" -> 5
                    else -> 0
                }

                val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
                    .setTitle(context.getString(R.string.select_language))
                    .setSingleChoiceItems(ArrayAdapter(context, R.layout.checked_list_item, options), checkedItem) { dialog, which ->
                        val selectedLanguage = when (which) {
                            0 -> "en"
                            1 -> "es"
                            2 -> "so"
                            3 -> "ne"
                            4 -> "ar"
                            5 -> "fr"
                            else -> "en"
                        }
                        LocaleHelper.setLocale(context, selectedLanguage)
                        (context as Activity).recreate()
                        dialog.dismiss()
                    }
                    .setNegativeButton(R.string.cancel, null)

                val dialog = builder.create()
                dialog.show()
            }
        }
    }

    companion object {
        var openDashboard = true
        private fun autoForceSync(autoSync: SwitchPreference, autoForceA: SwitchPreference, autoForceB: SwitchPreference) {
            autoForceA.onPreferenceChangeListener = OnPreferenceChangeListener { _: Preference?, _: Any? ->
                autoForceB.isChecked = !autoSync.isChecked
                true
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui


import android.app.Activity
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import androidx.preference.Preference
import androidx.preference.Preference.OnPreferenceChangeListener
import androidx.preference.Preference.OnPreferenceClickListener
import androidx.preference.PreferenceFragmentCompat
import androidx.preference.SwitchPreference
import dagger.hilt.android.AndroidEntryPoint
import java.io.File
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication.Companion.createLog
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.backgroundDownload
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.getAllLibraryList
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.di.DefaultPreferences
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.sync.SyncActivity.Companion.clearRealmDb
import org.ole.planet.myplanet.ui.sync.SyncActivity.Companion.clearSharedPref
import org.ole.planet.myplanet.ui.sync.SyncActivity.Companion.restartApp
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.DownloadUtils.downloadAllFiles
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.ThemeManager
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class SettingActivity : AppCompatActivity() {

    @Inject
    lateinit var databaseService: DatabaseService

    @Inject
    @AppPreferences
    lateinit var appPreferences: SharedPreferences

    @Inject
    @DefaultPreferences
    lateinit var defaultPreferences: SharedPreferences

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(base))
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        EdgeToEdgeUtils.setupEdgeToEdge(this, window.decorView)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        NavigationHelper.replaceFragment(supportFragmentManager, android.R.id.content, SettingFragment())
        title = getString(R.string.action_settings)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            android.R.id.home -> {
                finish()
                return true
            }
        }
        return super.onOptionsItemSelected(item)
    }

    override fun finish() {
        super.finish()
        if (openDashboard) {
            startActivity(Intent(this, DashboardActivity::class.java)
                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK))
        }
    }

    @AndroidEntryPoint
    class SettingFragment : PreferenceFragmentCompat() {
        @Inject
        lateinit var profileDbHandler: UserProfileDbHandler
        @Inject
        lateinit var databaseService: DatabaseService
        @Inject
        @DefaultPreferences
        lateinit var defaultPref: SharedPreferences
        @Inject
        @AppPreferences
        lateinit var settings: SharedPreferences
        var user: RealmUserModel? = null
        private lateinit var dialog: DialogUtils.CustomProgressDialog

        override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
            val view = super.onCreateView(inflater, container, savedInstanceState)
            view.setBackgroundColor(ContextCompat.getColor(requireContext(), R.color.secondary_bg))
            return view
        }

        override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
            requireContext().setTheme(R.style.PreferencesTheme)
            setPreferencesFromResource(R.xml.pref, rootKey)
            user = profileDbHandler.userModel
            dialog = DialogUtils.getCustomProgressDialog(requireActivity())

            setBetaToggleOn()
            setAutoSyncToggleOn()
            setImprovedSyncToggleOn()
            val lp = findPreference<Preference>("app_language")
            lp?.setOnPreferenceClickListener {
                context?.let { it1 -> languageChanger(it1) }
                true
            }

            val darkMode = findPreference<Preference>("dark_mode")
            darkMode?.setOnPreferenceClickListener {
                ThemeManager.showThemeDialog(requireActivity())
                true
            }

            // Show Available space under the "Freeup Space" preference.
            val spacePreference = findPreference<Preference>("freeup_space")
            if (spacePreference != null) {
                spacePreference.summary = "${getString(R.string.available_space_colon)} ${FileUtils.availableOverTotalMemoryFormattedString(requireContext())}"
            }

            val autoDownload = findPreference<SwitchPreference>("beta_auto_download")
            autoDownload?.onPreferenceChangeListener = OnPreferenceChangeListener { _: Preference?, _: Any? ->
                if (autoDownload.isChecked == true) {
                    defaultPref.edit { putBoolean("beta_auto_download", true) }
                    databaseService.withRealm { realm ->
                        backgroundDownload(
                            downloadAllFiles(getAllLibraryList(realm)),
                            requireContext()
                        )
                    }
                } else {
                    defaultPref.edit { putBoolean("beta_auto_download", false) }
                }
                true
            }

            val fastSync = findPreference<SwitchPreference>("beta_fast_sync")
            val isFastSync = settings.getBoolean("fastSync", false)
            fastSync?.isChecked = isFastSync
            fastSync?.onPreferenceChangeListener = OnPreferenceChangeListener { _, newValue ->
                val isChecked = newValue as Boolean
                settings.edit { putBoolean("fastSync", isChecked) }
                true
            }

            clearDataButtonInit()
        }

        private fun clearDataButtonInit() {
            val preference = findPreference<Preference>("reset_app")
            if (preference != null) {
                preference.onPreferenceClickListener = OnPreferenceClickListener {
                    AlertDialog.Builder(requireActivity()).setTitle(R.string.are_you_sure)
                        .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                            CoroutineScope(Dispatchers.Main).launch {
                                clearRealmDb()
                                clearSharedPref()
                                restartApp()
                            }
                        }.setNegativeButton(R.string.no, null).show()
                    false
                }
            }
            val prefFreeUp = findPreference<Preference>("freeup_space")
            if (prefFreeUp != null) {
                prefFreeUp.onPreferenceClickListener = OnPreferenceClickListener {
                    AlertDialog.Builder(requireActivity()).setTitle(R.string.are_you_sure_want_to_delete_all_the_files)
                        .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                            databaseService.withRealm { realm ->
                                realm.executeTransactionAsync({ bgRealm ->
                                    val libraries = bgRealm.where(RealmMyLibrary::class.java).findAll()
                                    for (library in libraries) {
                                        library.resourceOffline = false
                                    }
                                }, {
                                    val f = File(FileUtils.getOlePath(requireContext()))
                                    deleteRecursive(f)
                                    Utilities.toast(requireActivity(), getString(R.string.data_cleared))
                                }) {
                                    Utilities.toast(requireActivity(), getString(R.string.unable_to_clear_files))
                                }
                            }
                        }.setNegativeButton("No", null).show()
                    false
                }
            }
        }

        private fun deleteRecursive(fileOrDirectory: File) {
            if (fileOrDirectory.isDirectory) for (child in fileOrDirectory.listFiles()!!) deleteRecursive(child)
            fileOrDirectory.delete()
        }

        private fun setBetaToggleOn() {
            val beta = findPreference<SwitchPreference>("beta_function")

            beta?.onPreferenceChangeListener = OnPreferenceChangeListener { _: Preference?, _: Any? ->
                true
            }
        }

        private fun setAutoSyncToggleOn() {
            val autoSync = findPreference<SwitchPreference>("auto_sync_with_server")
            val autoForceWeeklySync = findPreference<SwitchPreference>("force_weekly_sync")
            val autoForceMonthlySync = findPreference<SwitchPreference>("force_monthly_sync")
            val lastSyncDate = findPreference<Preference>("lastSyncDate")
            autoSync!!.onPreferenceChangeListener = OnPreferenceChangeListener { _: Preference?, _: Any? ->
                if (autoSync.isChecked) {
                    if (autoForceWeeklySync!!.isChecked) {
                        autoForceMonthlySync!!.isChecked = false
                    } else autoForceWeeklySync.isChecked = !autoForceMonthlySync!!.isChecked
                }
                true
            }
            autoForceSync(autoSync, autoForceWeeklySync!!, autoForceMonthlySync!!)
            autoForceSync(autoSync, autoForceMonthlySync, autoForceWeeklySync)
            val syncPreferences = requireActivity().getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
            val lastSynced = syncPreferences.getLong("LastSync", 0)
            if (lastSynced == 0L) {
                lastSyncDate?.setTitle(R.string.last_synced_never)
            } else if (lastSyncDate != null) {
                lastSyncDate.title = getString(R.string.last_synced_colon) + TimeUtils.getRelativeTime(lastSynced)
            }
        }

        private fun setImprovedSyncToggleOn() {
            val improvedSyncPreference = findPreference<SwitchPreference>("beta_improved_sync")
            improvedSyncPreference?.isChecked = settings.getBoolean("useImprovedSync", false)
            improvedSyncPreference?.onPreferenceChangeListener = OnPreferenceChangeListener { _, newValue ->
                val isChecked = newValue as? Boolean ?: return@OnPreferenceChangeListener false
                settings.edit { putBoolean("useImprovedSync", isChecked) }
                val state = if (isChecked) "enabled" else "disabled"
                createLog("improved_sync_toggle", state)
                true
            }
        }

        override fun onDestroy() {
            super.onDestroy()
        }

        companion object {

            fun languageChanger(context: Context) {
                val options = arrayOf(
                    context.getString(R.string.english),
                    context.getString(R.string.spanish),
                    context.getString(R.string.somali),
                    context.getString(R.string.nepali),
                    context.getString(R.string.arabic),
                    context.getString(R.string.french)
                )
                val currentLanguage = LocaleHelper.getLanguage(context)
                val checkedItem = when (currentLanguage) {
                    "en" -> 0
                    "es" -> 1
                    "so" -> 2
                    "ne" -> 3
                    "ar" -> 4
                    "fr" -> 5
                    else -> 0
                }

                val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
                    .setTitle(context.getString(R.string.select_language))
                    .setSingleChoiceItems(ArrayAdapter(context, R.layout.checked_list_item, options), checkedItem) { dialog, which ->
                        val selectedLanguage = when (which) {
                            0 -> "en"
                            1 -> "es"
                            2 -> "so"
                            3 -> "ne"
                            4 -> "ar"
                            5 -> "fr"
                            else -> "en"
                        }
                        LocaleHelper.setLocale(context, selectedLanguage)
                        (context as Activity).recreate()
                        dialog.dismiss()
                    }
                    .setNegativeButton(R.string.cancel, null)

                val dialog = builder.create()
                dialog.show()
            }
        }
    }

    companion object {
        var openDashboard = true
        private fun autoForceSync(autoSync: SwitchPreference, autoForceA: SwitchPreference, autoForceB: SwitchPreference) {
            autoForceA.onPreferenceChangeListener = OnPreferenceChangeListener { _: Preference?, _: Any? ->
                autoForceB.isChecked = !autoSync.isChecked
                true
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/exam/ExamSubmissionUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.exam

import io.realm.Realm
import io.realm.RealmList
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.model.RealmAnswer
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmSubmission

object ExamSubmissionUtils {
    fun saveAnswer(
        realm: Realm, submission: RealmSubmission?, question: RealmExamQuestion,
        ans: String, listAns: Map<String, String>?, otherText: String?, otherVisible: Boolean,
        type: String, index: Int, total: Int
    ): Boolean {
        val submissionId = try {
            submission?.id
        } catch (e: IllegalStateException) {
            null
        }

        val questionId = question.id
        realm.executeTransactionAsync { r ->
            val realmSubmission = if (submissionId != null) {
                r.where(RealmSubmission::class.java).equalTo("id", submissionId).findFirst()
            } else {
                r.where(RealmSubmission::class.java)
                    .equalTo("status", "pending")
                    .findAll().lastOrNull()
            }

            val realmQuestion = r.where(RealmExamQuestion::class.java).equalTo("id", questionId).findFirst()

            if (realmSubmission != null && realmQuestion != null) {
                val answer = createOrRetrieveAnswer(r, realmSubmission, realmQuestion)
                populateAnswer(answer, realmQuestion, ans, listAns, otherText, otherVisible)
                if (type == "exam") {
                    val isCorrect = ExamAnswerUtils.checkCorrectAnswer(ans, listAns, realmQuestion)
                    answer.isPassed = isCorrect
                    answer.grade = 1
                    if (!isCorrect) {
                        answer.mistakes = answer.mistakes + 1
                    }
                }
                updateSubmissionStatus(r, realmSubmission, index, total, type)
            }
        }

        return if (type == "exam") {
            ExamAnswerUtils.checkCorrectAnswer(ans, listAns, question)
        } else {
            true
        }
    }

    private fun createOrRetrieveAnswer(
        realm: Realm,
        submission: RealmSubmission?,
        question: RealmExamQuestion,
    ): RealmAnswer {
        val existing = submission?.answers?.find { it.questionId == question.id }
        val ansObj = existing ?: realm.createObject(RealmAnswer::class.java, UUID.randomUUID().toString())
        if (existing == null) {
            submission?.answers?.add(ansObj)
        }
        ansObj.questionId = question.id
        ansObj.submissionId = submission?.id
        return ansObj
    }

    private fun updateSubmissionStatus(
        realm: Realm,
        submission: RealmSubmission?,
        index: Int,
        total: Int,
        type: String,
    ) {
        submission?.lastUpdateTime = Date().time
        val isFinal = index == total - 1
        submission?.status = when {
            isFinal && type == "survey" -> "complete"
            isFinal -> "requires grading"
            else -> "pending"
        }

        if (isFinal && type == "survey" && submission != null) {
            realm.where(RealmSubmission::class.java)
                .equalTo("userId", submission.userId)
                .equalTo("parentId", submission.parentId)
                .equalTo("status", "pending")
                .notEqualTo("id", submission.id)
                .findAll()
                .forEach { it.status = "complete" }
        }
    }

    private fun populateAnswer(
        answer: RealmAnswer, question: RealmExamQuestion, ans: String, listAns: Map<String, String>?,
        otherText: String?, otherVisible: Boolean,
    ) {
        when {
            question.type.equals("select", ignoreCase = true) -> {
                populateSelectAnswer(answer, question, ans, otherText, otherVisible)
            }
            question.type.equals("selectMultiple", ignoreCase = true) -> {
                populateMultipleSelectAnswer(answer, listAns, otherText, otherVisible)
            }
            else -> {
                val textValue = if (otherVisible && !otherText.isNullOrEmpty()) {
                    otherText
                } else {
                    ans
                }
                populateTextAnswer(answer, textValue)
            }
        }
    }

    private fun populateSelectAnswer(
        answer: RealmAnswer, question: RealmExamQuestion, ans: String, otherText: String?,
        otherVisible: Boolean,
    ) {
        if (otherVisible && !otherText.isNullOrEmpty()) {
            answer.value = otherText
            answer.valueChoices = RealmList<String>().apply {
                add("""{"id":"other","text":"$otherText"}""")
            }
        } else {
            val choiceText = ExamAnswerUtils.getChoiceTextById(question, ans)
            answer.value = choiceText
            answer.valueChoices = RealmList<String>().apply {
                if (ans.isNotEmpty()) {
                    add("""{"id":"$ans","text":"$choiceText"}""")
                }
            }
        }
    }

    private fun populateMultipleSelectAnswer(
        answer: RealmAnswer, listAns: Map<String, String>?, otherText: String?, otherVisible: Boolean
    ) {
        answer.value = ""
        answer.valueChoices = RealmList<String>().apply {
            listAns?.toMap()?.forEach { (text, id) ->
                if (id == "other" && otherVisible && !otherText.isNullOrEmpty()) {
                    add("""{"id":"other","text":"$otherText"}""")
                } else {
                    add("""{"id":"$id","text":"$text"}""")
                }
            }
        }
    }

    private fun populateTextAnswer(answer: RealmAnswer, ans: String) {
        answer.value = ans
        answer.valueChoices = null
    }
}
=======
package org.ole.planet.myplanet.ui.exam


import io.realm.Realm
import io.realm.RealmList
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.model.RealmAnswer
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmSubmission

object ExamSubmissionUtils {
    fun saveAnswer(
        realm: Realm, submission: RealmSubmission?, question: RealmExamQuestion,
        ans: String, listAns: Map<String, String>?, otherText: String?, otherVisible: Boolean,
        type: String, index: Int, total: Int
    ): Boolean {
        val submissionId = try {
            submission?.id
        } catch (e: IllegalStateException) {
            null
        }

        val questionId = question.id
        realm.executeTransactionAsync { r ->
            val realmSubmission = if (submissionId != null) {
                r.where(RealmSubmission::class.java).equalTo("id", submissionId).findFirst()
            } else {
                r.where(RealmSubmission::class.java)
                    .equalTo("status", "pending")
                    .findAll().lastOrNull()
            }

            val realmQuestion = r.where(RealmExamQuestion::class.java).equalTo("id", questionId).findFirst()

            if (realmSubmission != null && realmQuestion != null) {
                val answer = createOrRetrieveAnswer(r, realmSubmission, realmQuestion)
                populateAnswer(answer, realmQuestion, ans, listAns, otherText, otherVisible)
                if (type == "exam") {
                    val isCorrect = ExamAnswerUtils.checkCorrectAnswer(ans, listAns, realmQuestion)
                    answer.isPassed = isCorrect
                    answer.grade = 1
                    if (!isCorrect) {
                        answer.mistakes = answer.mistakes + 1
                    }
                }
                updateSubmissionStatus(r, realmSubmission, index, total, type)
            }
        }

        return if (type == "exam") {
            ExamAnswerUtils.checkCorrectAnswer(ans, listAns, question)
        } else {
            true
        }
    }

    private fun createOrRetrieveAnswer(
        realm: Realm,
        submission: RealmSubmission?,
        question: RealmExamQuestion,
    ): RealmAnswer {
        val existing = submission?.answers?.find { it.questionId == question.id }
        val ansObj = existing ?: realm.createObject(RealmAnswer::class.java, UUID.randomUUID().toString())
        if (existing == null) {
            submission?.answers?.add(ansObj)
        }
        ansObj.questionId = question.id
        ansObj.submissionId = submission?.id
        return ansObj
    }

    private fun updateSubmissionStatus(
        realm: Realm,
        submission: RealmSubmission?,
        index: Int,
        total: Int,
        type: String,
    ) {
        submission?.lastUpdateTime = Date().time
        val isFinal = index == total - 1
        submission?.status = when {
            isFinal && type == "survey" -> "complete"
            isFinal -> "requires grading"
            else -> "pending"
        }

        if (isFinal && type == "survey" && submission != null) {
            realm.where(RealmSubmission::class.java)
                .equalTo("userId", submission.userId)
                .equalTo("parentId", submission.parentId)
                .equalTo("status", "pending")
                .notEqualTo("id", submission.id)
                .findAll()
                .forEach { it.status = "complete" }
        }
    }

    private fun populateAnswer(
        answer: RealmAnswer, question: RealmExamQuestion, ans: String, listAns: Map<String, String>?,
        otherText: String?, otherVisible: Boolean,
    ) {
        when {
            question.type.equals("select", ignoreCase = true) -> {
                populateSelectAnswer(answer, question, ans, otherText, otherVisible)
            }
            question.type.equals("selectMultiple", ignoreCase = true) -> {
                populateMultipleSelectAnswer(answer, listAns, otherText, otherVisible)
            }
            else -> {
                val textValue = if (otherVisible && !otherText.isNullOrEmpty()) {
                    otherText
                } else {
                    ans
                }
                populateTextAnswer(answer, textValue)
            }
        }
    }

    private fun populateSelectAnswer(
        answer: RealmAnswer, question: RealmExamQuestion, ans: String, otherText: String?,
        otherVisible: Boolean,
    ) {
        if (otherVisible && !otherText.isNullOrEmpty()) {
            answer.value = otherText
            answer.valueChoices = RealmList<String>().apply {
                add("""{"id":"other","text":"$otherText"}""")
            }
        } else {
            val choiceText = ExamAnswerUtils.getChoiceTextById(question, ans)
            answer.value = choiceText
            answer.valueChoices = RealmList<String>().apply {
                if (ans.isNotEmpty()) {
                    add("""{"id":"$ans","text":"$choiceText"}""")
                }
            }
        }
    }

    private fun populateMultipleSelectAnswer(
        answer: RealmAnswer, listAns: Map<String, String>?, otherText: String?, otherVisible: Boolean
    ) {
        answer.value = ""
        answer.valueChoices = RealmList<String>().apply {
            listAns?.toMap()?.forEach { (text, id) ->
                if (id == "other" && otherVisible && !otherText.isNullOrEmpty()) {
                    add("""{"id":"other","text":"$otherText"}""")
                } else {
                    add("""{"id":"$id","text":"$text"}""")
                }
            }
        }
    }

    private fun populateTextAnswer(answer: RealmAnswer, ans: String) {
        answer.value = ans
        answer.valueChoices = null
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/exam/UserInformationFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.exam

import android.app.DatePickerDialog
import android.content.Context
import android.content.DialogInterface
import android.content.SharedPreferences
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.RadioButton
import androidx.appcompat.app.AppCompatActivity
import androidx.core.net.toUri
import androidx.core.view.isVisible
import androidx.lifecycle.lifecycleScope
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import java.util.Calendar
import java.util.Locale
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeoutOrNull
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseDialogFragment
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.databinding.FragmentUserInformationBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class UserInformationFragment : BaseDialogFragment(), View.OnClickListener {
    private lateinit var fragmentUserInformationBinding: FragmentUserInformationBinding
    var dob: String? = ""
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var submissionRepository: SubmissionRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    var userModel: RealmUserModel? = null
    var shouldHideElements: Boolean? = null
    @Inject
    lateinit var uploadManager: UploadManager

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        fragmentUserInformationBinding = FragmentUserInformationBinding.inflate(inflater, container, false)
        userModel = userProfileDbHandler.userModel
        shouldHideElements = arguments?.getBoolean("shouldHideElements") == true
        initViews()
        return fragmentUserInformationBinding.root
    }

    private fun initViews() {
        if (shouldHideElements == true) {
            fragmentUserInformationBinding.btnAdditionalFields.visibility = View.VISIBLE
            fragmentUserInformationBinding.btnAdditionalFields.setOnClickListener(this)
            fragmentUserInformationBinding.ltYob.visibility = View.VISIBLE
            fragmentUserInformationBinding.llNames.visibility = View.GONE
            fragmentUserInformationBinding.llEmailLang.visibility = View.GONE
            fragmentUserInformationBinding.llPhoneDob.visibility = View.GONE
            fragmentUserInformationBinding.llLevel.visibility = View.GONE
        } else {
            fragmentUserInformationBinding.btnAdditionalFields.visibility = View.GONE
            val langArray = resources.getStringArray(R.array.language)
            val levelArray = resources.getStringArray(R.array.level)
            val adapterLang = ArrayAdapter(requireContext(), R.layout.become_a_member_spinner_layout, langArray)
            val adapterLevel = ArrayAdapter(requireContext(), R.layout.become_a_member_spinner_layout, levelArray)
            adapterLang.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
            adapterLevel.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
            fragmentUserInformationBinding.spnLang.adapter = adapterLang
            fragmentUserInformationBinding.spnLevel.adapter = adapterLevel
        }
        fragmentUserInformationBinding.txtDob.setOnClickListener(this)
        fragmentUserInformationBinding.btnCancel.setOnClickListener(this)
        fragmentUserInformationBinding.btnSubmit.setOnClickListener(this)
    }

    override fun onClick(view: View) {
        when (view.id) {
            R.id.btn_cancel -> if (isAdded) {
                dialog?.dismiss()
            }
            R.id.btn_submit -> submitForm()
            R.id.txt_dob -> showDatePickerDialog()
            R.id.btnAdditionalFields -> toggleAdditionalFields()
        }
    }

    private fun toggleAdditionalFields() {
        val isAdditionalFieldsVisible = fragmentUserInformationBinding.llNames.isVisible
        if (isAdditionalFieldsVisible) {
            fragmentUserInformationBinding.etFname.setText("")
            fragmentUserInformationBinding.etLname.setText("")
            fragmentUserInformationBinding.etMname.setText("")
            fragmentUserInformationBinding.etPhone.setText("")
            fragmentUserInformationBinding.etEmail.setText("")
            fragmentUserInformationBinding.txtDob.text = getString(R.string.birth_date)
        } else {
            fragmentUserInformationBinding.etYob.setText("")
            fragmentUserInformationBinding.etYob.error = null
        }

        fragmentUserInformationBinding.btnAdditionalFields.text = if (isAdditionalFieldsVisible) getString(R.string.show_additional_fields) else getString(R.string.hide_additional_fields)
        fragmentUserInformationBinding.llNames.visibility = if (isAdditionalFieldsVisible) View.GONE else View.VISIBLE
        fragmentUserInformationBinding.llEmailLang.visibility = if (isAdditionalFieldsVisible) View.GONE else View.VISIBLE
        fragmentUserInformationBinding.llPhoneDob.visibility = if (isAdditionalFieldsVisible) View.GONE else View.VISIBLE
        fragmentUserInformationBinding.llLevel.visibility = if (isAdditionalFieldsVisible) View.GONE else View.VISIBLE
        fragmentUserInformationBinding.ltYob.visibility = if (isAdditionalFieldsVisible) View.VISIBLE else View.GONE
    }

    private fun submitForm() {
        var fname = ""
        var lname = ""
        var mName = ""
        var yob = ""
        var calculatedAge = 0

        if (fragmentUserInformationBinding.llNames.isVisible) {
            fname = "${fragmentUserInformationBinding.etFname.text}".trim()
            lname = "${fragmentUserInformationBinding.etLname.text}".trim()
            mName = "${fragmentUserInformationBinding.etMname.text}".trim()
        }

        val user = JsonObject()

        if (fragmentUserInformationBinding.ltYob.isVisible) {
            yob = "${fragmentUserInformationBinding.etYob.text}".trim()

            if (yob.isEmpty()) {
                fragmentUserInformationBinding.etYob.error =
                    getString(R.string.year_of_birth_cannot_be_empty)
                return
            }

            val yobInt = yob.toIntOrNull()
            if (yobInt == null) {
                fragmentUserInformationBinding.etYob.error =
                    getString(R.string.please_enter_a_valid_year_of_birth)
                return
            }

            val currentYear = Calendar.getInstance().get(Calendar.YEAR)
            if (yobInt < 1900 || yobInt > currentYear) {
                fragmentUserInformationBinding.etYob.error =
                    getString(R.string.please_enter_a_valid_year_between_1900_and, currentYear)
                return
            }

            calculatedAge = currentYear - yobInt
        }

        if (fname.isNotEmpty()) user.addProperty("firstName", fname)
        if (mName.isNotEmpty()) user.addProperty("middleName", mName)
        if (lname.isNotEmpty()) user.addProperty("lastName", lname)

        if (fragmentUserInformationBinding.llEmailLang.isVisible) {
            val email = fragmentUserInformationBinding.etEmail.text.toString().trim()
            val lang = fragmentUserInformationBinding.spnLang.selectedItem.toString()
            if (email.isNotEmpty()) user.addProperty("email", email)
            if (lang.isNotEmpty()) user.addProperty("language", lang)
        }

        if (fragmentUserInformationBinding.llPhoneDob.isVisible) {
            val phone = fragmentUserInformationBinding.etPhone.text.toString().trim()
            if (phone.isNotEmpty()) user.addProperty("phoneNumber", phone)

            if (!dob.isNullOrEmpty()) {
                val birthDateISO = TimeUtils.convertToISO8601(dob!!)
                user.addProperty("birthDate", birthDateISO)
            }
        }

        if (yob.isNotEmpty()) user.addProperty("age", calculatedAge.toString())

        if (fragmentUserInformationBinding.llLevel.isVisible) {
            val level = fragmentUserInformationBinding.spnLevel.selectedItem.toString()
            if (level.isNotEmpty()) user.addProperty("level", level)
        }

        if (fragmentUserInformationBinding.rbGender.isVisible) {
            val rbSelected = requireView().findViewById<RadioButton>(fragmentUserInformationBinding.rbGender.checkedRadioButtonId)
            if (rbSelected != null) {
                val gender = rbSelected.tag.toString()
                if (gender.isNotEmpty()) user.addProperty("gender", gender)
            }
        }

        user.addProperty("betaEnabled", false)

        val teamId = arguments?.getString("teamId")

        if (!teamId.isNullOrEmpty()) {
            saveSubmission(user)
        } else if (TextUtils.isEmpty(id)) {
            val userId = userModel?.id
            viewLifecycleOwner.lifecycleScope.launch {
                try {
                    databaseService.executeTransactionAsync { realm ->
                        val model = realm.where(RealmUserModel::class.java).equalTo("id", userId).findFirst()
                        if (model != null) {
                            user.keySet().forEach { key ->
                                when (key) {
                                    "firstName" -> model.firstName = user.get(key).asString
                                    "lastName" -> model.lastName = user.get(key).asString
                                    "middleName" -> model.middleName = user.get(key).asString
                                    "email" -> model.email = user.get(key).asString
                                    "language" -> model.language = user.get(key).asString
                                    "phoneNumber" -> model.phoneNumber = user.get(key).asString
                                    "birthDate" -> model.birthPlace = user.get(key).asString
                                    "level" -> model.level = user.get(key).asString
                                    "gender" -> model.gender = user.get(key).asString
                                    "age" -> model.age = user.get(key).asString
                                }
                            }
                            model.isUpdated = true
                        }
                    }
                    Utilities.toast(MainApplication.context, getString(R.string.user_profile_updated))
                    if (isAdded) dialog?.dismiss()
                } catch (_: Exception) {
                    Utilities.toast(MainApplication.context, getString(R.string.unable_to_update_user))
                    if (isAdded) dialog?.dismiss()
                }
            }
        } else {
            saveSubmission(user)
        }
    }

    private fun saveSubmission(user: JsonObject) {
        viewLifecycleOwner.lifecycleScope.launch {
            try {
                if (id.isNullOrEmpty()) {
                    Utilities.toast(MainApplication.context, "Error: Unable to save submission - no ID provided")
                    if (isAdded) dialog?.dismiss()
                    return@launch
                }

                databaseService.executeTransactionAsync { realm ->
                    val sub = realm.where(RealmSubmission::class.java)
                        .equalTo("id", id)
                        .findFirst()

                    if (sub != null) {
                        sub.user = user.toString()
                        sub.status = "complete"
                    } else {
                        throw IllegalStateException("Submission not found with id: $id")
                    }
                }

                withContext(Dispatchers.Main) {
                    Utilities.toast(MainApplication.context, getString(R.string.thank_you_for_taking_this_survey))
                    if (isAdded) {
                        dialog?.dismiss()
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
                withContext(Dispatchers.Main) {
                    Utilities.toast(MainApplication.context, "Error saving submission: ${e.message}")
                    if (isAdded) {
                        dialog?.dismiss()
                    }
                }
            }
        }
    }

    override fun onDismiss(dialog: DialogInterface) {
        super.onDismiss(dialog)
        val safeTeamId = arguments?.getString("teamId") ?: ""
        if (safeTeamId == "") {
            return
        } else {
            Utilities.toast(activity, getString(R.string.thank_you_for_taking_this_survey))
            val settings = MainApplication.context.getSharedPreferences(Constants.PREFS_NAME, Context.MODE_PRIVATE)
            checkAvailableServer(settings)
            val activity = requireActivity()
            if (activity is AppCompatActivity) {
                NavigationHelper.popBackStack(activity.supportFragmentManager)
            }
        }
    }

    private fun checkAvailableServer(settings: SharedPreferences) {
        val updateUrl = "${settings.getString("serverURL", "")}"
        val serverUrlMapper = ServerUrlMapper()
        val mapping = serverUrlMapper.processUrl(updateUrl)

        viewLifecycleOwner.lifecycleScope.launch {
            try {
                val primaryAvailable = withTimeoutOrNull(15000) {
                    MainApplication.isServerReachable(mapping.primaryUrl)
                } ?: false

                val alternativeAvailable = withTimeoutOrNull(15000) {
                    mapping.alternativeUrl?.let { MainApplication.isServerReachable(it) } == true
                } ?: false

                if (!primaryAvailable && alternativeAvailable) {
                    mapping.alternativeUrl?.let { alternativeUrl ->
                        val uri = updateUrl.toUri()
                        val editor = settings.edit()

                        serverUrlMapper.updateUrlPreferences(editor, uri, alternativeUrl, mapping.primaryUrl, settings)
                    }
                }

                uploadSubmissions()
            } catch (e: Exception) {
                uploadSubmissions()
            }
        }
    }

    private fun uploadSubmissions() {
        MainApplication.applicationScope.launch {
            try {
                withContext(Dispatchers.IO) {
                    uploadManager.uploadSubmissions()
                    uploadExamResultWrapper()
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    private fun uploadExamResultWrapper() {
        val successListener = object : SuccessListener {
            override fun onSuccess(success: String?) {
            }
        }

        uploadManager.uploadExamResult(successListener)
    }

    private fun showDatePickerDialog() {
        val now = Calendar.getInstance()
        val dpd = DatePickerDialog(
            requireContext(), { _, i, i1, i2 ->
                dob = String.format(Locale.US, "%04d-%02d-%02d", i, i1 + 1, i2)
                fragmentUserInformationBinding.txtDob.text = dob
            }, now[Calendar.YEAR], now[Calendar.MONTH], now[Calendar.DAY_OF_MONTH]
        )
        dpd.setTitle(getString(R.string.select_date_of_birth))
        dpd.datePicker.maxDate = now.timeInMillis
        dpd.show()
    }

    override val key: String
        get() = "sub_id"

    companion object {
        fun getInstance(id: String?, teamId: String?, shouldHideElements: Boolean): UserInformationFragment {
            val f = UserInformationFragment()
            setArgs(f, id, teamId, shouldHideElements)
            return f
        }

        private fun setArgs(f: UserInformationFragment, id: String?, teamId: String?, shouldHideElements: Boolean) {
            val b = Bundle()
            b.putString("sub_id", id)
            b.putString("teamId", teamId)
            b.putBoolean("shouldHideElements", shouldHideElements)
            f.arguments = b
        }
    }
}
=======
package org.ole.planet.myplanet.ui.exam


import android.app.DatePickerDialog
import android.content.Context
import android.content.DialogInterface
import android.content.SharedPreferences
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.RadioButton
import androidx.appcompat.app.AppCompatActivity
import androidx.core.net.toUri
import androidx.core.view.isVisible
import androidx.lifecycle.lifecycleScope
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import java.util.Calendar
import java.util.Locale
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeoutOrNull
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseDialogFragment
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.databinding.FragmentUserInformationBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class UserInformationFragment : BaseDialogFragment(), View.OnClickListener {
    private lateinit var fragmentUserInformationBinding: FragmentUserInformationBinding
    var dob: String? = ""
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var submissionRepository: SubmissionRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    var userModel: RealmUserModel? = null
    var shouldHideElements: Boolean? = null
    @Inject
    lateinit var uploadManager: UploadManager

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        fragmentUserInformationBinding = FragmentUserInformationBinding.inflate(inflater, container, false)
        userModel = userProfileDbHandler.userModel
        shouldHideElements = arguments?.getBoolean("shouldHideElements") == true
        initViews()
        return fragmentUserInformationBinding.root
    }

    private fun initViews() {
        if (shouldHideElements == true) {
            fragmentUserInformationBinding.btnAdditionalFields.visibility = View.VISIBLE
            fragmentUserInformationBinding.btnAdditionalFields.setOnClickListener(this)
            fragmentUserInformationBinding.ltYob.visibility = View.VISIBLE
            fragmentUserInformationBinding.llNames.visibility = View.GONE
            fragmentUserInformationBinding.llEmailLang.visibility = View.GONE
            fragmentUserInformationBinding.llPhoneDob.visibility = View.GONE
            fragmentUserInformationBinding.llLevel.visibility = View.GONE
        } else {
            fragmentUserInformationBinding.btnAdditionalFields.visibility = View.GONE
            val langArray = resources.getStringArray(R.array.language)
            val levelArray = resources.getStringArray(R.array.level)
            val adapterLang = ArrayAdapter(requireContext(), R.layout.become_a_member_spinner_layout, langArray)
            val adapterLevel = ArrayAdapter(requireContext(), R.layout.become_a_member_spinner_layout, levelArray)
            adapterLang.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
            adapterLevel.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
            fragmentUserInformationBinding.spnLang.adapter = adapterLang
            fragmentUserInformationBinding.spnLevel.adapter = adapterLevel
        }
        fragmentUserInformationBinding.txtDob.setOnClickListener(this)
        fragmentUserInformationBinding.btnCancel.setOnClickListener(this)
        fragmentUserInformationBinding.btnSubmit.setOnClickListener(this)
    }

    override fun onClick(view: View) {
        when (view.id) {
            R.id.btn_cancel -> if (isAdded) {
                dialog?.dismiss()
            }
            R.id.btn_submit -> submitForm()
            R.id.txt_dob -> showDatePickerDialog()
            R.id.btnAdditionalFields -> toggleAdditionalFields()
        }
    }

    private fun toggleAdditionalFields() {
        val isAdditionalFieldsVisible = fragmentUserInformationBinding.llNames.isVisible
        if (isAdditionalFieldsVisible) {
            fragmentUserInformationBinding.etFname.setText("")
            fragmentUserInformationBinding.etLname.setText("")
            fragmentUserInformationBinding.etMname.setText("")
            fragmentUserInformationBinding.etPhone.setText("")
            fragmentUserInformationBinding.etEmail.setText("")
            fragmentUserInformationBinding.txtDob.text = getString(R.string.birth_date)
        } else {
            fragmentUserInformationBinding.etYob.setText("")
            fragmentUserInformationBinding.etYob.error = null
        }

        fragmentUserInformationBinding.btnAdditionalFields.text = if (isAdditionalFieldsVisible) getString(R.string.show_additional_fields) else getString(R.string.hide_additional_fields)
        fragmentUserInformationBinding.llNames.visibility = if (isAdditionalFieldsVisible) View.GONE else View.VISIBLE
        fragmentUserInformationBinding.llEmailLang.visibility = if (isAdditionalFieldsVisible) View.GONE else View.VISIBLE
        fragmentUserInformationBinding.llPhoneDob.visibility = if (isAdditionalFieldsVisible) View.GONE else View.VISIBLE
        fragmentUserInformationBinding.llLevel.visibility = if (isAdditionalFieldsVisible) View.GONE else View.VISIBLE
        fragmentUserInformationBinding.ltYob.visibility = if (isAdditionalFieldsVisible) View.VISIBLE else View.GONE
    }

    private fun submitForm() {
        var fname = ""
        var lname = ""
        var mName = ""
        var yob = ""
        var calculatedAge = 0

        if (fragmentUserInformationBinding.llNames.isVisible) {
            fname = "${fragmentUserInformationBinding.etFname.text}".trim()
            lname = "${fragmentUserInformationBinding.etLname.text}".trim()
            mName = "${fragmentUserInformationBinding.etMname.text}".trim()
        }

        val user = JsonObject()

        if (fragmentUserInformationBinding.ltYob.isVisible) {
            yob = "${fragmentUserInformationBinding.etYob.text}".trim()

            if (yob.isEmpty()) {
                fragmentUserInformationBinding.etYob.error =
                    getString(R.string.year_of_birth_cannot_be_empty)
                return
            }

            val yobInt = yob.toIntOrNull()
            if (yobInt == null) {
                fragmentUserInformationBinding.etYob.error =
                    getString(R.string.please_enter_a_valid_year_of_birth)
                return
            }

            val currentYear = Calendar.getInstance().get(Calendar.YEAR)
            if (yobInt < 1900 || yobInt > currentYear) {
                fragmentUserInformationBinding.etYob.error =
                    getString(R.string.please_enter_a_valid_year_between_1900_and, currentYear)
                return
            }

            calculatedAge = currentYear - yobInt
        }

        if (fname.isNotEmpty()) user.addProperty("firstName", fname)
        if (mName.isNotEmpty()) user.addProperty("middleName", mName)
        if (lname.isNotEmpty()) user.addProperty("lastName", lname)

        if (fragmentUserInformationBinding.llEmailLang.isVisible) {
            val email = fragmentUserInformationBinding.etEmail.text.toString().trim()
            val lang = fragmentUserInformationBinding.spnLang.selectedItem.toString()
            if (email.isNotEmpty()) user.addProperty("email", email)
            if (lang.isNotEmpty()) user.addProperty("language", lang)
        }

        if (fragmentUserInformationBinding.llPhoneDob.isVisible) {
            val phone = fragmentUserInformationBinding.etPhone.text.toString().trim()
            if (phone.isNotEmpty()) user.addProperty("phoneNumber", phone)

            if (!dob.isNullOrEmpty()) {
                val birthDateISO = TimeUtils.convertToISO8601(dob!!)
                user.addProperty("birthDate", birthDateISO)
            }
        }

        if (yob.isNotEmpty()) user.addProperty("age", calculatedAge.toString())

        if (fragmentUserInformationBinding.llLevel.isVisible) {
            val level = fragmentUserInformationBinding.spnLevel.selectedItem.toString()
            if (level.isNotEmpty()) user.addProperty("level", level)
        }

        if (fragmentUserInformationBinding.rbGender.isVisible) {
            val rbSelected = requireView().findViewById<RadioButton>(fragmentUserInformationBinding.rbGender.checkedRadioButtonId)
            if (rbSelected != null) {
                val gender = rbSelected.tag.toString()
                if (gender.isNotEmpty()) user.addProperty("gender", gender)
            }
        }

        user.addProperty("betaEnabled", false)

        val teamId = arguments?.getString("teamId")

        if (!teamId.isNullOrEmpty()) {
            saveSubmission(user)
        } else if (TextUtils.isEmpty(id)) {
            val userId = userModel?.id
            viewLifecycleOwner.lifecycleScope.launch {
                try {
                    databaseService.executeTransactionAsync { realm ->
                        val model = realm.where(RealmUserModel::class.java).equalTo("id", userId).findFirst()
                        if (model != null) {
                            user.keySet().forEach { key ->
                                when (key) {
                                    "firstName" -> model.firstName = user.get(key).asString
                                    "lastName" -> model.lastName = user.get(key).asString
                                    "middleName" -> model.middleName = user.get(key).asString
                                    "email" -> model.email = user.get(key).asString
                                    "language" -> model.language = user.get(key).asString
                                    "phoneNumber" -> model.phoneNumber = user.get(key).asString
                                    "birthDate" -> model.birthPlace = user.get(key).asString
                                    "level" -> model.level = user.get(key).asString
                                    "gender" -> model.gender = user.get(key).asString
                                    "age" -> model.age = user.get(key).asString
                                }
                            }
                            model.isUpdated = true
                        }
                    }
                    Utilities.toast(MainApplication.context, getString(R.string.user_profile_updated))
                    if (isAdded) dialog?.dismiss()
                } catch (_: Exception) {
                    Utilities.toast(MainApplication.context, getString(R.string.unable_to_update_user))
                    if (isAdded) dialog?.dismiss()
                }
            }
        } else {
            saveSubmission(user)
        }
    }

    private fun saveSubmission(user: JsonObject) {
        viewLifecycleOwner.lifecycleScope.launch {
            try {
                if (id.isNullOrEmpty()) {
                    Utilities.toast(MainApplication.context, "Error: Unable to save submission - no ID provided")
                    if (isAdded) dialog?.dismiss()
                    return@launch
                }

                databaseService.executeTransactionAsync { realm ->
                    val sub = realm.where(RealmSubmission::class.java)
                        .equalTo("id", id)
                        .findFirst()

                    if (sub != null) {
                        sub.user = user.toString()
                        sub.status = "complete"
                    } else {
                        throw IllegalStateException("Submission not found with id: $id")
                    }
                }

                withContext(Dispatchers.Main) {
                    Utilities.toast(MainApplication.context, getString(R.string.thank_you_for_taking_this_survey))
                    if (isAdded) {
                        dialog?.dismiss()
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
                withContext(Dispatchers.Main) {
                    Utilities.toast(MainApplication.context, "Error saving submission: ${e.message}")
                    if (isAdded) {
                        dialog?.dismiss()
                    }
                }
            }
        }
    }

    override fun onDismiss(dialog: DialogInterface) {
        super.onDismiss(dialog)
        val safeTeamId = arguments?.getString("teamId") ?: ""
        if (safeTeamId == "") {
            return
        } else {
            Utilities.toast(activity, getString(R.string.thank_you_for_taking_this_survey))
            val settings = MainApplication.context.getSharedPreferences(Constants.PREFS_NAME, Context.MODE_PRIVATE)
            checkAvailableServer(settings)
            val activity = requireActivity()
            if (activity is AppCompatActivity) {
                NavigationHelper.popBackStack(activity.supportFragmentManager)
            }
        }
    }

    private fun checkAvailableServer(settings: SharedPreferences) {
        val updateUrl = "${settings.getString("serverURL", "")}"
        val serverUrlMapper = ServerUrlMapper()
        val mapping = serverUrlMapper.processUrl(updateUrl)

        viewLifecycleOwner.lifecycleScope.launch {
            try {
                val primaryAvailable = withTimeoutOrNull(15000) {
                    MainApplication.isServerReachable(mapping.primaryUrl)
                } ?: false

                val alternativeAvailable = withTimeoutOrNull(15000) {
                    mapping.alternativeUrl?.let { MainApplication.isServerReachable(it) } == true
                } ?: false

                if (!primaryAvailable && alternativeAvailable) {
                    mapping.alternativeUrl?.let { alternativeUrl ->
                        val uri = updateUrl.toUri()
                        val editor = settings.edit()

                        serverUrlMapper.updateUrlPreferences(editor, uri, alternativeUrl, mapping.primaryUrl, settings)
                    }
                }

                uploadSubmissions()
            } catch (e: Exception) {
                uploadSubmissions()
            }
        }
    }

    private fun uploadSubmissions() {
        MainApplication.applicationScope.launch {
            try {
                withContext(Dispatchers.IO) {
                    uploadManager.uploadSubmissions()
                    uploadExamResultWrapper()
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    private fun uploadExamResultWrapper() {
        val successListener = object : SuccessListener {
            override fun onSuccess(success: String?) {
            }
        }

        uploadManager.uploadExamResult(successListener)
    }

    private fun showDatePickerDialog() {
        val now = Calendar.getInstance()
        val dpd = DatePickerDialog(
            requireContext(), { _, i, i1, i2 ->
                dob = String.format(Locale.US, "%04d-%02d-%02d", i, i1 + 1, i2)
                fragmentUserInformationBinding.txtDob.text = dob
            }, now[Calendar.YEAR], now[Calendar.MONTH], now[Calendar.DAY_OF_MONTH]
        )
        dpd.setTitle(getString(R.string.select_date_of_birth))
        dpd.datePicker.maxDate = now.timeInMillis
        dpd.show()
    }

    override val key: String
        get() = "sub_id"

    companion object {
        fun getInstance(id: String?, teamId: String?, shouldHideElements: Boolean): UserInformationFragment {
            val f = UserInformationFragment()
            setArgs(f, id, teamId, shouldHideElements)
            return f
        }

        private fun setArgs(f: UserInformationFragment, id: String?, teamId: String?, shouldHideElements: Boolean) {
            val b = Bundle()
            b.putString("sub_id", id)
            b.putString("teamId", teamId)
            b.putBoolean("shouldHideElements", shouldHideElements)
            f.arguments = b
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/exam/BaseExamFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.exam

import android.content.DialogInterface
import android.graphics.Typeface
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.Gravity
import android.view.View
import android.widget.EditText
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import io.noties.markwon.Markwon
import io.noties.markwon.editor.MarkwonEditor
import io.noties.markwon.editor.MarkwonEditorTextWatcher
import io.realm.Realm
import io.realm.RealmResults
import java.util.Date
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmitPhotos
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.survey.SurveyFragment
import org.ole.planet.myplanet.utilities.CameraUtils.ImageCaptureCallback
import org.ole.planet.myplanet.utilities.NetworkUtils.getUniqueIdentifier
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
abstract class BaseExamFragment : Fragment(), ImageCaptureCallback {
    var exam: RealmStepExam? = null
    @Inject
    lateinit var databaseService: DatabaseService
    lateinit var mRealm: Realm
    var stepId: String? = null
    var id: String? = ""
    var type: String? = "exam"
    var currentIndex = 0
    private var stepNumber = 0
    var questions: RealmResults<RealmExamQuestion>? = null
    var ans = ""
    var user: RealmUserModel? = null
    var sub: RealmSubmission? = null
    var listAns: HashMap<String, String>? = null
    var isMySurvey = false
    private var uniqueId = getUniqueIdentifier()
    var date = Date().toString()
    private var photoPath: String? = ""
    var submitId = ""
    var isTeam: Boolean = false
    var teamId: String? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        mRealm = databaseService.realmInstance
        if (arguments != null) {
            stepId = requireArguments().getString("stepId")
            stepNumber = requireArguments().getInt("stepNum")
            isMySurvey = requireArguments().getBoolean("isMySurvey")
            isTeam = requireArguments().getBoolean("isTeam", false)
            teamId = requireArguments().getString("teamId")
            checkId()
            checkType()
        }
    }

    private fun checkId() {
        if (TextUtils.isEmpty(stepId)) {
            id = requireArguments().getString("id")
            if (isMySurvey) {
                sub = mRealm.where(RealmSubmission::class.java).equalTo("id", id).findFirst()
                id = if (sub?.parentId?.contains("@") == true) {
                    sub?.parentId?.split("@".toRegex())?.dropLastWhile { it.isEmpty() }?.toTypedArray()?.get(0)
                } else {
                    sub?.parentId
                }
            }
        }
    }

    private fun checkType() {
        if (requireArguments().containsKey("type")) {
            type = requireArguments().getString("type")
        }
    }

    fun initExam() {
        exam = if (!TextUtils.isEmpty(stepId)) {
            mRealm.where(RealmStepExam::class.java).equalTo("stepId", stepId).findFirst()
        } else {
            mRealm.where(RealmStepExam::class.java).equalTo("id", id).findFirst()
        }
    }

    var isLastAnsvalid = false
    fun checkAnsAndContinue(cont: Boolean) {
        if (cont) {
            isLastAnsvalid = true
            currentIndex += 1
            continueExam()
        } else {
            isLastAnsvalid = false
            val toast = Toast.makeText(activity, getString(R.string.incorrect_ans), Toast.LENGTH_SHORT)
            toast.show()
            viewLifecycleOwner.lifecycleScope.launch {
                delay(1000)
                toast.cancel()
            }
        }
    }

    private fun continueExam() {
        if (currentIndex < (questions?.size ?: 0)) {
            startExam(questions?.get(currentIndex))
        } else if (isTeam == true && type?.startsWith("survey") == true) {
            showUserInfoDialog()
        } else {
            saveCourseProgress()
            val titleView = TextView(requireContext()).apply {
                text = "${getString(R.string.thank_you_for_taking_this)}$type! ${getString(R.string.we_wish_you_all_the_best)}"
                textSize = 18f
                setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
                setTypeface(null, Typeface.BOLD)
                gravity = Gravity.CENTER
                setPadding(20, 25, 20, 0)
            }

            AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
                .setCustomTitle(titleView)
                .setPositiveButton(getString(R.string.finish)) { _: DialogInterface?, _: Int ->
                    NavigationHelper.popBackStack(parentFragmentManager)
                }.setCancelable(false).show()
        }
    }

    private fun saveCourseProgress() {
        val progress = mRealm.where(RealmCourseProgress::class.java)
            .equalTo("courseId", exam?.courseId)
            .equalTo("stepNum", stepNumber).findFirst()
        if (progress != null) {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            progress.passed = sub?.status == "graded"
            mRealm.commitTransaction()
        }
    }

    private fun showUserInfoDialog() {
        if (!isMySurvey && exam?.isFromNation != true) {
            UserInformationFragment.getInstance(sub?.id, teamId, exam?.isFromNation != true).show(childFragmentManager, "")
        } else {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            sub?.status = "complete"
            mRealm.commitTransaction()
            Utilities.toast(activity, getString(R.string.thank_you_for_taking_this_survey))
            navigateToSurveyList(requireActivity())
        }
    }

    companion object {
        fun navigateToSurveyList(activity: FragmentActivity) {
            val surveyListFragment = SurveyFragment()
            NavigationHelper.replaceFragment(
                activity.supportFragmentManager,
                R.id.fragment_container,
                surveyListFragment
            )
        }
    }
    abstract fun startExam(question: RealmExamQuestion?)
    private fun insertIntoSubmitPhotos(submitId: String?) {
        mRealm.beginTransaction()
        val submit = mRealm.createObject(RealmSubmitPhotos::class.java, UUID.randomUUID().toString())
        submit.submissionId = submitId
        submit.examId = exam?.id
        submit.courseId = exam?.courseId
        submit.memberId = user?.id
        submit.date = date
        submit.uniqueId = uniqueId
        submit.photoLocation = photoPath
        submit.uploaded = false
        mRealm.commitTransaction()
    }

    override fun onImageCapture(fileUri: String?) {
        photoPath = fileUri
        insertIntoSubmitPhotos(submitId)
    }

    fun setMarkdownViewAndShowInput(etAnswer: EditText, type: String, oldAnswer: String?) {
        etAnswer.visibility = View.VISIBLE
        val markwon = Markwon.create(requireActivity())
        val editor = MarkwonEditor.create(markwon)
        if (type.equals("textarea", ignoreCase = true)) {
            etAnswer.addTextChangedListener(MarkwonEditorTextWatcher.withProcess(editor))
        } else {
            etAnswer.addTextChangedListener(object : TextWatcher {
                override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
                override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
                override fun afterTextChanged(editable: Editable) {}
            })
        }
        etAnswer.setText(oldAnswer)
    }

    override fun onDestroy() {
        if (::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        super.onDestroy()
    }
}
=======
package org.ole.planet.myplanet.ui.exam


import android.content.DialogInterface
import android.graphics.Typeface
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.Gravity
import android.view.View
import android.widget.EditText
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import io.noties.markwon.Markwon
import io.noties.markwon.editor.MarkwonEditor
import io.noties.markwon.editor.MarkwonEditorTextWatcher
import io.realm.Realm
import io.realm.RealmResults
import java.util.Date
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmitPhotos
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.survey.SurveyFragment
import org.ole.planet.myplanet.utilities.CameraUtils.ImageCaptureCallback
import org.ole.planet.myplanet.utilities.NetworkUtils.getUniqueIdentifier
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
abstract class BaseExamFragment : Fragment(), ImageCaptureCallback {
    var exam: RealmStepExam? = null
    @Inject
    lateinit var databaseService: DatabaseService
    lateinit var mRealm: Realm
    var stepId: String? = null
    var id: String? = ""
    var type: String? = "exam"
    var currentIndex = 0
    private var stepNumber = 0
    var questions: RealmResults<RealmExamQuestion>? = null
    var ans = ""
    var user: RealmUserModel? = null
    var sub: RealmSubmission? = null
    var listAns: HashMap<String, String>? = null
    var isMySurvey = false
    private var uniqueId = getUniqueIdentifier()
    var date = Date().toString()
    private var photoPath: String? = ""
    var submitId = ""
    var isTeam: Boolean = false
    var teamId: String? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        mRealm = databaseService.realmInstance
        if (arguments != null) {
            stepId = requireArguments().getString("stepId")
            stepNumber = requireArguments().getInt("stepNum")
            isMySurvey = requireArguments().getBoolean("isMySurvey")
            isTeam = requireArguments().getBoolean("isTeam", false)
            teamId = requireArguments().getString("teamId")
            checkId()
            checkType()
        }
    }

    private fun checkId() {
        if (TextUtils.isEmpty(stepId)) {
            id = requireArguments().getString("id")
            if (isMySurvey) {
                sub = mRealm.where(RealmSubmission::class.java).equalTo("id", id).findFirst()
                id = if (sub?.parentId?.contains("@") == true) {
                    sub?.parentId?.split("@".toRegex())?.dropLastWhile { it.isEmpty() }?.toTypedArray()?.get(0)
                } else {
                    sub?.parentId
                }
            }
        }
    }

    private fun checkType() {
        if (requireArguments().containsKey("type")) {
            type = requireArguments().getString("type")
        }
    }

    fun initExam() {
        exam = if (!TextUtils.isEmpty(stepId)) {
            mRealm.where(RealmStepExam::class.java).equalTo("stepId", stepId).findFirst()
        } else {
            mRealm.where(RealmStepExam::class.java).equalTo("id", id).findFirst()
        }
    }

    var isLastAnsvalid = false
    fun checkAnsAndContinue(cont: Boolean) {
        if (cont) {
            isLastAnsvalid = true
            currentIndex += 1
            continueExam()
        } else {
            isLastAnsvalid = false
            val toast = Toast.makeText(activity, getString(R.string.incorrect_ans), Toast.LENGTH_SHORT)
            toast.show()
            viewLifecycleOwner.lifecycleScope.launch {
                delay(1000)
                toast.cancel()
            }
        }
    }

    private fun continueExam() {
        if (currentIndex < (questions?.size ?: 0)) {
            startExam(questions?.get(currentIndex))
        } else if (isTeam == true && type?.startsWith("survey") == true) {
            showUserInfoDialog()
        } else {
            saveCourseProgress()
            val titleView = TextView(requireContext()).apply {
                text = "${getString(R.string.thank_you_for_taking_this)}$type! ${getString(R.string.we_wish_you_all_the_best)}"
                textSize = 18f
                setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
                setTypeface(null, Typeface.BOLD)
                gravity = Gravity.CENTER
                setPadding(20, 25, 20, 0)
            }

            AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
                .setCustomTitle(titleView)
                .setPositiveButton(getString(R.string.finish)) { _: DialogInterface?, _: Int ->
                    NavigationHelper.popBackStack(parentFragmentManager)
                }.setCancelable(false).show()
        }
    }

    private fun saveCourseProgress() {
        val progress = mRealm.where(RealmCourseProgress::class.java)
            .equalTo("courseId", exam?.courseId)
            .equalTo("stepNum", stepNumber).findFirst()
        if (progress != null) {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            progress.passed = sub?.status == "graded"
            mRealm.commitTransaction()
        }
    }

    private fun showUserInfoDialog() {
        if (!isMySurvey && exam?.isFromNation != true) {
            UserInformationFragment.getInstance(sub?.id, teamId, exam?.isFromNation != true).show(childFragmentManager, "")
        } else {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            sub?.status = "complete"
            mRealm.commitTransaction()
            Utilities.toast(activity, getString(R.string.thank_you_for_taking_this_survey))
            navigateToSurveyList(requireActivity())
        }
    }

    companion object {
        fun navigateToSurveyList(activity: FragmentActivity) {
            val surveyListFragment = SurveyFragment()
            NavigationHelper.replaceFragment(
                activity.supportFragmentManager,
                R.id.fragment_container,
                surveyListFragment
            )
        }
    }
    abstract fun startExam(question: RealmExamQuestion?)
    private fun insertIntoSubmitPhotos(submitId: String?) {
        mRealm.beginTransaction()
        val submit = mRealm.createObject(RealmSubmitPhotos::class.java, UUID.randomUUID().toString())
        submit.submissionId = submitId
        submit.examId = exam?.id
        submit.courseId = exam?.courseId
        submit.memberId = user?.id
        submit.date = date
        submit.uniqueId = uniqueId
        submit.photoLocation = photoPath
        submit.uploaded = false
        mRealm.commitTransaction()
    }

    override fun onImageCapture(fileUri: String?) {
        photoPath = fileUri
        insertIntoSubmitPhotos(submitId)
    }

    fun setMarkdownViewAndShowInput(etAnswer: EditText, type: String, oldAnswer: String?) {
        etAnswer.visibility = View.VISIBLE
        val markwon = Markwon.create(requireActivity())
        val editor = MarkwonEditor.create(markwon)
        if (type.equals("textarea", ignoreCase = true)) {
            etAnswer.addTextChangedListener(MarkwonEditorTextWatcher.withProcess(editor))
        } else {
            etAnswer.addTextChangedListener(object : TextWatcher {
                override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
                override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
                override fun afterTextChanged(editable: Editable) {}
            })
        }
        etAnswer.setText(oldAnswer)
    }

    override fun onDestroy() {
        if (::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        super.onDestroy()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/exam/TakeExamFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.exam

import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.CompoundButton
import android.widget.RadioButton
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.core.view.isVisible
import androidx.lifecycle.lifecycleScope
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmQuery
import io.realm.Sort
import java.util.Date
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentTakeExamBinding
import org.ole.planet.myplanet.model.RealmCertification.Companion.isCourseCertified
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmMembershipDoc
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmission.Companion.createSubmission
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.CameraUtils.ImageCaptureCallback
import org.ole.planet.myplanet.utilities.CameraUtils.capturePhoto
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.JsonUtils.getStringAsJsonArray
import org.ole.planet.myplanet.utilities.KeyboardUtils.hideSoftKeyboard
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText
import org.ole.planet.myplanet.utilities.Utilities.toast

@AndroidEntryPoint
class TakeExamFragment : BaseExamFragment(), View.OnClickListener, CompoundButton.OnCheckedChangeListener, ImageCaptureCallback {
    private var _binding: FragmentTakeExamBinding? = null
    private val binding get() = _binding!!
    private var isCertified = false
    private val gson = Gson()

    private val answerCache = mutableMapOf<String, AnswerData>()

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    data class AnswerData(
        var singleAnswer: String = "",
        var multipleAnswers: HashMap<String, String> = HashMap(),
        var otherText: String = ""
    )

    override fun onCreateView(inflater: LayoutInflater, parent: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTakeExamBinding.inflate(inflater, parent, false)
        listAns = HashMap()
        user = userProfileDbHandler.userModel
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        initExam()
        questions = mRealm.where(RealmExamQuestion::class.java).equalTo("examId", exam?.id).findAll()
        binding.tvQuestionCount.text = getString(R.string.Q1, questions?.size)
        var q: RealmQuery<*> = mRealm.where(RealmSubmission::class.java)
            .equalTo("userId", user?.id)
            .equalTo("parentId", if (!TextUtils.isEmpty(exam?.courseId)) {
                id + "@" + exam?.courseId
            } else {
                id
            }).sort("startTime", Sort.DESCENDING)
        if (type == "exam") {
            q = q.equalTo("status", "pending")
        }
        sub = q.findFirst() as RealmSubmission?
        val courseId = exam?.courseId
        isCertified = isCourseCertified(mRealm, courseId)

        if ((questions?.size ?: 0) > 0) {
            clearAllExistingAnswers {
                createSubmission()
                startExam(questions?.get(currentIndex))
                updateNavButtons()
            }
        } else {
            binding.container.visibility = View.GONE
            binding.btnSubmit.visibility = View.GONE
            binding.tvQuestionCount.setText(R.string.no_questions)
            Snackbar.make(binding.tvQuestionCount, R.string.no_questions_available, Snackbar.LENGTH_LONG).show()
        }

        binding.btnBack.setOnClickListener {
            saveCurrentAnswer()
            goToPreviousQuestion()
        }
        binding.btnNext.setOnClickListener {
            saveCurrentAnswer()
            goToNextQuestion()
        }


        binding.etAnswer.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
            override fun afterTextChanged(s: Editable?) {
                val questionsSize = questions?.size ?: 0
                if (currentIndex < 0 || currentIndex >= questionsSize) return

                val currentQuestion = questions?.get(currentIndex)
                currentQuestion?.id?.let { questionId ->
                    val answerData = answerCache.getOrPut(questionId) { AnswerData() }
                    when (currentQuestion.type) {
                        "input", "textarea" -> {
                            answerData.singleAnswer = s.toString()
                        }
                        else -> {
                            answerData.otherText = s.toString()
                        }
                    }
                }
                updateNavButtons()
            }
        })
    }

    private fun saveCurrentAnswer() {
        val questionsSize = questions?.size ?: 0
        if (currentIndex < 0 || currentIndex >= questionsSize) return

        val currentQuestion = questions?.get(currentIndex) ?: return
        val questionId = currentQuestion.id ?: return

        val answerData = answerCache.getOrPut(questionId) { AnswerData() }

        when (currentQuestion.type) {
            "select", "ratingScale" -> {
                answerData.singleAnswer = ans
                if (binding.etAnswer.isVisible) {
                    answerData.otherText = binding.etAnswer.text.toString()
                }
            }
            "selectMultiple" -> {
                answerData.multipleAnswers.clear()
                listAns?.let { answerData.multipleAnswers.putAll(it) }
                if (binding.etAnswer.isVisible) {
                    answerData.otherText = binding.etAnswer.text.toString()
                }
            }
            "input", "textarea" -> {
                answerData.singleAnswer = binding.etAnswer.text.toString()
            }
        }

        updateAnsDb()
    }

    private fun goToPreviousQuestion() {
        if (currentIndex > 0) {
            currentIndex--
            startExam(questions?.get(currentIndex))
            updateNavButtons()
        }
    }

    private fun goToNextQuestion() {
        if (currentIndex < (questions?.size ?: 0) - 1) {
            currentIndex++
            startExam(questions?.get(currentIndex))
            updateNavButtons()
        }
    }

    private fun updateNavButtons() {
        binding.btnBack.visibility = if (currentIndex == 0) View.GONE else View.VISIBLE
        val isLastQuestion = currentIndex == (questions?.size ?: 0) - 1
        val isCurrentQuestionAnswered = isQuestionAnswered()

        binding.btnNext.visibility = if (isLastQuestion || !isCurrentQuestionAnswered) View.GONE else View.VISIBLE

        setButtonText()
    }

    private fun isQuestionAnswered(): Boolean {
        val questionsSize = questions?.size ?: 0
        if (currentIndex < 0 || currentIndex >= questionsSize) return false

        val currentQuestion = questions?.get(currentIndex)
        val questionId = currentQuestion?.id ?: return false
        val answerData = answerCache[questionId]

        val singleOtherOptionSelected = ans == "other" || answerData?.singleAnswer == "other"
        val multipleOtherOptionSelected = listAns?.containsKey("Other") == true ||
                answerData?.multipleAnswers?.containsKey("Other") == true
        val otherOptionSelected = singleOtherOptionSelected || multipleOtherOptionSelected
        val otherText = answerData?.otherText ?: binding.etAnswer.text.toString()

        if (currentQuestion.hasOtherOption && otherOptionSelected && otherText.isEmpty()) {
            return false
        }

        return when (currentQuestion.type) {
            "select" -> {
                ans.isNotEmpty() || answerData?.singleAnswer?.isNotEmpty() == true
            }
            "selectMultiple" -> {
                listAns?.isNotEmpty() == true || answerData?.multipleAnswers?.isNotEmpty() == true
            }
            "input", "textarea" -> {
                binding.etAnswer.text.toString().isNotEmpty() || answerData?.singleAnswer?.isNotEmpty() == true
            }
            "ratingScale" -> {
                ans.isNotEmpty() || answerData?.singleAnswer?.isNotEmpty() == true
            }
            else -> false
        }
    }

    private fun createSubmission() {
        mRealm.beginTransaction()
        try {
            sub = createSubmission(null, mRealm)
            setParentId()
            setParentJson()
            sub?.userId = user?.id
            sub?.status = "pending"
            sub?.type = type
            sub?.startTime = Date().time
            sub?.lastUpdateTime = Date().time
            if (sub?.answers == null) {
                sub?.answers = RealmList()
            }

            currentIndex = 0
            if (isTeam && teamId != null) {
                addTeamInformation(mRealm)
            }
            mRealm.commitTransaction()
        } catch (e: Exception) {
            mRealm.cancelTransaction()
            throw e
        }
    }

    private fun setParentId() {
        sub?.parentId = when {
            !TextUtils.isEmpty(exam?.id) -> if (!TextUtils.isEmpty(exam?.courseId)) {
                "${exam?.id}@${exam?.courseId}"
            } else {
                exam?.id
            }
            !TextUtils.isEmpty(id) -> if (!TextUtils.isEmpty(exam?.courseId)) {
                "$id@${exam?.courseId}"
            } else {
                id
            }
            else -> sub?.parentId
        }
    }

    private fun setParentJson() {
        try {
            val parentJsonString = JSONObject().apply {
                put("_id", exam?.id ?: id)
                put("name", exam?.name ?: "")
                put("courseId", exam?.courseId ?: "")
                put("sourcePlanet", exam?.sourcePlanet ?: "")
                put("teamShareAllowed", exam?.isTeamShareAllowed ?: false)
                put("noOfQuestions", exam?.noOfQuestions ?: 0)
                put("isFromNation", exam?.isFromNation ?: false)
            }.toString()
            sub?.parent = parentJsonString
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun addTeamInformation(realm: Realm) {
        sub?.team = teamId
        val membershipDoc = realm.createObject(RealmMembershipDoc::class.java)
        membershipDoc.teamId = teamId
        sub?.membershipDoc = membershipDoc

        val userModel = userProfileDbHandler.userModel

        try {
            val userJson = JSONObject()
            userJson.put("age", userModel?.dob ?: "")
            userJson.put("gender", userModel?.gender ?: "")
            val membershipJson = JSONObject()
            membershipJson.put("teamId", teamId)
            userJson.put("membershipDoc", membershipJson)

            sub?.user = userJson.toString()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    override fun startExam(question: RealmExamQuestion?) {
        binding.tvQuestionCount.text = getString(R.string.Q, currentIndex + 1, questions?.size)
        setButtonText()
        binding.groupChoices.removeAllViews()
        binding.llCheckbox.removeAllViews()
        binding.etAnswer.visibility = View.GONE
        binding.groupChoices.visibility = View.GONE
        binding.llCheckbox.visibility = View.GONE
        binding.llRatingScale.visibility = View.GONE

        loadSavedAnswer(question)

        when {
            question?.type.equals("select", ignoreCase = true) -> {
                binding.groupChoices.visibility = View.VISIBLE
                selectQuestion(question, ans)
            }
            question?.type.equals("input", ignoreCase = true) ||
                    question?.type.equals("textarea", ignoreCase = true) -> {
                question?.type?.let {
                    setMarkdownViewAndShowInput(binding.etAnswer, it, ans)
                }
            }
            question?.type.equals("selectMultiple", ignoreCase = true) -> {
                binding.llCheckbox.visibility = View.VISIBLE
                showCheckBoxes(question, ans)
            }
            question?.type.equals("ratingScale", ignoreCase = true) -> {
                binding.llRatingScale.visibility = View.VISIBLE
                setupRatingScale(ans)
            }
        }
        binding.tvHeader.text = question?.header
        question?.body?.let { setMarkdownText(binding.tvBody, it) }
        binding.btnSubmit.setOnClickListener(this)

        updateNavButtons()
    }

    private fun loadSavedAnswer(question: RealmExamQuestion?) {
        val questionId = question?.id ?: return
        val answerData = answerCache[questionId]
        clearAnswer()

        if (answerData != null) {
            when (question.type) {
                "select", "ratingScale" -> {
                    ans = answerData.singleAnswer
                    if (answerData.otherText.isNotEmpty()) {
                        binding.etAnswer.setText(answerData.otherText)
                        if (ans == "other") {
                            binding.etAnswer.visibility = View.VISIBLE
                        }
                    }
                }
                "selectMultiple" -> {
                    listAns?.putAll(answerData.multipleAnswers)
                    if (answerData.otherText.isNotEmpty()) {
                        binding.etAnswer.setText(answerData.otherText)
                        if (listAns?.containsKey("Other") == true) {
                            binding.etAnswer.visibility = View.VISIBLE
                        }
                    }
                }
                "input", "textarea" -> {
                    ans = answerData.singleAnswer
                    binding.etAnswer.setText(ans)
                }
            }
        }
    }

    private var selectedRatingButton: Button? = null

    private fun setupRatingScale(oldAnswer: String) {
        val ratingButtons = listOf(
            binding.rbRating1,
            binding.rbRating2,
            binding.rbRating3,
            binding.rbRating4,
            binding.rbRating5,
            binding.rbRating6,
            binding.rbRating7,
            binding.rbRating8,
            binding.rbRating9
        )

        ratingButtons.forEachIndexed { index, button ->
            button.setOnClickListener {
                selectedRatingButton?.isSelected = false

                button.isSelected = true
                selectedRatingButton = button
                ans = (index + 1).toString()

                updateNavButtons()
            }
        }

        if (oldAnswer.isNotEmpty()) {
            selectRatingValue(oldAnswer.toIntOrNull() ?: 1)
        }
    }

    private fun selectRatingValue(value: Int) {
        val ratingButtons = listOf(
            binding.rbRating1,
            binding.rbRating2,
            binding.rbRating3,
            binding.rbRating4,
            binding.rbRating5,
            binding.rbRating6,
            binding.rbRating7,
            binding.rbRating8,
            binding.rbRating9
        )

        selectedRatingButton?.isSelected = false

        if (value in 1..9) {
            val button = ratingButtons[value - 1]
            button.isSelected = true
            selectedRatingButton = button
        }
    }

    private fun clearAnswer() {
        ans = ""
        binding.etAnswer.setText("")
        listAns?.clear()
        selectedRatingButton?.isSelected = false
        selectedRatingButton = null
    }

    private fun setButtonText() {
        if (currentIndex == (questions?.size?.minus(1) ?: 0)) {
            binding.btnSubmit.setText(R.string.finish)
        } else {
            binding.btnSubmit.setText(R.string.submit)
        }
    }

    private fun showCheckBoxes(question: RealmExamQuestion?, oldAnswer: String) {
        val choices = getStringAsJsonArray(question?.choices)

        for (i in 0 until choices.size()) {
            addCompoundButton(choices[i].asJsonObject, false, oldAnswer)
        }

        if (question?.hasOtherOption == true) {
            val otherChoice = gson.fromJson("""{"text":"Other","id":"other"}""", JsonObject::class.java)

            addCompoundButton(otherChoice, false, oldAnswer)
        }
    }

    private fun selectQuestion(question: RealmExamQuestion?, oldAnswer: String) {
        val choices = getStringAsJsonArray(question?.choices)
        val isRadio = question?.type != "multiple"

        for (i in 0 until choices.size()) {
            if (choices[i].isJsonObject) {
                addCompoundButton(choices[i].asJsonObject, isRadio, oldAnswer)
            } else {
                addRadioButton(getString(choices, i), oldAnswer)
            }
        }

        if (question?.hasOtherOption == true) {
            if (choices.size() > 0 && choices[0].isJsonObject) {
                val otherChoice = gson.fromJson("""{"text":"Other","id":"other"}""", JsonObject::class.java)

                addCompoundButton(otherChoice, isRadio, oldAnswer)
            } else {
                addRadioButton("Other", oldAnswer)
            }
        }
    }

    private fun addRadioButton(choice: String, oldAnswer: String) {
        val inflater = LayoutInflater.from(activity)
        val rdBtn = inflater.inflate(R.layout.item_radio_btn, binding.groupChoices, false) as RadioButton
        rdBtn.text = choice
        rdBtn.isChecked = choice == oldAnswer
        rdBtn.setOnCheckedChangeListener(this)
        binding.groupChoices.addView(rdBtn)

        if (choice.equals("Other", ignoreCase = true) && choice == oldAnswer) {
            binding.etAnswer.visibility = View.VISIBLE
            binding.etAnswer.setText(oldAnswer)
        }
    }

    private fun addCompoundButton(choice: JsonObject?, isRadio: Boolean, oldAnswer: String) {
        val rdBtn = if (isRadio) {
            LayoutInflater.from(activity)
                .inflate(
                    R.layout.item_radio_btn,
                    binding.groupChoices, false
                ) as RadioButton
        } else {
            LayoutInflater.from(activity)
                .inflate(R.layout.item_checkbox, null) as CompoundButton
        }
        val choiceText = getString("text", choice)
        val choiceId = getString("id", choice)

        rdBtn.text = choiceText
        rdBtn.tag = choiceId

        if (isRadio) {
            rdBtn.isChecked = choiceId == oldAnswer
        } else {
            rdBtn.isChecked = listAns?.get(choiceText) == choiceId
        }

        rdBtn.setOnCheckedChangeListener(this)
        if (isRadio) {
            rdBtn.id = View.generateViewId()
            binding.groupChoices.addView(rdBtn)
        } else {
            rdBtn.setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
            rdBtn.buttonTintList = ContextCompat.getColorStateList(requireContext(), R.color.daynight_textColor)
            binding.llCheckbox.addView(rdBtn)
        }

        if (choiceText.equals("Other", ignoreCase = true) && rdBtn.isChecked) {
            binding.etAnswer.visibility = View.VISIBLE
        }
    }

    override fun onClick(view: View) {
        if (view.id == R.id.btn_submit) {
            if (questions != null && currentIndex in 0 until (questions?.size ?: 0)) {
                saveCurrentAnswer()

                if (!isQuestionAnswered()) {
                    toast(activity, getString(R.string.please_select_write_your_answer_to_continue), Toast.LENGTH_SHORT)
                    return
                }

                val cont = updateAnsDb()

                if (this.type == "exam" && !cont) {
                    Snackbar.make(binding.root, getString(R.string.incorrect_ans), Snackbar.LENGTH_LONG).show()
                    return
                }

                capturePhoto()
                hideSoftKeyboard(requireActivity())
                checkAnsAndContinue(cont)
            }
        }
    }

    private fun capturePhoto() {
        try {
            if (isCertified && !isMySurvey) {
                capturePhoto(this)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }


    private fun updateAnsDb(): Boolean {
        val questionsSize = questions?.size ?: 0
        if (currentIndex < 0 || currentIndex >= questionsSize) return true

        val currentQuestion = questions?.get(currentIndex) ?: return true
        val otherText = if (binding.etAnswer.isVisible) {
            binding.etAnswer.text.toString()
        } else {
            null
        }
        return ExamSubmissionUtils.saveAnswer(
            mRealm,
            sub,
            currentQuestion,
            ans,
            listAns,
            otherText,
            binding.etAnswer.isVisible,
            type ?: "exam",
            currentIndex,
            questions?.size ?: 0
        )
    }

    override fun onCheckedChanged(compoundButton: CompoundButton, isChecked: Boolean) {
        if (isChecked) {
            handleChecked(compoundButton)
        } else {
            handleUnchecked(compoundButton)
        }

        val questionsSize = questions?.size ?: 0
        if (currentIndex < 0 || currentIndex >= questionsSize) return

        val currentQuestion = questions?.get(currentIndex)
        currentQuestion?.id?.let { questionId ->
            val answerData = answerCache.getOrPut(questionId) { AnswerData() }

            if (currentQuestion.type == "selectMultiple") {
                answerData.multipleAnswers.clear()
                listAns?.let { answerData.multipleAnswers.putAll(it) }
            } else if (currentQuestion.type == "select") {
                answerData.singleAnswer = ans
            }
        }

        updateNavButtons()
    }

    private fun handleChecked(compoundButton: CompoundButton) {
        val selectedText = "${compoundButton.text}"

        if (selectedText.equals("Other", ignoreCase = true)) {
            binding.etAnswer.visibility = View.VISIBLE
            binding.etAnswer.requestFocus()
        } else if (!isOtherOptionSelected()) {
            binding.etAnswer.visibility = View.GONE
            binding.etAnswer.text.clear()
        }

        val choiceId = compoundButton.tag as? String
        if (compoundButton is RadioButton) {
            ans = choiceId ?: selectedText
        } else {
            listAns?.put(selectedText, choiceId ?: selectedText)
        }
    }

    private fun handleUnchecked(compoundButton: CompoundButton) {
        if (compoundButton.tag != null && compoundButton !is RadioButton) {
            val selectedText = "${compoundButton.text}"

            if (selectedText.equals("Other", ignoreCase = true)) {
                binding.etAnswer.visibility = View.GONE
                binding.etAnswer.text.clear()
            }

            listAns?.remove("${compoundButton.text}")
        }
    }

    private fun isOtherOptionSelected(): Boolean {
        for (i in 0 until binding.llCheckbox.childCount) {
            val child = binding.llCheckbox.getChildAt(i)
            if (child is CompoundButton &&
                child.text.toString().equals("Other", ignoreCase = true) &&
                child.isChecked) {
                return true
            }
        }
        return false
    }

    private fun clearAllExistingAnswers(onComplete: () -> Unit = {}) {
        val examIdValue = exam?.id
        val examCourseIdValue = exam?.courseId
        val userIdValue = user?.id

        viewLifecycleOwner.lifecycleScope.launch(Dispatchers.IO) {
            try {
                databaseService.executeTransactionAsync { realm ->
                    val parentIdToSearch = if (!TextUtils.isEmpty(examCourseIdValue)) {
                        "${examIdValue ?: id}@${examCourseIdValue}"
                    } else {
                        examIdValue ?: id
                    }

                    val allSubmissions = realm.where(RealmSubmission::class.java)
                        .equalTo("userId", userIdValue)
                        .equalTo("parentId", parentIdToSearch)
                        .findAll()

                    allSubmissions.forEach { submission ->
                        submission.answers?.deleteAllFromRealm()
                        submission.deleteFromRealm()
                    }
                }

                withContext(Dispatchers.Main) {
                    answerCache.clear()
                    clearAnswer()
                    ans = ""
                    listAns?.clear()
                    sub = null
                    onComplete()
                }
            } catch (e: Exception) {
                e.printStackTrace()
                withContext(Dispatchers.Main) {
                    answerCache.clear()
                    clearAnswer()
                    ans = ""
                    listAns?.clear()
                    sub = null
                    onComplete()
                }
            }
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        saveCurrentAnswer()
        selectedRatingButton = null
        _binding = null
    }
}
=======
package org.ole.planet.myplanet.ui.exam


import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.CompoundButton
import android.widget.RadioButton
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.core.view.isVisible
import androidx.lifecycle.lifecycleScope
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmQuery
import io.realm.Sort
import java.util.Date
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentTakeExamBinding
import org.ole.planet.myplanet.model.RealmCertification.Companion.isCourseCertified
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmMembershipDoc
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmission.Companion.createSubmission
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.CameraUtils.ImageCaptureCallback
import org.ole.planet.myplanet.utilities.CameraUtils.capturePhoto
import org.ole.planet.myplanet.utilities.JsonUtils.getString
import org.ole.planet.myplanet.utilities.JsonUtils.getStringAsJsonArray
import org.ole.planet.myplanet.utilities.KeyboardUtils.hideSoftKeyboard
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText
import org.ole.planet.myplanet.utilities.Utilities.toast

@AndroidEntryPoint
class TakeExamFragment : BaseExamFragment(), View.OnClickListener, CompoundButton.OnCheckedChangeListener, ImageCaptureCallback {
    private var _binding: FragmentTakeExamBinding? = null
    private val binding get() = _binding!!
    private var isCertified = false
    private val gson = Gson()

    private val answerCache = mutableMapOf<String, AnswerData>()

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    data class AnswerData(
        var singleAnswer: String = "",
        var multipleAnswers: HashMap<String, String> = HashMap(),
        var otherText: String = ""
    )

    override fun onCreateView(inflater: LayoutInflater, parent: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTakeExamBinding.inflate(inflater, parent, false)
        listAns = HashMap()
        user = userProfileDbHandler.userModel
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        initExam()
        questions = mRealm.where(RealmExamQuestion::class.java).equalTo("examId", exam?.id).findAll()
        binding.tvQuestionCount.text = getString(R.string.Q1, questions?.size)
        var q: RealmQuery<*> = mRealm.where(RealmSubmission::class.java)
            .equalTo("userId", user?.id)
            .equalTo("parentId", if (!TextUtils.isEmpty(exam?.courseId)) {
                id + "@" + exam?.courseId
            } else {
                id
            }).sort("startTime", Sort.DESCENDING)
        if (type == "exam") {
            q = q.equalTo("status", "pending")
        }
        sub = q.findFirst() as RealmSubmission?
        val courseId = exam?.courseId
        isCertified = isCourseCertified(mRealm, courseId)

        if ((questions?.size ?: 0) > 0) {
            clearAllExistingAnswers {
                createSubmission()
                startExam(questions?.get(currentIndex))
                updateNavButtons()
            }
        } else {
            binding.container.visibility = View.GONE
            binding.btnSubmit.visibility = View.GONE
            binding.tvQuestionCount.setText(R.string.no_questions)
            Snackbar.make(binding.tvQuestionCount, R.string.no_questions_available, Snackbar.LENGTH_LONG).show()
        }

        binding.btnBack.setOnClickListener {
            saveCurrentAnswer()
            goToPreviousQuestion()
        }
        binding.btnNext.setOnClickListener {
            saveCurrentAnswer()
            goToNextQuestion()
        }


        binding.etAnswer.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
            override fun afterTextChanged(s: Editable?) {
                val questionsSize = questions?.size ?: 0
                if (currentIndex < 0 || currentIndex >= questionsSize) return

                val currentQuestion = questions?.get(currentIndex)
                currentQuestion?.id?.let { questionId ->
                    val answerData = answerCache.getOrPut(questionId) { AnswerData() }
                    when (currentQuestion.type) {
                        "input", "textarea" -> {
                            answerData.singleAnswer = s.toString()
                        }
                        else -> {
                            answerData.otherText = s.toString()
                        }
                    }
                }
                updateNavButtons()
            }
        })
    }

    private fun saveCurrentAnswer() {
        val questionsSize = questions?.size ?: 0
        if (currentIndex < 0 || currentIndex >= questionsSize) return

        val currentQuestion = questions?.get(currentIndex) ?: return
        val questionId = currentQuestion.id ?: return

        val answerData = answerCache.getOrPut(questionId) { AnswerData() }

        when (currentQuestion.type) {
            "select", "ratingScale" -> {
                answerData.singleAnswer = ans
                if (binding.etAnswer.isVisible) {
                    answerData.otherText = binding.etAnswer.text.toString()
                }
            }
            "selectMultiple" -> {
                answerData.multipleAnswers.clear()
                listAns?.let { answerData.multipleAnswers.putAll(it) }
                if (binding.etAnswer.isVisible) {
                    answerData.otherText = binding.etAnswer.text.toString()
                }
            }
            "input", "textarea" -> {
                answerData.singleAnswer = binding.etAnswer.text.toString()
            }
        }

        updateAnsDb()
    }

    private fun goToPreviousQuestion() {
        if (currentIndex > 0) {
            currentIndex--
            startExam(questions?.get(currentIndex))
            updateNavButtons()
        }
    }

    private fun goToNextQuestion() {
        if (currentIndex < (questions?.size ?: 0) - 1) {
            currentIndex++
            startExam(questions?.get(currentIndex))
            updateNavButtons()
        }
    }

    private fun updateNavButtons() {
        binding.btnBack.visibility = if (currentIndex == 0) View.GONE else View.VISIBLE
        val isLastQuestion = currentIndex == (questions?.size ?: 0) - 1
        val isCurrentQuestionAnswered = isQuestionAnswered()

        binding.btnNext.visibility = if (isLastQuestion || !isCurrentQuestionAnswered) View.GONE else View.VISIBLE

        setButtonText()
    }

    private fun isQuestionAnswered(): Boolean {
        val questionsSize = questions?.size ?: 0
        if (currentIndex < 0 || currentIndex >= questionsSize) return false

        val currentQuestion = questions?.get(currentIndex)
        val questionId = currentQuestion?.id ?: return false
        val answerData = answerCache[questionId]

        val singleOtherOptionSelected = ans == "other" || answerData?.singleAnswer == "other"
        val multipleOtherOptionSelected = listAns?.containsKey("Other") == true ||
                answerData?.multipleAnswers?.containsKey("Other") == true
        val otherOptionSelected = singleOtherOptionSelected || multipleOtherOptionSelected
        val otherText = answerData?.otherText ?: binding.etAnswer.text.toString()

        if (currentQuestion.hasOtherOption && otherOptionSelected && otherText.isEmpty()) {
            return false
        }

        return when (currentQuestion.type) {
            "select" -> {
                ans.isNotEmpty() || answerData?.singleAnswer?.isNotEmpty() == true
            }
            "selectMultiple" -> {
                listAns?.isNotEmpty() == true || answerData?.multipleAnswers?.isNotEmpty() == true
            }
            "input", "textarea" -> {
                binding.etAnswer.text.toString().isNotEmpty() || answerData?.singleAnswer?.isNotEmpty() == true
            }
            "ratingScale" -> {
                ans.isNotEmpty() || answerData?.singleAnswer?.isNotEmpty() == true
            }
            else -> false
        }
    }

    private fun createSubmission() {
        mRealm.beginTransaction()
        try {
            sub = createSubmission(null, mRealm)
            setParentId()
            setParentJson()
            sub?.userId = user?.id
            sub?.status = "pending"
            sub?.type = type
            sub?.startTime = Date().time
            sub?.lastUpdateTime = Date().time
            if (sub?.answers == null) {
                sub?.answers = RealmList()
            }

            currentIndex = 0
            if (isTeam && teamId != null) {
                addTeamInformation(mRealm)
            }
            mRealm.commitTransaction()
        } catch (e: Exception) {
            mRealm.cancelTransaction()
            throw e
        }
    }

    private fun setParentId() {
        sub?.parentId = when {
            !TextUtils.isEmpty(exam?.id) -> if (!TextUtils.isEmpty(exam?.courseId)) {
                "${exam?.id}@${exam?.courseId}"
            } else {
                exam?.id
            }
            !TextUtils.isEmpty(id) -> if (!TextUtils.isEmpty(exam?.courseId)) {
                "$id@${exam?.courseId}"
            } else {
                id
            }
            else -> sub?.parentId
        }
    }

    private fun setParentJson() {
        try {
            val parentJsonString = JSONObject().apply {
                put("_id", exam?.id ?: id)
                put("name", exam?.name ?: "")
                put("courseId", exam?.courseId ?: "")
                put("sourcePlanet", exam?.sourcePlanet ?: "")
                put("teamShareAllowed", exam?.isTeamShareAllowed ?: false)
                put("noOfQuestions", exam?.noOfQuestions ?: 0)
                put("isFromNation", exam?.isFromNation ?: false)
            }.toString()
            sub?.parent = parentJsonString
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun addTeamInformation(realm: Realm) {
        sub?.team = teamId
        val membershipDoc = realm.createObject(RealmMembershipDoc::class.java)
        membershipDoc.teamId = teamId
        sub?.membershipDoc = membershipDoc

        val userModel = userProfileDbHandler.userModel

        try {
            val userJson = JSONObject()
            userJson.put("age", userModel?.dob ?: "")
            userJson.put("gender", userModel?.gender ?: "")
            val membershipJson = JSONObject()
            membershipJson.put("teamId", teamId)
            userJson.put("membershipDoc", membershipJson)

            sub?.user = userJson.toString()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    override fun startExam(question: RealmExamQuestion?) {
        binding.tvQuestionCount.text = getString(R.string.Q, currentIndex + 1, questions?.size)
        setButtonText()
        binding.groupChoices.removeAllViews()
        binding.llCheckbox.removeAllViews()
        binding.etAnswer.visibility = View.GONE
        binding.groupChoices.visibility = View.GONE
        binding.llCheckbox.visibility = View.GONE
        binding.llRatingScale.visibility = View.GONE

        loadSavedAnswer(question)

        when {
            question?.type.equals("select", ignoreCase = true) -> {
                binding.groupChoices.visibility = View.VISIBLE
                selectQuestion(question, ans)
            }
            question?.type.equals("input", ignoreCase = true) ||
                    question?.type.equals("textarea", ignoreCase = true) -> {
                question?.type?.let {
                    setMarkdownViewAndShowInput(binding.etAnswer, it, ans)
                }
            }
            question?.type.equals("selectMultiple", ignoreCase = true) -> {
                binding.llCheckbox.visibility = View.VISIBLE
                showCheckBoxes(question, ans)
            }
            question?.type.equals("ratingScale", ignoreCase = true) -> {
                binding.llRatingScale.visibility = View.VISIBLE
                setupRatingScale(ans)
            }
        }
        binding.tvHeader.text = question?.header
        question?.body?.let { setMarkdownText(binding.tvBody, it) }
        binding.btnSubmit.setOnClickListener(this)

        updateNavButtons()
    }

    private fun loadSavedAnswer(question: RealmExamQuestion?) {
        val questionId = question?.id ?: return
        val answerData = answerCache[questionId]
        clearAnswer()

        if (answerData != null) {
            when (question.type) {
                "select", "ratingScale" -> {
                    ans = answerData.singleAnswer
                    if (answerData.otherText.isNotEmpty()) {
                        binding.etAnswer.setText(answerData.otherText)
                        if (ans == "other") {
                            binding.etAnswer.visibility = View.VISIBLE
                        }
                    }
                }
                "selectMultiple" -> {
                    listAns?.putAll(answerData.multipleAnswers)
                    if (answerData.otherText.isNotEmpty()) {
                        binding.etAnswer.setText(answerData.otherText)
                        if (listAns?.containsKey("Other") == true) {
                            binding.etAnswer.visibility = View.VISIBLE
                        }
                    }
                }
                "input", "textarea" -> {
                    ans = answerData.singleAnswer
                    binding.etAnswer.setText(ans)
                }
            }
        }
    }

    private var selectedRatingButton: Button? = null

    private fun setupRatingScale(oldAnswer: String) {
        val ratingButtons = listOf(
            binding.rbRating1,
            binding.rbRating2,
            binding.rbRating3,
            binding.rbRating4,
            binding.rbRating5,
            binding.rbRating6,
            binding.rbRating7,
            binding.rbRating8,
            binding.rbRating9
        )

        ratingButtons.forEachIndexed { index, button ->
            button.setOnClickListener {
                selectedRatingButton?.isSelected = false

                button.isSelected = true
                selectedRatingButton = button
                ans = (index + 1).toString()

                updateNavButtons()
            }
        }

        if (oldAnswer.isNotEmpty()) {
            selectRatingValue(oldAnswer.toIntOrNull() ?: 1)
        }
    }

    private fun selectRatingValue(value: Int) {
        val ratingButtons = listOf(
            binding.rbRating1,
            binding.rbRating2,
            binding.rbRating3,
            binding.rbRating4,
            binding.rbRating5,
            binding.rbRating6,
            binding.rbRating7,
            binding.rbRating8,
            binding.rbRating9
        )

        selectedRatingButton?.isSelected = false

        if (value in 1..9) {
            val button = ratingButtons[value - 1]
            button.isSelected = true
            selectedRatingButton = button
        }
    }

    private fun clearAnswer() {
        ans = ""
        binding.etAnswer.setText("")
        listAns?.clear()
        selectedRatingButton?.isSelected = false
        selectedRatingButton = null
    }

    private fun setButtonText() {
        if (currentIndex == (questions?.size?.minus(1) ?: 0)) {
            binding.btnSubmit.setText(R.string.finish)
        } else {
            binding.btnSubmit.setText(R.string.submit)
        }
    }

    private fun showCheckBoxes(question: RealmExamQuestion?, oldAnswer: String) {
        val choices = getStringAsJsonArray(question?.choices)

        for (i in 0 until choices.size()) {
            addCompoundButton(choices[i].asJsonObject, false, oldAnswer)
        }

        if (question?.hasOtherOption == true) {
            val otherChoice = gson.fromJson("""{"text":"Other","id":"other"}""", JsonObject::class.java)

            addCompoundButton(otherChoice, false, oldAnswer)
        }
    }

    private fun selectQuestion(question: RealmExamQuestion?, oldAnswer: String) {
        val choices = getStringAsJsonArray(question?.choices)
        val isRadio = question?.type != "multiple"

        for (i in 0 until choices.size()) {
            if (choices[i].isJsonObject) {
                addCompoundButton(choices[i].asJsonObject, isRadio, oldAnswer)
            } else {
                addRadioButton(getString(choices, i), oldAnswer)
            }
        }

        if (question?.hasOtherOption == true) {
            if (choices.size() > 0 && choices[0].isJsonObject) {
                val otherChoice = gson.fromJson("""{"text":"Other","id":"other"}""", JsonObject::class.java)

                addCompoundButton(otherChoice, isRadio, oldAnswer)
            } else {
                addRadioButton("Other", oldAnswer)
            }
        }
    }

    private fun addRadioButton(choice: String, oldAnswer: String) {
        val inflater = LayoutInflater.from(activity)
        val rdBtn = inflater.inflate(R.layout.item_radio_btn, binding.groupChoices, false) as RadioButton
        rdBtn.text = choice
        rdBtn.isChecked = choice == oldAnswer
        rdBtn.setOnCheckedChangeListener(this)
        binding.groupChoices.addView(rdBtn)

        if (choice.equals("Other", ignoreCase = true) && choice == oldAnswer) {
            binding.etAnswer.visibility = View.VISIBLE
            binding.etAnswer.setText(oldAnswer)
        }
    }

    private fun addCompoundButton(choice: JsonObject?, isRadio: Boolean, oldAnswer: String) {
        val rdBtn = if (isRadio) {
            LayoutInflater.from(activity)
                .inflate(
                    R.layout.item_radio_btn,
                    binding.groupChoices, false
                ) as RadioButton
        } else {
            LayoutInflater.from(activity)
                .inflate(R.layout.item_checkbox, null) as CompoundButton
        }
        val choiceText = getString("text", choice)
        val choiceId = getString("id", choice)

        rdBtn.text = choiceText
        rdBtn.tag = choiceId

        if (isRadio) {
            rdBtn.isChecked = choiceId == oldAnswer
        } else {
            rdBtn.isChecked = listAns?.get(choiceText) == choiceId
        }

        rdBtn.setOnCheckedChangeListener(this)
        if (isRadio) {
            rdBtn.id = View.generateViewId()
            binding.groupChoices.addView(rdBtn)
        } else {
            rdBtn.setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
            rdBtn.buttonTintList = ContextCompat.getColorStateList(requireContext(), R.color.daynight_textColor)
            binding.llCheckbox.addView(rdBtn)
        }

        if (choiceText.equals("Other", ignoreCase = true) && rdBtn.isChecked) {
            binding.etAnswer.visibility = View.VISIBLE
        }
    }

    override fun onClick(view: View) {
        if (view.id == R.id.btn_submit) {
            if (questions != null && currentIndex in 0 until (questions?.size ?: 0)) {
                saveCurrentAnswer()

                if (!isQuestionAnswered()) {
                    toast(activity, getString(R.string.please_select_write_your_answer_to_continue), Toast.LENGTH_SHORT)
                    return
                }

                val cont = updateAnsDb()

                if (this.type == "exam" && !cont) {
                    Snackbar.make(binding.root, getString(R.string.incorrect_ans), Snackbar.LENGTH_LONG).show()
                    return
                }

                capturePhoto()
                hideSoftKeyboard(requireActivity())
                checkAnsAndContinue(cont)
            }
        }
    }

    private fun capturePhoto() {
        try {
            if (isCertified && !isMySurvey) {
                capturePhoto(this)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }


    private fun updateAnsDb(): Boolean {
        val questionsSize = questions?.size ?: 0
        if (currentIndex < 0 || currentIndex >= questionsSize) return true

        val currentQuestion = questions?.get(currentIndex) ?: return true
        val otherText = if (binding.etAnswer.isVisible) {
            binding.etAnswer.text.toString()
        } else {
            null
        }
        return ExamSubmissionUtils.saveAnswer(
            mRealm,
            sub,
            currentQuestion,
            ans,
            listAns,
            otherText,
            binding.etAnswer.isVisible,
            type ?: "exam",
            currentIndex,
            questions?.size ?: 0
        )
    }

    override fun onCheckedChanged(compoundButton: CompoundButton, isChecked: Boolean) {
        if (isChecked) {
            handleChecked(compoundButton)
        } else {
            handleUnchecked(compoundButton)
        }

        val questionsSize = questions?.size ?: 0
        if (currentIndex < 0 || currentIndex >= questionsSize) return

        val currentQuestion = questions?.get(currentIndex)
        currentQuestion?.id?.let { questionId ->
            val answerData = answerCache.getOrPut(questionId) { AnswerData() }

            if (currentQuestion.type == "selectMultiple") {
                answerData.multipleAnswers.clear()
                listAns?.let { answerData.multipleAnswers.putAll(it) }
            } else if (currentQuestion.type == "select") {
                answerData.singleAnswer = ans
            }
        }

        updateNavButtons()
    }

    private fun handleChecked(compoundButton: CompoundButton) {
        val selectedText = "${compoundButton.text}"

        if (selectedText.equals("Other", ignoreCase = true)) {
            binding.etAnswer.visibility = View.VISIBLE
            binding.etAnswer.requestFocus()
        } else if (!isOtherOptionSelected()) {
            binding.etAnswer.visibility = View.GONE
            binding.etAnswer.text.clear()
        }

        val choiceId = compoundButton.tag as? String
        if (compoundButton is RadioButton) {
            ans = choiceId ?: selectedText
        } else {
            listAns?.put(selectedText, choiceId ?: selectedText)
        }
    }

    private fun handleUnchecked(compoundButton: CompoundButton) {
        if (compoundButton.tag != null && compoundButton !is RadioButton) {
            val selectedText = "${compoundButton.text}"

            if (selectedText.equals("Other", ignoreCase = true)) {
                binding.etAnswer.visibility = View.GONE
                binding.etAnswer.text.clear()
            }

            listAns?.remove("${compoundButton.text}")
        }
    }

    private fun isOtherOptionSelected(): Boolean {
        for (i in 0 until binding.llCheckbox.childCount) {
            val child = binding.llCheckbox.getChildAt(i)
            if (child is CompoundButton &&
                child.text.toString().equals("Other", ignoreCase = true) &&
                child.isChecked) {
                return true
            }
        }
        return false
    }

    private fun clearAllExistingAnswers(onComplete: () -> Unit = {}) {
        val examIdValue = exam?.id
        val examCourseIdValue = exam?.courseId
        val userIdValue = user?.id

        viewLifecycleOwner.lifecycleScope.launch(Dispatchers.IO) {
            try {
                databaseService.executeTransactionAsync { realm ->
                    val parentIdToSearch = if (!TextUtils.isEmpty(examCourseIdValue)) {
                        "${examIdValue ?: id}@${examCourseIdValue}"
                    } else {
                        examIdValue ?: id
                    }

                    val allSubmissions = realm.where(RealmSubmission::class.java)
                        .equalTo("userId", userIdValue)
                        .equalTo("parentId", parentIdToSearch)
                        .findAll()

                    allSubmissions.forEach { submission ->
                        submission.answers?.deleteAllFromRealm()
                        submission.deleteFromRealm()
                    }
                }

                withContext(Dispatchers.Main) {
                    answerCache.clear()
                    clearAnswer()
                    ans = ""
                    listAns?.clear()
                    sub = null
                    onComplete()
                }
            } catch (e: Exception) {
                e.printStackTrace()
                withContext(Dispatchers.Main) {
                    answerCache.clear()
                    clearAnswer()
                    ans = ""
                    listAns?.clear()
                    sub = null
                    onComplete()
                }
            }
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        saveCurrentAnswer()
        selectedRatingButton = null
        _binding = null
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/exam/ExamAnswerUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.exam

import java.util.Arrays
import java.util.Locale
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.utilities.JsonUtils.getStringAsJsonArray

object ExamAnswerUtils {
    fun getChoiceTextById(question: RealmExamQuestion, id: String): String {
        val choices = getStringAsJsonArray(question.choices)
        for (i in 0 until choices.size()) {
            if (choices[i].isJsonObject) {
                val obj = choices[i].asJsonObject
                if (obj.get("id").asString == id) {
                    return obj.get("text").asString
                }
            }
        }
        return id
    }

    fun checkCorrectAnswer(
        ans: String,
        listAns: Map<String, String>?,
        question: RealmExamQuestion?
    ): Boolean {
        val questionType = question?.type
        val correctChoices = question?.getCorrectChoice()
        return when {
            questionType.equals("select", ignoreCase = true) ->
                checkSelectAnswer(ans, correctChoices)
            questionType.equals("selectMultiple", ignoreCase = true) ->
                checkMultipleSelectAnswer(listAns, correctChoices)
            else -> checkTextAnswer(ans, correctChoices)
        }
    }

    private fun checkSelectAnswer(ans: String, correctChoices: List<String>?): Boolean {
        return correctChoices?.contains(ans.lowercase(Locale.getDefault())) == true
    }

    private fun checkMultipleSelectAnswer(
        listAns: Map<String, String>?,
        correctChoices: List<String>?
    ): Boolean {
        val selectedAns = listAns?.values?.toTypedArray()
        val correctChoicesArray = correctChoices?.toTypedArray()
        return isEqual(selectedAns, correctChoicesArray)
    }

    private fun checkTextAnswer(ans: String, correctChoices: List<String>?): Boolean {
        return correctChoices?.any {
            ans.lowercase(Locale.getDefault()).contains(it.lowercase(Locale.getDefault()))
        } == true
    }

    private fun isEqual(ar1: Array<String>?, ar2: Array<String>?): Boolean {
        ar1?.let { Arrays.sort(it) }
        ar2?.let { Arrays.sort(it) }
        return ar1.contentEquals(ar2)
    }
}
=======
package org.ole.planet.myplanet.ui.exam


import java.util.Arrays
import java.util.Locale
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.utilities.JsonUtils.getStringAsJsonArray

object ExamAnswerUtils {
    fun getChoiceTextById(question: RealmExamQuestion, id: String): String {
        val choices = getStringAsJsonArray(question.choices)
        for (i in 0 until choices.size()) {
            if (choices[i].isJsonObject) {
                val obj = choices[i].asJsonObject
                if (obj.get("id").asString == id) {
                    return obj.get("text").asString
                }
            }
        }
        return id
    }

    fun checkCorrectAnswer(
        ans: String,
        listAns: Map<String, String>?,
        question: RealmExamQuestion?
    ): Boolean {
        val questionType = question?.type
        val correctChoices = question?.getCorrectChoice()
        return when {
            questionType.equals("select", ignoreCase = true) ->
                checkSelectAnswer(ans, correctChoices)
            questionType.equals("selectMultiple", ignoreCase = true) ->
                checkMultipleSelectAnswer(listAns, correctChoices)
            else -> checkTextAnswer(ans, correctChoices)
        }
    }

    private fun checkSelectAnswer(ans: String, correctChoices: List<String>?): Boolean {
        return correctChoices?.contains(ans.lowercase(Locale.getDefault())) == true
    }

    private fun checkMultipleSelectAnswer(
        listAns: Map<String, String>?,
        correctChoices: List<String>?
    ): Boolean {
        val selectedAns = listAns?.values?.toTypedArray()
        val correctChoicesArray = correctChoices?.toTypedArray()
        return isEqual(selectedAns, correctChoicesArray)
    }

    private fun checkTextAnswer(ans: String, correctChoices: List<String>?): Boolean {
        return correctChoices?.any {
            ans.lowercase(Locale.getDefault()).contains(it.lowercase(Locale.getDefault()))
        } == true
    }

    private fun isEqual(ar1: Array<String>?, ar2: Array<String>?): Boolean {
        ar1?.let { Arrays.sort(it) }
        ar2?.let { Arrays.sort(it) }
        return ar1.contentEquals(ar2)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/mymeetup/MyMeetupDetailFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.mymeetup

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ListView
import android.widget.TextView
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import java.util.ArrayList
import java.util.HashMap
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentMyMeetupDetailBinding
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmMeetup.Companion.getHashMap
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.MeetupRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.showBetaFeature

@AndroidEntryPoint
class MyMeetupDetailFragment : Fragment(), View.OnClickListener {
    private var _binding: FragmentMyMeetupDetailBinding? = null
    private val binding get() = _binding!!
    private var meetups: RealmMeetup? = null
    private var userProfileDbHandler: UserProfileDbHandler? = null
    @Inject
    fun setUserProfileDbHandler(handler: UserProfileDbHandler) {
        userProfileDbHandler = handler
    }
    @Inject
    lateinit var meetupRepository: MeetupRepository
    private var meetUpId: String? = null
    var user: RealmUserModel? = null
    private var listUsers: ListView? = null
    private var listDesc: ListView? = null
    private var tvJoined: TextView? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            meetUpId = requireArguments().getString("id")
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMyMeetupDetailBinding.inflate(inflater, container, false)
        listDesc = binding.root.findViewById(R.id.list_desc)
        listUsers = binding.root.findViewById(R.id.list_users)
        tvJoined = binding.root.findViewById(R.id.tv_joined)
        binding.btnInvite.visibility = if (showBetaFeature(Constants.KEY_MEETUPS, requireContext())) View.VISIBLE else View.GONE
        binding.btnLeave.visibility = if (showBetaFeature(Constants.KEY_MEETUPS, requireContext())) View.VISIBLE else View.GONE
        binding.btnLeave.setOnClickListener(this)
        user = userProfileDbHandler?.getUserModelCopy()
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewLifecycleOwner.lifecycleScope.launch {
            meetups = meetUpId?.takeIf { it.isNotBlank() }?.let { meetupRepository.getMeetupById(it) }
            meetups?.let { setUpData(it) }
            updateAttendanceButton()
            val members = meetUpId?.takeIf { it.isNotBlank() }?.let { meetupRepository.getJoinedMembers(it) }.orEmpty()
            setUserList(members)
        }
    }

    private fun setUserList(users: List<RealmUserModel>) {
        listUsers?.adapter = ArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, users)
        val joinedText = if (users.isEmpty()) {
            """(0) ${getString(R.string.no_members_has_joined_this_meet_up)}"""
        } else {
            users.size.toString()
        }
        tvJoined?.text = String.format(
            getString(R.string.joined_members_colon) + " %s",
            joinedText
        )
    }

    private fun setUpData(meetup: RealmMeetup) {
        binding.meetupTitle.text = meetup.title
        val map: HashMap<String, String> = getHashMap(meetup)
        val keys = ArrayList(map.keys)
        listDesc?.adapter = object : ArrayAdapter<String?>(requireActivity(), R.layout.row_description, keys) {
            override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
                var convertedView = convertView
                if (convertedView == null) {
                    convertedView = LayoutInflater.from(activity).inflate(R.layout.row_description, parent, false)
                }
                (convertedView?.findViewById<View>(R.id.title) as TextView).text = context.getString(R.string.message_placeholder, "${getItem(position)} : ")
                (convertedView.findViewById<View>(R.id.description) as TextView).text = context.getString(R.string.message_placeholder, map[getItem(position)])
                return convertedView
            }
        }
    }

    override fun onClick(view: View) {
        if (view.id == R.id.btn_leave) {
            leaveJoinMeetUp()
        }
    }

    private fun leaveJoinMeetUp() {
        val meetupId = meetUpId ?: return
        viewLifecycleOwner.lifecycleScope.launch {
            meetups = meetupRepository.toggleAttendance(meetupId, user?.id)
            updateAttendanceButton()
            val members = meetupRepository.getJoinedMembers(meetupId)
            setUserList(members)
        }
    }

    private fun updateAttendanceButton() {
        val isJoined = !meetups?.userId.isNullOrEmpty()
        binding.btnLeave.setText(if (isJoined) R.string.leave else R.string.join)
        binding.btnLeave.isEnabled = user?.id?.isNotBlank() == true
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    override fun onDestroy() {
        userProfileDbHandler = null
        super.onDestroy()
    }
}
=======
package org.ole.planet.myplanet.ui.mymeetup


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ListView
import android.widget.TextView
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import java.util.ArrayList
import java.util.HashMap
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentMyMeetupDetailBinding
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmMeetup.Companion.getHashMap
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.MeetupRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.showBetaFeature

@AndroidEntryPoint
class MyMeetupDetailFragment : Fragment(), View.OnClickListener {
    private var _binding: FragmentMyMeetupDetailBinding? = null
    private val binding get() = _binding!!
    private var meetups: RealmMeetup? = null
    private var userProfileDbHandler: UserProfileDbHandler? = null
    @Inject
    fun setUserProfileDbHandler(handler: UserProfileDbHandler) {
        userProfileDbHandler = handler
    }
    @Inject
    lateinit var meetupRepository: MeetupRepository
    private var meetUpId: String? = null
    var user: RealmUserModel? = null
    private var listUsers: ListView? = null
    private var listDesc: ListView? = null
    private var tvJoined: TextView? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            meetUpId = requireArguments().getString("id")
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMyMeetupDetailBinding.inflate(inflater, container, false)
        listDesc = binding.root.findViewById(R.id.list_desc)
        listUsers = binding.root.findViewById(R.id.list_users)
        tvJoined = binding.root.findViewById(R.id.tv_joined)
        binding.btnInvite.visibility = if (showBetaFeature(Constants.KEY_MEETUPS, requireContext())) View.VISIBLE else View.GONE
        binding.btnLeave.visibility = if (showBetaFeature(Constants.KEY_MEETUPS, requireContext())) View.VISIBLE else View.GONE
        binding.btnLeave.setOnClickListener(this)
        user = userProfileDbHandler?.getUserModelCopy()
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewLifecycleOwner.lifecycleScope.launch {
            meetups = meetUpId?.takeIf { it.isNotBlank() }?.let { meetupRepository.getMeetupById(it) }
            meetups?.let { setUpData(it) }
            updateAttendanceButton()
            val members = meetUpId?.takeIf { it.isNotBlank() }?.let { meetupRepository.getJoinedMembers(it) }.orEmpty()
            setUserList(members)
        }
    }

    private fun setUserList(users: List<RealmUserModel>) {
        listUsers?.adapter = ArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, users)
        val joinedText = if (users.isEmpty()) {
            """(0) ${getString(R.string.no_members_has_joined_this_meet_up)}"""
        } else {
            users.size.toString()
        }
        tvJoined?.text = String.format(
            getString(R.string.joined_members_colon) + " %s",
            joinedText
        )
    }

    private fun setUpData(meetup: RealmMeetup) {
        binding.meetupTitle.text = meetup.title
        val map: HashMap<String, String> = getHashMap(meetup)
        val keys = ArrayList(map.keys)
        listDesc?.adapter = object : ArrayAdapter<String?>(requireActivity(), R.layout.row_description, keys) {
            override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
                var convertedView = convertView
                if (convertedView == null) {
                    convertedView = LayoutInflater.from(activity).inflate(R.layout.row_description, parent, false)
                }
                (convertedView?.findViewById<View>(R.id.title) as TextView).text = context.getString(R.string.message_placeholder, "${getItem(position)} : ")
                (convertedView.findViewById<View>(R.id.description) as TextView).text = context.getString(R.string.message_placeholder, map[getItem(position)])
                return convertedView
            }
        }
    }

    override fun onClick(view: View) {
        if (view.id == R.id.btn_leave) {
            leaveJoinMeetUp()
        }
    }

    private fun leaveJoinMeetUp() {
        val meetupId = meetUpId ?: return
        viewLifecycleOwner.lifecycleScope.launch {
            meetups = meetupRepository.toggleAttendance(meetupId, user?.id)
            updateAttendanceButton()
            val members = meetupRepository.getJoinedMembers(meetupId)
            setUserList(members)
        }
    }

    private fun updateAttendanceButton() {
        val isJoined = !meetups?.userId.isNullOrEmpty()
        binding.btnLeave.setText(if (isJoined) R.string.leave else R.string.join)
        binding.btnLeave.isEnabled = user?.id?.isNotBlank() == true
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    override fun onDestroy() {
        userProfileDbHandler = null
        super.onDestroy()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/mymeetup/AdapterMeetup.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.mymeetup

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ItemMeetupBinding
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate

class AdapterMeetup : ListAdapter<RealmMeetup, AdapterMeetup.ViewHolderMeetup>(DIFF_CALLBACK) {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderMeetup {
        val binding = ItemMeetupBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderMeetup(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderMeetup, position: Int) {
        val meetup = getItem(position)
        val binding = holder.binding
        val context = binding.root.context
        binding.tvTitle.text = context.getString(R.string.message_placeholder, meetup.title)
        binding.tvDescription.text = context.getString(R.string.message_placeholder, meetup.description)
        binding.tvDateFrom.text = formatDate(meetup.startDate)
        binding.tvDateTo.text = formatDate(meetup.endDate)
        binding.tvTime.text = "${meetup.startTime} - ${meetup.endTime}"
        binding.tvLocation.text = context.getString(R.string.message_placeholder, meetup.meetupLocation)
        binding.tvLink.text = context.getString(R.string.message_placeholder, meetup.meetupLink)
        binding.tvRecurring.text = context.getString(R.string.message_placeholder, meetup.recurring)
        binding.tvCreator.text = context.getString(R.string.message_placeholder, meetup.creator)
    }

    class ViewHolderMeetup(val binding: ItemMeetupBinding) : RecyclerView.ViewHolder(binding.root)

    companion object {
        val DIFF_CALLBACK = DiffUtils.itemCallback<RealmMeetup>(
            areItemsTheSame = { oldItem, newItem -> oldItem.id == newItem.id },
            areContentsTheSame = { oldItem, newItem -> oldItem == newItem }
        )
    }
}
=======
package org.ole.planet.myplanet.ui.mymeetup


import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ItemMeetupBinding
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate

class AdapterMeetup : ListAdapter<RealmMeetup, AdapterMeetup.ViewHolderMeetup>(DIFF_CALLBACK) {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderMeetup {
        val binding = ItemMeetupBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderMeetup(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderMeetup, position: Int) {
        val meetup = getItem(position)
        val binding = holder.binding
        val context = binding.root.context
        binding.tvTitle.text = context.getString(R.string.message_placeholder, meetup.title)
        binding.tvDescription.text = context.getString(R.string.message_placeholder, meetup.description)
        binding.tvDateFrom.text = formatDate(meetup.startDate)
        binding.tvDateTo.text = formatDate(meetup.endDate)
        binding.tvTime.text = "${meetup.startTime} - ${meetup.endTime}"
        binding.tvLocation.text = context.getString(R.string.message_placeholder, meetup.meetupLocation)
        binding.tvLink.text = context.getString(R.string.message_placeholder, meetup.meetupLink)
        binding.tvRecurring.text = context.getString(R.string.message_placeholder, meetup.recurring)
        binding.tvCreator.text = context.getString(R.string.message_placeholder, meetup.creator)
    }

    class ViewHolderMeetup(val binding: ItemMeetupBinding) : RecyclerView.ViewHolder(binding.root)

    companion object {
        val DIFF_CALLBACK = DiffUtils.itemCallback<RealmMeetup>(
            areItemsTheSame = { oldItem, newItem -> oldItem.id == newItem.id },
            areContentsTheSame = { oldItem, newItem -> oldItem == newItem }
        )
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/sync/ProcessUserDataActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.sync

import android.content.BroadcastReceiver
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.content.SharedPreferences
import android.content.res.Configuration
import android.graphics.Color
import android.graphics.PorterDuff
import android.net.Uri
import android.os.Build
import android.text.TextUtils
import android.view.View
import android.view.inputmethod.InputMethodManager
import android.webkit.URLUtil
import android.widget.ImageView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatDelegate
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import androidx.core.net.toUri
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import java.util.concurrent.atomic.AtomicInteger
import javax.inject.Inject
import kotlin.math.roundToInt
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.PermissionActivity
import org.ole.planet.myplanet.callback.SecurityDataCallback
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.Download
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UploadToShelfService
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.DialogUtils.showAlert
import org.ole.planet.myplanet.utilities.DialogUtils.showError
import org.ole.planet.myplanet.utilities.FileUtils.installApk
import org.ole.planet.myplanet.utilities.UrlUtils

@AndroidEntryPoint
abstract class ProcessUserDataActivity : PermissionActivity(), SuccessListener {

    @Inject
    @AppPreferences
    lateinit var appPreferences: SharedPreferences

    @Inject
    lateinit var databaseService: DatabaseService

    @Inject
    lateinit var uploadManager: UploadManager

    @Inject
    lateinit var uploadToShelfService: UploadToShelfService

    @Inject
    lateinit var userRepository: UserRepository
    lateinit var settings: SharedPreferences
    val customProgressDialog: DialogUtils.CustomProgressDialog by lazy {
        DialogUtils.CustomProgressDialog(this)
    }

    @JvmField
    var broadcastReceiver: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (intent.action == DashboardActivity.MESSAGE_PROGRESS) {
                val download: Download? = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    intent.getParcelableExtra("download", Download::class.java)
                } else {
                    @Suppress("DEPRECATION")
                    intent.getParcelableExtra("download")
                }
                val fromSync = intent.getBooleanExtra("fromSync", false)
                if (!fromSync) {
                    checkDownloadResult(download)
                }
            }
        }
    }

    fun checkDownloadResult(download: Download?) {
        runOnUiThread {
            if (!isFinishing && !isDestroyed) {
                customProgressDialog.show()
                customProgressDialog.setText("${getString(R.string.downloading)} ${download?.progress}% ${getString(R.string.complete)}")
                customProgressDialog.setProgress(download?.progress ?: 0)
                if (download?.completeAll == true) {
                    safelyDismissDialog()
                    installApk(this, download.fileUrl)
                } else {
                    safelyDismissDialog()
                    showError(customProgressDialog, download?.message)
                }
            }
        }
    }

    private fun safelyDismissDialog() {
        if (customProgressDialog.isShowing() && !isFinishing) {
            try {
                customProgressDialog.dismiss()
            } catch (e: IllegalArgumentException) {
                e.printStackTrace()
            }
        }
    }

    fun openDashboard() {
        val dashboard = Intent(applicationContext, DashboardActivity::class.java)
            .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
            .putExtra("from_login", true)
        startActivity(dashboard)
        finish()
    }

    fun changeLogoColor() {
        val logo = findViewById<ImageView>(R.id.logoImageView)
        val newColor = ContextCompat.getColor(this, android.R.color.white)
        val alpha = (Color.alpha(newColor) * 10).toFloat().roundToInt()
        val red = Color.red(newColor)
        val green = Color.green(newColor)
        val blue = Color.blue(newColor)
        val alphaWhite = Color.argb(alpha, red, green, blue)
        val currentNightMode = resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK
        if (AppCompatDelegate.getDefaultNightMode() == AppCompatDelegate.MODE_NIGHT_NO ||
            (AppCompatDelegate.getDefaultNightMode() == AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM && currentNightMode == Configuration.UI_MODE_NIGHT_NO)) {
            logo.setColorFilter(alphaWhite, PorterDuff.Mode.SRC_ATOP)
        }
    }

    fun setUrlParts(url: String, password: String): String {
        val editor = settings.edit()
        val uri = url.toUri()
        var couchdbURL: String
        val urlUser: String
        val urlPwd: String
        if (url.contains("@")) {
            val userinfo = getUserInfo(uri)
            urlUser = userinfo[0]
            urlPwd = userinfo[1]
            couchdbURL = url
        } else if (TextUtils.isEmpty(password)) {
            showAlert(this, "", getString(R.string.pin_is_required))
            return ""
        } else {
            urlUser = "satellite"
            urlPwd = password
            couchdbURL = "${uri.scheme}://$urlUser:$urlPwd@${uri.host}:${if (uri.port == -1) (if (uri.scheme == "http") 80 else 443) else uri.port}"
        }
        editor.putString("serverPin", password)
        saveUrlScheme(editor, uri, url, couchdbURL)
        editor.putString("url_user", urlUser)
        editor.putString("url_pwd", urlPwd)
        editor.putString("url_Scheme", uri.scheme)
        editor.putString("url_Host", uri.host)
        editor.apply()
        if (!couchdbURL.endsWith("db")) {
            couchdbURL += "/db"
        }
        return couchdbURL
    }

    fun isUrlValid(url: String): Boolean {
        if (!URLUtil.isValidUrl(url) || url == "http://" || url == "https://") {
            showAlert(this, getString(R.string.invalid_url), getString(R.string.please_enter_valid_url_to_continue))
            return false
        }
        return true
    }

    fun startUpload(source: String, userName: String? = null, securityCallback: SecurityDataCallback? = null) {
        if (source == "becomeMember") {
            uploadToShelfService.uploadSingleUserData(userName, object : SuccessListener {
                override fun onSuccess(success: String?) {
                    uploadToShelfService.uploadSingleUserHealth("org.couchdb.user:${userName}", object : SuccessListener {
                        override fun onSuccess(success: String?) {
                            userName?.let { name ->
                                fetchAndLogUserSecurityData(name, securityCallback)
                            } ?: run {
                                securityCallback?.onSecurityDataUpdated()
                            }
                        }
                    })
                }
            })
            return
        } else if (source == "login") {
            lifecycleScope.launch(Dispatchers.IO) {
                uploadManager.uploadUserActivities(this@ProcessUserDataActivity)
            }
            return
        }
        customProgressDialog.setText(this.getString(R.string.uploading_data_to_server_please_wait))
        customProgressDialog.show()

        lifecycleScope.launch {
            val asyncOperationsCounter = AtomicInteger(0)
            val totalAsyncOperations = 6

            fun checkAllOperationsComplete() {
                if (asyncOperationsCounter.incrementAndGet() == totalAsyncOperations) {
                    runOnUiThread {
                        if (!isFinishing && !isDestroyed) {
                            customProgressDialog.dismiss()
                            Toast.makeText(this@ProcessUserDataActivity, "upload complete", Toast.LENGTH_SHORT).show()
                        }
                    }
                }
            }

            uploadManager.uploadAchievement()
            uploadManager.uploadNews()
            uploadManager.uploadResourceActivities("")
            uploadManager.uploadCourseActivities()
            uploadManager.uploadSearchActivity()
            uploadManager.uploadTeams()
            uploadManager.uploadRating()
            uploadManager.uploadTeamTask()
            uploadManager.uploadMeetups()
            uploadManager.uploadSubmissions()
            uploadManager.uploadCrashLog()

            uploadToShelfService.uploadUserData {
                uploadToShelfService.uploadHealth()
                checkAllOperationsComplete()
            }

            uploadManager.uploadUserActivities(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    checkAllOperationsComplete()
                }
            })

            launch(Dispatchers.IO) {
                uploadManager.uploadExamResult(object : SuccessListener {
                    override fun onSuccess(success: String?) {
                        checkAllOperationsComplete()
                    }
                })
            }

            uploadManager.uploadFeedback(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    checkAllOperationsComplete()
                }
            })

            uploadManager.uploadResource(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    checkAllOperationsComplete()
                }
            })

            uploadManager.uploadSubmitPhotos(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    checkAllOperationsComplete()
                }
            })

            uploadManager.uploadActivities(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    checkAllOperationsComplete()
                }
            })
        }
    }

    protected fun hideKeyboard(view: View?) {
        val `in` = getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager
        `in`.hideSoftInputFromWindow(view?.windowToken, InputMethodManager.HIDE_NOT_ALWAYS)
    }

    fun saveUserInfoPref(settings: SharedPreferences, password: String?, user: RealmUserModel?) {
        this.settings = settings ?: appPreferences
        settings.edit {
            putString("userId", user?.id)
            putString("name", user?.name)
            putString("password", password)
            putString("firstName", user?.firstName)
            putString("lastName", user?.lastName)
            putString("middleName", user?.middleName)
            user?.userAdmin?.let { putBoolean("isUserAdmin", it) }
            putLong("lastLogin", System.currentTimeMillis())
        }
    }

    fun alertDialogOkay(message: String?) {
        val builder1 = AlertDialog.Builder(this, R.style.AlertDialogTheme)
        builder1.setMessage(message)
        builder1.setCancelable(true)
        builder1.setNegativeButton(R.string.okay) { dialog: DialogInterface, _: Int -> dialog.cancel() }
        val alert11 = builder1.create()
        alert11.show()
    }

    companion object {
        fun getUserInfo(uri: Uri): Array<String> {
            val ar = arrayOf("", "")
            val info =
                uri.userInfo?.split(":".toRegex())?.dropLastWhile { it.isEmpty() }?.toTypedArray()
            if ((info?.size ?: 0) > 1) {
                ar[0] = "${info?.get(0)}"
                ar[1] = "${info?.get(1)}"
            }
            return ar
        }
    }

    private fun saveUrlScheme(editor: SharedPreferences.Editor, uri: Uri, url: String?, couchdbURL: String?) {
        editor.putString("url_Scheme", uri.scheme)
        editor.putString("url_Host", uri.host)
        editor.putInt("url_Port", if (uri.port == -1) (if (uri.scheme == "http") 80 else 443) else uri.port)
        editor.putString("serverURL", url)
        editor.putString("couchdbURL", couchdbURL)
    }

    fun fetchAndLogUserSecurityData(name: String, securityCallback: SecurityDataCallback? = null) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val apiInterface = client?.create(ApiInterface::class.java)
                val userDocUrl = "${UrlUtils.getUrl()}/tablet_users/org.couchdb.user:$name"
                val response = apiInterface?.getJsonObject(UrlUtils.header, userDocUrl)?.execute()

                if (response?.isSuccessful == true && response.body() != null) {
                    val userDoc = response.body()
                    val derivedKey = userDoc?.get("derived_key")?.asString
                    val salt = userDoc?.get("salt")?.asString
                    val passwordScheme = userDoc?.get("password_scheme")?.asString
                    val iterations = userDoc?.get("iterations")?.asString
                    val userId = userDoc?.get("_id")?.asString
                    val rev = userDoc?.get("_rev")?.asString
                    updateRealmUserSecurityData(name, userId, rev, derivedKey, salt, passwordScheme, iterations, securityCallback)

                } else {
                    withContext(Dispatchers.Main) {
                        securityCallback?.onSecurityDataUpdated()
                    }
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    e.printStackTrace()
                    securityCallback?.onSecurityDataUpdated()
                }
            }
        }
    }

    private suspend fun updateRealmUserSecurityData(
        name: String,
        userId: String?,
        rev: String?,
        derivedKey: String?,
        salt: String?,
        passwordScheme: String?,
        iterations: String?,
        securityCallback: SecurityDataCallback? = null,
    ) {
        try {
            userRepository.updateSecurityData(name, userId, rev, derivedKey, salt, passwordScheme, iterations)
            withContext(Dispatchers.Main) {
                securityCallback?.onSecurityDataUpdated()
            }
        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                e.printStackTrace()
                securityCallback?.onSecurityDataUpdated()
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.sync


import android.content.BroadcastReceiver
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.content.SharedPreferences
import android.content.res.Configuration
import android.graphics.Color
import android.graphics.PorterDuff
import android.net.Uri
import android.os.Build
import android.text.TextUtils
import android.view.View
import android.view.inputmethod.InputMethodManager
import android.webkit.URLUtil
import android.widget.ImageView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatDelegate
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import androidx.core.net.toUri
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import java.util.concurrent.atomic.AtomicInteger
import javax.inject.Inject
import kotlin.math.roundToInt
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.PermissionActivity
import org.ole.planet.myplanet.callback.SecurityDataCallback
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.Download
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UploadToShelfService
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.DialogUtils.showAlert
import org.ole.planet.myplanet.utilities.DialogUtils.showError
import org.ole.planet.myplanet.utilities.FileUtils.installApk
import org.ole.planet.myplanet.utilities.UrlUtils

@AndroidEntryPoint
abstract class ProcessUserDataActivity : PermissionActivity(), SuccessListener {

    @Inject
    @AppPreferences
    lateinit var appPreferences: SharedPreferences

    @Inject
    lateinit var databaseService: DatabaseService

    @Inject
    lateinit var uploadManager: UploadManager

    @Inject
    lateinit var uploadToShelfService: UploadToShelfService

    @Inject
    lateinit var userRepository: UserRepository
    lateinit var settings: SharedPreferences
    val customProgressDialog: DialogUtils.CustomProgressDialog by lazy {
        DialogUtils.CustomProgressDialog(this)
    }

    @JvmField
    var broadcastReceiver: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (intent.action == DashboardActivity.MESSAGE_PROGRESS) {
                val download: Download? = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    intent.getParcelableExtra("download", Download::class.java)
                } else {
                    @Suppress("DEPRECATION")
                    intent.getParcelableExtra("download")
                }
                val fromSync = intent.getBooleanExtra("fromSync", false)
                if (!fromSync) {
                    checkDownloadResult(download)
                }
            }
        }
    }

    fun checkDownloadResult(download: Download?) {
        runOnUiThread {
            if (!isFinishing && !isDestroyed) {
                customProgressDialog.show()
                customProgressDialog.setText("${getString(R.string.downloading)} ${download?.progress}% ${getString(R.string.complete)}")
                customProgressDialog.setProgress(download?.progress ?: 0)
                if (download?.completeAll == true) {
                    safelyDismissDialog()
                    installApk(this, download.fileUrl)
                } else {
                    safelyDismissDialog()
                    showError(customProgressDialog, download?.message)
                }
            }
        }
    }

    private fun safelyDismissDialog() {
        if (customProgressDialog.isShowing() && !isFinishing) {
            try {
                customProgressDialog.dismiss()
            } catch (e: IllegalArgumentException) {
                e.printStackTrace()
            }
        }
    }

    fun openDashboard() {
        val dashboard = Intent(applicationContext, DashboardActivity::class.java)
            .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
            .putExtra("from_login", true)
        startActivity(dashboard)
        finish()
    }

    fun changeLogoColor() {
        val logo = findViewById<ImageView>(R.id.logoImageView)
        val newColor = ContextCompat.getColor(this, android.R.color.white)
        val alpha = (Color.alpha(newColor) * 10).toFloat().roundToInt()
        val red = Color.red(newColor)
        val green = Color.green(newColor)
        val blue = Color.blue(newColor)
        val alphaWhite = Color.argb(alpha, red, green, blue)
        val currentNightMode = resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK
        if (AppCompatDelegate.getDefaultNightMode() == AppCompatDelegate.MODE_NIGHT_NO ||
            (AppCompatDelegate.getDefaultNightMode() == AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM && currentNightMode == Configuration.UI_MODE_NIGHT_NO)) {
            logo.setColorFilter(alphaWhite, PorterDuff.Mode.SRC_ATOP)
        }
    }

    fun setUrlParts(url: String, password: String): String {
        val editor = settings.edit()
        val uri = url.toUri()
        var couchdbURL: String
        val urlUser: String
        val urlPwd: String
        if (url.contains("@")) {
            val userinfo = getUserInfo(uri)
            urlUser = userinfo[0]
            urlPwd = userinfo[1]
            couchdbURL = url
        } else if (TextUtils.isEmpty(password)) {
            showAlert(this, "", getString(R.string.pin_is_required))
            return ""
        } else {
            urlUser = "satellite"
            urlPwd = password
            couchdbURL = "${uri.scheme}://$urlUser:$urlPwd@${uri.host}:${if (uri.port == -1) (if (uri.scheme == "http") 80 else 443) else uri.port}"
        }
        editor.putString("serverPin", password)
        saveUrlScheme(editor, uri, url, couchdbURL)
        editor.putString("url_user", urlUser)
        editor.putString("url_pwd", urlPwd)
        editor.putString("url_Scheme", uri.scheme)
        editor.putString("url_Host", uri.host)
        editor.apply()
        if (!couchdbURL.endsWith("db")) {
            couchdbURL += "/db"
        }
        return couchdbURL
    }

    fun isUrlValid(url: String): Boolean {
        if (!URLUtil.isValidUrl(url) || url == "http://" || url == "https://") {
            showAlert(this, getString(R.string.invalid_url), getString(R.string.please_enter_valid_url_to_continue))
            return false
        }
        return true
    }

    fun startUpload(source: String, userName: String? = null, securityCallback: SecurityDataCallback? = null) {
        if (source == "becomeMember") {
            uploadToShelfService.uploadSingleUserData(userName, object : SuccessListener {
                override fun onSuccess(success: String?) {
                    uploadToShelfService.uploadSingleUserHealth("org.couchdb.user:${userName}", object : SuccessListener {
                        override fun onSuccess(success: String?) {
                            userName?.let { name ->
                                fetchAndLogUserSecurityData(name, securityCallback)
                            } ?: run {
                                securityCallback?.onSecurityDataUpdated()
                            }
                        }
                    })
                }
            })
            return
        } else if (source == "login") {
            lifecycleScope.launch(Dispatchers.IO) {
                uploadManager.uploadUserActivities(this@ProcessUserDataActivity)
            }
            return
        }
        customProgressDialog.setText(this.getString(R.string.uploading_data_to_server_please_wait))
        customProgressDialog.show()

        lifecycleScope.launch {
            val asyncOperationsCounter = AtomicInteger(0)
            val totalAsyncOperations = 6

            fun checkAllOperationsComplete() {
                if (asyncOperationsCounter.incrementAndGet() == totalAsyncOperations) {
                    runOnUiThread {
                        if (!isFinishing && !isDestroyed) {
                            customProgressDialog.dismiss()
                            Toast.makeText(this@ProcessUserDataActivity, "upload complete", Toast.LENGTH_SHORT).show()
                        }
                    }
                }
            }

            uploadManager.uploadAchievement()
            uploadManager.uploadNews()
            uploadManager.uploadResourceActivities("")
            uploadManager.uploadCourseActivities()
            uploadManager.uploadSearchActivity()
            uploadManager.uploadTeams()
            uploadManager.uploadRating()
            uploadManager.uploadTeamTask()
            uploadManager.uploadMeetups()
            uploadManager.uploadSubmissions()
            uploadManager.uploadCrashLog()

            uploadToShelfService.uploadUserData {
                uploadToShelfService.uploadHealth()
                checkAllOperationsComplete()
            }

            uploadManager.uploadUserActivities(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    checkAllOperationsComplete()
                }
            })

            launch(Dispatchers.IO) {
                uploadManager.uploadExamResult(object : SuccessListener {
                    override fun onSuccess(success: String?) {
                        checkAllOperationsComplete()
                    }
                })
            }

            uploadManager.uploadFeedback(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    checkAllOperationsComplete()
                }
            })

            uploadManager.uploadResource(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    checkAllOperationsComplete()
                }
            })

            uploadManager.uploadSubmitPhotos(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    checkAllOperationsComplete()
                }
            })

            uploadManager.uploadActivities(object : SuccessListener {
                override fun onSuccess(success: String?) {
                    checkAllOperationsComplete()
                }
            })
        }
    }

    protected fun hideKeyboard(view: View?) {
        val `in` = getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager
        `in`.hideSoftInputFromWindow(view?.windowToken, InputMethodManager.HIDE_NOT_ALWAYS)
    }

    fun saveUserInfoPref(settings: SharedPreferences, password: String?, user: RealmUserModel?) {
        this.settings = settings ?: appPreferences
        settings.edit {
            putString("userId", user?.id)
            putString("name", user?.name)
            putString("password", password)
            putString("firstName", user?.firstName)
            putString("lastName", user?.lastName)
            putString("middleName", user?.middleName)
            user?.userAdmin?.let { putBoolean("isUserAdmin", it) }
            putLong("lastLogin", System.currentTimeMillis())
        }
    }

    fun alertDialogOkay(message: String?) {
        val builder1 = AlertDialog.Builder(this, R.style.AlertDialogTheme)
        builder1.setMessage(message)
        builder1.setCancelable(true)
        builder1.setNegativeButton(R.string.okay) { dialog: DialogInterface, _: Int -> dialog.cancel() }
        val alert11 = builder1.create()
        alert11.show()
    }

    companion object {
        fun getUserInfo(uri: Uri): Array<String> {
            val ar = arrayOf("", "")
            val info =
                uri.userInfo?.split(":".toRegex())?.dropLastWhile { it.isEmpty() }?.toTypedArray()
            if ((info?.size ?: 0) > 1) {
                ar[0] = "${info?.get(0)}"
                ar[1] = "${info?.get(1)}"
            }
            return ar
        }
    }

    private fun saveUrlScheme(editor: SharedPreferences.Editor, uri: Uri, url: String?, couchdbURL: String?) {
        editor.putString("url_Scheme", uri.scheme)
        editor.putString("url_Host", uri.host)
        editor.putInt("url_Port", if (uri.port == -1) (if (uri.scheme == "http") 80 else 443) else uri.port)
        editor.putString("serverURL", url)
        editor.putString("couchdbURL", couchdbURL)
    }

    fun fetchAndLogUserSecurityData(name: String, securityCallback: SecurityDataCallback? = null) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val apiInterface = client?.create(ApiInterface::class.java)
                val userDocUrl = "${UrlUtils.getUrl()}/tablet_users/org.couchdb.user:$name"
                val response = apiInterface?.getJsonObject(UrlUtils.header, userDocUrl)?.execute()

                if (response?.isSuccessful == true && response.body() != null) {
                    val userDoc = response.body()
                    val derivedKey = userDoc?.get("derived_key")?.asString
                    val salt = userDoc?.get("salt")?.asString
                    val passwordScheme = userDoc?.get("password_scheme")?.asString
                    val iterations = userDoc?.get("iterations")?.asString
                    val userId = userDoc?.get("_id")?.asString
                    val rev = userDoc?.get("_rev")?.asString
                    updateRealmUserSecurityData(name, userId, rev, derivedKey, salt, passwordScheme, iterations, securityCallback)

                } else {
                    withContext(Dispatchers.Main) {
                        securityCallback?.onSecurityDataUpdated()
                    }
                }

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    e.printStackTrace()
                    securityCallback?.onSecurityDataUpdated()
                }
            }
        }
    }

    private suspend fun updateRealmUserSecurityData(
        name: String,
        userId: String?,
        rev: String?,
        derivedKey: String?,
        salt: String?,
        passwordScheme: String?,
        iterations: String?,
        securityCallback: SecurityDataCallback? = null,
    ) {
        try {
            userRepository.updateSecurityData(name, userId, rev, derivedKey, salt, passwordScheme, iterations)
            withContext(Dispatchers.Main) {
                securityCallback?.onSecurityDataUpdated()
            }
        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                e.printStackTrace()
                securityCallback?.onSecurityDataUpdated()
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/sync/DashboardElementActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.sync

import android.annotation.SuppressLint
import android.content.Intent
import android.graphics.PorterDuff
import android.net.ConnectivityManager
import android.net.wifi.WifiManager
import android.os.Bundle
import android.provider.Settings
import android.view.ContextThemeWrapper
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuItem
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import androidx.core.graphics.drawable.DrawableCompat
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager
import androidx.lifecycle.lifecycleScope
import com.afollestad.materialdialogs.MaterialDialog
import com.google.android.material.bottomnavigation.BottomNavigationView
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.DialogServerUrlBinding
import org.ole.planet.myplanet.model.RealmUserChallengeActions.Companion.createActionAsync
import org.ole.planet.myplanet.ui.community.CommunityTabFragment
import org.ole.planet.myplanet.ui.courses.CoursesFragment
import org.ole.planet.myplanet.ui.dashboard.BellDashboardFragment
import org.ole.planet.myplanet.ui.feedback.FeedbackFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.rating.RatingFragment.Companion.newInstance
import org.ole.planet.myplanet.ui.resources.ResourcesFragment
import org.ole.planet.myplanet.ui.team.TeamFragment
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.Constants.isBetaWifiFeatureEnabled
import org.ole.planet.myplanet.utilities.NotificationUtils
import org.ole.planet.myplanet.utilities.SecurePrefs
import org.ole.planet.myplanet.utilities.SharedPrefManager

abstract class DashboardElementActivity : SyncActivity(), FragmentManager.OnBackStackChangedListener {
    lateinit var navigationView: BottomNavigationView
    var doubleBackToExitPressedOnce = false
    private lateinit var goOnline: MenuItem
    var c = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        settings = applicationContext.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        prefData = SharedPrefManager(this)
        supportFragmentManager.addOnBackStackChangedListener(this)
    }

    fun onClickTabItems(position: Int) {
        when (position) {
            0 -> openCallFragment(BellDashboardFragment(), "dashboard")
            1 -> openCallFragment(ResourcesFragment(), "library")
            2 -> openCallFragment(CoursesFragment(), "course")
            4 -> openEnterpriseFragment()
            3 -> openCallFragment(TeamFragment(), "survey")
            5 -> {
                openCallFragment(CommunityTabFragment(), "community")
            }
        }
    }

    protected fun bindGoOnlineMenu(menu: Menu) {
        goOnline = menu.findItem(R.id.menu_goOnline)
        updateGoOnlineVisibility()
    }

    fun openCallFragment(newFragment: Fragment, tag: String?) {
        val fragmentManager = supportFragmentManager
        if(c<2){
            c=0
        }
        val existingFragment = fragmentManager.findFragmentByTag(tag)
        if (tag == "") {
            c++
            if(c>2){
                c--
                NavigationHelper.popBackStack(fragmentManager, tag, 0)
            }else{
                NavigationHelper.replaceFragment(
                    fragmentManager,
                    R.id.fragment_container,
                    newFragment,
                    addToBackStack = true,
                    tag = tag
                )
            }
        } else {
            if (existingFragment != null && existingFragment.isVisible) {
                return
            } else if (existingFragment != null) {
                if(c>0 && c>2){
                    c=0
                }
                NavigationHelper.popBackStack(fragmentManager, tag, 0)
            } else {
                if(c>0 && c>2){
                    c=0
                }
                if(tag!="") {
                    NavigationHelper.replaceFragment(
                        fragmentManager,
                        R.id.fragment_container,
                        newFragment,
                        addToBackStack = true,
                        tag = tag
                    )
                }
            }
        }
    }
    protected fun updateGoOnlineVisibility() {
        if (::goOnline.isInitialized) {
            goOnline.isVisible = isBetaWifiFeatureEnabled(this)
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_goOnline -> {
                wifiStatusSwitch()
                return true
            }
            R.id.action_logout -> {
                logout()
            }
            R.id.action_feedback -> {
                openCallFragment(FeedbackFragment(), getString(R.string.menu_feedback))
            }
            R.id.action_sync -> {
                logSyncInSharedPrefs()
            }
        }
        return super.onOptionsItemSelected(item)
    }

    fun logSyncInSharedPrefs() {
        val protocol = settings.getString("serverProtocol", "")
        val serverUrl = "${settings.getString("serverURL", "")}"
        val serverPin = "${settings.getString("serverPin", "")}"

        val url = if (serverUrl.startsWith("http://") || serverUrl.startsWith("https://")) {
            serverUrl
        } else {
            "$protocol$serverUrl"
        }

        val dialogServerUrlBinding = DialogServerUrlBinding.inflate(LayoutInflater.from(this))
        val contextWrapper = ContextThemeWrapper(this, R.style.AlertDialogTheme)

        val builder = MaterialDialog.Builder(contextWrapper)
            .customView(dialogServerUrlBinding.root, true)

        val dialog = builder.build()
        currentDialog = dialog
        service.getMinApk(this, url, serverPin, this, "DashboardActivity")
        createActionAsync("${profileDbHandler.userModel?.id}", null, "sync")
    }

    @SuppressLint("RestrictedApi")
    fun wifiStatusSwitch() {
        val resIcon = ContextCompat.getDrawable(this, R.drawable.goonline)
        val connManager = getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager
        val wifi = applicationContext.getSystemService(WIFI_SERVICE) as WifiManager
        val mWifi = connManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI)
        val intent = Intent(Settings.ACTION_WIFI_SETTINGS)
        startActivity(intent)
        if (mWifi?.isConnected == true) {
            wifi.isWifiEnabled = false
            if (resIcon != null) {
                DrawableCompat.setTintMode(resIcon.mutate(), PorterDuff.Mode.SRC_ATOP)
                DrawableCompat.setTint(resIcon, ContextCompat.getColor(this, R.color.green))
            }
            goOnline.icon = resIcon
            Toast.makeText(this, getString(R.string.wifi_is_turned_off_saving_battery_power), Toast.LENGTH_LONG).show()
        } else {
            wifi.isWifiEnabled = true
            Toast.makeText(this, getString(R.string.turning_on_wifi_please_wait), Toast.LENGTH_LONG).show()
            lifecycleScope.launch {
                delay(5000)
                connectToWifi()
            }
            if (resIcon != null) {
                DrawableCompat.setTintMode(resIcon.mutate(), PorterDuff.Mode.SRC_ATOP)
                DrawableCompat.setTint(resIcon, ContextCompat.getColor(this, R.color.accent))
            }
            goOnline.icon = resIcon
        }
    }

    private fun connectToWifi() {
        val id = settings.getInt("LastWifiID", -1)
        val wifiManager = applicationContext.getSystemService(WIFI_SERVICE) as WifiManager
        val netId: Int
        for (tmp in wifiManager.configuredNetworks) {
            if (tmp.networkId > -1 && tmp.networkId == id) {
                netId = tmp.networkId
                wifiManager.enableNetwork(netId, true)
                Toast.makeText(this, R.string.you_are_now_connected + netId, Toast.LENGTH_SHORT).show()
                lifecycleScope.launch {
                    broadcastService.sendBroadcast(Intent("ACTION_NETWORK_CHANGED"))
                }
                break
            }
        }
    }

    fun logout() {
        lifecycleScope.launch {
            profileDbHandler.logoutAsync()
            SecurePrefs.clearCredentials(this@DashboardElementActivity)
            settings.edit { putBoolean(Constants.KEY_LOGIN, false) }
            settings.edit { putBoolean(Constants.KEY_NOTIFICATION_SHOWN, false) }
            NotificationUtils.cancelAll(this@DashboardElementActivity)

            val loginScreen = Intent(this@DashboardElementActivity, LoginActivity::class.java)
                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK)
                .putExtra("fromLogout", true)
            startActivity(loginScreen)
            doubleBackToExitPressedOnce = true
            finish()
        }
    }

    override fun finish() {
        if (doubleBackToExitPressedOnce) {
            super.finish()
        } else {
            doubleBackToExitPressedOnce = true
            Toast.makeText(this, getString(R.string.press_back_again_to_exit), Toast.LENGTH_SHORT).show()
            lifecycleScope.launch {
                delay(2000)
                doubleBackToExitPressedOnce = false
            }
        }
    }

    fun showRatingDialog(type: String?, resourceId: String?, title: String?, listener: OnRatingChangeListener?) {
        val f = newInstance(type, resourceId, title)
        f.setListener(listener)
        f.show(supportFragmentManager, "")
    }

    override fun onBackStackChanged() {
        val f = supportFragmentManager.findFragmentById(R.id.fragment_container)
        val fragmentTag = f?.tag
        if (f is CoursesFragment) {
            if ("MyCoursesFragment" == fragmentTag) {
                navigationView.menu.findItem(R.id.menu_mycourses).isChecked = true
            } else {
                navigationView.menu.findItem(R.id.menu_courses).isChecked = true
            }
        } else if (f is ResourcesFragment) {
            if ("MyResourcesFragment" == fragmentTag) {
                navigationView.menu.findItem(R.id.menu_mylibrary).isChecked = true
            } else {
                navigationView.menu.findItem(R.id.menu_library).isChecked = true
            }
        }
    }

    fun openEnterpriseFragment() {
        val fragment: Fragment = TeamFragment()
        val b = Bundle()
        b.putString("type", "enterprise")
        fragment.arguments = b
        openCallFragment(fragment, "Enterprise")
    }
}
=======
package org.ole.planet.myplanet.ui.sync


import android.annotation.SuppressLint
import android.content.Intent
import android.graphics.PorterDuff
import android.net.ConnectivityManager
import android.net.wifi.WifiManager
import android.os.Bundle
import android.provider.Settings
import android.view.ContextThemeWrapper
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuItem
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import androidx.core.graphics.drawable.DrawableCompat
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager
import androidx.lifecycle.lifecycleScope
import com.afollestad.materialdialogs.MaterialDialog
import com.google.android.material.bottomnavigation.BottomNavigationView
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.DialogServerUrlBinding
import org.ole.planet.myplanet.model.RealmUserChallengeActions.Companion.createActionAsync
import org.ole.planet.myplanet.ui.community.CommunityTabFragment
import org.ole.planet.myplanet.ui.courses.CoursesFragment
import org.ole.planet.myplanet.ui.dashboard.BellDashboardFragment
import org.ole.planet.myplanet.ui.feedback.FeedbackFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.rating.RatingFragment.Companion.newInstance
import org.ole.planet.myplanet.ui.resources.ResourcesFragment
import org.ole.planet.myplanet.ui.team.TeamFragment
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.Constants.isBetaWifiFeatureEnabled
import org.ole.planet.myplanet.utilities.NotificationUtils
import org.ole.planet.myplanet.utilities.SecurePrefs
import org.ole.planet.myplanet.utilities.SharedPrefManager

abstract class DashboardElementActivity : SyncActivity(), FragmentManager.OnBackStackChangedListener {
    lateinit var navigationView: BottomNavigationView
    var doubleBackToExitPressedOnce = false
    private lateinit var goOnline: MenuItem
    var c = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        settings = applicationContext.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        prefData = SharedPrefManager(this)
        supportFragmentManager.addOnBackStackChangedListener(this)
    }

    fun onClickTabItems(position: Int) {
        when (position) {
            0 -> openCallFragment(BellDashboardFragment(), "dashboard")
            1 -> openCallFragment(ResourcesFragment(), "library")
            2 -> openCallFragment(CoursesFragment(), "course")
            4 -> openEnterpriseFragment()
            3 -> openCallFragment(TeamFragment(), "survey")
            5 -> {
                openCallFragment(CommunityTabFragment(), "community")
            }
        }
    }

    protected fun bindGoOnlineMenu(menu: Menu) {
        goOnline = menu.findItem(R.id.menu_goOnline)
        updateGoOnlineVisibility()
    }

    fun openCallFragment(newFragment: Fragment, tag: String?) {
        val fragmentManager = supportFragmentManager
        if(c<2){
            c=0
        }
        val existingFragment = fragmentManager.findFragmentByTag(tag)
        if (tag == "") {
            c++
            if(c>2){
                c--
                NavigationHelper.popBackStack(fragmentManager, tag, 0)
            }else{
                NavigationHelper.replaceFragment(
                    fragmentManager,
                    R.id.fragment_container,
                    newFragment,
                    addToBackStack = true,
                    tag = tag
                )
            }
        } else {
            if (existingFragment != null && existingFragment.isVisible) {
                return
            } else if (existingFragment != null) {
                if(c>0 && c>2){
                    c=0
                }
                NavigationHelper.popBackStack(fragmentManager, tag, 0)
            } else {
                if(c>0 && c>2){
                    c=0
                }
                if(tag!="") {
                    NavigationHelper.replaceFragment(
                        fragmentManager,
                        R.id.fragment_container,
                        newFragment,
                        addToBackStack = true,
                        tag = tag
                    )
                }
            }
        }
    }
    protected fun updateGoOnlineVisibility() {
        if (::goOnline.isInitialized) {
            goOnline.isVisible = isBetaWifiFeatureEnabled(this)
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_goOnline -> {
                wifiStatusSwitch()
                return true
            }
            R.id.action_logout -> {
                logout()
            }
            R.id.action_feedback -> {
                openCallFragment(FeedbackFragment(), getString(R.string.menu_feedback))
            }
            R.id.action_sync -> {
                logSyncInSharedPrefs()
            }
        }
        return super.onOptionsItemSelected(item)
    }

    fun logSyncInSharedPrefs() {
        val protocol = settings.getString("serverProtocol", "")
        val serverUrl = "${settings.getString("serverURL", "")}"
        val serverPin = "${settings.getString("serverPin", "")}"

        val url = if (serverUrl.startsWith("http://") || serverUrl.startsWith("https://")) {
            serverUrl
        } else {
            "$protocol$serverUrl"
        }

        val dialogServerUrlBinding = DialogServerUrlBinding.inflate(LayoutInflater.from(this))
        val contextWrapper = ContextThemeWrapper(this, R.style.AlertDialogTheme)

        val builder = MaterialDialog.Builder(contextWrapper)
            .customView(dialogServerUrlBinding.root, true)

        val dialog = builder.build()
        currentDialog = dialog
        service.getMinApk(this, url, serverPin, this, "DashboardActivity")
        createActionAsync("${profileDbHandler.userModel?.id}", null, "sync")
    }

    @SuppressLint("RestrictedApi")
    fun wifiStatusSwitch() {
        val resIcon = ContextCompat.getDrawable(this, R.drawable.goonline)
        val connManager = getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager
        val wifi = applicationContext.getSystemService(WIFI_SERVICE) as WifiManager
        val mWifi = connManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI)
        val intent = Intent(Settings.ACTION_WIFI_SETTINGS)
        startActivity(intent)
        if (mWifi?.isConnected == true) {
            wifi.isWifiEnabled = false
            if (resIcon != null) {
                DrawableCompat.setTintMode(resIcon.mutate(), PorterDuff.Mode.SRC_ATOP)
                DrawableCompat.setTint(resIcon, ContextCompat.getColor(this, R.color.green))
            }
            goOnline.icon = resIcon
            Toast.makeText(this, getString(R.string.wifi_is_turned_off_saving_battery_power), Toast.LENGTH_LONG).show()
        } else {
            wifi.isWifiEnabled = true
            Toast.makeText(this, getString(R.string.turning_on_wifi_please_wait), Toast.LENGTH_LONG).show()
            lifecycleScope.launch {
                delay(5000)
                connectToWifi()
            }
            if (resIcon != null) {
                DrawableCompat.setTintMode(resIcon.mutate(), PorterDuff.Mode.SRC_ATOP)
                DrawableCompat.setTint(resIcon, ContextCompat.getColor(this, R.color.accent))
            }
            goOnline.icon = resIcon
        }
    }

    private fun connectToWifi() {
        val id = settings.getInt("LastWifiID", -1)
        val wifiManager = applicationContext.getSystemService(WIFI_SERVICE) as WifiManager
        val netId: Int
        for (tmp in wifiManager.configuredNetworks) {
            if (tmp.networkId > -1 && tmp.networkId == id) {
                netId = tmp.networkId
                wifiManager.enableNetwork(netId, true)
                Toast.makeText(this, R.string.you_are_now_connected + netId, Toast.LENGTH_SHORT).show()
                lifecycleScope.launch {
                    broadcastService.sendBroadcast(Intent("ACTION_NETWORK_CHANGED"))
                }
                break
            }
        }
    }

    fun logout() {
        lifecycleScope.launch {
            profileDbHandler.logoutAsync()
            SecurePrefs.clearCredentials(this@DashboardElementActivity)
            settings.edit { putBoolean(Constants.KEY_LOGIN, false) }
            settings.edit { putBoolean(Constants.KEY_NOTIFICATION_SHOWN, false) }
            NotificationUtils.cancelAll(this@DashboardElementActivity)

            val loginScreen = Intent(this@DashboardElementActivity, LoginActivity::class.java)
                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK)
                .putExtra("fromLogout", true)
            startActivity(loginScreen)
            doubleBackToExitPressedOnce = true
            finish()
        }
    }

    override fun finish() {
        if (doubleBackToExitPressedOnce) {
            super.finish()
        } else {
            doubleBackToExitPressedOnce = true
            Toast.makeText(this, getString(R.string.press_back_again_to_exit), Toast.LENGTH_SHORT).show()
            lifecycleScope.launch {
                delay(2000)
                doubleBackToExitPressedOnce = false
            }
        }
    }

    fun showRatingDialog(type: String?, resourceId: String?, title: String?, listener: OnRatingChangeListener?) {
        val f = newInstance(type, resourceId, title)
        f.setListener(listener)
        f.show(supportFragmentManager, "")
    }

    override fun onBackStackChanged() {
        val f = supportFragmentManager.findFragmentById(R.id.fragment_container)
        val fragmentTag = f?.tag
        if (f is CoursesFragment) {
            if ("MyCoursesFragment" == fragmentTag) {
                navigationView.menu.findItem(R.id.menu_mycourses).isChecked = true
            } else {
                navigationView.menu.findItem(R.id.menu_courses).isChecked = true
            }
        } else if (f is ResourcesFragment) {
            if ("MyResourcesFragment" == fragmentTag) {
                navigationView.menu.findItem(R.id.menu_mylibrary).isChecked = true
            } else {
                navigationView.menu.findItem(R.id.menu_library).isChecked = true
            }
        }
    }

    fun openEnterpriseFragment() {
        val fragment: Fragment = TeamFragment()
        val b = Bundle()
        b.putString("type", "enterprise")
        fragment.arguments = b
        openCallFragment(fragment, "Enterprise")
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/sync/GuestLoginExtensions.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.sync

import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import androidx.appcompat.app.AlertDialog
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AlertGuestLoginBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.AuthHelper
import org.ole.planet.myplanet.utilities.Utilities.toast

fun LoginActivity.showGuestLoginDialog() {
    MainApplication.service.withRealm { realm ->
        realm.refresh()
        val binding = AlertGuestLoginBinding.inflate(LayoutInflater.from(this))
        val view: View = binding.root
        binding.etUserName.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                val input = s.toString()
                val error = AuthHelper.validateUsername(this@showGuestLoginDialog, input)
                if (error != null) {
                    binding.etUserName.error = error
                } else {
                    val lowercaseText = input.lowercase()
                    if (input != lowercaseText) {
                        binding.etUserName.setText(lowercaseText)
                        binding.etUserName.setSelection(lowercaseText.length)
                    }
                    binding.etUserName.error = null
                }
            }

            override fun afterTextChanged(s: Editable) {}
        })
        val dialog = AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle(R.string.btn_guest_login)
            .setView(view)
            .setPositiveButton(R.string.login, null)
            .setNegativeButton(R.string.cancel, null)
            .create()
        dialog.show()
        val login = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
        val cancel = dialog.getButton(AlertDialog.BUTTON_NEGATIVE)
        login.setOnClickListener {
            MainApplication.service.withRealm { loginRealm ->
                val username = binding.etUserName.text.toString().trim { it <= ' ' }
                val error = AuthHelper.validateUsername(this@showGuestLoginDialog, username)
                if (error == null) {
                    val existingUser = loginRealm.where(RealmUserModel::class.java).equalTo("name", username).findFirst()
                    dialog.dismiss()
                    if (existingUser != null) {
                        when {
                            existingUser._id?.contains("guest") == true -> showGuestDialog(username)
                            existingUser._id?.contains("org.couchdb.user:") == true -> showUserAlreadyMemberDialog(username)
                        }
                    } else {
                        val model = RealmUserModel.createGuestUser(username, loginRealm, settings)?.let { loginRealm.copyFromRealm(it) }
                        if (model == null) {
                            toast(this, getString(R.string.unable_to_login))
                        } else {
                            saveUsers(username, "", "guest")
                            saveUserInfoPref(settings, "", model)
                            onLogin()
                        }
                    }
                } else {
                    binding.etUserName.error = error
                }
            }
        }
        cancel.setOnClickListener { dialog.dismiss() }
    }
}
=======
package org.ole.planet.myplanet.ui.sync


import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import androidx.appcompat.app.AlertDialog
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AlertGuestLoginBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.AuthHelper
import org.ole.planet.myplanet.utilities.Utilities.toast

fun LoginActivity.showGuestLoginDialog() {
    MainApplication.service.withRealm { realm ->
        realm.refresh()
        val binding = AlertGuestLoginBinding.inflate(LayoutInflater.from(this))
        val view: View = binding.root
        binding.etUserName.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                val input = s.toString()
                val error = AuthHelper.validateUsername(this@showGuestLoginDialog, input)
                if (error != null) {
                    binding.etUserName.error = error
                } else {
                    val lowercaseText = input.lowercase()
                    if (input != lowercaseText) {
                        binding.etUserName.setText(lowercaseText)
                        binding.etUserName.setSelection(lowercaseText.length)
                    }
                    binding.etUserName.error = null
                }
            }

            override fun afterTextChanged(s: Editable) {}
        })
        val dialog = AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle(R.string.btn_guest_login)
            .setView(view)
            .setPositiveButton(R.string.login, null)
            .setNegativeButton(R.string.cancel, null)
            .create()
        dialog.show()
        val login = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
        val cancel = dialog.getButton(AlertDialog.BUTTON_NEGATIVE)
        login.setOnClickListener {
            MainApplication.service.withRealm { loginRealm ->
                val username = binding.etUserName.text.toString().trim { it <= ' ' }
                val error = AuthHelper.validateUsername(this@showGuestLoginDialog, username)
                if (error == null) {
                    val existingUser = loginRealm.where(RealmUserModel::class.java).equalTo("name", username).findFirst()
                    dialog.dismiss()
                    if (existingUser != null) {
                        when {
                            existingUser._id?.contains("guest") == true -> showGuestDialog(username)
                            existingUser._id?.contains("org.couchdb.user:") == true -> showUserAlreadyMemberDialog(username)
                        }
                    } else {
                        val model = RealmUserModel.createGuestUser(username, loginRealm, settings)?.let { loginRealm.copyFromRealm(it) }
                        if (model == null) {
                            toast(this, getString(R.string.unable_to_login))
                        } else {
                            saveUsers(username, "", "guest")
                            saveUserInfoPref(settings, "", model)
                            onLogin()
                        }
                    }
                } else {
                    binding.etUserName.error = error
                }
            }
        }
        cancel.setOnClickListener { dialog.dismiss() }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/sync/SyncActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.sync

import android.Manifest
import android.content.DialogInterface
import android.content.Intent
import android.content.IntentFilter
import android.content.SharedPreferences
import android.graphics.drawable.AnimationDrawable
import android.os.Build
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.ContextThemeWrapper
import android.view.LayoutInflater
import android.view.View
import android.webkit.URLUtil
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.CompoundButton
import android.widget.EditText
import android.widget.ImageView
import android.widget.RadioGroup
import android.widget.Spinner
import android.widget.TextView
import android.widget.Toast
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.widget.SwitchCompat
import androidx.core.content.edit
import androidx.lifecycle.lifecycleScope
import androidx.preference.PreferenceManager
import androidx.recyclerview.widget.RecyclerView
import com.afollestad.materialdialogs.DialogAction
import com.afollestad.materialdialogs.MaterialDialog
import dagger.hilt.android.AndroidEntryPoint
import java.io.File
import java.util.ArrayList
import java.util.Calendar
import java.util.Date
import java.util.HashMap
import java.util.Locale
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.MainApplication.Companion.createLog
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.backgroundDownload
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.getAllLibraryList
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.databinding.DialogServerUrlBinding
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.datamanager.Service.CheckVersionCallback
import org.ole.planet.myplanet.datamanager.Service.ConfigurationIdListener
import org.ole.planet.myplanet.datamanager.Service.PlanetAvailableListener
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.model.ServerAddressesModel
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.TransactionSyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.androidDecrypter
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.Constants.autoSynFeature
import org.ole.planet.myplanet.utilities.DialogUtils.getUpdateDialog
import org.ole.planet.myplanet.utilities.DialogUtils.showAlert
import org.ole.planet.myplanet.utilities.DialogUtils.showSnack
import org.ole.planet.myplanet.utilities.DialogUtils.showWifiSettingDialog
import org.ole.planet.myplanet.utilities.DownloadUtils.downloadAllFiles
import org.ole.planet.myplanet.utilities.DownloadUtils.openDownloadService
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.NetworkUtils.extractProtocol
import org.ole.planet.myplanet.utilities.NetworkUtils.getCustomDeviceName
import org.ole.planet.myplanet.utilities.NetworkUtils.isNetworkConnectedFlow
import org.ole.planet.myplanet.utilities.NotificationUtils.cancelAll
import org.ole.planet.myplanet.utilities.ServerConfigUtils
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
abstract class SyncActivity : ProcessUserDataActivity(), SyncListener, CheckVersionCallback,
    ConfigurationIdListener {
    private lateinit var syncDate: TextView
    lateinit var lblLastSyncDate: TextView
    lateinit var btnSignIn: Button
    lateinit var lblVersion: TextView
    lateinit var tvAvailableSpace: TextView
    lateinit var btnGuestLogin: Button
    lateinit var becomeMember: Button
    lateinit var btnFeedback: Button
    lateinit var openCommunity: Button
    lateinit var btnLang: Button
    lateinit var inputName: EditText
    lateinit var inputPassword: EditText
    private lateinit var intervalLabel: TextView
    lateinit var spinner: Spinner
    private lateinit var syncSwitch: SwitchCompat
    lateinit var editor: SharedPreferences.Editor
    private var syncTimeInterval = intArrayOf(60 * 60, 3 * 60 * 60)
    lateinit var syncIcon: ImageView
    lateinit var syncIconDrawable: AnimationDrawable
    lateinit var prefData: SharedPrefManager
    @Inject
    lateinit var profileDbHandler: UserProfileDbHandler
    lateinit var spnCloud: Spinner
    lateinit var protocolCheckIn: RadioGroup
    lateinit var serverUrl: EditText
    lateinit var serverPassword: EditText
    lateinit var serverAddresses: RecyclerView
    lateinit var syncToServerText: TextView
    var selectedTeamId: String? = null
    lateinit var positiveAction: View
    lateinit var neutralAction: View
    lateinit var processedUrl: String
    var isSync = false
    var forceSync = false
    var syncFailed = false
    lateinit var defaultPref: SharedPreferences
    lateinit var service: Service
    var currentDialog: MaterialDialog? = null
    var serverConfigAction = ""
    var serverCheck = true
    var showAdditionalServers = false
    var serverAddressAdapter: ServerAddressAdapter? = null
    var serverListAddresses: List<ServerAddressesModel> = emptyList()
    private var isProgressDialogShowing = false

    @Inject
    lateinit var syncManager: SyncManager

    @Inject
    lateinit var broadcastService: org.ole.planet.myplanet.service.BroadcastService

    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        settings = getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        editor = settings.edit()
        requestAllPermissions()
        prefData = SharedPrefManager(this)
        defaultPref = PreferenceManager.getDefaultSharedPreferences(this)
        processedUrl = UrlUtils.getUrl()
    }

    override fun onConfigurationIdReceived(id: String, code: String, url: String, defaultUrl: String, isAlternativeUrl: Boolean, callerActivity: String) {
        val savedId = settings.getString("configurationId", null)

        when (callerActivity) {
            "LoginActivity", "DashboardActivity"-> {
                if (isAlternativeUrl) {
                    ServerConfigUtils.saveAlternativeUrl(url, settings.getString("serverPin", "") ?: "", settings, editor)
                }
                isSync = false
                forceSync = true
                service.checkVersion(this, settings)
            }
            else -> {
                if (serverConfigAction == "sync") {
                    if (savedId == null) {
                        editor.putString("configurationId", id).apply()
                        editor.putString("communityName", code).apply()
                        currentDialog?.let {
                            continueSync(it, url, isAlternativeUrl, defaultUrl)
                        }
                    } else if (id == savedId) {
                        currentDialog?.let {
                            continueSync(it, url, isAlternativeUrl, defaultUrl)
                        }
                    } else {
                        clearDataDialog(getString(R.string.you_want_to_connect_to_a_different_server), false)
                    }
                } else if (serverConfigAction == "save") {
                    if (savedId == null || id == savedId) {
                        currentDialog?.let { saveConfigAndContinue(it, "", false, defaultUrl) }
                    } else {
                        clearDataDialog(getString(R.string.you_want_to_connect_to_a_different_server), false)
                    }
                }
            }
        }
    }

    fun clearDataDialog(message: String, config: Boolean, onCancel: () -> Unit = {}) {
        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setMessage(message)
            .setPositiveButton(getString(R.string.clear_data)) { dialog, _ ->
                (dialog as AlertDialog).getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = false
                dialog.getButton(AlertDialog.BUTTON_NEGATIVE).isEnabled = false

                lifecycleScope.launch {
                    try {
                        customProgressDialog.setText(getString(R.string.clearing_data))
                        customProgressDialog.show()

                        clearRealmDb()
                        prefData.setManualConfig(config)
                        clearSharedPref()

                        delay(500)
                        restartApp()
                    } catch (e: Exception) {
                        e.printStackTrace()
                        customProgressDialog.dismiss()
                        dialog.getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = true
                        dialog.getButton(AlertDialog.BUTTON_NEGATIVE).isEnabled = true
                    }
                }
            }
            .setNegativeButton(getString(R.string.cancel)) { _, _ ->
                onCancel()
            }
            .setCancelable(false)
            .show()
    }

    private fun clearInternalStorage() {
        val myDir = File(FileUtils.getOlePath(this))
        if (myDir.isDirectory) {
            val children = myDir.list()
            if (children != null) {
                for (i in children.indices) {
                    File(myDir, children[i]).delete()
                }
            }
        }
        editor.putBoolean("firstRun", false).apply()
    }

    fun sync(dialog: MaterialDialog) {
        spinner = dialog.findViewById(R.id.intervalDropper) as Spinner
        syncSwitch = dialog.findViewById(R.id.syncSwitch) as SwitchCompat
        intervalLabel = dialog.findViewById(R.id.intervalLabel) as TextView
        syncSwitch.setOnCheckedChangeListener { _: CompoundButton?, isChecked: Boolean ->
            setSpinnerVisibility(isChecked)
        }
        syncSwitch.isChecked = settings.getBoolean("autoSync", true)
        dateCheck(dialog)
    }

    private fun setSpinnerVisibility(isChecked: Boolean) {
        if (isChecked) {
            intervalLabel.visibility = View.VISIBLE
            spinner.visibility = View.VISIBLE
        } else {
            spinner.visibility = View.GONE
            intervalLabel.visibility = View.GONE
        }
    }

    suspend fun isServerReachable(processedUrl: String?, type: String): Boolean {
        return withContext(Dispatchers.IO) {
            val apiInterface = client?.create(ApiInterface::class.java)
            try {
                val response = if (settings.getBoolean("isAlternativeUrl", false)){
                    if (processedUrl?.contains("/db") == true) {
                        val processedUrlWithoutDb = processedUrl.replace("/db", "")
                        apiInterface?.isPlanetAvailable("$processedUrlWithoutDb/db/_all_dbs")?.execute()
                    } else {
                        apiInterface?.isPlanetAvailable("$processedUrl/db/_all_dbs")?.execute()
                    }
                } else {
                    apiInterface?.isPlanetAvailable("$processedUrl/_all_dbs")?.execute()
                }

                when {
                    response?.isSuccessful == true -> {
                        val ss = response.body()?.string()
                        val myList = ss?.split(",")?.dropLastWhile { it.isEmpty() }

                        if ((myList?.size ?: 0) < 8) {
                            withContext(Dispatchers.Main) {
                                customProgressDialog.dismiss()
                                alertDialogOkay(context.getString(R.string.check_the_server_address_again_what_i_connected_to_wasn_t_the_planet_server))
                            }
                            false
                        } else {
                            withContext(Dispatchers.Main) {
                                startSync(type)
                            }
                            true
                        }
                    }
                    else -> {
                        syncFailed = true
                        val protocol = extractProtocol("$processedUrl")
                        val errorMessage = when (protocol) {
                            context.getString(R.string.http_protocol) -> context.getString(R.string.device_couldn_t_reach_local_server)
                            context.getString(R.string.https_protocol) -> context.getString(R.string.device_couldn_t_reach_nation_server)
                            else -> ""
                        }
                        withContext(Dispatchers.Main) {
                            customProgressDialog.dismiss()
                            alertDialogOkay(errorMessage)
                        }
                        false
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
                false
            }
        }
    }

    private fun dateCheck(dialog: MaterialDialog) {
        // Check if the user never synced
        syncDate = dialog.findViewById(R.id.lastDateSynced) as TextView
        syncDate.text = getString(R.string.last_sync_date, convertDate())
        syncDropdownAdd()
    }

    // Converts OS date to human date
    private fun convertDate(): String {
        val lastSynced = settings.getLong("LastSync", 0)
        return if (lastSynced == 0L) {
            " Never Synced"
        } else {
            TimeUtils.getRelativeTime(lastSynced)
        }
    }

    private fun syncDropdownAdd() {
        val list: MutableList<String> = ArrayList()
        list.add("1 " + getString(R.string.hour))
        list.add("3 " + getString(R.string.hours))
        val spinnerArrayAdapter = ArrayAdapter(this, R.layout.spinner_item, list)
        spinnerArrayAdapter.setDropDownViewResource(R.layout.spinner_item)
        spinner.adapter = spinnerArrayAdapter
    }

    private fun saveSyncInfoToPreference() {
        editor.putBoolean("autoSync", syncSwitch.isChecked)
        editor.putInt("autoSyncInterval", syncTimeInterval[spinner.selectedItemPosition])
        editor.putInt("autoSyncPosition", spinner.selectedItemPosition)
        editor.apply()
    }

    fun authenticateUser(settings: SharedPreferences?, username: String?, password: String?, isManagerMode: Boolean): Boolean {
        return try {
            if (settings != null) {
                this.settings = settings
            }
            val isEmpty = databaseService.withRealm { realm -> realm.isEmpty }
            if (isEmpty) {
                alertDialogOkay(getString(R.string.server_not_configured_properly_connect_this_device_with_planet_server))
                false
            } else {
                checkName(username, password, isManagerMode)
            }
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    private fun checkName(username: String?, password: String?, isManagerMode: Boolean): Boolean {
        try {
            val user = databaseService.withRealm { realm ->
                realm.where(RealmUserModel::class.java).equalTo("name", username).findFirst()?.let { realm.copyFromRealm(it) }
            }
            user?.let {
                if (it._id?.isEmpty() == true) {
                    if (username == it.name && password == it.password) {
                        saveUserInfoPref(settings, password, it)
                        return true
                    }
                } else {
                    if (androidDecrypter(username, password, it.derived_key, it.salt)) {
                        if (isManagerMode && !it.isManager()) return false
                        saveUserInfoPref(settings, password, it)
                        return true
                    }
                }
            }
        } catch (err: Exception) {
            err.printStackTrace()
            return false
        }
        return false
    }

    fun startSync(type: String) {
        syncManager.start(this@SyncActivity, type)
    }

    private fun saveConfigAndContinue(
        dialog: MaterialDialog,
        url: String,
        isAlternativeUrl: Boolean,
        defaultUrl: String
    ): String {
        dialog.dismiss()
        saveSyncInfoToPreference()
        return if (isAlternativeUrl) {
            handleAlternativeUrlSave(dialog, url, defaultUrl)
        } else {
            handleRegularUrlSave(dialog)
        }
    }

    private fun handleAlternativeUrlSave(
        dialog: MaterialDialog,
        url: String,
        defaultUrl: String
    ): String {
        val password = if (settings.getString("serverPin", "") != "") {
            settings.getString("serverPin", "")!!
        } else {
            (dialog.customView?.findViewById<View>(R.id.input_server_Password) as EditText).text.toString()
        }

        val couchdbURL = ServerConfigUtils.saveAlternativeUrl(url, password, settings, editor)
        if (isUrlValid(url)) setUrlParts(defaultUrl, password) else ""
        return couchdbURL
    }

    private fun handleRegularUrlSave(dialog: MaterialDialog): String {
        val protocol = settings.getString("serverProtocol", "")
        var url = (dialog.customView?.findViewById<View>(R.id.input_server_url) as EditText).text.toString()
        val pin = (dialog.customView?.findViewById<View>(R.id.input_server_Password) as EditText).text.toString()

        editor.putString(
            "customDeviceName",
            (dialog.customView?.findViewById<View>(R.id.deviceName) as EditText).text.toString()
        ).apply()

        url = protocol + url
        return if (isUrlValid(url)) setUrlParts(url, pin) else ""
    }

    override fun onSyncStarted() {
        customProgressDialog.setText(getString(R.string.syncing_data_please_wait))
        customProgressDialog.show()
        isProgressDialogShowing = true
    }

    override fun onSyncFailed(msg: String?) {
        if (isProgressDialogShowing) {
            customProgressDialog.dismiss()
        }
        if (::syncIconDrawable.isInitialized) {
            syncIconDrawable = syncIcon.drawable as AnimationDrawable
            syncIconDrawable.stop()
            syncIconDrawable.selectDrawable(0)
            syncIcon.invalidateDrawable(syncIconDrawable)
        }
        runOnUiThread {
            showAlert(this@SyncActivity, getString(R.string.sync_failed), msg)
            showWifiSettingDialog(this@SyncActivity)
        }
    }

    override fun onSyncComplete() {
        val activityContext = this@SyncActivity
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                var attempt = 0
                while (true) {
                    val hasUser = databaseService.withRealm { realm ->
                        realm.where(RealmUserModel::class.java).findAll().isNotEmpty()
                    }
                    if (hasUser) {
                        break
                    }
                    attempt++
                    delay(1000)
                }

                withContext(Dispatchers.Main) {
                    forceSyncTrigger()
                    val syncedUrl = settings.getString("serverURL", null)?.let { ServerConfigUtils.removeProtocol(it) }
                    if (
                        syncedUrl != null &&
                        serverListAddresses.isNotEmpty() &&
                        serverListAddresses.any { it.url.replace(Regex("^https?://"), "") == syncedUrl }
                    ) {
                        editor.putString("pinnedServerUrl", syncedUrl).apply()
                    }

                    customProgressDialog.dismiss()

                    if (::syncIconDrawable.isInitialized) {
                        syncIconDrawable = syncIcon.drawable as AnimationDrawable
                        syncIconDrawable.stop()
                        syncIconDrawable.selectDrawable(0)
                        syncIcon.invalidateDrawable(syncIconDrawable)
                    }

                    lifecycleScope.launch {
                        createLog("synced successfully", "")
                    }

                    lifecycleScope.launch(Dispatchers.IO) {
                        val pendingLanguage = settings.getString("pendingLanguageChange", null)
                        if (pendingLanguage != null) {
                            withContext(Dispatchers.Main) {
                                editor.remove("pendingLanguageChange").apply()

                                LocaleHelper.setLocale(this@SyncActivity, pendingLanguage)
                                updateUIWithNewLanguage()
                            }
                        }
                    }

                    showSnack(activityContext.findViewById(android.R.id.content), getString(R.string.sync_completed))

                    if (settings.getBoolean("isAlternativeUrl", false)) {
                        editor.putString("alternativeUrl", "")
                        editor.putString("processedAlternativeUrl", "")
                        editor.putBoolean("isAlternativeUrl", false)
                        editor.apply()
                    }

                    downloadAdditionalResources()

                    val betaAutoDownload = defaultPref.getBoolean("beta_auto_download", false)
                    if (betaAutoDownload) {
                        withContext(Dispatchers.IO) {
                            databaseService.withRealm { realm ->
                                backgroundDownload(
                                    downloadAllFiles(getAllLibraryList(realm)),
                                    activityContext
                                )
                            }
                        }
                    }

                    cancelAll(activityContext)

                    if (activityContext is LoginActivity) {
                        activityContext.updateTeamDropdown()
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    private fun updateUIWithNewLanguage() {
        try {
            if (::lblLastSyncDate.isInitialized) {
                lblLastSyncDate.text = getString(R.string.last_sync, TimeUtils.getRelativeTime(Date().time))
            }

            lblVersion.text = getString(R.string.app_version)
            tvAvailableSpace.text = buildString {
                append(getString(R.string.available_space_colon))
                append(" ")
                append(FileUtils.availableOverTotalMemoryFormattedString(this@SyncActivity))
            }

            inputName.hint = getString(R.string.hint_name)
            inputPassword.hint = getString(R.string.password)
            btnSignIn.text = getString(R.string.btn_sign_in)
            btnGuestLogin.text = getString(R.string.btn_guest_login)
            becomeMember.text = getString(R.string.become_a_member)
            btnFeedback.text = getString(R.string.feedback)
            openCommunity.text = getString(R.string.open_community)
            val currentLanguage = LocaleHelper.getLanguage(this)
            btnLang.text = getLanguageString(currentLanguage)
            invalidateOptionsMenu()
        } catch (e: Exception) {
            e.printStackTrace()
            recreate()
        }
    }

    fun getLanguageString(languageCode: String): String {
        return when (languageCode) {
            "en" -> getString(R.string.english)
            "es" -> getString(R.string.spanish)
            "so" -> getString(R.string.somali)
            "ne" -> getString(R.string.nepali)
            "ar" -> getString(R.string.arabic)
            "fr" -> getString(R.string.french)
            else -> getString(R.string.english)
        }
    }

    private fun downloadAdditionalResources() {
        val storedJsonConcatenatedLinks = settings.getString("concatenated_links", null)
        if (storedJsonConcatenatedLinks != null) {
            val storedConcatenatedLinks: ArrayList<String> = Json.decodeFromString(storedJsonConcatenatedLinks)
            openDownloadService(context, storedConcatenatedLinks, true)
        }
    }

    fun forceSyncTrigger(): Boolean {
        if (::lblLastSyncDate.isInitialized) {
            if (settings.getLong(getString(R.string.last_syncs), 0) <= 0) {
                lblLastSyncDate.text = getString(R.string.last_synced_never)
            } else {
                val lastSyncMillis = settings.getLong(getString(R.string.last_syncs), 0)
                var relativeTime = TimeUtils.getRelativeTime(lastSyncMillis)

                if (relativeTime.matches(Regex("^\\d{1,2} seconds ago$"))) {
                    relativeTime = getString(R.string.a_few_seconds_ago)
                }

                lblLastSyncDate.text = getString(R.string.last_sync, relativeTime)
            }
        }
        if (autoSynFeature(Constants.KEY_AUTOSYNC_, applicationContext) && autoSynFeature(Constants.KEY_AUTOSYNC_WEEKLY, applicationContext)) {
            return checkForceSync(7)
        } else if (autoSynFeature(Constants.KEY_AUTOSYNC_, applicationContext) && autoSynFeature(Constants.KEY_AUTOSYNC_MONTHLY, applicationContext)) {
            return checkForceSync(30)
        }
        return false
    }

    fun showWifiDialog() {
        if (intent.getBooleanExtra("showWifiDialog", false)) {
            showWifiSettingDialog(this)
        }
    }

    private fun checkForceSync(maxDays: Int): Boolean {
        cal_today = Calendar.getInstance(Locale.ENGLISH)
        cal_last_Sync = Calendar.getInstance(Locale.ENGLISH)
        val lastSyncTime = settings.getLong("LastSync", -1)
        if (lastSyncTime <= 0) {
            return false
        }
        cal_last_Sync.timeInMillis = lastSyncTime
        cal_today.timeInMillis = System.currentTimeMillis()
        val msDiff = cal_today.timeInMillis - cal_last_Sync.timeInMillis
        val daysDiff = TimeUnit.MILLISECONDS.toDays(msDiff)
        return if (daysDiff >= maxDays) {
            val alertDialogBuilder = AlertDialog.Builder(this, R.style.AlertDialogTheme)
            alertDialogBuilder.setMessage("${getString(R.string.it_has_been_more_than)}${(daysDiff - 1)}${getString(R.string.days_since_you_last_synced_this_device)}${getString(R.string.connect_it_to_the_server_over_wifi_and_sync_it_to_reactivate_this_tablet)}")
            alertDialogBuilder.setPositiveButton(R.string.okay) { _: DialogInterface?, _: Int ->
                Toast.makeText(applicationContext, getString(R.string.connect_to_the_server_over_wifi_and_sync_your_device_to_continue), Toast.LENGTH_LONG).show()
            }
            alertDialogBuilder.show()
            true
        } else {
            false
        }
    }

    fun onLogin() {
        profileDbHandler.onLoginAsync(
            callback = {},
            onError = { error ->
                error.printStackTrace()
            }
        )

        editor.putBoolean(Constants.KEY_LOGIN, true).commit()
        openDashboard()
        isNetworkConnectedFlow.onEach { isConnected ->
            if (isConnected) {
                val serverUrl = settings.getString("serverURL", "")
                if (!serverUrl.isNullOrEmpty()) {
                    MainApplication.applicationScope.launch {
                        val canReachServer = MainApplication.Companion.isServerReachable(serverUrl)
                        if (canReachServer) {
                            withContext(Dispatchers.Main) {
                                startUpload("login")
                            }
                            val backgroundRealm = databaseService.realmInstance
                            try {
                                TransactionSyncManager.syncDb(backgroundRealm, "login_activities")
                            } finally {
                                backgroundRealm.close()
                            }
                        }
                    }
                }
            }
        }.launchIn(MainApplication.applicationScope)
    }

    fun settingDialog() {
        val binding = DialogServerUrlBinding.inflate(LayoutInflater.from(this))
        initServerDialog(binding)

        val contextWrapper = ContextThemeWrapper(this, R.style.AlertDialogTheme)
        val dialog = MaterialDialog.Builder(contextWrapper)
            .customView(binding.root, true)
            .positiveText(R.string.sync)
            .negativeText(R.string.txt_cancel)
            .neutralText(R.string.btn_sync_save)
            .onPositive { d: MaterialDialog, _: DialogAction? -> performSync(d) }
            .build()

        positiveAction = dialog.getActionButton(DialogAction.POSITIVE)
        neutralAction = dialog.getActionButton(DialogAction.NEUTRAL)

        handleManualConfiguration(binding, settings.getString("configurationId", null), dialog)
        setRadioProtocolListener(binding)
        binding.clearData.setOnClickListener {
            clearDataDialog(getString(R.string.are_you_sure_you_want_to_clear_data), false)
        }
        setupFastSyncOption(binding)

        showAdditionalServers = false
        if (serverListAddresses.isNotEmpty() && settings.getString("serverURL", "")?.isNotEmpty() == true) {
            refreshServerList()
        }

        neutralAction.setOnClickListener { onNeutralButtonClick(dialog) }

        dialog.show()
        sync(dialog)
        if (!prefData.getManualConfig()) {
            dialog.getActionButton(DialogAction.NEUTRAL).text = getString(R.string.show_more)
        }
    }
    fun continueSync(dialog: MaterialDialog, url: String, isAlternativeUrl: Boolean, defaultUrl: String) {
        processedUrl = saveConfigAndContinue(dialog, url, isAlternativeUrl, defaultUrl)
        if (TextUtils.isEmpty(processedUrl)) return
        isSync = true
        if (checkPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) && settings.getBoolean("firstRun", true)) {
            clearInternalStorage()
        }
        Service(this).isPlanetAvailable(object : PlanetAvailableListener {
            override fun isAvailable() {
                Service(context).checkVersion(this@SyncActivity, settings)
            }
            override fun notAvailable() {
                if (!isFinishing) {
                    syncFailed = true
                    showAlert(context, "Error", getString(R.string.planet_server_not_reachable))
                }
            }
        })
    }

    override fun onSuccess(success: String?) {
        if (customProgressDialog.isShowing() == true && success?.contains("Crash") == true) {
            customProgressDialog.dismiss()
        }
        if (::btnSignIn.isInitialized) {
            showSnack(btnSignIn, success)
        }
        editor.putLong("lastUsageUploaded", Date().time).apply()
        if (::lblLastSyncDate.isInitialized) {
            lblLastSyncDate.text = getString(R.string.message_placeholder, "${getString(R.string.last_sync, TimeUtils.getRelativeTime(Date().time))} >>")
        }
        syncFailed = false
    }

    override fun onUpdateAvailable(info: MyPlanet?, cancelable: Boolean) {
        val builder = getUpdateDialog(this, info, customProgressDialog)
        if (cancelable || getCustomDeviceName(this).endsWith("###")) {
            builder.setNegativeButton(R.string.update_later) { _: DialogInterface?, _: Int ->
                continueSyncProcess()
            }
        } else {
            lifecycleScope.launch(Dispatchers.IO) {
                databaseService.executeTransactionAsync { realm -> realm.deleteAll() }
            }
        }
        builder.setCancelable(cancelable)
        builder.show()
    }

    override fun onCheckingVersion() {
        val lastCheckTime = settings.getLong("last_version_check_timestamp", 0)
        val currentTime = System.currentTimeMillis()
        val twentyFourHoursInMillis = 24 * 60 * 60 * 1000

        if (currentTime - lastCheckTime < twentyFourHoursInMillis) {
            return
        }

        customProgressDialog.setText(getString(R.string.checking_version))
        customProgressDialog.show()
    }

    fun registerReceiver() {
        lifecycleScope.launch {
            broadcastService.events.collect { intent ->
                if (intent.action == DashboardActivity.MESSAGE_PROGRESS) {
                    broadcastReceiver.onReceive(this@SyncActivity, intent)
                }
            }
        }
    }

    override fun onError(msg: String, blockSync: Boolean) {
        Utilities.toast(this, msg)
        if (msg.startsWith("Config")) {
            settingDialog()
        }
        customProgressDialog.dismiss()
        if (!blockSync) continueSyncProcess() else {
            syncIconDrawable.stop()
            syncIconDrawable.selectDrawable(0)
        }
    }

    private fun continueSyncProcess() {
        try {
            lifecycleScope.launch {
                if (isSync) {
                    isServerReachable(processedUrl, "sync")
                } else if (forceSync) {
                    isServerReachable(processedUrl, "upload")
                    startUpload("")
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }


    inner class MyTextWatcher(var view: View?) : TextWatcher {
        override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
        override fun onTextChanged(s: CharSequence, i: Int, i1: Int, i2: Int) {
            if (view?.id == R.id.input_server_url) {
                positiveAction.isEnabled = "$s".trim { it <= ' ' }.isNotEmpty() && URLUtil.isValidUrl("${settings.getString("serverProtocol", "")}$s")
            }
        }
        override fun afterTextChanged(editable: Editable) {}
    }

    override fun onDestroy() {
        super.onDestroy()
    }
    companion object {
        lateinit var cal_today: Calendar
        lateinit var cal_last_Sync: Calendar

        suspend fun clearRealmDb() {
            withContext(Dispatchers.IO) {
                MainApplication.service.withRealm { realm ->
                    realm.executeTransaction { transactionRealm ->
                        transactionRealm.deleteAll()
                    }
                }
            }
        }

        fun clearSharedPref() {
            val settings = context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
            val editor = settings.edit()
            val keysToKeep = setOf(SharedPrefManager.FIRST_LAUNCH, SharedPrefManager.MANUAL_CONFIG)
            val tempStorage = HashMap<String, Boolean>()
            for (key in keysToKeep) {
                tempStorage[key] = settings.getBoolean(key, false)
            }
            editor.clear().apply()
            for ((key, value) in tempStorage) {
                editor.putBoolean(key, value)
            }
            editor.commit()

            val preferences = PreferenceManager.getDefaultSharedPreferences(context)
            preferences.edit { clear() }
        }

        fun restartApp() {
            val intent = context.packageManager.getLaunchIntentForPackage(context.packageName)
            val mainIntent = Intent.makeRestartActivityTask(intent?.component)
            context.startActivity(mainIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}
=======
package org.ole.planet.myplanet.ui.sync


import android.Manifest
import android.content.DialogInterface
import android.content.Intent
import android.content.IntentFilter
import android.content.SharedPreferences
import android.graphics.drawable.AnimationDrawable
import android.os.Build
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.ContextThemeWrapper
import android.view.LayoutInflater
import android.view.View
import android.webkit.URLUtil
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.CompoundButton
import android.widget.EditText
import android.widget.ImageView
import android.widget.RadioGroup
import android.widget.Spinner
import android.widget.TextView
import android.widget.Toast
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.widget.SwitchCompat
import androidx.core.content.edit
import androidx.lifecycle.lifecycleScope
import androidx.preference.PreferenceManager
import androidx.recyclerview.widget.RecyclerView
import com.afollestad.materialdialogs.DialogAction
import com.afollestad.materialdialogs.MaterialDialog
import dagger.hilt.android.AndroidEntryPoint
import java.io.File
import java.util.ArrayList
import java.util.Calendar
import java.util.Date
import java.util.HashMap
import java.util.Locale
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.MainApplication.Companion.createLog
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.backgroundDownload
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.getAllLibraryList
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.databinding.DialogServerUrlBinding
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.datamanager.Service.CheckVersionCallback
import org.ole.planet.myplanet.datamanager.Service.ConfigurationIdListener
import org.ole.planet.myplanet.datamanager.Service.PlanetAvailableListener
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.model.ServerAddressesModel
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.TransactionSyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.androidDecrypter
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.Constants.autoSynFeature
import org.ole.planet.myplanet.utilities.DialogUtils.getUpdateDialog
import org.ole.planet.myplanet.utilities.DialogUtils.showAlert
import org.ole.planet.myplanet.utilities.DialogUtils.showSnack
import org.ole.planet.myplanet.utilities.DialogUtils.showWifiSettingDialog
import org.ole.planet.myplanet.utilities.DownloadUtils.downloadAllFiles
import org.ole.planet.myplanet.utilities.DownloadUtils.openDownloadService
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.NetworkUtils.extractProtocol
import org.ole.planet.myplanet.utilities.NetworkUtils.getCustomDeviceName
import org.ole.planet.myplanet.utilities.NetworkUtils.isNetworkConnectedFlow
import org.ole.planet.myplanet.utilities.NotificationUtils.cancelAll
import org.ole.planet.myplanet.utilities.ServerConfigUtils
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.TimeUtils
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
abstract class SyncActivity : ProcessUserDataActivity(), SyncListener, CheckVersionCallback,
    ConfigurationIdListener {
    private lateinit var syncDate: TextView
    lateinit var lblLastSyncDate: TextView
    lateinit var btnSignIn: Button
    lateinit var lblVersion: TextView
    lateinit var tvAvailableSpace: TextView
    lateinit var btnGuestLogin: Button
    lateinit var becomeMember: Button
    lateinit var btnFeedback: Button
    lateinit var openCommunity: Button
    lateinit var btnLang: Button
    lateinit var inputName: EditText
    lateinit var inputPassword: EditText
    private lateinit var intervalLabel: TextView
    lateinit var spinner: Spinner
    private lateinit var syncSwitch: SwitchCompat
    lateinit var editor: SharedPreferences.Editor
    private var syncTimeInterval = intArrayOf(60 * 60, 3 * 60 * 60)
    lateinit var syncIcon: ImageView
    lateinit var syncIconDrawable: AnimationDrawable
    lateinit var prefData: SharedPrefManager
    @Inject
    lateinit var profileDbHandler: UserProfileDbHandler
    lateinit var spnCloud: Spinner
    lateinit var protocolCheckIn: RadioGroup
    lateinit var serverUrl: EditText
    lateinit var serverPassword: EditText
    lateinit var serverAddresses: RecyclerView
    lateinit var syncToServerText: TextView
    var selectedTeamId: String? = null
    lateinit var positiveAction: View
    lateinit var neutralAction: View
    lateinit var processedUrl: String
    var isSync = false
    var forceSync = false
    var syncFailed = false
    lateinit var defaultPref: SharedPreferences
    lateinit var service: Service
    var currentDialog: MaterialDialog? = null
    var serverConfigAction = ""
    var serverCheck = true
    var showAdditionalServers = false
    var serverAddressAdapter: ServerAddressAdapter? = null
    var serverListAddresses: List<ServerAddressesModel> = emptyList()
    private var isProgressDialogShowing = false

    @Inject
    lateinit var syncManager: SyncManager

    @Inject
    lateinit var broadcastService: org.ole.planet.myplanet.service.BroadcastService

    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        settings = getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        editor = settings.edit()
        requestAllPermissions()
        prefData = SharedPrefManager(this)
        defaultPref = PreferenceManager.getDefaultSharedPreferences(this)
        processedUrl = UrlUtils.getUrl()
    }

    override fun onConfigurationIdReceived(id: String, code: String, url: String, defaultUrl: String, isAlternativeUrl: Boolean, callerActivity: String) {
        val savedId = settings.getString("configurationId", null)

        when (callerActivity) {
            "LoginActivity", "DashboardActivity"-> {
                if (isAlternativeUrl) {
                    ServerConfigUtils.saveAlternativeUrl(url, settings.getString("serverPin", "") ?: "", settings, editor)
                }
                isSync = false
                forceSync = true
                service.checkVersion(this, settings)
            }
            else -> {
                if (serverConfigAction == "sync") {
                    if (savedId == null) {
                        editor.putString("configurationId", id).apply()
                        editor.putString("communityName", code).apply()
                        currentDialog?.let {
                            continueSync(it, url, isAlternativeUrl, defaultUrl)
                        }
                    } else if (id == savedId) {
                        currentDialog?.let {
                            continueSync(it, url, isAlternativeUrl, defaultUrl)
                        }
                    } else {
                        clearDataDialog(getString(R.string.you_want_to_connect_to_a_different_server), false)
                    }
                } else if (serverConfigAction == "save") {
                    if (savedId == null || id == savedId) {
                        currentDialog?.let { saveConfigAndContinue(it, "", false, defaultUrl) }
                    } else {
                        clearDataDialog(getString(R.string.you_want_to_connect_to_a_different_server), false)
                    }
                }
            }
        }
    }

    fun clearDataDialog(message: String, config: Boolean, onCancel: () -> Unit = {}) {
        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setMessage(message)
            .setPositiveButton(getString(R.string.clear_data)) { dialog, _ ->
                (dialog as AlertDialog).getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = false
                dialog.getButton(AlertDialog.BUTTON_NEGATIVE).isEnabled = false

                lifecycleScope.launch {
                    try {
                        customProgressDialog.setText(getString(R.string.clearing_data))
                        customProgressDialog.show()

                        clearRealmDb()
                        prefData.setManualConfig(config)
                        clearSharedPref()

                        delay(500)
                        restartApp()
                    } catch (e: Exception) {
                        e.printStackTrace()
                        customProgressDialog.dismiss()
                        dialog.getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = true
                        dialog.getButton(AlertDialog.BUTTON_NEGATIVE).isEnabled = true
                    }
                }
            }
            .setNegativeButton(getString(R.string.cancel)) { _, _ ->
                onCancel()
            }
            .setCancelable(false)
            .show()
    }

    private fun clearInternalStorage() {
        val myDir = File(FileUtils.getOlePath(this))
        if (myDir.isDirectory) {
            val children = myDir.list()
            if (children != null) {
                for (i in children.indices) {
                    File(myDir, children[i]).delete()
                }
            }
        }
        editor.putBoolean("firstRun", false).apply()
    }

    fun sync(dialog: MaterialDialog) {
        spinner = dialog.findViewById(R.id.intervalDropper) as Spinner
        syncSwitch = dialog.findViewById(R.id.syncSwitch) as SwitchCompat
        intervalLabel = dialog.findViewById(R.id.intervalLabel) as TextView
        syncSwitch.setOnCheckedChangeListener { _: CompoundButton?, isChecked: Boolean ->
            setSpinnerVisibility(isChecked)
        }
        syncSwitch.isChecked = settings.getBoolean("autoSync", true)
        dateCheck(dialog)
    }

    private fun setSpinnerVisibility(isChecked: Boolean) {
        if (isChecked) {
            intervalLabel.visibility = View.VISIBLE
            spinner.visibility = View.VISIBLE
        } else {
            spinner.visibility = View.GONE
            intervalLabel.visibility = View.GONE
        }
    }

    suspend fun isServerReachable(processedUrl: String?, type: String): Boolean {
        return withContext(Dispatchers.IO) {
            val apiInterface = client?.create(ApiInterface::class.java)
            try {
                val response = if (settings.getBoolean("isAlternativeUrl", false)){
                    if (processedUrl?.contains("/db") == true) {
                        val processedUrlWithoutDb = processedUrl.replace("/db", "")
                        apiInterface?.isPlanetAvailable("$processedUrlWithoutDb/db/_all_dbs")?.execute()
                    } else {
                        apiInterface?.isPlanetAvailable("$processedUrl/db/_all_dbs")?.execute()
                    }
                } else {
                    apiInterface?.isPlanetAvailable("$processedUrl/_all_dbs")?.execute()
                }

                when {
                    response?.isSuccessful == true -> {
                        val ss = response.body()?.string()
                        val myList = ss?.split(",")?.dropLastWhile { it.isEmpty() }

                        if ((myList?.size ?: 0) < 8) {
                            withContext(Dispatchers.Main) {
                                customProgressDialog.dismiss()
                                alertDialogOkay(context.getString(R.string.check_the_server_address_again_what_i_connected_to_wasn_t_the_planet_server))
                            }
                            false
                        } else {
                            withContext(Dispatchers.Main) {
                                startSync(type)
                            }
                            true
                        }
                    }
                    else -> {
                        syncFailed = true
                        val protocol = extractProtocol("$processedUrl")
                        val errorMessage = when (protocol) {
                            context.getString(R.string.http_protocol) -> context.getString(R.string.device_couldn_t_reach_local_server)
                            context.getString(R.string.https_protocol) -> context.getString(R.string.device_couldn_t_reach_nation_server)
                            else -> ""
                        }
                        withContext(Dispatchers.Main) {
                            customProgressDialog.dismiss()
                            alertDialogOkay(errorMessage)
                        }
                        false
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
                false
            }
        }
    }

    private fun dateCheck(dialog: MaterialDialog) {
        // Check if the user never synced
        syncDate = dialog.findViewById(R.id.lastDateSynced) as TextView
        syncDate.text = getString(R.string.last_sync_date, convertDate())
        syncDropdownAdd()
    }

    // Converts OS date to human date
    private fun convertDate(): String {
        val lastSynced = settings.getLong("LastSync", 0)
        return if (lastSynced == 0L) {
            " Never Synced"
        } else {
            TimeUtils.getRelativeTime(lastSynced)
        }
    }

    private fun syncDropdownAdd() {
        val list: MutableList<String> = ArrayList()
        list.add("1 " + getString(R.string.hour))
        list.add("3 " + getString(R.string.hours))
        val spinnerArrayAdapter = ArrayAdapter(this, R.layout.spinner_item, list)
        spinnerArrayAdapter.setDropDownViewResource(R.layout.spinner_item)
        spinner.adapter = spinnerArrayAdapter
    }

    private fun saveSyncInfoToPreference() {
        editor.putBoolean("autoSync", syncSwitch.isChecked)
        editor.putInt("autoSyncInterval", syncTimeInterval[spinner.selectedItemPosition])
        editor.putInt("autoSyncPosition", spinner.selectedItemPosition)
        editor.apply()
    }

    fun authenticateUser(settings: SharedPreferences?, username: String?, password: String?, isManagerMode: Boolean): Boolean {
        return try {
            if (settings != null) {
                this.settings = settings
            }
            val isEmpty = databaseService.withRealm { realm -> realm.isEmpty }
            if (isEmpty) {
                alertDialogOkay(getString(R.string.server_not_configured_properly_connect_this_device_with_planet_server))
                false
            } else {
                checkName(username, password, isManagerMode)
            }
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    private fun checkName(username: String?, password: String?, isManagerMode: Boolean): Boolean {
        try {
            val user = databaseService.withRealm { realm ->
                realm.where(RealmUserModel::class.java).equalTo("name", username).findFirst()?.let { realm.copyFromRealm(it) }
            }
            user?.let {
                if (it._id?.isEmpty() == true) {
                    if (username == it.name && password == it.password) {
                        saveUserInfoPref(settings, password, it)
                        return true
                    }
                } else {
                    if (androidDecrypter(username, password, it.derived_key, it.salt)) {
                        if (isManagerMode && !it.isManager()) return false
                        saveUserInfoPref(settings, password, it)
                        return true
                    }
                }
            }
        } catch (err: Exception) {
            err.printStackTrace()
            return false
        }
        return false
    }

    fun startSync(type: String) {
        syncManager.start(this@SyncActivity, type)
    }

    private fun saveConfigAndContinue(
        dialog: MaterialDialog,
        url: String,
        isAlternativeUrl: Boolean,
        defaultUrl: String
    ): String {
        dialog.dismiss()
        saveSyncInfoToPreference()
        return if (isAlternativeUrl) {
            handleAlternativeUrlSave(dialog, url, defaultUrl)
        } else {
            handleRegularUrlSave(dialog)
        }
    }

    private fun handleAlternativeUrlSave(
        dialog: MaterialDialog,
        url: String,
        defaultUrl: String
    ): String {
        val password = if (settings.getString("serverPin", "") != "") {
            settings.getString("serverPin", "")!!
        } else {
            (dialog.customView?.findViewById<View>(R.id.input_server_Password) as EditText).text.toString()
        }

        val couchdbURL = ServerConfigUtils.saveAlternativeUrl(url, password, settings, editor)
        if (isUrlValid(url)) setUrlParts(defaultUrl, password) else ""
        return couchdbURL
    }

    private fun handleRegularUrlSave(dialog: MaterialDialog): String {
        val protocol = settings.getString("serverProtocol", "")
        var url = (dialog.customView?.findViewById<View>(R.id.input_server_url) as EditText).text.toString()
        val pin = (dialog.customView?.findViewById<View>(R.id.input_server_Password) as EditText).text.toString()

        editor.putString(
            "customDeviceName",
            (dialog.customView?.findViewById<View>(R.id.deviceName) as EditText).text.toString()
        ).apply()

        url = protocol + url
        return if (isUrlValid(url)) setUrlParts(url, pin) else ""
    }

    override fun onSyncStarted() {
        customProgressDialog.setText(getString(R.string.syncing_data_please_wait))
        customProgressDialog.show()
        isProgressDialogShowing = true
    }

    override fun onSyncFailed(msg: String?) {
        if (isProgressDialogShowing) {
            customProgressDialog.dismiss()
        }
        if (::syncIconDrawable.isInitialized) {
            syncIconDrawable = syncIcon.drawable as AnimationDrawable
            syncIconDrawable.stop()
            syncIconDrawable.selectDrawable(0)
            syncIcon.invalidateDrawable(syncIconDrawable)
        }
        runOnUiThread {
            showAlert(this@SyncActivity, getString(R.string.sync_failed), msg)
            showWifiSettingDialog(this@SyncActivity)
        }
    }

    override fun onSyncComplete() {
        val activityContext = this@SyncActivity
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                var attempt = 0
                while (true) {
                    val hasUser = databaseService.withRealm { realm ->
                        realm.where(RealmUserModel::class.java).findAll().isNotEmpty()
                    }
                    if (hasUser) {
                        break
                    }
                    attempt++
                    delay(1000)
                }

                withContext(Dispatchers.Main) {
                    forceSyncTrigger()
                    val syncedUrl = settings.getString("serverURL", null)?.let { ServerConfigUtils.removeProtocol(it) }
                    if (
                        syncedUrl != null &&
                        serverListAddresses.isNotEmpty() &&
                        serverListAddresses.any { it.url.replace(Regex("^https?://"), "") == syncedUrl }
                    ) {
                        editor.putString("pinnedServerUrl", syncedUrl).apply()
                    }

                    customProgressDialog.dismiss()

                    if (::syncIconDrawable.isInitialized) {
                        syncIconDrawable = syncIcon.drawable as AnimationDrawable
                        syncIconDrawable.stop()
                        syncIconDrawable.selectDrawable(0)
                        syncIcon.invalidateDrawable(syncIconDrawable)
                    }

                    lifecycleScope.launch {
                        createLog("synced successfully", "")
                    }

                    lifecycleScope.launch(Dispatchers.IO) {
                        val pendingLanguage = settings.getString("pendingLanguageChange", null)
                        if (pendingLanguage != null) {
                            withContext(Dispatchers.Main) {
                                editor.remove("pendingLanguageChange").apply()

                                LocaleHelper.setLocale(this@SyncActivity, pendingLanguage)
                                updateUIWithNewLanguage()
                            }
                        }
                    }

                    showSnack(activityContext.findViewById(android.R.id.content), getString(R.string.sync_completed))

                    if (settings.getBoolean("isAlternativeUrl", false)) {
                        editor.putString("alternativeUrl", "")
                        editor.putString("processedAlternativeUrl", "")
                        editor.putBoolean("isAlternativeUrl", false)
                        editor.apply()
                    }

                    downloadAdditionalResources()

                    val betaAutoDownload = defaultPref.getBoolean("beta_auto_download", false)
                    if (betaAutoDownload) {
                        withContext(Dispatchers.IO) {
                            databaseService.withRealm { realm ->
                                backgroundDownload(
                                    downloadAllFiles(getAllLibraryList(realm)),
                                    activityContext
                                )
                            }
                        }
                    }

                    cancelAll(activityContext)

                    if (activityContext is LoginActivity) {
                        activityContext.updateTeamDropdown()
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    private fun updateUIWithNewLanguage() {
        try {
            if (::lblLastSyncDate.isInitialized) {
                lblLastSyncDate.text = getString(R.string.last_sync, TimeUtils.getRelativeTime(Date().time))
            }

            lblVersion.text = getString(R.string.app_version)
            tvAvailableSpace.text = buildString {
                append(getString(R.string.available_space_colon))
                append(" ")
                append(FileUtils.availableOverTotalMemoryFormattedString(this@SyncActivity))
            }

            inputName.hint = getString(R.string.hint_name)
            inputPassword.hint = getString(R.string.password)
            btnSignIn.text = getString(R.string.btn_sign_in)
            btnGuestLogin.text = getString(R.string.btn_guest_login)
            becomeMember.text = getString(R.string.become_a_member)
            btnFeedback.text = getString(R.string.feedback)
            openCommunity.text = getString(R.string.open_community)
            val currentLanguage = LocaleHelper.getLanguage(this)
            btnLang.text = getLanguageString(currentLanguage)
            invalidateOptionsMenu()
        } catch (e: Exception) {
            e.printStackTrace()
            recreate()
        }
    }

    fun getLanguageString(languageCode: String): String {
        return when (languageCode) {
            "en" -> getString(R.string.english)
            "es" -> getString(R.string.spanish)
            "so" -> getString(R.string.somali)
            "ne" -> getString(R.string.nepali)
            "ar" -> getString(R.string.arabic)
            "fr" -> getString(R.string.french)
            else -> getString(R.string.english)
        }
    }

    private fun downloadAdditionalResources() {
        val storedJsonConcatenatedLinks = settings.getString("concatenated_links", null)
        if (storedJsonConcatenatedLinks != null) {
            val storedConcatenatedLinks: ArrayList<String> = Json.decodeFromString(storedJsonConcatenatedLinks)
            openDownloadService(context, storedConcatenatedLinks, true)
        }
    }

    fun forceSyncTrigger(): Boolean {
        if (::lblLastSyncDate.isInitialized) {
            if (settings.getLong(getString(R.string.last_syncs), 0) <= 0) {
                lblLastSyncDate.text = getString(R.string.last_synced_never)
            } else {
                val lastSyncMillis = settings.getLong(getString(R.string.last_syncs), 0)
                var relativeTime = TimeUtils.getRelativeTime(lastSyncMillis)

                if (relativeTime.matches(Regex("^\\d{1,2} seconds ago$"))) {
                    relativeTime = getString(R.string.a_few_seconds_ago)
                }

                lblLastSyncDate.text = getString(R.string.last_sync, relativeTime)
            }
        }
        if (autoSynFeature(Constants.KEY_AUTOSYNC_, applicationContext) && autoSynFeature(Constants.KEY_AUTOSYNC_WEEKLY, applicationContext)) {
            return checkForceSync(7)
        } else if (autoSynFeature(Constants.KEY_AUTOSYNC_, applicationContext) && autoSynFeature(Constants.KEY_AUTOSYNC_MONTHLY, applicationContext)) {
            return checkForceSync(30)
        }
        return false
    }

    fun showWifiDialog() {
        if (intent.getBooleanExtra("showWifiDialog", false)) {
            showWifiSettingDialog(this)
        }
    }

    private fun checkForceSync(maxDays: Int): Boolean {
        cal_today = Calendar.getInstance(Locale.ENGLISH)
        cal_last_Sync = Calendar.getInstance(Locale.ENGLISH)
        val lastSyncTime = settings.getLong("LastSync", -1)
        if (lastSyncTime <= 0) {
            return false
        }
        cal_last_Sync.timeInMillis = lastSyncTime
        cal_today.timeInMillis = System.currentTimeMillis()
        val msDiff = cal_today.timeInMillis - cal_last_Sync.timeInMillis
        val daysDiff = TimeUnit.MILLISECONDS.toDays(msDiff)
        return if (daysDiff >= maxDays) {
            val alertDialogBuilder = AlertDialog.Builder(this, R.style.AlertDialogTheme)
            alertDialogBuilder.setMessage("${getString(R.string.it_has_been_more_than)}${(daysDiff - 1)}${getString(R.string.days_since_you_last_synced_this_device)}${getString(R.string.connect_it_to_the_server_over_wifi_and_sync_it_to_reactivate_this_tablet)}")
            alertDialogBuilder.setPositiveButton(R.string.okay) { _: DialogInterface?, _: Int ->
                Toast.makeText(applicationContext, getString(R.string.connect_to_the_server_over_wifi_and_sync_your_device_to_continue), Toast.LENGTH_LONG).show()
            }
            alertDialogBuilder.show()
            true
        } else {
            false
        }
    }

    fun onLogin() {
        profileDbHandler.onLoginAsync(
            callback = {},
            onError = { error ->
                error.printStackTrace()
            }
        )

        editor.putBoolean(Constants.KEY_LOGIN, true).commit()
        openDashboard()
        isNetworkConnectedFlow.onEach { isConnected ->
            if (isConnected) {
                val serverUrl = settings.getString("serverURL", "")
                if (!serverUrl.isNullOrEmpty()) {
                    MainApplication.applicationScope.launch {
                        val canReachServer = MainApplication.Companion.isServerReachable(serverUrl)
                        if (canReachServer) {
                            withContext(Dispatchers.Main) {
                                startUpload("login")
                            }
                            val backgroundRealm = databaseService.realmInstance
                            try {
                                TransactionSyncManager.syncDb(backgroundRealm, "login_activities")
                            } finally {
                                backgroundRealm.close()
                            }
                        }
                    }
                }
            }
        }.launchIn(MainApplication.applicationScope)
    }

    fun settingDialog() {
        val binding = DialogServerUrlBinding.inflate(LayoutInflater.from(this))
        initServerDialog(binding)

        val contextWrapper = ContextThemeWrapper(this, R.style.AlertDialogTheme)
        val dialog = MaterialDialog.Builder(contextWrapper)
            .customView(binding.root, true)
            .positiveText(R.string.sync)
            .negativeText(R.string.txt_cancel)
            .neutralText(R.string.btn_sync_save)
            .onPositive { d: MaterialDialog, _: DialogAction? -> performSync(d) }
            .build()

        positiveAction = dialog.getActionButton(DialogAction.POSITIVE)
        neutralAction = dialog.getActionButton(DialogAction.NEUTRAL)

        handleManualConfiguration(binding, settings.getString("configurationId", null), dialog)
        setRadioProtocolListener(binding)
        binding.clearData.setOnClickListener {
            clearDataDialog(getString(R.string.are_you_sure_you_want_to_clear_data), false)
        }
        setupFastSyncOption(binding)

        showAdditionalServers = false
        if (serverListAddresses.isNotEmpty() && settings.getString("serverURL", "")?.isNotEmpty() == true) {
            refreshServerList()
        }

        neutralAction.setOnClickListener { onNeutralButtonClick(dialog) }

        dialog.show()
        sync(dialog)
        if (!prefData.getManualConfig()) {
            dialog.getActionButton(DialogAction.NEUTRAL).text = getString(R.string.show_more)
        }
    }
    fun continueSync(dialog: MaterialDialog, url: String, isAlternativeUrl: Boolean, defaultUrl: String) {
        processedUrl = saveConfigAndContinue(dialog, url, isAlternativeUrl, defaultUrl)
        if (TextUtils.isEmpty(processedUrl)) return
        isSync = true
        if (checkPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) && settings.getBoolean("firstRun", true)) {
            clearInternalStorage()
        }
        Service(this).isPlanetAvailable(object : PlanetAvailableListener {
            override fun isAvailable() {
                Service(context).checkVersion(this@SyncActivity, settings)
            }
            override fun notAvailable() {
                if (!isFinishing) {
                    syncFailed = true
                    showAlert(context, "Error", getString(R.string.planet_server_not_reachable))
                }
            }
        })
    }

    override fun onSuccess(success: String?) {
        if (customProgressDialog.isShowing() == true && success?.contains("Crash") == true) {
            customProgressDialog.dismiss()
        }
        if (::btnSignIn.isInitialized) {
            showSnack(btnSignIn, success)
        }
        editor.putLong("lastUsageUploaded", Date().time).apply()
        if (::lblLastSyncDate.isInitialized) {
            lblLastSyncDate.text = getString(R.string.message_placeholder, "${getString(R.string.last_sync, TimeUtils.getRelativeTime(Date().time))} >>")
        }
        syncFailed = false
    }

    override fun onUpdateAvailable(info: MyPlanet?, cancelable: Boolean) {
        val builder = getUpdateDialog(this, info, customProgressDialog)
        if (cancelable || getCustomDeviceName(this).endsWith("###")) {
            builder.setNegativeButton(R.string.update_later) { _: DialogInterface?, _: Int ->
                continueSyncProcess()
            }
        } else {
            lifecycleScope.launch(Dispatchers.IO) {
                databaseService.executeTransactionAsync { realm -> realm.deleteAll() }
            }
        }
        builder.setCancelable(cancelable)
        builder.show()
    }

    override fun onCheckingVersion() {
        val lastCheckTime = settings.getLong("last_version_check_timestamp", 0)
        val currentTime = System.currentTimeMillis()
        val twentyFourHoursInMillis = 24 * 60 * 60 * 1000

        if (currentTime - lastCheckTime < twentyFourHoursInMillis) {
            return
        }

        customProgressDialog.setText(getString(R.string.checking_version))
        customProgressDialog.show()
    }

    fun registerReceiver() {
        lifecycleScope.launch {
            broadcastService.events.collect { intent ->
                if (intent.action == DashboardActivity.MESSAGE_PROGRESS) {
                    broadcastReceiver.onReceive(this@SyncActivity, intent)
                }
            }
        }
    }

    override fun onError(msg: String, blockSync: Boolean) {
        Utilities.toast(this, msg)
        if (msg.startsWith("Config")) {
            settingDialog()
        }
        customProgressDialog.dismiss()
        if (!blockSync) continueSyncProcess() else {
            syncIconDrawable.stop()
            syncIconDrawable.selectDrawable(0)
        }
    }

    private fun continueSyncProcess() {
        try {
            lifecycleScope.launch {
                if (isSync) {
                    isServerReachable(processedUrl, "sync")
                } else if (forceSync) {
                    isServerReachable(processedUrl, "upload")
                    startUpload("")
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }


    inner class MyTextWatcher(var view: View?) : TextWatcher {
        override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
        override fun onTextChanged(s: CharSequence, i: Int, i1: Int, i2: Int) {
            if (view?.id == R.id.input_server_url) {
                positiveAction.isEnabled = "$s".trim { it <= ' ' }.isNotEmpty() && URLUtil.isValidUrl("${settings.getString("serverProtocol", "")}$s")
            }
        }
        override fun afterTextChanged(editable: Editable) {}
    }

    override fun onDestroy() {
        super.onDestroy()
    }
    companion object {
        lateinit var cal_today: Calendar
        lateinit var cal_last_Sync: Calendar

        suspend fun clearRealmDb() {
            withContext(Dispatchers.IO) {
                MainApplication.service.withRealm { realm ->
                    realm.executeTransaction { transactionRealm ->
                        transactionRealm.deleteAll()
                    }
                }
            }
        }

        fun clearSharedPref() {
            val settings = context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
            val editor = settings.edit()
            val keysToKeep = setOf(SharedPrefManager.FIRST_LAUNCH, SharedPrefManager.MANUAL_CONFIG)
            val tempStorage = HashMap<String, Boolean>()
            for (key in keysToKeep) {
                tempStorage[key] = settings.getBoolean(key, false)
            }
            editor.clear().apply()
            for ((key, value) in tempStorage) {
                editor.putBoolean(key, value)
            }
            editor.commit()

            val preferences = PreferenceManager.getDefaultSharedPreferences(context)
            preferences.edit { clear() }
        }

        fun restartApp() {
            val intent = context.packageManager.getLaunchIntentForPackage(context.packageName)
            val mainIntent = Intent.makeRestartActivityTask(intent?.component)
            context.startActivity(mainIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/sync/LoginActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.sync

import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.graphics.drawable.AnimationDrawable
import android.os.Build
import android.os.Build.VERSION_CODES.TIRAMISU
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.ContextThemeWrapper
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.inputmethod.EditorInfo
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.TextView
import androidx.activity.OnBackPressedCallback
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.afollestad.materialdialogs.MaterialDialog
import com.bumptech.glide.Glide
import java.util.Locale
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityLoginBinding
import org.ole.planet.myplanet.databinding.DialogServerUrlBinding
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.model.User
import org.ole.planet.myplanet.ui.community.HomeCommunityDialogFragment
import org.ole.planet.myplanet.ui.feedback.FeedbackFragment
import org.ole.planet.myplanet.ui.userprofile.BecomeMemberActivity
import org.ole.planet.myplanet.ui.userprofile.TeamListAdapter
import org.ole.planet.myplanet.utilities.AuthHelper
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.ThemeManager
import org.ole.planet.myplanet.utilities.UrlUtils.getUrl
import org.ole.planet.myplanet.utilities.Utilities.toast

class LoginActivity : SyncActivity(), TeamListAdapter.OnItemClickListener {
    private lateinit var binding: ActivityLoginBinding
    private var guest = false
    var users: List<RealmUserModel>? = null
    private var mAdapter: TeamListAdapter? = null
    private var backPressedTime: Long = 0
    private val backPressedInterval: Long = 2000
    private var teamList = java.util.ArrayList<String?>()
    private var teamAdapter: ArrayAdapter<String?>? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityLoginBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        lblLastSyncDate = binding.lblLastSyncDate
        btnSignIn = binding.btnSignin
        syncIcon = binding.syncIcon
        lblVersion = binding.lblVersion
        tvAvailableSpace = binding.tvAvailableSpace
        btnGuestLogin = binding.btnGuestLogin
        becomeMember = binding.becomeMember
        btnFeedback = binding.btnFeedback
        openCommunity = binding.openCommunity
        btnLang = binding.btnLang
        inputName = binding.inputName
        inputPassword = binding.inputPassword
        service = Service(this)

        binding.tvAvailableSpace.text = buildString {
            append(getString(R.string.available_space_colon))
            append(" ")
            append(FileUtils.availableOverTotalMemoryFormattedString(this@LoginActivity))
        }
        changeLogoColor()
        declareElements()
        declareMoreElements()
        showWifiDialog()
        registerReceiver()
        forceSync = intent.getBooleanExtra("forceSync", false)
        processedUrl = getUrl()
        if (forceSync) {
            isSync = false
        }
        val versionInfo = if (Build.VERSION.SDK_INT >= TIRAMISU) {
            intent.getSerializableExtra("versionInfo", MyPlanet::class.java)
        } else {
            @Suppress("DEPRECATION")
            intent.getSerializableExtra("versionInfo") as? MyPlanet
        }

        if (versionInfo != null) {
            onUpdateAvailable(versionInfo, intent.getBooleanExtra("cancelable", false))
        } else {
            service.checkVersion(this, settings)
        }
        checkUsagesPermission()
        forceSyncTrigger()

        val url = getUrl()
        if (url.isNotEmpty() && url != "/db") {
            binding.openCommunity.visibility = View.VISIBLE
            binding.openCommunity.setOnClickListener {
                HomeCommunityDialogFragment().show(supportFragmentManager, "")
            }
            HomeCommunityDialogFragment().show(supportFragmentManager, "")
        } else {
            binding.openCommunity.visibility = View.GONE
        }
        binding.btnFeedback.setOnClickListener {
            if (getUrl() != "/db") {
                FeedbackFragment().show(supportFragmentManager, "")
            } else {
                toast(this, getString(R.string.please_enter_server_url_first))
                settingDialog()
            }
        }

        guest = intent.getBooleanExtra("guest", false)
        val username = intent.getStringExtra("username")
        val password = intent.getStringExtra("password")
        val autoLogin = intent.getBooleanExtra("auto_login", false)

        if (guest) {
            resetGuestAsMember(username)
        }

        if (autoLogin && username != null && password != null) {
            lifecycleScope.launch {
                delay(500)
                submitForm(username, password)
            }
        }

        getTeamMembers()

        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                if (System.currentTimeMillis() - backPressedTime < backPressedInterval) {
                    finish()
                } else {
                    toast(this@LoginActivity, getString(R.string.press_back_again_to_exit))
                    backPressedTime = System.currentTimeMillis()
                }
            }
        })
        val selectDarkModeButton = binding.themeToggleButton
        selectDarkModeButton.setOnClickListener {
            ThemeManager.showThemeDialog(this)
        }
    }

    private fun declareElements() {
        binding.customDeviceName.text = getCustomDeviceName()
        btnSignIn.setOnClickListener {
            if (isFinishing || isDestroyed) {
                return@setOnClickListener
            }
            if (getUrl() != "/db") {
                if (TextUtils.isEmpty(binding.inputName.text.toString())) {
                    binding.inputName.error = getString(R.string.err_msg_name)
                } else if (TextUtils.isEmpty(binding.inputPassword.text.toString())) {
                    binding.inputPassword.error = getString(R.string.err_msg_password)
                } else {
                    val enterUserName = binding.inputName.text.toString().trimEnd()
                    val user = databaseService.withRealm { realm ->
                        realm.where(RealmUserModel::class.java).equalTo("name", enterUserName).findFirst()?.let { realm.copyFromRealm(it) }
                    }
                    if (user == null || !user.isArchived) {
                        submitForm(enterUserName, binding.inputPassword.text.toString())
                    } else {
                        val builder = AlertDialog.Builder(this)
                        builder.setMessage("member ${binding.inputName.text} is archived")
                        builder.setCancelable(false)
                        builder.setPositiveButton("ok") { dialog: DialogInterface, _: Int ->
                            dialog.dismiss()
                            binding.inputName.setText(R.string.empty_text)
                            binding.inputPassword.setText(R.string.empty_text)
                        }
                        val dialog = builder.create()
                        dialog.show()
                    }
                }
            } else {
                toast(this, getString(R.string.please_enter_server_url_first))
                settingDialog()
            }
        }
        if (!settings.contains("serverProtocol")) settings.edit {
            putString("serverProtocol", "http://")
        }
        binding.becomeMember.setOnClickListener {
            if (getUrl() != "/db") {
                binding.inputName.setText(R.string.empty_text)
                becomeAMember()
            } else {
                toast(this, getString(R.string.please_enter_server_url_first))
                settingDialog()
            }
        }

        binding.imgBtnSetting.setOnClickListener {
            binding.inputName.setText(R.string.empty_text)
            settingDialog()
        }

        binding.btnGuestLogin.setOnClickListener {
            if (getUrl() != "/db") {
                binding.inputName.setText(R.string.empty_text)
                showGuestLoginDialog()
            } else {
                toast(this, getString(R.string.please_enter_server_url_first))
                settingDialog()
            }
        }
    }

    private fun declareMoreElements() {
        syncIcon.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.login_file_upload_animation))
        syncIcon.scaleType
        syncIconDrawable = syncIcon.drawable as AnimationDrawable
        syncIcon.setOnClickListener {
            if (getUrl() != "/db") {
                val protocol = settings.getString("serverProtocol", "")
                val serverUrl = "${settings.getString("serverURL", "")}"
                val serverPin = "${settings.getString("serverPin", "")}"

                val url = if (serverUrl.startsWith("http://") || serverUrl.startsWith("https://")) {
                    serverUrl
                } else {
                    "$protocol$serverUrl"
                }
                syncIconDrawable.start()

                val dialogServerUrlBinding = DialogServerUrlBinding.inflate(LayoutInflater.from(this))
                val contextWrapper = ContextThemeWrapper(this, R.style.AlertDialogTheme)
                val builder = MaterialDialog.Builder(contextWrapper).customView(dialogServerUrlBinding.root, true)
                val dialog = builder.build()
                currentDialog = dialog
                service.getMinApk(this, url, serverPin, this, "LoginActivity")
            } else {
                toast(this, getString(R.string.please_enter_server_url_first))
                settingDialog()
            }
        }
        declareHideKeyboardElements()
        binding.lblVersion.text = getString(R.string.version, resources.getText(R.string.app_version))
        binding.inputName.addTextChangedListener(MyTextWatcher(binding.inputName))
        binding.inputPassword.addTextChangedListener(MyTextWatcher(binding.inputPassword))
        binding.inputPassword.setOnEditorActionListener { _: TextView?, actionId: Int, event: KeyEvent? ->
            if (isFinishing || isDestroyed) {
                return@setOnEditorActionListener false
            }
            if (actionId == EditorInfo.IME_ACTION_DONE || event != null && event.action == KeyEvent.ACTION_DOWN && event.keyCode == KeyEvent.KEYCODE_ENTER) {
                btnSignIn.performClick()
                return@setOnEditorActionListener true
            }
            false
        }
        setUpLanguageButton()
        if (NetworkUtils.isNetworkConnected) {
            service.syncPlanetServers { success: String? ->
                toast(this, success)
            }
        }
        binding.inputName.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                val lowercaseText = s.toString().lowercase()
                if (s.toString() != lowercaseText) {
                    binding.inputName.setText(lowercaseText)
                    binding.inputName.setSelection(lowercaseText.length)
                }
            }

            override fun afterTextChanged(s: Editable) {}
        })
        if (getUrl().isNotEmpty()) {
            updateTeamDropdown()
        }
    }

    fun updateTeamDropdown() {
        val teams: List<RealmMyTeam>? = databaseService.withRealm { realm ->
            realm.where(RealmMyTeam::class.java)
                .isEmpty("teamId").equalTo("status", "active").findAll()?.let { realm.copyFromRealm(it) }
        }

        if (!teams.isNullOrEmpty()) {
            binding.team.visibility = View.VISIBLE
            teamAdapter = ArrayAdapter(this, R.layout.spinner_item_white, teamList)
            teamAdapter?.setDropDownViewResource(R.layout.custom_simple_list_item_1)
            teamList.clear()
            teamList.add(getString(R.string.select_team))
            for (team in teams) {
                if (team.isValid) {
                    teamList.add(team.name)
                }
            }
            binding.team.adapter = teamAdapter
            val lastSelection = prefData.getSelectedTeamId()
            if (!lastSelection.isNullOrEmpty()) {
                for (i in teams.indices) {
                    val team = teams[i]
                    if (team._id != null && team._id == lastSelection && team.isValid) {
                        val lastSelectedPosition = i + 1
                        binding.team.setSelection(lastSelectedPosition)
                        break
                    }
                }
            }

            binding.team.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                override fun onItemSelected(parentView: AdapterView<*>?, selectedItemView: View?, position: Int, id: Long) {
                    if (position > 0) {
                        val selectedTeam = teams[position - 1]
                        val currentTeamId = prefData.getSelectedTeamId()
                        if (currentTeamId != selectedTeam._id) {
                            prefData.setSelectedTeamId(selectedTeam._id)
                            getTeamMembers()
                        }
                    }
                }

                override fun onNothingSelected(parentView: AdapterView<*>?) {}
            }
        } else {
            binding.team.visibility = View.GONE
        }
    }

    private fun setUpLanguageButton() {
        updateLanguageButtonText()

        binding.btnLang.setOnClickListener {
            showLanguageSelectionDialog()
        }
    }

    private fun updateLanguageButtonText() {
        val currentLanguage = LocaleHelper.getLanguage(this)
        binding.btnLang.text = getLanguageString(currentLanguage)
    }

    private fun showLanguageSelectionDialog() {
        val currentLanguage = LocaleHelper.getLanguage(this)
        val options = arrayOf(
            getString(R.string.english),
            getString(R.string.spanish),
            getString(R.string.somali),
            getString(R.string.nepali),
            getString(R.string.arabic),
            getString(R.string.french)
        )
        val languageCodes = arrayOf("en", "es", "so", "ne", "ar", "fr")
        val checkedItem = languageCodes.indexOf(currentLanguage)

        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle(getString(R.string.select_language))
            .setSingleChoiceItems(
                ArrayAdapter(this, R.layout.checked_list_item, options),
                checkedItem
            ) { dialog, which ->
                val selectedLanguage = languageCodes[which]
                if (selectedLanguage != currentLanguage) {
                    LocaleHelper.setLocale(this, selectedLanguage)
                    recreate()
                    dialog.dismiss()
                } else {
                    dialog.dismiss()
                }
            }
            .setNegativeButton(R.string.cancel, null)
            .show()
    }

    private fun updateConfiguration(languageCode: String) {
        val locale = Locale(languageCode)
        Locale.setDefault(locale)
        val config = resources.configuration
        config.setLocale(locale)
        resources.updateConfiguration(config, resources.displayMetrics)
    }

    override fun attachBaseContext(newBase: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(newBase))
    }

    private fun declareHideKeyboardElements() {
        binding.constraintLayout.setOnTouchListener { view, event ->
            when (event?.action) {
                MotionEvent.ACTION_UP -> {
                    view?.let {
                        hideKeyboard(it)
                        it.performClick()
                    }
                }
            }
            true
        }
    }

    fun getTeamMembers() {
        selectedTeamId = prefData.getSelectedTeamId().toString()
        if (selectedTeamId?.isNotEmpty() == true) {
            users = databaseService.withRealm { realm ->
                RealmMyTeam.getUsers(selectedTeamId, realm, "membership").map { realm.copyFromRealm(it) }.toMutableList()
            }
            val userList = (users as? MutableList<RealmUserModel>)?.map {
                User(it.name ?: "", it.name ?: "", "", it.userImage ?: "", "team")
            } ?: emptyList()

            val existingUsers = prefData.getSavedUsers().toMutableList()
            val filteredExistingUsers = existingUsers.filter { it.source != "team" }
            val updatedUserList = userList.filterNot { user -> filteredExistingUsers.any { it.name == user.name } } + filteredExistingUsers
            prefData.setSavedUsers(updatedUserList)
        }

        updateTeamDropdown()

        if (mAdapter == null) {
            mAdapter = TeamListAdapter(prefData.getSavedUsers().toMutableList(), this)
            binding.recyclerView.layoutManager = LinearLayoutManager(this)
            binding.recyclerView.adapter = mAdapter
        } else {
            mAdapter?.updateList(prefData.getSavedUsers().toMutableList())
        }

        binding.recyclerView.isNestedScrollingEnabled = true
        binding.recyclerView.scrollBarStyle = View.SCROLLBARS_INSIDE_OVERLAY
        binding.recyclerView.isVerticalScrollBarEnabled = true

    }
    override fun onItemClick(user: User) {
        if (user.password?.isEmpty() == true && user.source != "guest") {
            Glide.with(this)
                .load(user.image)
                .placeholder(R.drawable.profile)
                .error(R.drawable.profile)
                .into(binding.userProfile)

            binding.inputName.setText(user.name)
        } else {
            if (user.source == "guest"){
                val model = databaseService.withRealm { realm ->
                    RealmUserModel.createGuestUser(user.name, realm, settings)?.let { realm.copyFromRealm(it) }
                }
                if (model == null) {
                    toast(this, getString(R.string.unable_to_login))
                } else {
                    saveUserInfoPref(settings, "", model)
                    onLogin()
                }
            } else {
                submitForm(user.name, user.password)
            }
        }
    }

    private fun submitForm(name: String?, password: String?) {
        AuthHelper.login(this, name, password)
    }

    internal fun showGuestDialog(username: String) {
        val builder = AlertDialog.Builder(this)
        builder.setTitle("$username is already a guest")
        builder.setMessage("Continue only if this is you")
        builder.setCancelable(false)
        builder.setNegativeButton("cancel") { dialog: DialogInterface, _: Int -> dialog.dismiss() }
        builder.setPositiveButton("continue") { dialog: DialogInterface, _: Int ->
            dialog.dismiss()
            val model = databaseService.withRealm { realm ->
                RealmUserModel.createGuestUser(username, realm, settings)?.let { realm.copyFromRealm(it) }
            }
            if (model == null) {
                toast(this, getString(R.string.unable_to_login))
            } else {
                saveUserInfoPref(settings, "", model)
                onLogin()
            }
        }
        val dialog = builder.create()
        dialog.show()
    }

    internal fun showUserAlreadyMemberDialog(username: String) {
        val builder = AlertDialog.Builder(this)
        builder.setTitle("$username is already a member")
        builder.setMessage("Continue to login if this is you")
        builder.setCancelable(false)
        builder.setNegativeButton("Cancel") { dialog: DialogInterface, _: Int -> dialog.dismiss() }
        builder.setPositiveButton("login") { dialog: DialogInterface, _: Int ->
            dialog.dismiss()
            binding.inputName.setText(username)
        }
        val dialog = builder.create()
        dialog.show()
    }

    fun saveUsers(name: String?, password: String?, source: String) {
        if (source === "guest") {
            val newUser = User("", name, password, "", "guest")
            val existingUsers: MutableList<User> = ArrayList(
                prefData.getSavedUsers()
            )
            var newUserExists = false
            for ((_, name1) in existingUsers) {
                if (name1 == newUser.name?.trim { it <= ' ' }) {
                    newUserExists = true
                    break
                }
            }
            if (!newUserExists) {
                existingUsers.add(newUser)
                prefData.setSavedUsers(existingUsers)
            }
        } else if (source === "member") {
            var userProfile = profileDbHandler.userModel?.userImage
            val userName: String? = profileDbHandler.userModel?.name
            if (userProfile == null) {
                userProfile = ""
            }
            val newUser = User(userName, name, password, userProfile, "member")
            val existingUsers: MutableList<User> = ArrayList(prefData.getSavedUsers())
            var newUserExists = false
            for ((fullName1) in existingUsers) {
                if (fullName1 == newUser.fullName?.trim { it <= ' ' }) {
                    newUserExists = true
                    break
                }
            }
            if (!newUserExists) {
                existingUsers.add(newUser)
                prefData.setSavedUsers(existingUsers)
            }
        }
    }

    private fun becomeAMember() {
        if (getUrl().isNotEmpty()) {
            startActivity(Intent(this, BecomeMemberActivity::class.java))
        } else {
            toast(this, getString(R.string.please_enter_server_url_first))
            settingDialog()
        }
    }

    fun getCustomDeviceName(): String? {
        return settings.getString("customDeviceName", NetworkUtils.getDeviceName())
    }

    private fun resetGuestAsMember(username: String?) {
        val existingUsers = prefData.getSavedUsers().toMutableList()
        var newUserExists = false
        for ((_, name) in existingUsers) {
            if (name == username) {
                newUserExists = true
                break
            }
        }
        if (newUserExists) {
            val iterator = existingUsers.iterator()
            while (iterator.hasNext()) {
                val (_, name) = iterator.next()
                if (name == username) {
                    iterator.remove()
                }
            }
            prefData.setSavedUsers(existingUsers)
        }
    }

    override fun onResume() {
        super.onResume()
        binding.userProfile.setImageResource(R.drawable.profile)
    }

    override fun onDestroy() {
        super.onDestroy()
    }
}
=======
package org.ole.planet.myplanet.ui.sync


import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.graphics.drawable.AnimationDrawable
import android.os.Build
import android.os.Build.VERSION_CODES.TIRAMISU
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.ContextThemeWrapper
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.inputmethod.EditorInfo
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.TextView
import androidx.activity.OnBackPressedCallback
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.afollestad.materialdialogs.MaterialDialog
import com.bumptech.glide.Glide
import java.util.Locale
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityLoginBinding
import org.ole.planet.myplanet.databinding.DialogServerUrlBinding
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.model.User
import org.ole.planet.myplanet.ui.community.HomeCommunityDialogFragment
import org.ole.planet.myplanet.ui.feedback.FeedbackFragment
import org.ole.planet.myplanet.ui.userprofile.BecomeMemberActivity
import org.ole.planet.myplanet.ui.userprofile.TeamListAdapter
import org.ole.planet.myplanet.utilities.AuthHelper
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.ThemeManager
import org.ole.planet.myplanet.utilities.UrlUtils.getUrl
import org.ole.planet.myplanet.utilities.Utilities.toast

class LoginActivity : SyncActivity(), TeamListAdapter.OnItemClickListener {
    private lateinit var binding: ActivityLoginBinding
    private var guest = false
    var users: List<RealmUserModel>? = null
    private var mAdapter: TeamListAdapter? = null
    private var backPressedTime: Long = 0
    private val backPressedInterval: Long = 2000
    private var teamList = java.util.ArrayList<String?>()
    private var teamAdapter: ArrayAdapter<String?>? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityLoginBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        lblLastSyncDate = binding.lblLastSyncDate
        btnSignIn = binding.btnSignin
        syncIcon = binding.syncIcon
        lblVersion = binding.lblVersion
        tvAvailableSpace = binding.tvAvailableSpace
        btnGuestLogin = binding.btnGuestLogin
        becomeMember = binding.becomeMember
        btnFeedback = binding.btnFeedback
        openCommunity = binding.openCommunity
        btnLang = binding.btnLang
        inputName = binding.inputName
        inputPassword = binding.inputPassword
        service = Service(this)

        binding.tvAvailableSpace.text = buildString {
            append(getString(R.string.available_space_colon))
            append(" ")
            append(FileUtils.availableOverTotalMemoryFormattedString(this@LoginActivity))
        }
        changeLogoColor()
        declareElements()
        declareMoreElements()
        showWifiDialog()
        registerReceiver()
        forceSync = intent.getBooleanExtra("forceSync", false)
        processedUrl = getUrl()
        if (forceSync) {
            isSync = false
        }
        val versionInfo = if (Build.VERSION.SDK_INT >= TIRAMISU) {
            intent.getSerializableExtra("versionInfo", MyPlanet::class.java)
        } else {
            @Suppress("DEPRECATION")
            intent.getSerializableExtra("versionInfo") as? MyPlanet
        }

        if (versionInfo != null) {
            onUpdateAvailable(versionInfo, intent.getBooleanExtra("cancelable", false))
        } else {
            service.checkVersion(this, settings)
        }
        checkUsagesPermission()
        forceSyncTrigger()

        val url = getUrl()
        if (url.isNotEmpty() && url != "/db") {
            binding.openCommunity.visibility = View.VISIBLE
            binding.openCommunity.setOnClickListener {
                HomeCommunityDialogFragment().show(supportFragmentManager, "")
            }
            HomeCommunityDialogFragment().show(supportFragmentManager, "")
        } else {
            binding.openCommunity.visibility = View.GONE
        }
        binding.btnFeedback.setOnClickListener {
            if (getUrl() != "/db") {
                FeedbackFragment().show(supportFragmentManager, "")
            } else {
                toast(this, getString(R.string.please_enter_server_url_first))
                settingDialog()
            }
        }

        guest = intent.getBooleanExtra("guest", false)
        val username = intent.getStringExtra("username")
        val password = intent.getStringExtra("password")
        val autoLogin = intent.getBooleanExtra("auto_login", false)

        if (guest) {
            resetGuestAsMember(username)
        }

        if (autoLogin && username != null && password != null) {
            lifecycleScope.launch {
                delay(500)
                submitForm(username, password)
            }
        }

        getTeamMembers()

        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                if (System.currentTimeMillis() - backPressedTime < backPressedInterval) {
                    finish()
                } else {
                    toast(this@LoginActivity, getString(R.string.press_back_again_to_exit))
                    backPressedTime = System.currentTimeMillis()
                }
            }
        })
        val selectDarkModeButton = binding.themeToggleButton
        selectDarkModeButton.setOnClickListener {
            ThemeManager.showThemeDialog(this)
        }
    }

    private fun declareElements() {
        binding.customDeviceName.text = getCustomDeviceName()
        btnSignIn.setOnClickListener {
            if (isFinishing || isDestroyed) {
                return@setOnClickListener
            }
            if (getUrl() != "/db") {
                if (TextUtils.isEmpty(binding.inputName.text.toString())) {
                    binding.inputName.error = getString(R.string.err_msg_name)
                } else if (TextUtils.isEmpty(binding.inputPassword.text.toString())) {
                    binding.inputPassword.error = getString(R.string.err_msg_password)
                } else {
                    val enterUserName = binding.inputName.text.toString().trimEnd()
                    val user = databaseService.withRealm { realm ->
                        realm.where(RealmUserModel::class.java).equalTo("name", enterUserName).findFirst()?.let { realm.copyFromRealm(it) }
                    }
                    if (user == null || !user.isArchived) {
                        submitForm(enterUserName, binding.inputPassword.text.toString())
                    } else {
                        val builder = AlertDialog.Builder(this)
                        builder.setMessage("member ${binding.inputName.text} is archived")
                        builder.setCancelable(false)
                        builder.setPositiveButton("ok") { dialog: DialogInterface, _: Int ->
                            dialog.dismiss()
                            binding.inputName.setText(R.string.empty_text)
                            binding.inputPassword.setText(R.string.empty_text)
                        }
                        val dialog = builder.create()
                        dialog.show()
                    }
                }
            } else {
                toast(this, getString(R.string.please_enter_server_url_first))
                settingDialog()
            }
        }
        if (!settings.contains("serverProtocol")) settings.edit {
            putString("serverProtocol", "http://")
        }
        binding.becomeMember.setOnClickListener {
            if (getUrl() != "/db") {
                binding.inputName.setText(R.string.empty_text)
                becomeAMember()
            } else {
                toast(this, getString(R.string.please_enter_server_url_first))
                settingDialog()
            }
        }

        binding.imgBtnSetting.setOnClickListener {
            binding.inputName.setText(R.string.empty_text)
            settingDialog()
        }

        binding.btnGuestLogin.setOnClickListener {
            if (getUrl() != "/db") {
                binding.inputName.setText(R.string.empty_text)
                showGuestLoginDialog()
            } else {
                toast(this, getString(R.string.please_enter_server_url_first))
                settingDialog()
            }
        }
    }

    private fun declareMoreElements() {
        syncIcon.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.login_file_upload_animation))
        syncIcon.scaleType
        syncIconDrawable = syncIcon.drawable as AnimationDrawable
        syncIcon.setOnClickListener {
            if (getUrl() != "/db") {
                val protocol = settings.getString("serverProtocol", "")
                val serverUrl = "${settings.getString("serverURL", "")}"
                val serverPin = "${settings.getString("serverPin", "")}"

                val url = if (serverUrl.startsWith("http://") || serverUrl.startsWith("https://")) {
                    serverUrl
                } else {
                    "$protocol$serverUrl"
                }
                syncIconDrawable.start()

                val dialogServerUrlBinding = DialogServerUrlBinding.inflate(LayoutInflater.from(this))
                val contextWrapper = ContextThemeWrapper(this, R.style.AlertDialogTheme)
                val builder = MaterialDialog.Builder(contextWrapper).customView(dialogServerUrlBinding.root, true)
                val dialog = builder.build()
                currentDialog = dialog
                service.getMinApk(this, url, serverPin, this, "LoginActivity")
            } else {
                toast(this, getString(R.string.please_enter_server_url_first))
                settingDialog()
            }
        }
        declareHideKeyboardElements()
        binding.lblVersion.text = getString(R.string.version, resources.getText(R.string.app_version))
        binding.inputName.addTextChangedListener(MyTextWatcher(binding.inputName))
        binding.inputPassword.addTextChangedListener(MyTextWatcher(binding.inputPassword))
        binding.inputPassword.setOnEditorActionListener { _: TextView?, actionId: Int, event: KeyEvent? ->
            if (isFinishing || isDestroyed) {
                return@setOnEditorActionListener false
            }
            if (actionId == EditorInfo.IME_ACTION_DONE || event != null && event.action == KeyEvent.ACTION_DOWN && event.keyCode == KeyEvent.KEYCODE_ENTER) {
                btnSignIn.performClick()
                return@setOnEditorActionListener true
            }
            false
        }
        setUpLanguageButton()
        if (NetworkUtils.isNetworkConnected) {
            service.syncPlanetServers { success: String? ->
                toast(this, success)
            }
        }
        binding.inputName.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                val lowercaseText = s.toString().lowercase()
                if (s.toString() != lowercaseText) {
                    binding.inputName.setText(lowercaseText)
                    binding.inputName.setSelection(lowercaseText.length)
                }
            }

            override fun afterTextChanged(s: Editable) {}
        })
        if (getUrl().isNotEmpty()) {
            updateTeamDropdown()
        }
    }

    fun updateTeamDropdown() {
        val teams: List<RealmMyTeam>? = databaseService.withRealm { realm ->
            realm.where(RealmMyTeam::class.java)
                .isEmpty("teamId").equalTo("status", "active").findAll()?.let { realm.copyFromRealm(it) }
        }

        if (!teams.isNullOrEmpty()) {
            binding.team.visibility = View.VISIBLE
            teamAdapter = ArrayAdapter(this, R.layout.spinner_item_white, teamList)
            teamAdapter?.setDropDownViewResource(R.layout.custom_simple_list_item_1)
            teamList.clear()
            teamList.add(getString(R.string.select_team))
            for (team in teams) {
                if (team.isValid) {
                    teamList.add(team.name)
                }
            }
            binding.team.adapter = teamAdapter
            val lastSelection = prefData.getSelectedTeamId()
            if (!lastSelection.isNullOrEmpty()) {
                for (i in teams.indices) {
                    val team = teams[i]
                    if (team._id != null && team._id == lastSelection && team.isValid) {
                        val lastSelectedPosition = i + 1
                        binding.team.setSelection(lastSelectedPosition)
                        break
                    }
                }
            }

            binding.team.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
                override fun onItemSelected(parentView: AdapterView<*>?, selectedItemView: View?, position: Int, id: Long) {
                    if (position > 0) {
                        val selectedTeam = teams[position - 1]
                        val currentTeamId = prefData.getSelectedTeamId()
                        if (currentTeamId != selectedTeam._id) {
                            prefData.setSelectedTeamId(selectedTeam._id)
                            getTeamMembers()
                        }
                    }
                }

                override fun onNothingSelected(parentView: AdapterView<*>?) {}
            }
        } else {
            binding.team.visibility = View.GONE
        }
    }

    private fun setUpLanguageButton() {
        updateLanguageButtonText()

        binding.btnLang.setOnClickListener {
            showLanguageSelectionDialog()
        }
    }

    private fun updateLanguageButtonText() {
        val currentLanguage = LocaleHelper.getLanguage(this)
        binding.btnLang.text = getLanguageString(currentLanguage)
    }

    private fun showLanguageSelectionDialog() {
        val currentLanguage = LocaleHelper.getLanguage(this)
        val options = arrayOf(
            getString(R.string.english),
            getString(R.string.spanish),
            getString(R.string.somali),
            getString(R.string.nepali),
            getString(R.string.arabic),
            getString(R.string.french)
        )
        val languageCodes = arrayOf("en", "es", "so", "ne", "ar", "fr")
        val checkedItem = languageCodes.indexOf(currentLanguage)

        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle(getString(R.string.select_language))
            .setSingleChoiceItems(
                ArrayAdapter(this, R.layout.checked_list_item, options),
                checkedItem
            ) { dialog, which ->
                val selectedLanguage = languageCodes[which]
                if (selectedLanguage != currentLanguage) {
                    LocaleHelper.setLocale(this, selectedLanguage)
                    recreate()
                    dialog.dismiss()
                } else {
                    dialog.dismiss()
                }
            }
            .setNegativeButton(R.string.cancel, null)
            .show()
    }

    private fun updateConfiguration(languageCode: String) {
        val locale = Locale(languageCode)
        Locale.setDefault(locale)
        val config = resources.configuration
        config.setLocale(locale)
        resources.updateConfiguration(config, resources.displayMetrics)
    }

    override fun attachBaseContext(newBase: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(newBase))
    }

    private fun declareHideKeyboardElements() {
        binding.constraintLayout.setOnTouchListener { view, event ->
            when (event?.action) {
                MotionEvent.ACTION_UP -> {
                    view?.let {
                        hideKeyboard(it)
                        it.performClick()
                    }
                }
            }
            true
        }
    }

    fun getTeamMembers() {
        selectedTeamId = prefData.getSelectedTeamId().toString()
        if (selectedTeamId?.isNotEmpty() == true) {
            users = databaseService.withRealm { realm ->
                RealmMyTeam.getUsers(selectedTeamId, realm, "membership").map { realm.copyFromRealm(it) }.toMutableList()
            }
            val userList = (users as? MutableList<RealmUserModel>)?.map {
                User(it.name ?: "", it.name ?: "", "", it.userImage ?: "", "team")
            } ?: emptyList()

            val existingUsers = prefData.getSavedUsers().toMutableList()
            val filteredExistingUsers = existingUsers.filter { it.source != "team" }
            val updatedUserList = userList.filterNot { user -> filteredExistingUsers.any { it.name == user.name } } + filteredExistingUsers
            prefData.setSavedUsers(updatedUserList)
        }

        updateTeamDropdown()

        if (mAdapter == null) {
            mAdapter = TeamListAdapter(prefData.getSavedUsers().toMutableList(), this)
            binding.recyclerView.layoutManager = LinearLayoutManager(this)
            binding.recyclerView.adapter = mAdapter
        } else {
            mAdapter?.updateList(prefData.getSavedUsers().toMutableList())
        }

        binding.recyclerView.isNestedScrollingEnabled = true
        binding.recyclerView.scrollBarStyle = View.SCROLLBARS_INSIDE_OVERLAY
        binding.recyclerView.isVerticalScrollBarEnabled = true

    }
    override fun onItemClick(user: User) {
        if (user.password?.isEmpty() == true && user.source != "guest") {
            Glide.with(this)
                .load(user.image)
                .placeholder(R.drawable.profile)
                .error(R.drawable.profile)
                .into(binding.userProfile)

            binding.inputName.setText(user.name)
        } else {
            if (user.source == "guest"){
                val model = databaseService.withRealm { realm ->
                    RealmUserModel.createGuestUser(user.name, realm, settings)?.let { realm.copyFromRealm(it) }
                }
                if (model == null) {
                    toast(this, getString(R.string.unable_to_login))
                } else {
                    saveUserInfoPref(settings, "", model)
                    onLogin()
                }
            } else {
                submitForm(user.name, user.password)
            }
        }
    }

    private fun submitForm(name: String?, password: String?) {
        AuthHelper.login(this, name, password)
    }

    internal fun showGuestDialog(username: String) {
        val builder = AlertDialog.Builder(this)
        builder.setTitle("$username is already a guest")
        builder.setMessage("Continue only if this is you")
        builder.setCancelable(false)
        builder.setNegativeButton("cancel") { dialog: DialogInterface, _: Int -> dialog.dismiss() }
        builder.setPositiveButton("continue") { dialog: DialogInterface, _: Int ->
            dialog.dismiss()
            val model = databaseService.withRealm { realm ->
                RealmUserModel.createGuestUser(username, realm, settings)?.let { realm.copyFromRealm(it) }
            }
            if (model == null) {
                toast(this, getString(R.string.unable_to_login))
            } else {
                saveUserInfoPref(settings, "", model)
                onLogin()
            }
        }
        val dialog = builder.create()
        dialog.show()
    }

    internal fun showUserAlreadyMemberDialog(username: String) {
        val builder = AlertDialog.Builder(this)
        builder.setTitle("$username is already a member")
        builder.setMessage("Continue to login if this is you")
        builder.setCancelable(false)
        builder.setNegativeButton("Cancel") { dialog: DialogInterface, _: Int -> dialog.dismiss() }
        builder.setPositiveButton("login") { dialog: DialogInterface, _: Int ->
            dialog.dismiss()
            binding.inputName.setText(username)
        }
        val dialog = builder.create()
        dialog.show()
    }

    fun saveUsers(name: String?, password: String?, source: String) {
        if (source === "guest") {
            val newUser = User("", name, password, "", "guest")
            val existingUsers: MutableList<User> = ArrayList(
                prefData.getSavedUsers()
            )
            var newUserExists = false
            for ((_, name1) in existingUsers) {
                if (name1 == newUser.name?.trim { it <= ' ' }) {
                    newUserExists = true
                    break
                }
            }
            if (!newUserExists) {
                existingUsers.add(newUser)
                prefData.setSavedUsers(existingUsers)
            }
        } else if (source === "member") {
            var userProfile = profileDbHandler.userModel?.userImage
            val userName: String? = profileDbHandler.userModel?.name
            if (userProfile == null) {
                userProfile = ""
            }
            val newUser = User(userName, name, password, userProfile, "member")
            val existingUsers: MutableList<User> = ArrayList(prefData.getSavedUsers())
            var newUserExists = false
            for ((fullName1) in existingUsers) {
                if (fullName1 == newUser.fullName?.trim { it <= ' ' }) {
                    newUserExists = true
                    break
                }
            }
            if (!newUserExists) {
                existingUsers.add(newUser)
                prefData.setSavedUsers(existingUsers)
            }
        }
    }

    private fun becomeAMember() {
        if (getUrl().isNotEmpty()) {
            startActivity(Intent(this, BecomeMemberActivity::class.java))
        } else {
            toast(this, getString(R.string.please_enter_server_url_first))
            settingDialog()
        }
    }

    fun getCustomDeviceName(): String? {
        return settings.getString("customDeviceName", NetworkUtils.getDeviceName())
    }

    private fun resetGuestAsMember(username: String?) {
        val existingUsers = prefData.getSavedUsers().toMutableList()
        var newUserExists = false
        for ((_, name) in existingUsers) {
            if (name == username) {
                newUserExists = true
                break
            }
        }
        if (newUserExists) {
            val iterator = existingUsers.iterator()
            while (iterator.hasNext()) {
                val (_, name) = iterator.next()
                if (name == username) {
                    iterator.remove()
                }
            }
            prefData.setSavedUsers(existingUsers)
        }
    }

    override fun onResume() {
        super.onResume()
        binding.userProfile.setImageResource(R.drawable.profile)
    }

    override fun onDestroy() {
        super.onDestroy()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/sync/ServerAddressAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.sync

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.button.MaterialButton
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.ServerAddressesModel
import org.ole.planet.myplanet.utilities.DiffUtils

class ServerAddressAdapter(
    private val onItemClick: (ServerAddressesModel) -> Unit,
    private val onClearDataDialog: (ServerAddressesModel, Int) -> Unit,
    private val urlWithoutProtocol: String?,
) : ListAdapter<ServerAddressesModel, ServerAddressAdapter.ViewHolder>(
    DiffUtils.itemCallback(
        areItemsTheSame = { old, new -> old.url == new.url },
        areContentsTheSame = { old, new -> old == new },
    ),
) {
    private var selectedPosition: Int = -1
    private var lastSelectedPosition: Int = -1

    fun setSelectedPosition(position: Int) {
        val previous = selectedPosition
        lastSelectedPosition = previous
        selectedPosition = position
        if (previous in currentList.indices) {
            notifyItemChanged(previous)
        }
        if (position in currentList.indices) {
            notifyItemChanged(position)
        }
    }

    fun revertSelection() {
        val current = selectedPosition
        selectedPosition = lastSelectedPosition
        if (current in currentList.indices) {
            notifyItemChanged(current)
        }
        if (selectedPosition in currentList.indices) {
            notifyItemChanged(selectedPosition)
        }
    }

    fun clearSelection() {
        val current = selectedPosition
        selectedPosition = -1
        if (current in currentList.indices) {
            notifyItemChanged(current)
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_server_address, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val serverAddress = getItem(position)
        holder.bind(serverAddress, position == selectedPosition)
        holder.itemView.setOnClickListener {
            if (!urlWithoutProtocol.isNullOrEmpty() &&
                serverAddress.url.replace(Regex("^https?://"), "") != urlWithoutProtocol
            ) {
                onClearDataDialog(serverAddress, position)
            } else {
                onItemClick(serverAddress)
                setSelectedPosition(position)
            }
        }
    }

    inner class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val button: MaterialButton = itemView.findViewById(R.id.btn_server_address)

        fun bind(serverAddress: ServerAddressesModel, isSelected: Boolean) {
            button.text = serverAddress.name
            button.contentDescription =
                context.getString(
                    R.string.server_address_content_description,
                    serverAddress.name,
                )
            button.isSelected = isSelected
            if (isSelected) {
                button.setBackgroundColor(
                    ContextCompat.getColor(button.context, R.color.selected_color),
                )
            } else {
                button.setBackgroundColor(
                    ContextCompat.getColor(button.context, android.R.color.transparent),
                )
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.sync


import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.button.MaterialButton
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.ServerAddressesModel
import org.ole.planet.myplanet.utilities.DiffUtils

class ServerAddressAdapter(
    private val onItemClick: (ServerAddressesModel) -> Unit,
    private val onClearDataDialog: (ServerAddressesModel, Int) -> Unit,
    private val urlWithoutProtocol: String?,
) : ListAdapter<ServerAddressesModel, ServerAddressAdapter.ViewHolder>(
    DiffUtils.itemCallback(
        areItemsTheSame = { old, new -> old.url == new.url },
        areContentsTheSame = { old, new -> old == new },
    ),
) {
    private var selectedPosition: Int = -1
    private var lastSelectedPosition: Int = -1

    fun setSelectedPosition(position: Int) {
        val previous = selectedPosition
        lastSelectedPosition = previous
        selectedPosition = position
        if (previous in currentList.indices) {
            notifyItemChanged(previous)
        }
        if (position in currentList.indices) {
            notifyItemChanged(position)
        }
    }

    fun revertSelection() {
        val current = selectedPosition
        selectedPosition = lastSelectedPosition
        if (current in currentList.indices) {
            notifyItemChanged(current)
        }
        if (selectedPosition in currentList.indices) {
            notifyItemChanged(selectedPosition)
        }
    }

    fun clearSelection() {
        val current = selectedPosition
        selectedPosition = -1
        if (current in currentList.indices) {
            notifyItemChanged(current)
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_server_address, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val serverAddress = getItem(position)
        holder.bind(serverAddress, position == selectedPosition)
        holder.itemView.setOnClickListener {
            if (!urlWithoutProtocol.isNullOrEmpty() &&
                serverAddress.url.replace(Regex("^https?://"), "") != urlWithoutProtocol
            ) {
                onClearDataDialog(serverAddress, position)
            } else {
                onItemClick(serverAddress)
                setSelectedPosition(position)
            }
        }
    }

    inner class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val button: MaterialButton = itemView.findViewById(R.id.btn_server_address)

        fun bind(serverAddress: ServerAddressesModel, isSelected: Boolean) {
            button.text = serverAddress.name
            button.contentDescription =
                context.getString(
                    R.string.server_address_content_description,
                    serverAddress.name,
                )
            button.isSelected = isSelected
            if (isSelected) {
                button.setBackgroundColor(
                    ContextCompat.getColor(button.context, R.color.selected_color),
                )
            } else {
                button.setBackgroundColor(
                    ContextCompat.getColor(button.context, android.R.color.transparent),
                )
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/sync/RealtimeSyncMixin.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.sync

import androidx.fragment.app.Fragment
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator

interface RealtimeSyncMixin {
    fun getWatchedTables(): List<String>
    fun onDataUpdated(table: String, update: TableDataUpdate)
    fun getSyncRecyclerView(): RecyclerView?
    fun shouldAutoRefresh(table: String): Boolean = true
}

class RealtimeSyncHelper(
    private val fragment: Fragment,
    private val mixin: RealtimeSyncMixin
) {

    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()

    private val realtimeSyncListener = object : BaseRealtimeSyncListener() {
        override fun onTableDataUpdated(update: TableDataUpdate) {
            if (mixin.getWatchedTables().contains(update.table)) {
                mixin.onDataUpdated(update.table, update)
                if (mixin.shouldAutoRefresh(update.table)) {
                    refreshRecyclerView()
                }
            }
        }

        override fun onSyncStarted() {}
        override fun onSyncComplete() {}
        override fun onSyncFailed(msg: String?) {}
    }

    fun setupRealtimeSync() {
        syncCoordinator.addListener(realtimeSyncListener)

        // Listen to data update flow
        fragment.lifecycleScope.launch {
            fragment.repeatOnLifecycle(Lifecycle.State.STARTED) {
                syncCoordinator.dataUpdateFlow
                    .filter { update -> mixin.getWatchedTables().contains(update.table) }
                    .distinctUntilChanged { old, new ->
                        old.table == new.table &&
                        old.newItemsCount == new.newItemsCount &&
                        old.updatedItemsCount == new.updatedItemsCount
                    }
                    .collect { update ->
                        mixin.onDataUpdated(update.table, update)
                        if (mixin.shouldAutoRefresh(update.table)) {
                            refreshRecyclerView()
                        }
                    }
            }
        }
    }

    private fun refreshRecyclerView() {
        fragment.viewLifecycleOwner.lifecycleScope.launch {
            mixin.getSyncRecyclerView()?.adapter?.notifyDataSetChanged()
        }
    }

    fun cleanup() {
        syncCoordinator.removeListener(realtimeSyncListener)
    }
}
=======
package org.ole.planet.myplanet.ui.sync


import androidx.fragment.app.Fragment
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator

interface RealtimeSyncMixin {
    fun getWatchedTables(): List<String>
    fun onDataUpdated(table: String, update: TableDataUpdate)
    fun getSyncRecyclerView(): RecyclerView?
    fun shouldAutoRefresh(table: String): Boolean = true
}

class RealtimeSyncHelper(
    private val fragment: Fragment,
    private val mixin: RealtimeSyncMixin
) {

    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()

    private val realtimeSyncListener = object : BaseRealtimeSyncListener() {
        override fun onTableDataUpdated(update: TableDataUpdate) {
            if (mixin.getWatchedTables().contains(update.table)) {
                mixin.onDataUpdated(update.table, update)
                if (mixin.shouldAutoRefresh(update.table)) {
                    refreshRecyclerView()
                }
            }
        }

        override fun onSyncStarted() {}
        override fun onSyncComplete() {}
        override fun onSyncFailed(msg: String?) {}
    }

    fun setupRealtimeSync() {
        syncCoordinator.addListener(realtimeSyncListener)

        // Listen to data update flow
        fragment.lifecycleScope.launch {
            fragment.repeatOnLifecycle(Lifecycle.State.STARTED) {
                syncCoordinator.dataUpdateFlow
                    .filter { update -> mixin.getWatchedTables().contains(update.table) }
                    .distinctUntilChanged { old, new ->
                        old.table == new.table &&
                        old.newItemsCount == new.newItemsCount &&
                        old.updatedItemsCount == new.updatedItemsCount
                    }
                    .collect { update ->
                        mixin.onDataUpdated(update.table, update)
                        if (mixin.shouldAutoRefresh(update.table)) {
                            refreshRecyclerView()
                        }
                    }
            }
        }
    }

    private fun refreshRecyclerView() {
        fragment.viewLifecycleOwner.lifecycleScope.launch {
            mixin.getSyncRecyclerView()?.adapter?.notifyDataSetChanged()
        }
    }

    fun cleanup() {
        syncCoordinator.removeListener(realtimeSyncListener)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/sync/ServerDialogExtensions.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.sync

import android.text.TextUtils
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.CompoundButton
import android.widget.RadioGroup
import androidx.recyclerview.widget.LinearLayoutManager
import com.afollestad.materialdialogs.DialogAction
import com.afollestad.materialdialogs.MaterialDialog
import io.realm.Sort
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.DialogServerUrlBinding
import org.ole.planet.myplanet.model.RealmCommunity
import org.ole.planet.myplanet.utilities.ServerConfigUtils

fun SyncActivity.showConfigurationUIElements(
    binding: DialogServerUrlBinding,
    manualSelected: Boolean,
    dialog: MaterialDialog,
) {
    serverAddresses.visibility = if (manualSelected) View.GONE else View.VISIBLE
    syncToServerText.visibility = if (manualSelected) View.GONE else View.VISIBLE
    positiveAction.visibility = if (manualSelected) View.VISIBLE else View.GONE
    dialog.getActionButton(DialogAction.NEUTRAL).text =
        if (manualSelected) {
            getString(R.string.btn_sync_save)
        } else {
            if (showAdditionalServers) {
                getString(R.string.show_less)
            } else {
                getString(R.string.show_more)
            }
        }
    binding.ltAdvanced.visibility = if (manualSelected) View.VISIBLE else View.GONE
    binding.switchServerUrl.visibility = if (manualSelected) View.VISIBLE else View.GONE

    if (manualSelected) {
        setupManualUi(binding)
    } else {
        setupServerListUi(binding, dialog)
    }
}

fun SyncActivity.performSync(dialog: MaterialDialog) {
    serverConfigAction = "sync"
    val protocol = "${settings.getString("serverProtocol", "")}"
    var url = "${serverUrl.text}"
    val pin = "${serverPassword.text}"
    editor.putString("serverURL", url).apply()
    url = protocol + url
    if (isUrlValid(url)) {
        currentDialog = dialog
        service.getMinApk(this, url, pin, this, "SyncActivity")
    }
}

fun SyncActivity.onChangeServerUrl() {
    val selected = spnCloud.selectedItem
    if (selected is RealmCommunity && selected.isValid) {
        serverUrl.setText(selected.localDomain)
        protocolCheckIn.check(R.id.radio_https)
        settings.getString("serverProtocol", getString(R.string.https_protocol))
        serverPassword.setText(if (selected.weight == 0) "1983" else "")
        serverPassword.isEnabled = selected.weight != 0
    }
}

fun SyncActivity.setUrlAndPin(checked: Boolean) {
    if (checked) {
        onChangeServerUrl()
    } else {
        serverUrl.setText(settings.getString("serverURL", "")?.let { ServerConfigUtils.removeProtocol(it) })
        serverPassword.setText(settings.getString("serverPin", ""))
        protocolCheckIn.check(
            if (TextUtils.equals(settings.getString("serverProtocol", ""), "http://")) {
                R.id.radio_http
            } else {
                R.id.radio_https
            }
        )
    }
    serverUrl.isEnabled = !checked
    serverPassword.isEnabled = !checked
    serverPassword.clearFocus()
    serverUrl.clearFocus()
    protocolCheckIn.isEnabled = !checked
}

fun SyncActivity.protocolSemantics() {
    protocolCheckIn.setOnCheckedChangeListener { _: RadioGroup?, i: Int ->
        when (i) {
            R.id.radio_http -> editor.putString("serverProtocol", getString(R.string.http_protocol)).apply()
            R.id.radio_https -> editor.putString("serverProtocol", getString(R.string.https_protocol)).apply()
        }
    }
}

fun SyncActivity.refreshServerList() {
    val filteredList = ServerConfigUtils.getFilteredList(
        showAdditionalServers,
        serverListAddresses,
        settings.getString("pinnedServerUrl", null),
    )
    serverAddressAdapter?.submitList(filteredList)

    val pinnedUrl = settings.getString("serverURL", "")
    val pinnedIndex = filteredList.indexOfFirst {
        it.url.replace(Regex("^https?://"), "") == pinnedUrl?.replace(Regex("^https?://"), "")
    }
    if (pinnedIndex != -1) {
        serverAddressAdapter?.setSelectedPosition(pinnedIndex)
    }
}

fun SyncActivity.setupManualUi(binding: DialogServerUrlBinding) {
    if (settings.getString("serverProtocol", "") == getString(R.string.http_protocol)) {
        binding.radioHttp.isChecked = true
        editor.putString("serverProtocol", getString(R.string.http_protocol)).apply()
    } else if (settings.getString("serverProtocol", "") == getString(R.string.https_protocol)) {
        binding.radioHttps.isChecked = true
        editor.putString("serverProtocol", getString(R.string.https_protocol)).apply()
    }
    serverUrl.setText(settings.getString("serverURL", "")?.let { ServerConfigUtils.removeProtocol(it) })
    serverPassword.setText(settings.getString("serverPin", ""))
    serverUrl.isEnabled = true
    serverPassword.isEnabled = true
}

fun SyncActivity.setupServerListUi(binding: DialogServerUrlBinding, dialog: MaterialDialog) {
    serverAddresses.layoutManager = LinearLayoutManager(this)
    serverListAddresses = ServerConfigUtils.getServerAddresses(this)

    val storedUrl = settings.getString("serverURL", null)
    val storedPin = settings.getString("serverPin", null)
    val urlWithoutProtocol = storedUrl?.replace(Regex("^https?://"), "")

    val filteredList = ServerConfigUtils.getFilteredList(
        showAdditionalServers,
        serverListAddresses,
        settings.getString("pinnedServerUrl", null),
    )

    serverAddressAdapter = ServerAddressAdapter(
        { serverListAddress ->
            val actualUrl = serverListAddress.url.replace(Regex("^https?://"), "")
            binding.inputServerUrl.setText(actualUrl)
            binding.inputServerPassword.setText(ServerConfigUtils.getPinForUrl(actualUrl))
            val protocol = if (
                actualUrl == BuildConfig.PLANET_XELA_URL ||
                actualUrl == BuildConfig.PLANET_SANPABLO_URL ||
                actualUrl == BuildConfig.PLANET_URIUR_URL
            ) "http://" else "https://"
            editor.putString("serverProtocol", protocol).apply()
            if (serverCheck) {
                performSync(dialog)
            }
        },
        { _, _ ->
            clearDataDialog(getString(R.string.you_want_to_connect_to_a_different_server), false) {
                serverAddressAdapter?.revertSelection()
            }
        },
        urlWithoutProtocol,
    )

    serverAddressAdapter?.submitList(filteredList)

    serverAddresses.adapter = serverAddressAdapter

    if (urlWithoutProtocol != null) {
        val position = serverListAddresses.indexOfFirst { it.url.replace(Regex("^https?://"), "") == urlWithoutProtocol }
        if (position != -1) {
            serverAddressAdapter?.setSelectedPosition(position)
            binding.inputServerUrl.setText(urlWithoutProtocol)
            binding.inputServerPassword.setText(settings.getString("serverPin", ""))
        }
    }

    if (!prefData.getManualConfig()) {
        serverAddresses.visibility = View.VISIBLE
        if (storedUrl != null && !syncFailed) {
            val position = serverListAddresses.indexOfFirst { it.url.replace(Regex("^https?://"), "") == urlWithoutProtocol }
            if (position != -1) {
                serverAddressAdapter?.setSelectedPosition(position)
                binding.inputServerUrl.setText(urlWithoutProtocol)
                binding.inputServerPassword.setText(storedPin)
            }
        } else if (syncFailed) {
            serverAddressAdapter?.clearSelection()
        }
    } else if (storedUrl != null) {
        val position = serverListAddresses.indexOfFirst { it.url.replace(Regex("^https?://"), "") == urlWithoutProtocol }
        if (position != -1) {
            serverAddressAdapter?.setSelectedPosition(position)
            binding.inputServerUrl.setText(urlWithoutProtocol)
            binding.inputServerPassword.setText(storedPin)
        }
    }
    serverUrl.isEnabled = false
    serverPassword.isEnabled = false
    editor.putString("serverProtocol", getString(R.string.https_protocol)).apply()
}

fun SyncActivity.onNeutralButtonClick(dialog: MaterialDialog) {
    if (!prefData.getManualConfig()) {
        showAdditionalServers = !showAdditionalServers
        refreshServerList()
        dialog.getActionButton(DialogAction.NEUTRAL).text =
            if (showAdditionalServers) getString(R.string.show_less) else getString(R.string.show_more)
    } else {
        serverConfigAction = "save"
        val protocol = "${settings.getString("serverProtocol", "")}"
        var url = "${serverUrl.text}"
        val pin = "${serverPassword.text}"
        url = protocol + url
        if (isUrlValid(url)) {
            currentDialog = dialog
            service.getMinApk(this, url, pin, this, "SyncActivity")
        }
    }
}

fun SyncActivity.initServerDialog(binding: DialogServerUrlBinding) {
    spnCloud = binding.spnCloud
    protocolCheckIn = binding.radioProtocol
    serverUrl = binding.inputServerUrl
    serverPassword = binding.inputServerPassword
    serverAddresses = binding.serverUrls
    syncToServerText = binding.syncToServerText
    binding.deviceName.setText(org.ole.planet.myplanet.utilities.NetworkUtils.getDeviceName())
}

fun SyncActivity.setRadioProtocolListener(binding: DialogServerUrlBinding) {
    binding.radioProtocol.setOnCheckedChangeListener { _: RadioGroup?, checkedId: Int ->
        when (checkedId) {
            R.id.radio_http -> editor.putString("serverProtocol", getString(R.string.http_protocol)).apply()
            R.id.radio_https -> editor.putString("serverProtocol", getString(R.string.https_protocol)).apply()
        }
    }
}

fun SyncActivity.setupFastSyncOption(binding: DialogServerUrlBinding) {
    val isFastSync = settings.getBoolean("fastSync", false)
    binding.fastSync.isChecked = isFastSync
    binding.fastSync.setOnCheckedChangeListener { _: CompoundButton?, checked: Boolean ->
        editor.putBoolean("fastSync", checked).apply()
    }
}

fun SyncActivity.handleManualConfiguration(
    binding: DialogServerUrlBinding,
    configurationId: String?,
    dialog: MaterialDialog,
) {
    if (!prefData.getManualConfig()) {
        binding.manualConfiguration.isChecked = false
        showConfigurationUIElements(binding, false, dialog)
    } else {
        binding.manualConfiguration.isChecked = true
        showConfigurationUIElements(binding, true, dialog)
    }

    binding.manualConfiguration.setOnCheckedChangeListener(null)
    binding.manualConfiguration.setOnClickListener {
        if (configurationId != null) {
            binding.manualConfiguration.isChecked = prefData.getManualConfig()
            if (prefData.getManualConfig()) {
                clearDataDialog(getString(R.string.switching_off_manual_configuration_to_clear_data), false)
            } else {
                clearDataDialog(getString(R.string.switching_on_manual_configuration_to_clear_data), true)
            }
        } else {
            val newCheckedState = !prefData.getManualConfig()
            prefData.setManualConfig(newCheckedState)
            if (newCheckedState) {
                setupManualConfigEnabled(binding, dialog)
            } else {
                prefData.setManualConfig(false)
                showConfigurationUIElements(binding, false, dialog)
                editor.putBoolean("switchCloudUrl", false).apply()
            }
        }
    }
}

fun SyncActivity.setupManualConfigEnabled(binding: DialogServerUrlBinding, dialog: MaterialDialog) {
    prefData.setManualConfig(true)
    editor.putString("serverURL", "").apply()
    editor.putString("serverPin", "").apply()
    binding.radioHttp.isChecked = true
    editor.putString("serverProtocol", getString(R.string.http_protocol)).apply()
    showConfigurationUIElements(binding, true, dialog)

    val communities: List<RealmCommunity> = databaseService.withRealm { realm ->
        realm.where(RealmCommunity::class.java).sort("weight", Sort.ASCENDING).findAll().let { realm.copyFromRealm(it) }
    }
    val nonEmptyCommunities = communities.filter { !TextUtils.isEmpty(it.name) }
    binding.spnCloud.adapter = ArrayAdapter(this, R.layout.spinner_item_white, nonEmptyCommunities)
    binding.spnCloud.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
        override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
            onChangeServerUrl()
        }

        override fun onNothingSelected(parent: AdapterView<*>?) {}
    }

    binding.switchServerUrl.setOnCheckedChangeListener { _: CompoundButton?, b: Boolean ->
        editor.putBoolean("switchCloudUrl", b).apply()
        binding.spnCloud.visibility = if (b) View.VISIBLE else View.GONE
        setUrlAndPin(binding.switchServerUrl.isChecked)
    }
    serverUrl.addTextChangedListener(MyTextWatcher(serverUrl))
    binding.switchServerUrl.isChecked = settings.getBoolean("switchCloudUrl", false)
    setUrlAndPin(settings.getBoolean("switchCloudUrl", false))
    protocolSemantics()
}
=======
package org.ole.planet.myplanet.ui.sync


import android.text.TextUtils
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.CompoundButton
import android.widget.RadioGroup
import androidx.recyclerview.widget.LinearLayoutManager
import com.afollestad.materialdialogs.DialogAction
import com.afollestad.materialdialogs.MaterialDialog
import io.realm.Sort
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.DialogServerUrlBinding
import org.ole.planet.myplanet.model.RealmCommunity
import org.ole.planet.myplanet.utilities.ServerConfigUtils

fun SyncActivity.showConfigurationUIElements(
    binding: DialogServerUrlBinding,
    manualSelected: Boolean,
    dialog: MaterialDialog,
) {
    serverAddresses.visibility = if (manualSelected) View.GONE else View.VISIBLE
    syncToServerText.visibility = if (manualSelected) View.GONE else View.VISIBLE
    positiveAction.visibility = if (manualSelected) View.VISIBLE else View.GONE
    dialog.getActionButton(DialogAction.NEUTRAL).text =
        if (manualSelected) {
            getString(R.string.btn_sync_save)
        } else {
            if (showAdditionalServers) {
                getString(R.string.show_less)
            } else {
                getString(R.string.show_more)
            }
        }
    binding.ltAdvanced.visibility = if (manualSelected) View.VISIBLE else View.GONE
    binding.switchServerUrl.visibility = if (manualSelected) View.VISIBLE else View.GONE

    if (manualSelected) {
        setupManualUi(binding)
    } else {
        setupServerListUi(binding, dialog)
    }
}

fun SyncActivity.performSync(dialog: MaterialDialog) {
    serverConfigAction = "sync"
    val protocol = "${settings.getString("serverProtocol", "")}"
    var url = "${serverUrl.text}"
    val pin = "${serverPassword.text}"
    editor.putString("serverURL", url).apply()
    url = protocol + url
    if (isUrlValid(url)) {
        currentDialog = dialog
        service.getMinApk(this, url, pin, this, "SyncActivity")
    }
}

fun SyncActivity.onChangeServerUrl() {
    val selected = spnCloud.selectedItem
    if (selected is RealmCommunity && selected.isValid) {
        serverUrl.setText(selected.localDomain)
        protocolCheckIn.check(R.id.radio_https)
        settings.getString("serverProtocol", getString(R.string.https_protocol))
        serverPassword.setText(if (selected.weight == 0) "1983" else "")
        serverPassword.isEnabled = selected.weight != 0
    }
}

fun SyncActivity.setUrlAndPin(checked: Boolean) {
    if (checked) {
        onChangeServerUrl()
    } else {
        serverUrl.setText(settings.getString("serverURL", "")?.let { ServerConfigUtils.removeProtocol(it) })
        serverPassword.setText(settings.getString("serverPin", ""))
        protocolCheckIn.check(
            if (TextUtils.equals(settings.getString("serverProtocol", ""), "http://")) {
                R.id.radio_http
            } else {
                R.id.radio_https
            }
        )
    }
    serverUrl.isEnabled = !checked
    serverPassword.isEnabled = !checked
    serverPassword.clearFocus()
    serverUrl.clearFocus()
    protocolCheckIn.isEnabled = !checked
}

fun SyncActivity.protocolSemantics() {
    protocolCheckIn.setOnCheckedChangeListener { _: RadioGroup?, i: Int ->
        when (i) {
            R.id.radio_http -> editor.putString("serverProtocol", getString(R.string.http_protocol)).apply()
            R.id.radio_https -> editor.putString("serverProtocol", getString(R.string.https_protocol)).apply()
        }
    }
}

fun SyncActivity.refreshServerList() {
    val filteredList = ServerConfigUtils.getFilteredList(
        showAdditionalServers,
        serverListAddresses,
        settings.getString("pinnedServerUrl", null),
    )
    serverAddressAdapter?.submitList(filteredList)

    val pinnedUrl = settings.getString("serverURL", "")
    val pinnedIndex = filteredList.indexOfFirst {
        it.url.replace(Regex("^https?://"), "") == pinnedUrl?.replace(Regex("^https?://"), "")
    }
    if (pinnedIndex != -1) {
        serverAddressAdapter?.setSelectedPosition(pinnedIndex)
    }
}

fun SyncActivity.setupManualUi(binding: DialogServerUrlBinding) {
    if (settings.getString("serverProtocol", "") == getString(R.string.http_protocol)) {
        binding.radioHttp.isChecked = true
        editor.putString("serverProtocol", getString(R.string.http_protocol)).apply()
    } else if (settings.getString("serverProtocol", "") == getString(R.string.https_protocol)) {
        binding.radioHttps.isChecked = true
        editor.putString("serverProtocol", getString(R.string.https_protocol)).apply()
    }
    serverUrl.setText(settings.getString("serverURL", "")?.let { ServerConfigUtils.removeProtocol(it) })
    serverPassword.setText(settings.getString("serverPin", ""))
    serverUrl.isEnabled = true
    serverPassword.isEnabled = true
}

fun SyncActivity.setupServerListUi(binding: DialogServerUrlBinding, dialog: MaterialDialog) {
    serverAddresses.layoutManager = LinearLayoutManager(this)
    serverListAddresses = ServerConfigUtils.getServerAddresses(this)

    val storedUrl = settings.getString("serverURL", null)
    val storedPin = settings.getString("serverPin", null)
    val urlWithoutProtocol = storedUrl?.replace(Regex("^https?://"), "")

    val filteredList = ServerConfigUtils.getFilteredList(
        showAdditionalServers,
        serverListAddresses,
        settings.getString("pinnedServerUrl", null),
    )

    serverAddressAdapter = ServerAddressAdapter(
        { serverListAddress ->
            val actualUrl = serverListAddress.url.replace(Regex("^https?://"), "")
            binding.inputServerUrl.setText(actualUrl)
            binding.inputServerPassword.setText(ServerConfigUtils.getPinForUrl(actualUrl))
            val protocol = if (
                actualUrl == BuildConfig.PLANET_XELA_URL ||
                actualUrl == BuildConfig.PLANET_SANPABLO_URL ||
                actualUrl == BuildConfig.PLANET_URIUR_URL
            ) "http://" else "https://"
            editor.putString("serverProtocol", protocol).apply()
            if (serverCheck) {
                performSync(dialog)
            }
        },
        { _, _ ->
            clearDataDialog(getString(R.string.you_want_to_connect_to_a_different_server), false) {
                serverAddressAdapter?.revertSelection()
            }
        },
        urlWithoutProtocol,
    )

    serverAddressAdapter?.submitList(filteredList)

    serverAddresses.adapter = serverAddressAdapter

    if (urlWithoutProtocol != null) {
        val position = serverListAddresses.indexOfFirst { it.url.replace(Regex("^https?://"), "") == urlWithoutProtocol }
        if (position != -1) {
            serverAddressAdapter?.setSelectedPosition(position)
            binding.inputServerUrl.setText(urlWithoutProtocol)
            binding.inputServerPassword.setText(settings.getString("serverPin", ""))
        }
    }

    if (!prefData.getManualConfig()) {
        serverAddresses.visibility = View.VISIBLE
        if (storedUrl != null && !syncFailed) {
            val position = serverListAddresses.indexOfFirst { it.url.replace(Regex("^https?://"), "") == urlWithoutProtocol }
            if (position != -1) {
                serverAddressAdapter?.setSelectedPosition(position)
                binding.inputServerUrl.setText(urlWithoutProtocol)
                binding.inputServerPassword.setText(storedPin)
            }
        } else if (syncFailed) {
            serverAddressAdapter?.clearSelection()
        }
    } else if (storedUrl != null) {
        val position = serverListAddresses.indexOfFirst { it.url.replace(Regex("^https?://"), "") == urlWithoutProtocol }
        if (position != -1) {
            serverAddressAdapter?.setSelectedPosition(position)
            binding.inputServerUrl.setText(urlWithoutProtocol)
            binding.inputServerPassword.setText(storedPin)
        }
    }
    serverUrl.isEnabled = false
    serverPassword.isEnabled = false
    editor.putString("serverProtocol", getString(R.string.https_protocol)).apply()
}

fun SyncActivity.onNeutralButtonClick(dialog: MaterialDialog) {
    if (!prefData.getManualConfig()) {
        showAdditionalServers = !showAdditionalServers
        refreshServerList()
        dialog.getActionButton(DialogAction.NEUTRAL).text =
            if (showAdditionalServers) getString(R.string.show_less) else getString(R.string.show_more)
    } else {
        serverConfigAction = "save"
        val protocol = "${settings.getString("serverProtocol", "")}"
        var url = "${serverUrl.text}"
        val pin = "${serverPassword.text}"
        url = protocol + url
        if (isUrlValid(url)) {
            currentDialog = dialog
            service.getMinApk(this, url, pin, this, "SyncActivity")
        }
    }
}

fun SyncActivity.initServerDialog(binding: DialogServerUrlBinding) {
    spnCloud = binding.spnCloud
    protocolCheckIn = binding.radioProtocol
    serverUrl = binding.inputServerUrl
    serverPassword = binding.inputServerPassword
    serverAddresses = binding.serverUrls
    syncToServerText = binding.syncToServerText
    binding.deviceName.setText(org.ole.planet.myplanet.utilities.NetworkUtils.getDeviceName())
}

fun SyncActivity.setRadioProtocolListener(binding: DialogServerUrlBinding) {
    binding.radioProtocol.setOnCheckedChangeListener { _: RadioGroup?, checkedId: Int ->
        when (checkedId) {
            R.id.radio_http -> editor.putString("serverProtocol", getString(R.string.http_protocol)).apply()
            R.id.radio_https -> editor.putString("serverProtocol", getString(R.string.https_protocol)).apply()
        }
    }
}

fun SyncActivity.setupFastSyncOption(binding: DialogServerUrlBinding) {
    val isFastSync = settings.getBoolean("fastSync", false)
    binding.fastSync.isChecked = isFastSync
    binding.fastSync.setOnCheckedChangeListener { _: CompoundButton?, checked: Boolean ->
        editor.putBoolean("fastSync", checked).apply()
    }
}

fun SyncActivity.handleManualConfiguration(
    binding: DialogServerUrlBinding,
    configurationId: String?,
    dialog: MaterialDialog,
) {
    if (!prefData.getManualConfig()) {
        binding.manualConfiguration.isChecked = false
        showConfigurationUIElements(binding, false, dialog)
    } else {
        binding.manualConfiguration.isChecked = true
        showConfigurationUIElements(binding, true, dialog)
    }

    binding.manualConfiguration.setOnCheckedChangeListener(null)
    binding.manualConfiguration.setOnClickListener {
        if (configurationId != null) {
            binding.manualConfiguration.isChecked = prefData.getManualConfig()
            if (prefData.getManualConfig()) {
                clearDataDialog(getString(R.string.switching_off_manual_configuration_to_clear_data), false)
            } else {
                clearDataDialog(getString(R.string.switching_on_manual_configuration_to_clear_data), true)
            }
        } else {
            val newCheckedState = !prefData.getManualConfig()
            prefData.setManualConfig(newCheckedState)
            if (newCheckedState) {
                setupManualConfigEnabled(binding, dialog)
            } else {
                prefData.setManualConfig(false)
                showConfigurationUIElements(binding, false, dialog)
                editor.putBoolean("switchCloudUrl", false).apply()
            }
        }
    }
}

fun SyncActivity.setupManualConfigEnabled(binding: DialogServerUrlBinding, dialog: MaterialDialog) {
    prefData.setManualConfig(true)
    editor.putString("serverURL", "").apply()
    editor.putString("serverPin", "").apply()
    binding.radioHttp.isChecked = true
    editor.putString("serverProtocol", getString(R.string.http_protocol)).apply()
    showConfigurationUIElements(binding, true, dialog)

    val communities: List<RealmCommunity> = databaseService.withRealm { realm ->
        realm.where(RealmCommunity::class.java).sort("weight", Sort.ASCENDING).findAll().let { realm.copyFromRealm(it) }
    }
    val nonEmptyCommunities = communities.filter { !TextUtils.isEmpty(it.name) }
    binding.spnCloud.adapter = ArrayAdapter(this, R.layout.spinner_item_white, nonEmptyCommunities)
    binding.spnCloud.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
        override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
            onChangeServerUrl()
        }

        override fun onNothingSelected(parent: AdapterView<*>?) {}
    }

    binding.switchServerUrl.setOnCheckedChangeListener { _: CompoundButton?, b: Boolean ->
        editor.putBoolean("switchCloudUrl", b).apply()
        binding.spnCloud.visibility = if (b) View.VISIBLE else View.GONE
        setUrlAndPin(binding.switchServerUrl.isChecked)
    }
    serverUrl.addTextChangedListener(MyTextWatcher(serverUrl))
    binding.switchServerUrl.isChecked = settings.getBoolean("switchCloudUrl", false)
    setUrlAndPin(settings.getBoolean("switchCloudUrl", false))
    protocolSemantics()
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/courses/CourseProgressActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.courses

import android.os.Bundle
import androidx.recyclerview.widget.GridLayoutManager
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmResults
import javax.inject.Inject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseActivity
import org.ole.planet.myplanet.databinding.ActivityCourseProgressBinding
import org.ole.planet.myplanet.model.RealmAnswer
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils

@AndroidEntryPoint
class CourseProgressActivity : BaseActivity() {
    private lateinit var binding: ActivityCourseProgressBinding
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    var user: RealmUserModel? = null
    lateinit var courseId: String
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityCourseProgressBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        initActionBar()
        courseId = intent.getStringExtra("courseId").toString()
        user = userProfileDbHandler.userModel
        databaseService.withRealm { realm ->
            val courseProgress = RealmCourseProgress.getCourseProgress(realm, user?.id)
            val progress = courseProgress[courseId]
            val course = realm.where(RealmMyCourse::class.java).equalTo("courseId", courseId).findFirst()
            if (progress != null) {
                val maxProgress = progress["max"].asInt
                if (maxProgress != 0) {
                    binding.progressView.setProgress((progress["current"].asInt.toDouble() / maxProgress.toDouble() * 100).toInt(), true)
                } else {
                    binding.progressView.setProgress(0, true)
                }
            }
            binding.tvCourse.text = course?.courseTitle
            binding.tvProgress.text = getString(
                R.string.course_progress,
                courseProgress[courseId]?.get("current")?.asString,
                courseProgress[courseId]?.get("max")?.asString
            )
            binding.rvProgress.layoutManager = GridLayoutManager(this, 4)
            showProgress(realm)
        }
    }

    private fun showProgress(realm: Realm) {
        val steps = realm.where(RealmCourseStep::class.java).contains("courseId", courseId).findAll()
        val array = JsonArray()
        steps.map {
            val ob = JsonObject()
            ob.addProperty("stepId", it.id)
            val exams = realm.where(RealmStepExam::class.java).equalTo("stepId", it.id).findAll()
            getExamObject(realm, exams, ob)
            array.add(ob)
        }
        binding.rvProgress.adapter = AdapterProgressGrid(this, array)
    }

    private fun getExamObject(
        realm: Realm,
        exams: RealmResults<RealmStepExam>,
        ob: JsonObject
    ) {
        exams.forEach { it ->
            it.id?.let { it1 ->
                realm.where(RealmSubmission::class.java).equalTo("userId", user?.id)
                    .contains("parentId", it1).equalTo("type", "exam").findAll()
            }?.map {
                val answers = realm.where(RealmAnswer::class.java).equalTo("submissionId", it.id).findAll()
                var examId = it.parentId
                if (it.parentId?.contains("@") == true) {
                    examId = it.parentId!!.split("@")[0]
                }
                val questions = realm.where(RealmExamQuestion::class.java).equalTo("examId", examId).findAll()
                val questionCount = questions.size
                if (questionCount == 0) {
                    ob.addProperty("completed", false)
                    ob.addProperty("percentage", 0)
                } else {
                    ob.addProperty("completed", answers.size == questionCount)
                    val percentage = (answers.size.toDouble() / questionCount) * 100
                    ob.addProperty("percentage", percentage)
                }
                ob.addProperty("status", it.status)
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.courses


import android.os.Bundle
import androidx.recyclerview.widget.GridLayoutManager
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmResults
import javax.inject.Inject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseActivity
import org.ole.planet.myplanet.databinding.ActivityCourseProgressBinding
import org.ole.planet.myplanet.model.RealmAnswer
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils

@AndroidEntryPoint
class CourseProgressActivity : BaseActivity() {
    private lateinit var binding: ActivityCourseProgressBinding
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    var user: RealmUserModel? = null
    lateinit var courseId: String
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityCourseProgressBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        initActionBar()
        courseId = intent.getStringExtra("courseId").toString()
        user = userProfileDbHandler.userModel
        databaseService.withRealm { realm ->
            val courseProgress = RealmCourseProgress.getCourseProgress(realm, user?.id)
            val progress = courseProgress[courseId]
            val course = realm.where(RealmMyCourse::class.java).equalTo("courseId", courseId).findFirst()
            if (progress != null) {
                val maxProgress = progress["max"].asInt
                if (maxProgress != 0) {
                    binding.progressView.setProgress((progress["current"].asInt.toDouble() / maxProgress.toDouble() * 100).toInt(), true)
                } else {
                    binding.progressView.setProgress(0, true)
                }
            }
            binding.tvCourse.text = course?.courseTitle
            binding.tvProgress.text = getString(
                R.string.course_progress,
                courseProgress[courseId]?.get("current")?.asString,
                courseProgress[courseId]?.get("max")?.asString
            )
            binding.rvProgress.layoutManager = GridLayoutManager(this, 4)
            showProgress(realm)
        }
    }

    private fun showProgress(realm: Realm) {
        val steps = realm.where(RealmCourseStep::class.java).contains("courseId", courseId).findAll()
        val array = JsonArray()
        steps.map {
            val ob = JsonObject()
            ob.addProperty("stepId", it.id)
            val exams = realm.where(RealmStepExam::class.java).equalTo("stepId", it.id).findAll()
            getExamObject(realm, exams, ob)
            array.add(ob)
        }
        binding.rvProgress.adapter = AdapterProgressGrid(this, array)
    }

    private fun getExamObject(
        realm: Realm,
        exams: RealmResults<RealmStepExam>,
        ob: JsonObject
    ) {
        exams.forEach { it ->
            it.id?.let { it1 ->
                realm.where(RealmSubmission::class.java).equalTo("userId", user?.id)
                    .contains("parentId", it1).equalTo("type", "exam").findAll()
            }?.map {
                val answers = realm.where(RealmAnswer::class.java).equalTo("submissionId", it.id).findAll()
                var examId = it.parentId
                if (it.parentId?.contains("@") == true) {
                    examId = it.parentId!!.split("@")[0]
                }
                val questions = realm.where(RealmExamQuestion::class.java).equalTo("examId", examId).findAll()
                val questionCount = questions.size
                if (questionCount == 0) {
                    ob.addProperty("completed", false)
                    ob.addProperty("percentage", 0)
                } else {
                    ob.addProperty("completed", answers.size == questionCount)
                    val percentage = (answers.size.toDouble() / questionCount) * 100
                    ob.addProperty("percentage", percentage)
                }
                ob.addProperty("status", it.status)
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/courses/CoursesFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.courses

import android.app.AlertDialog
import android.content.Context
import android.content.DialogInterface
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.CheckBox
import android.widget.EditText
import android.widget.Spinner
import android.widget.TextView
import androidx.appcompat.view.ContextThemeWrapper
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import java.util.Calendar
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment
import org.ole.planet.myplanet.callback.OnCourseItemSelected
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.callback.TagClickListener
import org.ole.planet.myplanet.model.RealmCourseProgress.Companion.getCourseProgress
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmRating.Companion.getRatings
import org.ole.planet.myplanet.model.RealmSearchActivity
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmTag.Companion.getTagsArray
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.resources.CollectionsFragment
import org.ole.planet.myplanet.ui.sync.RealtimeSyncHelper
import org.ole.planet.myplanet.ui.sync.RealtimeSyncMixin
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.KeyboardUtils.setupUI
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager

@AndroidEntryPoint
class CoursesFragment : BaseRecyclerFragment<RealmMyCourse?>(), OnCourseItemSelected, TagClickListener, RealtimeSyncMixin {

    private lateinit var tvAddToLib: TextView
    private lateinit var tvSelected: TextView
    private lateinit var etSearch: EditText
    private lateinit var adapterCourses: AdapterCourses
    private lateinit var btnRemove: Button
    private lateinit var btnArchive: Button
    private lateinit var orderByDate: Button
    private lateinit var orderByTitle: Button
    private lateinit var selectAll: CheckBox
    var userModel: RealmUserModel ?= null
    lateinit var spnGrade: Spinner
    lateinit var spnSubject: Spinner
    lateinit var searchTags: MutableList<RealmTag>
    private lateinit var confirmation: AlertDialog
    private var isUpdatingSelectAllState = false
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null

    @Inject
    lateinit var prefManager: SharedPrefManager

    @Inject
    lateinit var serverUrlMapper: ServerUrlMapper

    @Inject
    lateinit var syncManager: SyncManager

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    @Inject
    lateinit var tagRepository: TagRepository
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    private lateinit var realtimeSyncHelper: RealtimeSyncHelper

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        startCoursesSync()
    }

    override fun getLayout(): Int {
        return R.layout.fragment_my_course
    }

    private fun startCoursesSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isCoursesSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(getString(R.string.syncing_courses_data))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.setText(getString(R.string.loading_courses))

                        lifecycleScope.launch {
                            delay(3000)
                            withContext(Dispatchers.Main) {
                                customProgressDialog?.dismiss()
                                customProgressDialog = null
                                refreshCoursesData()
                            }
                        }
                        prefManager.setCoursesSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null

                        Snackbar.make(requireView(), "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG).setAction("Retry") {
                            startCoursesSync()
                        }.show()
                    }
                }
            }
        }, "full", listOf("courses"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun scrollToTop() {
        recyclerView.post {
            if ((recyclerView.adapter?.itemCount ?: 0) > 0) {
                recyclerView.scrollToPosition(0)
            }
        }
    }

    private fun getFullCourseList(): List<RealmMyCourse?> {
        val courseList: List<RealmMyCourse?> = getList(RealmMyCourse::class.java)
            .filterIsInstance<RealmMyCourse?>()
            .filter { !it?.courseTitle.isNullOrBlank() }
        return courseList.sortedWith(compareBy({ it?.isMyCourse }, { it?.courseTitle }))
    }

    private fun refreshCoursesData() {
        if (!isAdded || requireActivity().isFinishing) return

        try {
            if (!mRealm.isInTransaction) {
                mRealm.refresh()
            }
            val map = getRatings(mRealm, "course", model?.id)
            val progressMap = getCourseProgress(mRealm, model?.id)
            val courseList: List<RealmMyCourse?> = getList(RealmMyCourse::class.java).filterIsInstance<RealmMyCourse?>().filter { !it?.courseTitle.isNullOrBlank() }
            val sortedCourseList = courseList.sortedWith(compareBy({ it?.isMyCourse }, { it?.courseTitle }))

            recyclerView.adapter = null
            adapterCourses = AdapterCourses(
                requireActivity(),
                sortedCourseList,
                map,
                userProfileDbHandler,
                tagRepository,
                this@CoursesFragment
            )
            adapterCourses.setProgressMap(progressMap)
            adapterCourses.setListener(this)
            adapterCourses.setRatingChangeListener(this)
            recyclerView.adapter = adapterCourses

            if (isMyCourseLib) {
                val courseIds = courseList.mapNotNull { it?.id }
                resources = mRealm.where(RealmMyLibrary::class.java)
                    .`in`("courseId", courseIds.toTypedArray())
                    .equalTo("resourceOffline", false)
                    .isNotNull("resourceLocalAddress")
                    .findAll()
            }
            checkList()
            showNoData(tvMessage, adapterCourses.itemCount, "courses")
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    override fun getAdapter(): RecyclerView.Adapter<*> {
        if (!mRealm.isInTransaction) {
            mRealm.refresh()
        }

        val map = getRatings(mRealm, "course", model?.id)
        val progressMap = getCourseProgress(mRealm, model?.id)
        val courseList: List<RealmMyCourse?> = getList(RealmMyCourse::class.java).filterIsInstance<RealmMyCourse?>().filter { !it?.courseTitle.isNullOrBlank() }
        val sortedCourseList = courseList.sortedWith(compareBy({ it?.isMyCourse }, { it?.courseTitle }))
        adapterCourses = AdapterCourses(
            requireActivity(),
            sortedCourseList,
            map,
            userProfileDbHandler,
            tagRepository,
            this@CoursesFragment
        )
        adapterCourses.setProgressMap(progressMap)
        adapterCourses.setListener(this)
        adapterCourses.setRatingChangeListener(this)

        if (isMyCourseLib) {
            val courseIds = courseList.mapNotNull { it?.id }
            resources = mRealm.where(RealmMyLibrary::class.java)
                .`in`("courseId", courseIds.toTypedArray())
                .equalTo("resourceOffline", false)
                .isNotNull("resourceLocalAddress")
                .findAll()
            courseLib = "courses"
        }
        return adapterCourses
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        userModel = userProfileDbHandler.userModel
        searchTags = ArrayList()
        initializeView()
        updateCheckBoxState(false)
        setupButtonVisibility()
        setupEventListeners()
        clearTags()
        showNoData(tvMessage, adapterCourses.itemCount, "courses")
        setupUI(requireView().findViewById(R.id.my_course_parent_layout), requireActivity())

        if (!isMyCourseLib) tvFragmentInfo.setText(R.string.our_courses)
        additionalSetup()
        setupMyProgressButton()

        realtimeSyncHelper = RealtimeSyncHelper(this, this)
        realtimeSyncHelper.setupRealtimeSync()
    }

    private fun setupButtonVisibility() {
        if (isMyCourseLib) {
            btnRemove.visibility = View.VISIBLE
            btnArchive.visibility = View.VISIBLE
            checkList()
        } else {
            btnRemove.visibility = View.GONE
            btnArchive.visibility = View.GONE
        }
        hideButtons()
    }

    private fun setupEventListeners() {
        etSearch.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                if (!etSearch.isFocused) return
                val query = s.toString().trim()
                if (query.isEmpty()) {
                    adapterCourses.setCourseList(getFullCourseList())
                    scrollToTop()
                    showNoData(tvMessage, adapterCourses.itemCount, "courses")
                } else {
                    adapterCourses.setCourseList(filterCourseByTag(etSearch.text.toString(), searchTags))
                    scrollToTop()
                    showNoData(tvMessage, adapterCourses.itemCount, "courses")
                }
            }
            override fun afterTextChanged(s: Editable) {}
        })

        btnRemove.setOnClickListener {
            val alertDialogBuilder = AlertDialog.Builder(ContextThemeWrapper(this.context, R.style.CustomAlertDialog))
            val message = if (countSelected() == 1) {
                R.string.are_you_sure_you_want_to_leave_this_course
            } else {
                R.string.are_you_sure_you_want_to_leave_these_courses
            }
            alertDialogBuilder.setMessage(message)
                .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                    deleteSelected(true)
                    val newFragment = CoursesFragment()
                    recreateFragment(newFragment)
                    checkList()
                }
                .setNegativeButton(R.string.no, null).show()
        }

        btnArchive.setOnClickListener {
            val alertDialogBuilder = AlertDialog.Builder(ContextThemeWrapper(this.context, R.style.CustomAlertDialog))
            val message = if (countSelected() == 1) {
                R.string.are_you_sure_you_want_to_archive_this_course
            } else {
                R.string.are_you_sure_you_want_to_archive_these_courses
            }
            alertDialogBuilder.setMessage(message)
                .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                    deleteSelected(true)
                    val newFragment = CoursesFragment()
                    recreateFragment(newFragment)
                    checkList()
                }
                .setNegativeButton(R.string.no, null).show()
        }

        requireView().findViewById<View>(R.id.btn_collections).setOnClickListener {
            val f = CollectionsFragment.getInstance(searchTags, "courses")
            f.setListener(this)
            f.show(childFragmentManager, "")
        }
    }

    private fun setupMyProgressButton() {
        if (isMyCourseLib) {
            requireView().findViewById<View>(R.id.fabMyProgress).apply {
                visibility = View.VISIBLE
                setOnClickListener {
                    val myProgressFragment = MyProgressFragment().apply {
                        arguments = Bundle().apply {
                            putBoolean("isMyCourseLib", true)
                        }
                    }

                    NavigationHelper.replaceFragment(
                        parentFragmentManager,
                        R.id.fragment_container,
                        myProgressFragment,
                        addToBackStack = true
                    )
                }
            }
        }
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) {
            homeItemClickListener = context
        }
    }

    private fun additionalSetup() {
        val bottomSheet = requireView().findViewById<View>(R.id.card_filter)
        requireView().findViewById<View>(R.id.filter).setOnClickListener {
            bottomSheet.visibility = if (bottomSheet.isVisible) View.GONE else View.VISIBLE
        }
        orderByDate = requireView().findViewById(R.id.order_by_date_button)
        orderByTitle = requireView().findViewById(R.id.order_by_title_button)
        orderByDate.setOnClickListener { adapterCourses.toggleSortOrder() }
        orderByTitle.setOnClickListener { adapterCourses.toggleTitleSortOrder() }
    }

    private fun initializeView() {
        tvAddToLib = requireView().findViewById(R.id.tv_add)
        tvAddToLib.setOnClickListener {
            if ((selectedItems?.size ?: 0) > 0) {
                confirmation = createAlertDialog()
                confirmation.show()
                addToMyList()
                selectedItems?.clear()
                tvAddToLib.isEnabled = false
                checkList()
            }
        }
        etSearch = requireView().findViewById(R.id.et_search)
        tvSelected = requireView().findViewById(R.id.tv_selected)
        btnRemove = requireView().findViewById(R.id.btn_remove)
        btnArchive = requireView().findViewById(R.id.btn_archive)
        spnGrade = requireView().findViewById(R.id.spn_grade)
        spnSubject = requireView().findViewById(R.id.spn_subject)
        tvMessage = requireView().findViewById(R.id.tv_message)
        requireView().findViewById<View>(R.id.tl_tags).visibility = View.GONE
        tvFragmentInfo = requireView().findViewById(R.id.tv_fragment_info)

        setupSpinners()
        setupSelectAll()
        checkList()
    }

    private fun setupSpinners() {
        val gradeAdapter = ArrayAdapter.createFromResource(requireContext(), R.array.grade_level, R.layout.spinner_item)
        gradeAdapter.setDropDownViewResource(R.layout.custom_simple_list_item_1)
        spnGrade.adapter = gradeAdapter

        val subjectAdapter = ArrayAdapter.createFromResource(requireContext(), R.array.subject_level, R.layout.spinner_item)
        subjectAdapter.setDropDownViewResource(R.layout.custom_simple_list_item_1)
        spnSubject.adapter = subjectAdapter

        spnGrade.onItemSelectedListener = itemSelectedListener
        spnSubject.onItemSelectedListener = itemSelectedListener
    }

    private fun setupSelectAll() {
        selectAll = requireView().findViewById(R.id.selectAllCourse)
        if (userModel?.isGuest() == true) {
            tvAddToLib.visibility = View.GONE
            btnRemove.visibility = View.GONE
            btnArchive.visibility = View.GONE
            selectAll.visibility = View.GONE
        }

        selectAll.setOnCheckedChangeListener { _, isChecked ->
            if (isUpdatingSelectAllState) {
                return@setOnCheckedChangeListener
            }
            hideButtons()
            adapterCourses.selectAllItems(isChecked)
            selectAll.text = if (isChecked) getString(R.string.unselect_all) else getString(R.string.select_all)
        }
    }

    private fun hideButtons() {
        btnArchive.isEnabled = selectedItems?.size!! != 0
        btnRemove.isEnabled = selectedItems?.size!! != 0
        if (selectedItems?.size!! != 0) {
            if (isMyCourseLib) {
                btnArchive.visibility = View.VISIBLE
                btnRemove.visibility = View.VISIBLE
            } else {
                tvAddToLib.visibility = View.VISIBLE
            }
        } else {
            if (isMyCourseLib) {
                btnArchive.visibility = View.GONE
                btnRemove.visibility = View.GONE
            } else {
                tvAddToLib.visibility = View.GONE
            }
        }
    }

    private fun checkList() {
        if (adapterCourses.getCourseList().isEmpty()) {
            selectAll.visibility = View.GONE
            etSearch.visibility = View.GONE
            tvAddToLib.visibility = View.GONE
            requireView().findViewById<View>(R.id.filter).visibility = View.GONE
            btnRemove.visibility = View.GONE
            tvSelected.visibility = View.GONE
            btnArchive.visibility = View.GONE
        } else {
            etSearch.visibility = View.VISIBLE
            requireView().findViewById<View>(R.id.filter).visibility = View.VISIBLE
            val allMyCourses = adapterCourses.getCourseList().all { it?.isMyCourse == true }
            if (userModel?.isGuest() == false) {
                selectAll.visibility = if (allMyCourses) View.GONE else View.VISIBLE
            }
        }
    }

    private val itemSelectedListener: AdapterView.OnItemSelectedListener = object : AdapterView.OnItemSelectedListener {
        override fun onItemSelected(adapterView: AdapterView<*>?, view: View?, i: Int, l: Long) {
            if (view == null) {
                return
            }
            gradeLevel = if (spnGrade.selectedItem.toString() == "All") "" else spnGrade.selectedItem.toString()
            subjectLevel = if (spnSubject.selectedItem.toString() == "All") "" else spnSubject.selectedItem.toString()
            if (etSearch.text.toString().isEmpty() && searchTags.isEmpty() && gradeLevel.isEmpty() && subjectLevel.isEmpty()) {
                adapterCourses.setCourseList(getFullCourseList())
            } else {
                adapterCourses.setCourseList(filterCourseByTag(etSearch.text.toString(), searchTags))
            }
            scrollToTop()
            showNoFilter(tvMessage, adapterCourses.itemCount)
        }

        override fun onNothingSelected(adapterView: AdapterView<*>?) {}
    }

    private fun clearTags() {
        requireView().findViewById<View>(R.id.btn_clear_tags).setOnClickListener {
            searchTags.clear()
            etSearch.setText(R.string.empty_text)
            tvSelected.text = context?.getString(R.string.empty_text)
            adapterCourses.setCourseList(getFullCourseList())
            scrollToTop()
            showNoData(tvMessage, adapterCourses.itemCount, "courses")
            spnGrade.setSelection(0)
            spnSubject.setSelection(0)
        }
    }

    private fun createAlertDialog(): AlertDialog {
        val builder = AlertDialog.Builder(requireContext(), R.style.CustomAlertDialog)
        var msg = getString(R.string.success_you_have_added_the_following_courses)
        if ((selectedItems?.size ?: 0) <= 5) {
            for (i in selectedItems?.indices!!) {
                msg += " - ${selectedItems?.get(i)?.courseTitle} \n"
            }
        } else {
            for (i in 0..4) {
                msg += " - ${selectedItems?.get(i)?.courseTitle} \n"
            }
            msg += "${getString(R.string.and)}${((selectedItems?.size ?: 0) - 5)}${getString(R.string.more_course_s)}"
        }
        msg += getString(R.string.return_to_the_home_tab_to_access_mycourses)
        builder.setMessage(msg)
        builder.setCancelable(true)
            .setPositiveButton(R.string.go_to_mycourses) { dialog: DialogInterface, _: Int ->
                if (userModel?.id?.startsWith("guest") == true) {
                    DialogUtils.guestDialog(requireContext())
                } else {
                    val fragment = CoursesFragment().apply {
                        arguments = Bundle().apply {
                            putBoolean("isMyCourseLib", true)
                        }
                    }
                    homeItemClickListener?.openMyFragment(fragment)
                }
            }
            .setNegativeButton(R.string.ok) { dialog: DialogInterface, _: Int ->
                dialog.cancel()
                val newFragment = CoursesFragment()
                recreateFragment(newFragment)
            }
            .setOnDismissListener {
                val newFragment = CoursesFragment()
                recreateFragment(newFragment)
            }

        return builder.create()
    }

    override fun onSelectedListChange(list: MutableList<RealmMyCourse?>) {
        selectedItems = list
        changeButtonStatus()
        hideButtons()
    }

    override fun onTagClicked(tag: RealmTag?) {
        if (!searchTags.contains(tag)) {
            tag?.let { searchTags.add(it) }
        }
        adapterCourses.setCourseList(filterCourseByTag(etSearch.text.toString(), searchTags))
        scrollToTop()
        showTagText(searchTags, tvSelected)
        showNoData(tvMessage, adapterCourses.itemCount, "courses")
    }

    private fun updateCheckBoxState(programmaticState: Boolean) {
        isUpdatingSelectAllState = true
        selectAll.isChecked = programmaticState
        isUpdatingSelectAllState = false
    }

    private fun clearAllSelections() {
        if (::adapterCourses.isInitialized) {
            adapterCourses.selectAllItems(false)
            updateCheckBoxState(false)
            selectAll.text = getString(R.string.select_all)
        }
    }

    private fun changeButtonStatus() {
        tvAddToLib.isEnabled = (selectedItems?.size ?: 0) > 0
        btnRemove.isEnabled = (selectedItems?.size ?: 0) > 0
        btnArchive.isEnabled = (selectedItems?.size ?: 0) > 0

        val allSelected = adapterCourses.areAllSelected()
        updateCheckBoxState(allSelected)
        selectAll.text = if (allSelected) getString(R.string.unselect_all) else getString(R.string.select_all)
    }

    override fun onTagSelected(tag: RealmTag) {
        val li: MutableList<RealmTag> = ArrayList()
        li.add(tag)
        searchTags = li
        tvSelected.text = context?.getString(R.string.tag_selected, tag.name)
        adapterCourses.setCourseList(filterCourseByTag(etSearch.text.toString(), li))
        scrollToTop()
        showNoData(tvMessage, adapterCourses.itemCount, "courses")
    }

    override fun onOkClicked(list: List<RealmTag>?) {
        if (list?.isEmpty() == true) {
            searchTags.clear()
            if (etSearch.text.toString().isEmpty() && gradeLevel.isEmpty() && subjectLevel.isEmpty()) {
                adapterCourses.setCourseList(getFullCourseList())
            } else {
                adapterCourses.setCourseList(filterCourseByTag(etSearch.text.toString(), searchTags))
            }
            scrollToTop()
            showNoData(tvMessage, adapterCourses.itemCount, "courses")
        } else {
            for (tag in list ?: emptyList()) {
                onTagClicked(tag)
            }
        }
    }

    private fun filterApplied(): Boolean {
        return !(searchTags.isEmpty() && gradeLevel.isEmpty() && subjectLevel.isEmpty() && etSearch.text.toString().isEmpty())
    }

    private fun saveSearchActivity() {
        if (filterApplied()) {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            val activity = mRealm.createObject(RealmSearchActivity::class.java, UUID.randomUUID().toString())
            activity.user = "${model?.name}"
            activity.time = Calendar.getInstance().timeInMillis
            activity.createdOn = "${model?.planetCode}"
            activity.parentCode = "${model?.parentCode}"
            activity.text = etSearch.text.toString()
            activity.type = "courses"
            val filter = JsonObject()

            filter.add("tags", getTagsArray(searchTags.toList()))
            filter.addProperty("doc.gradeLevel", gradeLevel)
            filter.addProperty("doc.subjectLevel", subjectLevel)
            activity.filter = Gson().toJson(filter)
            mRealm.commitTransaction()
        }
    }

    override fun onPause() {
        super.onPause()
        saveSearchActivity()
        clearAllSelections()
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        super.onDestroy()
    }

    private fun recreateFragment(fragment: Fragment) {
        if (isAdded && activity != null && !requireActivity().isFinishing) {
            if (isMyCourseLib) {
                val args = Bundle()
                args.putBoolean("isMyCourseLib", true)
                args.putString("courseLib", courseLib)
                args.putSerializable("resources", resources?.let { ArrayList(it) })
                fragment.arguments = args
                NavigationHelper.replaceFragment(
                    parentFragmentManager,
                    R.id.fragment_container,
                    fragment,
                    addToBackStack = true,
                    allowStateLoss = true
                )
            } else {
                NavigationHelper.replaceFragment(
                    parentFragmentManager,
                    R.id.fragment_container,
                    fragment,
                    addToBackStack = true,
                    allowStateLoss = true
                )
            }
        }
    }

    override fun getWatchedTables(): List<String> {
        return listOf("courses")
    }

    override fun onDataUpdated(table: String, update: TableDataUpdate) {
        if (table == "courses" && update.shouldRefreshUI) {
            if (::adapterCourses.isInitialized) {
                refreshCoursesData()
            } else {
                recyclerView.adapter = getAdapter()
            }
        }
    }

    override fun getSyncRecyclerView(): RecyclerView? {
        return if (::recyclerView.isInitialized) recyclerView else null
    }

    override fun onDestroyView() {
        if (::realtimeSyncHelper.isInitialized) {
            realtimeSyncHelper.cleanup()
        }
        super.onDestroyView()
    }

    override fun onRatingChanged() {
        if (!::adapterCourses.isInitialized) {
            super.onRatingChanged()
            return
        }

        if (!mRealm.isInTransaction) {
            mRealm.refresh()
        }
        val map = getRatings(mRealm, "course", model?.id)
        val progressMap = getCourseProgress(mRealm, model?.id)

        val filteredCourseList = if (etSearch.text.toString().isEmpty() && searchTags.isEmpty() && gradeLevel.isEmpty() && subjectLevel.isEmpty()) {
            getFullCourseList()
        } else {
            filterCourseByTag(etSearch.text.toString(), searchTags)
        }

        adapterCourses = AdapterCourses(
            requireActivity(), filteredCourseList, map, userProfileDbHandler,
            tagRepository, this@CoursesFragment
        )
        adapterCourses.setProgressMap(progressMap)
        adapterCourses.setListener(this)
        adapterCourses.setRatingChangeListener(this)
        recyclerView.adapter = adapterCourses
    }
}
=======
package org.ole.planet.myplanet.ui.courses


import android.app.AlertDialog
import android.content.Context
import android.content.DialogInterface
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.CheckBox
import android.widget.EditText
import android.widget.Spinner
import android.widget.TextView
import androidx.appcompat.view.ContextThemeWrapper
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import java.util.Calendar
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment
import org.ole.planet.myplanet.callback.OnCourseItemSelected
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.callback.TagClickListener
import org.ole.planet.myplanet.model.RealmCourseProgress.Companion.getCourseProgress
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmRating.Companion.getRatings
import org.ole.planet.myplanet.model.RealmSearchActivity
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmTag.Companion.getTagsArray
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.resources.CollectionsFragment
import org.ole.planet.myplanet.ui.sync.RealtimeSyncHelper
import org.ole.planet.myplanet.ui.sync.RealtimeSyncMixin
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.KeyboardUtils.setupUI
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager

@AndroidEntryPoint
class CoursesFragment : BaseRecyclerFragment<RealmMyCourse?>(), OnCourseItemSelected, TagClickListener, RealtimeSyncMixin {

    private lateinit var tvAddToLib: TextView
    private lateinit var tvSelected: TextView
    private lateinit var etSearch: EditText
    private lateinit var adapterCourses: AdapterCourses
    private lateinit var btnRemove: Button
    private lateinit var btnArchive: Button
    private lateinit var orderByDate: Button
    private lateinit var orderByTitle: Button
    private lateinit var selectAll: CheckBox
    var userModel: RealmUserModel ?= null
    lateinit var spnGrade: Spinner
    lateinit var spnSubject: Spinner
    lateinit var searchTags: MutableList<RealmTag>
    private lateinit var confirmation: AlertDialog
    private var isUpdatingSelectAllState = false
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null

    @Inject
    lateinit var prefManager: SharedPrefManager

    @Inject
    lateinit var serverUrlMapper: ServerUrlMapper

    @Inject
    lateinit var syncManager: SyncManager

    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    @Inject
    lateinit var tagRepository: TagRepository
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    private lateinit var realtimeSyncHelper: RealtimeSyncHelper

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        startCoursesSync()
    }

    override fun getLayout(): Int {
        return R.layout.fragment_my_course
    }

    private fun startCoursesSync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isCoursesSynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded && !requireActivity().isFinishing) {
                        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                        customProgressDialog?.setText(getString(R.string.syncing_courses_data))
                        customProgressDialog?.show()
                    }
                }
            }

            override fun onSyncComplete() {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.setText(getString(R.string.loading_courses))

                        lifecycleScope.launch {
                            delay(3000)
                            withContext(Dispatchers.Main) {
                                customProgressDialog?.dismiss()
                                customProgressDialog = null
                                refreshCoursesData()
                            }
                        }
                        prefManager.setCoursesSynced(true)
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                viewLifecycleOwner.lifecycleScope.launch {
                    if (isAdded) {
                        customProgressDialog?.dismiss()
                        customProgressDialog = null

                        Snackbar.make(requireView(), "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG).setAction("Retry") {
                            startCoursesSync()
                        }.show()
                    }
                }
            }
        }, "full", listOf("courses"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun scrollToTop() {
        recyclerView.post {
            if ((recyclerView.adapter?.itemCount ?: 0) > 0) {
                recyclerView.scrollToPosition(0)
            }
        }
    }

    private fun getFullCourseList(): List<RealmMyCourse?> {
        val courseList: List<RealmMyCourse?> = getList(RealmMyCourse::class.java)
            .filterIsInstance<RealmMyCourse?>()
            .filter { !it?.courseTitle.isNullOrBlank() }
        return courseList.sortedWith(compareBy({ it?.isMyCourse }, { it?.courseTitle }))
    }

    private fun refreshCoursesData() {
        if (!isAdded || requireActivity().isFinishing) return

        try {
            if (!mRealm.isInTransaction) {
                mRealm.refresh()
            }
            val map = getRatings(mRealm, "course", model?.id)
            val progressMap = getCourseProgress(mRealm, model?.id)
            val courseList: List<RealmMyCourse?> = getList(RealmMyCourse::class.java).filterIsInstance<RealmMyCourse?>().filter { !it?.courseTitle.isNullOrBlank() }
            val sortedCourseList = courseList.sortedWith(compareBy({ it?.isMyCourse }, { it?.courseTitle }))

            recyclerView.adapter = null
            adapterCourses = AdapterCourses(
                requireActivity(),
                sortedCourseList,
                map,
                userProfileDbHandler,
                tagRepository,
                this@CoursesFragment
            )
            adapterCourses.setProgressMap(progressMap)
            adapterCourses.setListener(this)
            adapterCourses.setRatingChangeListener(this)
            recyclerView.adapter = adapterCourses

            if (isMyCourseLib) {
                val courseIds = courseList.mapNotNull { it?.id }
                resources = mRealm.where(RealmMyLibrary::class.java)
                    .`in`("courseId", courseIds.toTypedArray())
                    .equalTo("resourceOffline", false)
                    .isNotNull("resourceLocalAddress")
                    .findAll()
            }
            checkList()
            showNoData(tvMessage, adapterCourses.itemCount, "courses")
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    override fun getAdapter(): RecyclerView.Adapter<*> {
        if (!mRealm.isInTransaction) {
            mRealm.refresh()
        }

        val map = getRatings(mRealm, "course", model?.id)
        val progressMap = getCourseProgress(mRealm, model?.id)
        val courseList: List<RealmMyCourse?> = getList(RealmMyCourse::class.java).filterIsInstance<RealmMyCourse?>().filter { !it?.courseTitle.isNullOrBlank() }
        val sortedCourseList = courseList.sortedWith(compareBy({ it?.isMyCourse }, { it?.courseTitle }))
        adapterCourses = AdapterCourses(
            requireActivity(),
            sortedCourseList,
            map,
            userProfileDbHandler,
            tagRepository,
            this@CoursesFragment
        )
        adapterCourses.setProgressMap(progressMap)
        adapterCourses.setListener(this)
        adapterCourses.setRatingChangeListener(this)

        if (isMyCourseLib) {
            val courseIds = courseList.mapNotNull { it?.id }
            resources = mRealm.where(RealmMyLibrary::class.java)
                .`in`("courseId", courseIds.toTypedArray())
                .equalTo("resourceOffline", false)
                .isNotNull("resourceLocalAddress")
                .findAll()
            courseLib = "courses"
        }
        return adapterCourses
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        userModel = userProfileDbHandler.userModel
        searchTags = ArrayList()
        initializeView()
        updateCheckBoxState(false)
        setupButtonVisibility()
        setupEventListeners()
        clearTags()
        showNoData(tvMessage, adapterCourses.itemCount, "courses")
        setupUI(requireView().findViewById(R.id.my_course_parent_layout), requireActivity())

        if (!isMyCourseLib) tvFragmentInfo.setText(R.string.our_courses)
        additionalSetup()
        setupMyProgressButton()

        realtimeSyncHelper = RealtimeSyncHelper(this, this)
        realtimeSyncHelper.setupRealtimeSync()
    }

    private fun setupButtonVisibility() {
        if (isMyCourseLib) {
            btnRemove.visibility = View.VISIBLE
            btnArchive.visibility = View.VISIBLE
            checkList()
        } else {
            btnRemove.visibility = View.GONE
            btnArchive.visibility = View.GONE
        }
        hideButtons()
    }

    private fun setupEventListeners() {
        etSearch.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
                if (!etSearch.isFocused) return
                val query = s.toString().trim()
                if (query.isEmpty()) {
                    adapterCourses.setCourseList(getFullCourseList())
                    scrollToTop()
                    showNoData(tvMessage, adapterCourses.itemCount, "courses")
                } else {
                    adapterCourses.setCourseList(filterCourseByTag(etSearch.text.toString(), searchTags))
                    scrollToTop()
                    showNoData(tvMessage, adapterCourses.itemCount, "courses")
                }
            }
            override fun afterTextChanged(s: Editable) {}
        })

        btnRemove.setOnClickListener {
            val alertDialogBuilder = AlertDialog.Builder(ContextThemeWrapper(this.context, R.style.CustomAlertDialog))
            val message = if (countSelected() == 1) {
                R.string.are_you_sure_you_want_to_leave_this_course
            } else {
                R.string.are_you_sure_you_want_to_leave_these_courses
            }
            alertDialogBuilder.setMessage(message)
                .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                    deleteSelected(true)
                    val newFragment = CoursesFragment()
                    recreateFragment(newFragment)
                    checkList()
                }
                .setNegativeButton(R.string.no, null).show()
        }

        btnArchive.setOnClickListener {
            val alertDialogBuilder = AlertDialog.Builder(ContextThemeWrapper(this.context, R.style.CustomAlertDialog))
            val message = if (countSelected() == 1) {
                R.string.are_you_sure_you_want_to_archive_this_course
            } else {
                R.string.are_you_sure_you_want_to_archive_these_courses
            }
            alertDialogBuilder.setMessage(message)
                .setPositiveButton(R.string.yes) { _: DialogInterface?, _: Int ->
                    deleteSelected(true)
                    val newFragment = CoursesFragment()
                    recreateFragment(newFragment)
                    checkList()
                }
                .setNegativeButton(R.string.no, null).show()
        }

        requireView().findViewById<View>(R.id.btn_collections).setOnClickListener {
            val f = CollectionsFragment.getInstance(searchTags, "courses")
            f.setListener(this)
            f.show(childFragmentManager, "")
        }
    }

    private fun setupMyProgressButton() {
        if (isMyCourseLib) {
            requireView().findViewById<View>(R.id.fabMyProgress).apply {
                visibility = View.VISIBLE
                setOnClickListener {
                    val myProgressFragment = MyProgressFragment().apply {
                        arguments = Bundle().apply {
                            putBoolean("isMyCourseLib", true)
                        }
                    }

                    NavigationHelper.replaceFragment(
                        parentFragmentManager,
                        R.id.fragment_container,
                        myProgressFragment,
                        addToBackStack = true
                    )
                }
            }
        }
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) {
            homeItemClickListener = context
        }
    }

    private fun additionalSetup() {
        val bottomSheet = requireView().findViewById<View>(R.id.card_filter)
        requireView().findViewById<View>(R.id.filter).setOnClickListener {
            bottomSheet.visibility = if (bottomSheet.isVisible) View.GONE else View.VISIBLE
        }
        orderByDate = requireView().findViewById(R.id.order_by_date_button)
        orderByTitle = requireView().findViewById(R.id.order_by_title_button)
        orderByDate.setOnClickListener { adapterCourses.toggleSortOrder() }
        orderByTitle.setOnClickListener { adapterCourses.toggleTitleSortOrder() }
    }

    private fun initializeView() {
        tvAddToLib = requireView().findViewById(R.id.tv_add)
        tvAddToLib.setOnClickListener {
            if ((selectedItems?.size ?: 0) > 0) {
                confirmation = createAlertDialog()
                confirmation.show()
                addToMyList()
                selectedItems?.clear()
                tvAddToLib.isEnabled = false
                checkList()
            }
        }
        etSearch = requireView().findViewById(R.id.et_search)
        tvSelected = requireView().findViewById(R.id.tv_selected)
        btnRemove = requireView().findViewById(R.id.btn_remove)
        btnArchive = requireView().findViewById(R.id.btn_archive)
        spnGrade = requireView().findViewById(R.id.spn_grade)
        spnSubject = requireView().findViewById(R.id.spn_subject)
        tvMessage = requireView().findViewById(R.id.tv_message)
        requireView().findViewById<View>(R.id.tl_tags).visibility = View.GONE
        tvFragmentInfo = requireView().findViewById(R.id.tv_fragment_info)

        setupSpinners()
        setupSelectAll()
        checkList()
    }

    private fun setupSpinners() {
        val gradeAdapter = ArrayAdapter.createFromResource(requireContext(), R.array.grade_level, R.layout.spinner_item)
        gradeAdapter.setDropDownViewResource(R.layout.custom_simple_list_item_1)
        spnGrade.adapter = gradeAdapter

        val subjectAdapter = ArrayAdapter.createFromResource(requireContext(), R.array.subject_level, R.layout.spinner_item)
        subjectAdapter.setDropDownViewResource(R.layout.custom_simple_list_item_1)
        spnSubject.adapter = subjectAdapter

        spnGrade.onItemSelectedListener = itemSelectedListener
        spnSubject.onItemSelectedListener = itemSelectedListener
    }

    private fun setupSelectAll() {
        selectAll = requireView().findViewById(R.id.selectAllCourse)
        if (userModel?.isGuest() == true) {
            tvAddToLib.visibility = View.GONE
            btnRemove.visibility = View.GONE
            btnArchive.visibility = View.GONE
            selectAll.visibility = View.GONE
        }

        selectAll.setOnCheckedChangeListener { _, isChecked ->
            if (isUpdatingSelectAllState) {
                return@setOnCheckedChangeListener
            }
            hideButtons()
            adapterCourses.selectAllItems(isChecked)
            selectAll.text = if (isChecked) getString(R.string.unselect_all) else getString(R.string.select_all)
        }
    }

    private fun hideButtons() {
        btnArchive.isEnabled = selectedItems?.size!! != 0
        btnRemove.isEnabled = selectedItems?.size!! != 0
        if (selectedItems?.size!! != 0) {
            if (isMyCourseLib) {
                btnArchive.visibility = View.VISIBLE
                btnRemove.visibility = View.VISIBLE
            } else {
                tvAddToLib.visibility = View.VISIBLE
            }
        } else {
            if (isMyCourseLib) {
                btnArchive.visibility = View.GONE
                btnRemove.visibility = View.GONE
            } else {
                tvAddToLib.visibility = View.GONE
            }
        }
    }

    private fun checkList() {
        if (adapterCourses.getCourseList().isEmpty()) {
            selectAll.visibility = View.GONE
            etSearch.visibility = View.GONE
            tvAddToLib.visibility = View.GONE
            requireView().findViewById<View>(R.id.filter).visibility = View.GONE
            btnRemove.visibility = View.GONE
            tvSelected.visibility = View.GONE
            btnArchive.visibility = View.GONE
        } else {
            etSearch.visibility = View.VISIBLE
            requireView().findViewById<View>(R.id.filter).visibility = View.VISIBLE
            val allMyCourses = adapterCourses.getCourseList().all { it?.isMyCourse == true }
            if (userModel?.isGuest() == false) {
                selectAll.visibility = if (allMyCourses) View.GONE else View.VISIBLE
            }
        }
    }

    private val itemSelectedListener: AdapterView.OnItemSelectedListener = object : AdapterView.OnItemSelectedListener {
        override fun onItemSelected(adapterView: AdapterView<*>?, view: View?, i: Int, l: Long) {
            if (view == null) {
                return
            }
            gradeLevel = if (spnGrade.selectedItem.toString() == "All") "" else spnGrade.selectedItem.toString()
            subjectLevel = if (spnSubject.selectedItem.toString() == "All") "" else spnSubject.selectedItem.toString()
            if (etSearch.text.toString().isEmpty() && searchTags.isEmpty() && gradeLevel.isEmpty() && subjectLevel.isEmpty()) {
                adapterCourses.setCourseList(getFullCourseList())
            } else {
                adapterCourses.setCourseList(filterCourseByTag(etSearch.text.toString(), searchTags))
            }
            scrollToTop()
            showNoFilter(tvMessage, adapterCourses.itemCount)
        }

        override fun onNothingSelected(adapterView: AdapterView<*>?) {}
    }

    private fun clearTags() {
        requireView().findViewById<View>(R.id.btn_clear_tags).setOnClickListener {
            searchTags.clear()
            etSearch.setText(R.string.empty_text)
            tvSelected.text = context?.getString(R.string.empty_text)
            adapterCourses.setCourseList(getFullCourseList())
            scrollToTop()
            showNoData(tvMessage, adapterCourses.itemCount, "courses")
            spnGrade.setSelection(0)
            spnSubject.setSelection(0)
        }
    }

    private fun createAlertDialog(): AlertDialog {
        val builder = AlertDialog.Builder(requireContext(), R.style.CustomAlertDialog)
        var msg = getString(R.string.success_you_have_added_the_following_courses)
        if ((selectedItems?.size ?: 0) <= 5) {
            for (i in selectedItems?.indices!!) {
                msg += " - ${selectedItems?.get(i)?.courseTitle} \n"
            }
        } else {
            for (i in 0..4) {
                msg += " - ${selectedItems?.get(i)?.courseTitle} \n"
            }
            msg += "${getString(R.string.and)}${((selectedItems?.size ?: 0) - 5)}${getString(R.string.more_course_s)}"
        }
        msg += getString(R.string.return_to_the_home_tab_to_access_mycourses)
        builder.setMessage(msg)
        builder.setCancelable(true)
            .setPositiveButton(R.string.go_to_mycourses) { dialog: DialogInterface, _: Int ->
                if (userModel?.id?.startsWith("guest") == true) {
                    DialogUtils.guestDialog(requireContext())
                } else {
                    val fragment = CoursesFragment().apply {
                        arguments = Bundle().apply {
                            putBoolean("isMyCourseLib", true)
                        }
                    }
                    homeItemClickListener?.openMyFragment(fragment)
                }
            }
            .setNegativeButton(R.string.ok) { dialog: DialogInterface, _: Int ->
                dialog.cancel()
                val newFragment = CoursesFragment()
                recreateFragment(newFragment)
            }
            .setOnDismissListener {
                val newFragment = CoursesFragment()
                recreateFragment(newFragment)
            }

        return builder.create()
    }

    override fun onSelectedListChange(list: MutableList<RealmMyCourse?>) {
        selectedItems = list
        changeButtonStatus()
        hideButtons()
    }

    override fun onTagClicked(tag: RealmTag?) {
        if (!searchTags.contains(tag)) {
            tag?.let { searchTags.add(it) }
        }
        adapterCourses.setCourseList(filterCourseByTag(etSearch.text.toString(), searchTags))
        scrollToTop()
        showTagText(searchTags, tvSelected)
        showNoData(tvMessage, adapterCourses.itemCount, "courses")
    }

    private fun updateCheckBoxState(programmaticState: Boolean) {
        isUpdatingSelectAllState = true
        selectAll.isChecked = programmaticState
        isUpdatingSelectAllState = false
    }

    private fun clearAllSelections() {
        if (::adapterCourses.isInitialized) {
            adapterCourses.selectAllItems(false)
            updateCheckBoxState(false)
            selectAll.text = getString(R.string.select_all)
        }
    }

    private fun changeButtonStatus() {
        tvAddToLib.isEnabled = (selectedItems?.size ?: 0) > 0
        btnRemove.isEnabled = (selectedItems?.size ?: 0) > 0
        btnArchive.isEnabled = (selectedItems?.size ?: 0) > 0

        val allSelected = adapterCourses.areAllSelected()
        updateCheckBoxState(allSelected)
        selectAll.text = if (allSelected) getString(R.string.unselect_all) else getString(R.string.select_all)
    }

    override fun onTagSelected(tag: RealmTag) {
        val li: MutableList<RealmTag> = ArrayList()
        li.add(tag)
        searchTags = li
        tvSelected.text = context?.getString(R.string.tag_selected, tag.name)
        adapterCourses.setCourseList(filterCourseByTag(etSearch.text.toString(), li))
        scrollToTop()
        showNoData(tvMessage, adapterCourses.itemCount, "courses")
    }

    override fun onOkClicked(list: List<RealmTag>?) {
        if (list?.isEmpty() == true) {
            searchTags.clear()
            if (etSearch.text.toString().isEmpty() && gradeLevel.isEmpty() && subjectLevel.isEmpty()) {
                adapterCourses.setCourseList(getFullCourseList())
            } else {
                adapterCourses.setCourseList(filterCourseByTag(etSearch.text.toString(), searchTags))
            }
            scrollToTop()
            showNoData(tvMessage, adapterCourses.itemCount, "courses")
        } else {
            for (tag in list ?: emptyList()) {
                onTagClicked(tag)
            }
        }
    }

    private fun filterApplied(): Boolean {
        return !(searchTags.isEmpty() && gradeLevel.isEmpty() && subjectLevel.isEmpty() && etSearch.text.toString().isEmpty())
    }

    private fun saveSearchActivity() {
        if (filterApplied()) {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            val activity = mRealm.createObject(RealmSearchActivity::class.java, UUID.randomUUID().toString())
            activity.user = "${model?.name}"
            activity.time = Calendar.getInstance().timeInMillis
            activity.createdOn = "${model?.planetCode}"
            activity.parentCode = "${model?.parentCode}"
            activity.text = etSearch.text.toString()
            activity.type = "courses"
            val filter = JsonObject()

            filter.add("tags", getTagsArray(searchTags.toList()))
            filter.addProperty("doc.gradeLevel", gradeLevel)
            filter.addProperty("doc.subjectLevel", subjectLevel)
            activity.filter = Gson().toJson(filter)
            mRealm.commitTransaction()
        }
    }

    override fun onPause() {
        super.onPause()
        saveSearchActivity()
        clearAllSelections()
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        super.onDestroy()
    }

    private fun recreateFragment(fragment: Fragment) {
        if (isAdded && activity != null && !requireActivity().isFinishing) {
            if (isMyCourseLib) {
                val args = Bundle()
                args.putBoolean("isMyCourseLib", true)
                args.putString("courseLib", courseLib)
                args.putSerializable("resources", resources?.let { ArrayList(it) })
                fragment.arguments = args
                NavigationHelper.replaceFragment(
                    parentFragmentManager,
                    R.id.fragment_container,
                    fragment,
                    addToBackStack = true,
                    allowStateLoss = true
                )
            } else {
                NavigationHelper.replaceFragment(
                    parentFragmentManager,
                    R.id.fragment_container,
                    fragment,
                    addToBackStack = true,
                    allowStateLoss = true
                )
            }
        }
    }

    override fun getWatchedTables(): List<String> {
        return listOf("courses")
    }

    override fun onDataUpdated(table: String, update: TableDataUpdate) {
        if (table == "courses" && update.shouldRefreshUI) {
            if (::adapterCourses.isInitialized) {
                refreshCoursesData()
            } else {
                recyclerView.adapter = getAdapter()
            }
        }
    }

    override fun getSyncRecyclerView(): RecyclerView? {
        return if (::recyclerView.isInitialized) recyclerView else null
    }

    override fun onDestroyView() {
        if (::realtimeSyncHelper.isInitialized) {
            realtimeSyncHelper.cleanup()
        }
        super.onDestroyView()
    }

    override fun onRatingChanged() {
        if (!::adapterCourses.isInitialized) {
            super.onRatingChanged()
            return
        }

        if (!mRealm.isInTransaction) {
            mRealm.refresh()
        }
        val map = getRatings(mRealm, "course", model?.id)
        val progressMap = getCourseProgress(mRealm, model?.id)

        val filteredCourseList = if (etSearch.text.toString().isEmpty() && searchTags.isEmpty() && gradeLevel.isEmpty() && subjectLevel.isEmpty()) {
            getFullCourseList()
        } else {
            filterCourseByTag(etSearch.text.toString(), searchTags)
        }

        adapterCourses = AdapterCourses(
            requireActivity(), filteredCourseList, map, userProfileDbHandler,
            tagRepository, this@CoursesFragment
        )
        adapterCourses.setProgressMap(progressMap)
        adapterCourses.setListener(this)
        adapterCourses.setRatingChangeListener(this)
        recyclerView.adapter = adapterCourses
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/courses/TakeCourseFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.courses

import android.content.DialogInterface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.SeekBar
import android.widget.SeekBar.OnSeekBarChangeListener
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.viewpager.widget.ViewPager
import androidx.viewpager2.widget.ViewPager2
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import java.util.Locale
import javax.inject.Inject
import kotlin.collections.isNotEmpty
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.cancelChildren
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentTakeCourseBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmCourseActivity.Companion.createActivity
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmCourseProgress.Companion.getCurrentProgress
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getCourseStepIds
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getCourseSteps
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.onAdd
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.onRemove
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmission.Companion.isStepCompleted
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.DialogUtils.getDialog
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class TakeCourseFragment : Fragment(), ViewPager.OnPageChangeListener, View.OnClickListener {
    private var _binding: FragmentTakeCourseBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    lateinit var mRealm: Realm
    private var currentCourse: RealmMyCourse? = null
    lateinit var steps: List<RealmCourseStep?>
    var position = 0
    private var currentStep = 0
    private var joinDialog: AlertDialog? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            courseId = requireArguments().getString("id")
            if (requireArguments().containsKey("position")) {
                position = requireArguments().getInt("position")
            }
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTakeCourseBinding.inflate(inflater, container, false)
        mRealm = databaseService.realmInstance
        userModel = userProfileDbHandler.userModel
        currentCourse = mRealm.where(RealmMyCourse::class.java).equalTo("courseId", courseId).findFirst()
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.tvCourseTitle.text = currentCourse?.courseTitle
        steps = getCourseSteps(mRealm, courseId)
        if (steps.isEmpty()) {
            binding.nextStep.visibility = View.GONE
            binding.previousStep.visibility = View.GONE
        }

        currentStep = getCourseProgress()
        position = if (currentStep > 0) currentStep  else 0
        setNavigationButtons()
        binding.viewPager2.adapter =
            CoursesPagerAdapter(
                this@TakeCourseFragment,
                courseId,
                getCourseStepIds(mRealm, courseId)
            )

        binding.viewPager2.isUserInputEnabled = false
        binding.viewPager2.setCurrentItem(position, false)

        binding.viewPager2.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {
            override fun onPageSelected(position: Int) {
                super.onPageSelected(position)
                this@TakeCourseFragment.onPageSelected(position)
            }
        })

        updateStepDisplay(position)

        if (position == 0) {
            binding.previousStep.visibility = View.GONE
        }
        setCourseData()
        setListeners()
        checkSurveyCompletion()
        binding.backButton.setOnClickListener {
            NavigationHelper.popBackStack(requireActivity().supportFragmentManager)
        }
    }

    override fun onResume() {
        super.onResume()
        val currentPosition = binding.viewPager2.currentItem
        updateStepDisplay(currentPosition)

        // Update Next/Finish button visibility when returning from exam
        if (currentPosition >= steps.size) {
            binding.nextStep.visibility = View.GONE
            binding.finishStep.visibility = View.VISIBLE
        } else {
            binding.nextStep.visibility = View.VISIBLE
            binding.finishStep.visibility = View.GONE
        }
    }

    private fun setListeners() {
        binding.nextStep.setOnClickListener(this)
        binding.previousStep.setOnClickListener(this)
        binding.btnRemove.setOnClickListener(this)
        binding.finishStep.setOnClickListener(this)
        binding.courseProgress.setOnSeekBarChangeListener(object : OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: SeekBar, i: Int, b: Boolean) {
                val currentProgress = getCurrentProgress(steps, mRealm, userModel?.id, courseId)
                if (b && i <= currentProgress + 1) {
                    binding.viewPager2.currentItem = i
                }
            }

            override fun onStartTrackingTouch(seekBar: SeekBar) {}
            override fun onStopTrackingTouch(seekBar: SeekBar) {}
        })
    }

    private fun updateStepDisplay(position: Int) {
        if (position == 0) {
            binding.tvStep.text = "Course Details"
        } else {
            val stepNumber = position
            binding.tvStep.text = String.format(getString(R.string.step) + " %d/%d", stepNumber, steps.size)
        }

        val currentProgress = getCurrentProgress(steps, mRealm, userModel?.id, courseId)
        if (currentProgress < steps.size) {
            binding.courseProgress.secondaryProgress = currentProgress + 1
        }
        binding.courseProgress.progress = currentProgress
    }

    private fun setCourseData() {
        val isGuest = userModel?.isGuest() == true
        val containsUserId = currentCourse?.userId?.contains(userModel?.id) == true
        val stepsSize = steps.size

        lifecycleScope.launch {
            withContext(Dispatchers.Main) {
                if (!isGuest && !containsUserId) {
                    binding.btnRemove.visibility = View.VISIBLE
                    binding.btnRemove.text = getString(R.string.join)
                    joinDialog = getDialog(
                        requireActivity(),
                        getString(R.string.do_you_want_to_join_this_course),
                        getString(R.string.join_this_course)
                    ) { _: DialogInterface?, _: Int ->
                        addRemoveCourse()
                    }
                    joinDialog?.show()
                } else {
                    binding.btnRemove.visibility = View.GONE
                }
            }

            val detachedUserModel = userModel
            val detachedCurrentCourse = currentCourse?.let { mRealm.copyFromRealm(it) }

            withContext(Dispatchers.IO) {
                val backgroundRealm = databaseService.realmInstance
                try {
                    createActivity(backgroundRealm, detachedUserModel, detachedCurrentCourse)
                } catch (e: Exception) {
                    e.printStackTrace()
                } finally {
                    backgroundRealm.close()
                }
            }

            withContext(Dispatchers.Main) {
                binding.courseProgress.max = stepsSize

                if (containsUserId) {
                    if(position < steps.size - 1){
                        binding.nextStep.visibility = View.VISIBLE
                    }
                    binding.courseProgress.visibility = View.VISIBLE
                } else {
                    binding.nextStep.visibility = View.GONE
                    binding.previousStep.visibility = View.GONE
                    binding.courseProgress.visibility = View.GONE
                }
            }
        }
    }

    override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {}

    override fun onPageSelected(position: Int) {
        if (position > 0) {
            if (position - 1 < steps.size) changeNextButtonState(position)
        } else {
            binding.nextStep.visibility = View.VISIBLE
            binding.nextStep.isClickable = true
            binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
        }

        updateStepDisplay(position)
    }

    private fun changeNextButtonState(position: Int) {
        if (courseId == "4e6b78800b6ad18b4e8b0e1e38a98cac") {
            if (isStepCompleted(mRealm, steps[position - 1]?.id, userModel?.id)) {
                binding.nextStep.isClickable = true
                binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
            } else {
                binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_grey_500))
                binding.nextStep.isClickable = false
            }
        } else {
            binding.nextStep.isClickable = true
            binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
        }
    }

    override fun onPageScrollStateChanged(state: Int) {}

    private fun onClickNext() {
        binding.tvStep.text = String.format(Locale.getDefault(), "${getString(R.string.step)} %d/%d", binding.viewPager2.currentItem, steps.size)
        if (binding.viewPager2.currentItem >= steps.size) {
            binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_grey_500))
            binding.nextStep.visibility = View.GONE
            binding.finishStep.visibility = View.VISIBLE
        } else {
            binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
            binding.nextStep.visibility = View.VISIBLE
            binding.finishStep.visibility = View.GONE
        }
    }

    private fun onClickPrevious() {
        binding.tvStep.text = String.format(Locale.getDefault(), "${getString(R.string.step)} %d/%d", binding.viewPager2.currentItem - 1, steps.size)
        if (binding.viewPager2.currentItem - 1 == 0) {
            binding.previousStep.visibility = View.GONE
            binding.nextStep.visibility = View.VISIBLE
            binding.finishStep.visibility = View.GONE
        }else{
            binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
            binding.nextStep.visibility = View.VISIBLE
            binding.finishStep.visibility = View.GONE
        }
    }

    override fun onClick(view: View) {
        when (view.id) {
            R.id.next_step -> {
                if (isValidClickRight) {
                    binding.viewPager2.currentItem += 1
                    binding.previousStep.visibility = View.VISIBLE
                }
                onClickNext()
            }

            R.id.previous_step -> {
                onClickPrevious()
                if (isValidClickLeft) {
                    binding.viewPager2.currentItem -= 1
                }
            }

            R.id.finish_step -> checkSurveyCompletion()
            R.id.btn_remove -> addRemoveCourse()
        }
    }

    private fun addRemoveCourse() {
        if (!mRealm.isInTransaction) mRealm.beginTransaction()
        if (currentCourse?.userId?.contains(userModel?.id) == true) {
            currentCourse?.removeUserId(userModel?.id)
            onRemove(mRealm, "courses", userModel?.id, courseId)
        } else {
            currentCourse?.setUserId(userModel?.id)
            onAdd(mRealm, "courses", userModel?.id, courseId)
        }
        Utilities.toast(activity, "course ${(if (currentCourse?.userId?.contains(userModel?.id) == true) {
            getString(R.string.added_to)
        } else {
            getString(R.string.removed_from)
        })} ${getString(R.string.my_courses)}")
        setCourseData()
    }

    private fun getCourseProgress(): Int {
        return databaseService.withRealm { realm ->
            val user = userProfileDbHandler.userModel
            val courseProgressMap = RealmCourseProgress.getCourseProgress(realm, user?.id)
            courseProgressMap[courseId]?.asJsonObject?.get("current")?.asInt ?: 0
        }
    }

    private fun checkSurveyCompletion() {
        val hasUnfinishedSurvey = steps.any { step ->
            val stepSurvey = mRealm.where(RealmStepExam::class.java)
                .equalTo("stepId", step?.id)
                .equalTo("type", "surveys")
                .findAll()
            stepSurvey.any { survey -> !existsSubmission(mRealm, survey.id, "survey") }
        }

        if (hasUnfinishedSurvey && courseId == "4e6b78800b6ad18b4e8b0e1e38a98cac") {
            binding.finishStep.setOnClickListener {
                Toast.makeText(context, getString(R.string.please_complete_survey), Toast.LENGTH_SHORT).show() }
        } else {
            binding.finishStep.isEnabled = true
            binding.finishStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
            binding.finishStep.setOnClickListener {
                NavigationHelper.popBackStack(requireActivity().supportFragmentManager)
            }
        }
    }

    private fun setNavigationButtons(){
        if(position >= steps.size - 1){
            binding.nextStep.visibility = View.GONE
            binding.finishStep.visibility = View.VISIBLE
        } else {
            binding.nextStep.visibility = View.VISIBLE
            binding.finishStep.visibility = View.GONE
        }

    }

    override fun onDestroyView() {
        binding.courseProgress.setOnSeekBarChangeListener(null)
        lifecycleScope.coroutineContext.cancelChildren()
        if (this::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        joinDialog?.dismiss()
        joinDialog = null
        _binding = null
        super.onDestroyView()
    }

    private val isValidClickRight: Boolean get() = binding.viewPager2.adapter != null && binding.viewPager2.currentItem < binding.viewPager2.adapter?.itemCount!!
    private val isValidClickLeft: Boolean get() = binding.viewPager2.adapter != null && binding.viewPager2.currentItem > 0

    companion object {
        var courseId: String? = null
        var userModel: RealmUserModel? = null

        @JvmStatic
        fun newInstance(b: Bundle?): TakeCourseFragment {
            val takeCourseFragment = TakeCourseFragment()
            takeCourseFragment.arguments = b
            return takeCourseFragment
        }

        fun existsSubmission(mRealm: Realm, firstStepId: String?, submissionType: String): Boolean {
            val questions = mRealm.where(RealmExamQuestion::class.java)
                .equalTo("examId", firstStepId)
                .findAll()

            var isPresent = false
            if (questions != null && questions.isNotEmpty()) {
                val examId = questions[0]?.examId
                val isSubmitted = courseId?.let { courseId ->
                    val parentId = "$examId@$courseId"
                    mRealm.where(RealmSubmission::class.java)
                        .equalTo("userId", userModel?.id)
                        .equalTo("parentId", parentId)
                        .equalTo("type", submissionType)
                        .findFirst() != null
                } == true
                isPresent = isSubmitted
            }
            return isPresent
        }
    }
}
=======
package org.ole.planet.myplanet.ui.courses


import android.content.DialogInterface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.SeekBar
import android.widget.SeekBar.OnSeekBarChangeListener
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.viewpager.widget.ViewPager
import androidx.viewpager2.widget.ViewPager2
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import java.util.Locale
import javax.inject.Inject
import kotlin.collections.isNotEmpty
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.cancelChildren
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentTakeCourseBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmCourseActivity.Companion.createActivity
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmCourseProgress.Companion.getCurrentProgress
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getCourseStepIds
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getCourseSteps
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.onAdd
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.onRemove
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmission.Companion.isStepCompleted
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.DialogUtils.getDialog
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class TakeCourseFragment : Fragment(), ViewPager.OnPageChangeListener, View.OnClickListener {
    private var _binding: FragmentTakeCourseBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    lateinit var mRealm: Realm
    private var currentCourse: RealmMyCourse? = null
    lateinit var steps: List<RealmCourseStep?>
    var position = 0
    private var currentStep = 0
    private var joinDialog: AlertDialog? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            courseId = requireArguments().getString("id")
            if (requireArguments().containsKey("position")) {
                position = requireArguments().getInt("position")
            }
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentTakeCourseBinding.inflate(inflater, container, false)
        mRealm = databaseService.realmInstance
        userModel = userProfileDbHandler.userModel
        currentCourse = mRealm.where(RealmMyCourse::class.java).equalTo("courseId", courseId).findFirst()
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.tvCourseTitle.text = currentCourse?.courseTitle
        steps = getCourseSteps(mRealm, courseId)
        if (steps.isEmpty()) {
            binding.nextStep.visibility = View.GONE
            binding.previousStep.visibility = View.GONE
        }

        currentStep = getCourseProgress()
        position = if (currentStep > 0) currentStep  else 0
        setNavigationButtons()
        binding.viewPager2.adapter =
            CoursesPagerAdapter(
                this@TakeCourseFragment,
                courseId,
                getCourseStepIds(mRealm, courseId)
            )

        binding.viewPager2.isUserInputEnabled = false
        binding.viewPager2.setCurrentItem(position, false)

        binding.viewPager2.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {
            override fun onPageSelected(position: Int) {
                super.onPageSelected(position)
                this@TakeCourseFragment.onPageSelected(position)
            }
        })

        updateStepDisplay(position)

        if (position == 0) {
            binding.previousStep.visibility = View.GONE
        }
        setCourseData()
        setListeners()
        checkSurveyCompletion()
        binding.backButton.setOnClickListener {
            NavigationHelper.popBackStack(requireActivity().supportFragmentManager)
        }
    }

    override fun onResume() {
        super.onResume()
        val currentPosition = binding.viewPager2.currentItem
        updateStepDisplay(currentPosition)

        // Update Next/Finish button visibility when returning from exam
        if (currentPosition >= steps.size) {
            binding.nextStep.visibility = View.GONE
            binding.finishStep.visibility = View.VISIBLE
        } else {
            binding.nextStep.visibility = View.VISIBLE
            binding.finishStep.visibility = View.GONE
        }
    }

    private fun setListeners() {
        binding.nextStep.setOnClickListener(this)
        binding.previousStep.setOnClickListener(this)
        binding.btnRemove.setOnClickListener(this)
        binding.finishStep.setOnClickListener(this)
        binding.courseProgress.setOnSeekBarChangeListener(object : OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: SeekBar, i: Int, b: Boolean) {
                val currentProgress = getCurrentProgress(steps, mRealm, userModel?.id, courseId)
                if (b && i <= currentProgress + 1) {
                    binding.viewPager2.currentItem = i
                }
            }

            override fun onStartTrackingTouch(seekBar: SeekBar) {}
            override fun onStopTrackingTouch(seekBar: SeekBar) {}
        })
    }

    private fun updateStepDisplay(position: Int) {
        if (position == 0) {
            binding.tvStep.text = "Course Details"
        } else {
            val stepNumber = position
            binding.tvStep.text = String.format(getString(R.string.step) + " %d/%d", stepNumber, steps.size)
        }

        val currentProgress = getCurrentProgress(steps, mRealm, userModel?.id, courseId)
        if (currentProgress < steps.size) {
            binding.courseProgress.secondaryProgress = currentProgress + 1
        }
        binding.courseProgress.progress = currentProgress
    }

    private fun setCourseData() {
        val isGuest = userModel?.isGuest() == true
        val containsUserId = currentCourse?.userId?.contains(userModel?.id) == true
        val stepsSize = steps.size

        lifecycleScope.launch {
            withContext(Dispatchers.Main) {
                if (!isGuest && !containsUserId) {
                    binding.btnRemove.visibility = View.VISIBLE
                    binding.btnRemove.text = getString(R.string.join)
                    joinDialog = getDialog(
                        requireActivity(),
                        getString(R.string.do_you_want_to_join_this_course),
                        getString(R.string.join_this_course)
                    ) { _: DialogInterface?, _: Int ->
                        addRemoveCourse()
                    }
                    joinDialog?.show()
                } else {
                    binding.btnRemove.visibility = View.GONE
                }
            }

            val detachedUserModel = userModel
            val detachedCurrentCourse = currentCourse?.let { mRealm.copyFromRealm(it) }

            withContext(Dispatchers.IO) {
                val backgroundRealm = databaseService.realmInstance
                try {
                    createActivity(backgroundRealm, detachedUserModel, detachedCurrentCourse)
                } catch (e: Exception) {
                    e.printStackTrace()
                } finally {
                    backgroundRealm.close()
                }
            }

            withContext(Dispatchers.Main) {
                binding.courseProgress.max = stepsSize

                if (containsUserId) {
                    if(position < steps.size - 1){
                        binding.nextStep.visibility = View.VISIBLE
                    }
                    binding.courseProgress.visibility = View.VISIBLE
                } else {
                    binding.nextStep.visibility = View.GONE
                    binding.previousStep.visibility = View.GONE
                    binding.courseProgress.visibility = View.GONE
                }
            }
        }
    }

    override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {}

    override fun onPageSelected(position: Int) {
        if (position > 0) {
            if (position - 1 < steps.size) changeNextButtonState(position)
        } else {
            binding.nextStep.visibility = View.VISIBLE
            binding.nextStep.isClickable = true
            binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
        }

        updateStepDisplay(position)
    }

    private fun changeNextButtonState(position: Int) {
        if (courseId == "4e6b78800b6ad18b4e8b0e1e38a98cac") {
            if (isStepCompleted(mRealm, steps[position - 1]?.id, userModel?.id)) {
                binding.nextStep.isClickable = true
                binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
            } else {
                binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_grey_500))
                binding.nextStep.isClickable = false
            }
        } else {
            binding.nextStep.isClickable = true
            binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
        }
    }

    override fun onPageScrollStateChanged(state: Int) {}

    private fun onClickNext() {
        binding.tvStep.text = String.format(Locale.getDefault(), "${getString(R.string.step)} %d/%d", binding.viewPager2.currentItem, steps.size)
        if (binding.viewPager2.currentItem >= steps.size) {
            binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_grey_500))
            binding.nextStep.visibility = View.GONE
            binding.finishStep.visibility = View.VISIBLE
        } else {
            binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
            binding.nextStep.visibility = View.VISIBLE
            binding.finishStep.visibility = View.GONE
        }
    }

    private fun onClickPrevious() {
        binding.tvStep.text = String.format(Locale.getDefault(), "${getString(R.string.step)} %d/%d", binding.viewPager2.currentItem - 1, steps.size)
        if (binding.viewPager2.currentItem - 1 == 0) {
            binding.previousStep.visibility = View.GONE
            binding.nextStep.visibility = View.VISIBLE
            binding.finishStep.visibility = View.GONE
        }else{
            binding.nextStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
            binding.nextStep.visibility = View.VISIBLE
            binding.finishStep.visibility = View.GONE
        }
    }

    override fun onClick(view: View) {
        when (view.id) {
            R.id.next_step -> {
                if (isValidClickRight) {
                    binding.viewPager2.currentItem += 1
                    binding.previousStep.visibility = View.VISIBLE
                }
                onClickNext()
            }

            R.id.previous_step -> {
                onClickPrevious()
                if (isValidClickLeft) {
                    binding.viewPager2.currentItem -= 1
                }
            }

            R.id.finish_step -> checkSurveyCompletion()
            R.id.btn_remove -> addRemoveCourse()
        }
    }

    private fun addRemoveCourse() {
        if (!mRealm.isInTransaction) mRealm.beginTransaction()
        if (currentCourse?.userId?.contains(userModel?.id) == true) {
            currentCourse?.removeUserId(userModel?.id)
            onRemove(mRealm, "courses", userModel?.id, courseId)
        } else {
            currentCourse?.setUserId(userModel?.id)
            onAdd(mRealm, "courses", userModel?.id, courseId)
        }
        Utilities.toast(activity, "course ${(if (currentCourse?.userId?.contains(userModel?.id) == true) {
            getString(R.string.added_to)
        } else {
            getString(R.string.removed_from)
        })} ${getString(R.string.my_courses)}")
        setCourseData()
    }

    private fun getCourseProgress(): Int {
        return databaseService.withRealm { realm ->
            val user = userProfileDbHandler.userModel
            val courseProgressMap = RealmCourseProgress.getCourseProgress(realm, user?.id)
            courseProgressMap[courseId]?.asJsonObject?.get("current")?.asInt ?: 0
        }
    }

    private fun checkSurveyCompletion() {
        val hasUnfinishedSurvey = steps.any { step ->
            val stepSurvey = mRealm.where(RealmStepExam::class.java)
                .equalTo("stepId", step?.id)
                .equalTo("type", "surveys")
                .findAll()
            stepSurvey.any { survey -> !existsSubmission(mRealm, survey.id, "survey") }
        }

        if (hasUnfinishedSurvey && courseId == "4e6b78800b6ad18b4e8b0e1e38a98cac") {
            binding.finishStep.setOnClickListener {
                Toast.makeText(context, getString(R.string.please_complete_survey), Toast.LENGTH_SHORT).show() }
        } else {
            binding.finishStep.isEnabled = true
            binding.finishStep.setTextColor(ContextCompat.getColor(requireContext(), R.color.md_white_1000))
            binding.finishStep.setOnClickListener {
                NavigationHelper.popBackStack(requireActivity().supportFragmentManager)
            }
        }
    }

    private fun setNavigationButtons(){
        if(position >= steps.size - 1){
            binding.nextStep.visibility = View.GONE
            binding.finishStep.visibility = View.VISIBLE
        } else {
            binding.nextStep.visibility = View.VISIBLE
            binding.finishStep.visibility = View.GONE
        }

    }

    override fun onDestroyView() {
        binding.courseProgress.setOnSeekBarChangeListener(null)
        lifecycleScope.coroutineContext.cancelChildren()
        if (this::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        joinDialog?.dismiss()
        joinDialog = null
        _binding = null
        super.onDestroyView()
    }

    private val isValidClickRight: Boolean get() = binding.viewPager2.adapter != null && binding.viewPager2.currentItem < binding.viewPager2.adapter?.itemCount!!
    private val isValidClickLeft: Boolean get() = binding.viewPager2.adapter != null && binding.viewPager2.currentItem > 0

    companion object {
        var courseId: String? = null
        var userModel: RealmUserModel? = null

        @JvmStatic
        fun newInstance(b: Bundle?): TakeCourseFragment {
            val takeCourseFragment = TakeCourseFragment()
            takeCourseFragment.arguments = b
            return takeCourseFragment
        }

        fun existsSubmission(mRealm: Realm, firstStepId: String?, submissionType: String): Boolean {
            val questions = mRealm.where(RealmExamQuestion::class.java)
                .equalTo("examId", firstStepId)
                .findAll()

            var isPresent = false
            if (questions != null && questions.isNotEmpty()) {
                val examId = questions[0]?.examId
                val isSubmitted = courseId?.let { courseId ->
                    val parentId = "$examId@$courseId"
                    mRealm.where(RealmSubmission::class.java)
                        .equalTo("userId", userModel?.id)
                        .equalTo("parentId", parentId)
                        .equalTo("type", submissionType)
                        .findFirst() != null
                } == true
                isPresent = isSubmitted
            }
            return isPresent
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/courses/AdapterCourses.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.courses

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import android.widget.SeekBar
import android.widget.SeekBar.OnSeekBarChangeListener
import android.widget.TextView
import androidx.fragment.app.Fragment
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView
import com.google.android.flexbox.FlexboxLayout
import com.google.gson.JsonObject
import fisk.chipcloud.ChipCloud
import fisk.chipcloud.ChipCloudConfig
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnCourseItemSelected
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.RowCourseBinding
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.CourseRatingUtils
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.JsonUtils.getInt
import org.ole.planet.myplanet.utilities.Markdown.prependBaseUrlToImages
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText
import org.ole.planet.myplanet.utilities.SelectionUtils
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities

class AdapterCourses(
    private val context: Context,
    private var courseList: List<RealmMyCourse?>,
    private val map: HashMap<String?, JsonObject>,
    private val userProfileDbHandler: UserProfileDbHandler,
    private val tagRepository: TagRepository,
    private val lifecycleOwner: LifecycleOwner
) : RecyclerView.Adapter<RecyclerView.ViewHolder>() {
    private val selectedItems: MutableList<RealmMyCourse?> = ArrayList()
    private var listener: OnCourseItemSelected? = null
    private var homeItemClickListener: OnHomeItemClickListener? = null
    private var progressMap: HashMap<String?, JsonObject>? = null
    private var ratingChangeListener: OnRatingChangeListener? = null
    private val config: ChipCloudConfig
    private var isAscending = true
    private var isTitleAscending = false
    private var areAllSelected = false
    var userModel: RealmUserModel?= null
    private val tagCache: MutableMap<String, List<RealmTag>> = mutableMapOf()
    private val tagRequestsInProgress: MutableSet<String> = mutableSetOf()

    companion object {
        private const val TAG_PAYLOAD = "payload_tags"
        private const val RATING_PAYLOAD = "payload_rating"
        private const val PROGRESS_PAYLOAD = "payload_progress"
    }

    init {
        if (context is OnHomeItemClickListener) {
            homeItemClickListener = context
        }
        config = Utilities.getCloudConfig().selectMode(ChipCloud.SelectMode.single)
    }

    fun setRatingChangeListener(ratingChangeListener: OnRatingChangeListener?) {
        this.ratingChangeListener = ratingChangeListener
    }

    fun getCourseList(): List<RealmMyCourse?> {
        return courseList
    }

    private fun dispatchDiff(newList: List<RealmMyCourse?>) {
        val diffResult = DiffUtils.calculateDiff(
            courseList,
            newList,
            areItemsTheSame = { old, new -> old?.id == new?.id },
            areContentsTheSame = { old, new ->
                val ratingSame = map[old?.courseId] == map[new?.courseId]
                val progressSame = progressMap?.get(old?.courseId) == progressMap?.get(new?.courseId)

                old?.courseTitle == new?.courseTitle &&
                        old?.description == new?.description &&
                        old?.gradeLevel == new?.gradeLevel &&
                        old?.subjectLevel == new?.subjectLevel &&
                        old?.createdDate == new?.createdDate &&
                        old?.isMyCourse == new?.isMyCourse &&
                        old?.getNumberOfSteps() == new?.getNumberOfSteps() &&
                        ratingSame &&
                        progressSame
            },
            getChangePayload = { old, new ->
                val bundle = Bundle()
                if (map[old?.courseId] != map[new?.courseId]) {
                    bundle.putBoolean(RATING_PAYLOAD, true)
                }
                if (progressMap?.get(old?.courseId) != progressMap?.get(new?.courseId)) {
                    bundle.putBoolean(PROGRESS_PAYLOAD, true)
                }
                if (bundle.isEmpty) null else bundle
            }
        )
        courseList = newList
        diffResult.dispatchUpdatesTo(this)
    }

    fun setCourseList(courseList: List<RealmMyCourse?>) {
        dispatchDiff(courseList)
    }

    private fun sortCourseListByTitle(list: List<RealmMyCourse?>): List<RealmMyCourse?> {
        return list.sortedWith { course1: RealmMyCourse?, course2: RealmMyCourse? ->
            if (isTitleAscending) {
                course1?.courseTitle?.compareTo(course2?.courseTitle ?: "", ignoreCase = true) ?: 0
            } else {
                course2?.courseTitle?.compareTo(course1?.courseTitle ?: "", ignoreCase = true) ?: 0
            }
        }
    }

    private fun sortCourseList(list: List<RealmMyCourse?>): List<RealmMyCourse?> {
        return list.sortedWith { course1, course2 ->
            if (isAscending) {
                course1?.createdDate?.compareTo(course2?.createdDate ?: 0) ?: 0
            } else {
                course2?.createdDate?.compareTo(course1?.createdDate ?: 0) ?: 0
            }
        }
    }

    fun toggleTitleSortOrder() {
        isTitleAscending = !isTitleAscending
        val sortedList = sortCourseListByTitle(courseList)
        dispatchDiff(sortedList)
    }

    fun toggleSortOrder() {
        isAscending = !isAscending
        val sortedList = sortCourseList(courseList)
        dispatchDiff(sortedList)
    }

    fun setProgressMap(progressMap: HashMap<String?, JsonObject>?) {
        this.progressMap = progressMap
    }

    fun setListener(listener: OnCourseItemSelected?) {
        this.listener = listener
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val binding = RowCourseBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHoldercourse(binding)
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder !is ViewHoldercourse) return

        holder.bind(position)
        val course = courseList[position] ?: return

        updateVisibilityForMyCourse(holder, course)
        holder.rowCourseBinding.title.text = course.courseTitle
        configureDescription(holder, course, position)
        configureDateViews(holder, course)
        setTextViewContent(
            holder.rowCourseBinding.gradLevel,
            course.gradeLevel,
            holder.rowCourseBinding.gradLevel,
            context.getString(R.string.grade_level_colon)
        )
        setTextViewContent(
            holder.rowCourseBinding.subjectLevel,
            course.subjectLevel,
            holder.rowCourseBinding.subjectLevel,
            context.getString(R.string.subject_level_colon)
        )
        holder.rowCourseBinding.courseProgress.max = course.getNumberOfSteps()
        displayTagCloud(holder, position)

        userModel = userProfileDbHandler.userModel
        val isGuest = userModel?.isGuest() ?: true
        if (!isGuest) setupRatingBar(holder, course)
        setupCheckbox(holder, course, position, isGuest)

        updateRatingViews(holder, position)
        updateProgressViews(holder, position)

        holder.rowCourseBinding.root.setOnClickListener {
            val newPosition = holder.bindingAdapterPosition
            if (newPosition != RecyclerView.NO_POSITION) {
                openCourse(courseList[newPosition], 0)
            }
        }
    }

    private fun updateVisibilityForMyCourse(holder: ViewHoldercourse, course: RealmMyCourse) {
        if (course.isMyCourse) {
            holder.rowCourseBinding.isMyCourse.visibility = View.VISIBLE
            holder.rowCourseBinding.checkbox.visibility = View.GONE
        } else {
            holder.rowCourseBinding.isMyCourse.visibility = View.GONE
            holder.rowCourseBinding.checkbox.visibility = View.VISIBLE
        }
    }

    private fun configureDescription(holder: ViewHoldercourse, course: RealmMyCourse, position: Int) {
        holder.rowCourseBinding.description.apply {
            text = course.description
            val markdownContentWithLocalPaths = prependBaseUrlToImages(
                course.description,
                "file://${context.getExternalFilesDir(null)}/ole/",
                150,
                100
            )
            setMarkdownText(this, markdownContentWithLocalPaths)

            setOnClickListener {
                homeItemClickListener?.openCallFragment(TakeCourseFragment().apply {
                    arguments = Bundle().apply {
                        putString("id", course.courseId)
                        putInt("position", position)
                    }
                })
            }
        }
    }

    private fun configureDateViews(holder: ViewHoldercourse, course: RealmMyCourse) {
        if (course.gradeLevel.isNullOrEmpty() && course.subjectLevel.isNullOrEmpty()) {
            holder.rowCourseBinding.holder.visibility = View.VISIBLE
            holder.rowCourseBinding.tvDate2.visibility = View.VISIBLE
            holder.rowCourseBinding.tvDate.visibility = View.GONE
            try {
                holder.rowCourseBinding.tvDate2.text = formatDate(course.createdDate, "MMM dd, yyyy")
            } catch (e: Exception) {
                throw RuntimeException(e)
            }
        } else {
            holder.rowCourseBinding.tvDate.visibility = View.VISIBLE
            holder.rowCourseBinding.tvDate2.visibility = View.GONE
            holder.rowCourseBinding.holder.visibility = View.GONE
            try {
                holder.rowCourseBinding.tvDate.text = formatDate(course.createdDate, "MMM dd, yyyy")
            } catch (e: Exception) {
                throw RuntimeException(e)
            }
        }
    }

    private fun setupRatingBar(holder: ViewHoldercourse, course: RealmMyCourse) {
        holder.rowCourseBinding.ratingBar.setOnTouchListener { _: View?, event: MotionEvent ->
            if (event.action == MotionEvent.ACTION_UP) homeItemClickListener?.showRatingDialog(
                "course",
                course.courseId,
                course.courseTitle,
                ratingChangeListener
            )
            true
        }
    }

    private fun setupCheckbox(holder: ViewHoldercourse, course: RealmMyCourse, position: Int, isGuest: Boolean) {
        if (!isGuest) {
            if (course.isMyCourse) {
                holder.rowCourseBinding.checkbox.visibility = View.GONE
            } else {
                holder.rowCourseBinding.checkbox.visibility = View.VISIBLE
                holder.rowCourseBinding.checkbox.isChecked = selectedItems.contains(course)
                holder.rowCourseBinding.checkbox.setOnClickListener { view: View ->
                    holder.rowCourseBinding.checkbox.contentDescription =
                        context.getString(R.string.select_res_course, course.courseTitle)
                    SelectionUtils.handleCheck((view as CheckBox).isChecked, position, selectedItems, courseList)
                    listener?.onSelectedListChange(selectedItems)
                }
            }
        } else {
            holder.rowCourseBinding.checkbox.visibility = View.GONE
        }
    }

    private fun setTextViewContent(textView: TextView?, content: String?, layout: View?, prefix: String) {
        if (content.isNullOrEmpty()) {
            layout?.visibility = View.GONE
        } else {
            layout?.visibility = View.VISIBLE
            textView?.text = context.getString(R.string.prefix_content, prefix, content)
        }
    }

    fun areAllSelected(): Boolean {
        val selectableCourses = courseList.filterNotNull().filter { !it.isMyCourse }
        areAllSelected = selectedItems.size == selectableCourses.size && selectableCourses.isNotEmpty()
        return areAllSelected
    }

    fun selectAllItems(selectAll: Boolean) {
        selectedItems.clear()

        if (selectAll) {
            val selectableCourses = courseList.filterNotNull().filter { !it.isMyCourse }
            selectedItems.addAll(selectableCourses)
        }

        val updatedPositions = mutableListOf<Int>()
        courseList.forEachIndexed { index, course ->
            if (course != null && !course.isMyCourse) {
                updatedPositions.add(index)
            }
        }

        updatedPositions.forEach { position ->
            notifyItemChanged(position)
        }

        listener?.onSelectedListChange(selectedItems)
    }

    override fun onBindViewHolder(
        holder: RecyclerView.ViewHolder,
        position: Int,
        payloads: MutableList<Any>
    ) {
        if (holder !is ViewHoldercourse) {
            super.onBindViewHolder(holder, position, payloads)
            return
        }

        val hasTagPayload = payloads.any { it == TAG_PAYLOAD }
        val bundle = payloads.filterIsInstance<Bundle>().fold(Bundle()) { acc, b -> acc.apply { putAll(b) } }
        val hasRatingPayload = bundle.containsKey(RATING_PAYLOAD)
        val hasProgressPayload = bundle.containsKey(PROGRESS_PAYLOAD)

        if (hasTagPayload || hasRatingPayload || hasProgressPayload) {
            if (hasTagPayload) {
                val courseId = courseList.getOrNull(position)?.id ?: return
                val tags = tagCache[courseId].orEmpty()
                renderTagCloud(holder.rowCourseBinding.flexboxDrawable, tags)
            }
            if (hasRatingPayload) {
                updateRatingViews(holder, position)
            }
            if (hasProgressPayload) {
                updateProgressViews(holder, position)
            }
        } else {
            super.onBindViewHolder(holder, position, payloads)
        }
    }

    private fun displayTagCloud(holder: ViewHoldercourse, position: Int) {
        val flexboxDrawable = holder.rowCourseBinding.flexboxDrawable
        val courseId = courseList.getOrNull(position)?.id
        if (courseId == null) {
            flexboxDrawable.removeAllViews()
            return
        }

        val cachedTags = tagCache[courseId]
        if (cachedTags != null) {
            renderTagCloud(flexboxDrawable, cachedTags)
            return
        }

        flexboxDrawable.removeAllViews()

        if (!tagRequestsInProgress.add(courseId)) {
            return
        }

        lifecycleOwner.lifecycleScope.launch {
            try {
                val tags = tagRepository.getTagsForCourse(courseId)
                tagCache[courseId] = tags
                val adapterPosition = holder.bindingAdapterPosition
                if (adapterPosition != RecyclerView.NO_POSITION) {
                    notifyItemChanged(adapterPosition, TAG_PAYLOAD)
                }
            } finally {
                tagRequestsInProgress.remove(courseId)
            }
        }
    }

    private fun renderTagCloud(flexboxDrawable: FlexboxLayout, tags: List<RealmTag>) {
        flexboxDrawable.removeAllViews()
        if (tags.isEmpty()) {
            return
        }
        val chipCloud = ChipCloud(context, flexboxDrawable, config)
        tags.forEach { tag ->
            chipCloud.addChip(tag.name ?: "")
        }
        chipCloud.setListener { index: Int, _: Boolean, isSelected: Boolean ->
            if (isSelected) {
                tags.getOrNull(index)?.let { selectedTag ->
                    listener?.onTagClicked(selectedTag)
                }
            }
        }
    }

    private fun updateRatingViews(holder: ViewHoldercourse, position: Int) {
        val course = courseList.getOrNull(position) ?: return
        if (map.containsKey(course.courseId)) {
            val ratingObject = map[course.courseId]
            CourseRatingUtils.showRating(
                context,
                ratingObject,
                holder.rowCourseBinding.rating,
                holder.rowCourseBinding.timesRated,
                holder.rowCourseBinding.ratingBar
            )
        } else {
            holder.rowCourseBinding.ratingBar.rating = 0f
            holder.rowCourseBinding.rating.text = context.getString(R.string.zero_point_zero)
            holder.rowCourseBinding.timesRated.text = context.getString(R.string.rating_count_format, 0)
        }
    }

    private fun updateProgressViews(holder: ViewHoldercourse, position: Int) {
        val course = courseList.getOrNull(position) ?: return
        val progress = progressMap?.get(course.courseId)
        if (progress != null) {
            holder.rowCourseBinding.courseProgress.max = getInt("max", progress)
            val currentProgress = getInt("current", progress)
            holder.rowCourseBinding.courseProgress.progress = currentProgress
            if (currentProgress < holder.rowCourseBinding.courseProgress.max) {
                holder.rowCourseBinding.courseProgress.secondaryProgress = currentProgress + 1
            }
            holder.rowCourseBinding.courseProgress.visibility = View.VISIBLE
        } else {
            holder.rowCourseBinding.courseProgress.visibility = View.GONE
        }
    }

    private fun openCourse(realmMyCourses: RealmMyCourse?, step: Int) {
        if (homeItemClickListener != null) {
            val f: Fragment = TakeCourseFragment()
            val b = Bundle()
            b.putString("id", realmMyCourses?.courseId)
            b.putInt("position", step)
            f.arguments = b
            homeItemClickListener?.openCallFragment(f)
        }
    }

    override fun getItemCount(): Int {
        return courseList.size
    }

    internal inner class ViewHoldercourse(val rowCourseBinding: RowCourseBinding) :
        RecyclerView.ViewHolder(rowCourseBinding.root) {
        private var adapterPosition = 0

        init {
            itemView.setOnClickListener {
                if (adapterPosition != RecyclerView.NO_POSITION) {
                    openCourse(courseList[adapterPosition], 0)
                }
            }
            rowCourseBinding.courseProgress.scaleY = 0.3f
            rowCourseBinding.courseProgress.setOnSeekBarChangeListener(object : OnSeekBarChangeListener {
                override fun onProgressChanged(seekBar: SeekBar, i: Int, b: Boolean) {
                    val position = bindingAdapterPosition
                    if (position != RecyclerView.NO_POSITION && position < courseList.size) {
                        if (progressMap?.containsKey(courseList[bindingAdapterPosition]?.courseId) == true) {
                            val ob = progressMap!![courseList[bindingAdapterPosition]?.courseId]
                            val current = getInt("current", ob)
                            if (b && i <= current + 1) {
                                openCourse(courseList[bindingAdapterPosition], seekBar.progress)
                            }
                        }
                    }
                }

                override fun onStartTrackingTouch(seekBar: SeekBar) {}
                override fun onStopTrackingTouch(seekBar: SeekBar) {}
            })
        }

        fun bind(position: Int) {
            adapterPosition = position
        }
    }
}
=======
package org.ole.planet.myplanet.ui.courses


import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import android.widget.SeekBar
import android.widget.SeekBar.OnSeekBarChangeListener
import android.widget.TextView
import androidx.fragment.app.Fragment
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.RecyclerView
import com.google.android.flexbox.FlexboxLayout
import com.google.gson.JsonObject
import fisk.chipcloud.ChipCloud
import fisk.chipcloud.ChipCloudConfig
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnCourseItemSelected
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.RowCourseBinding
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.CourseRatingUtils
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.JsonUtils.getInt
import org.ole.planet.myplanet.utilities.Markdown.prependBaseUrlToImages
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText
import org.ole.planet.myplanet.utilities.SelectionUtils
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities

class AdapterCourses(
    private val context: Context,
    private var courseList: List<RealmMyCourse?>,
    private val map: HashMap<String?, JsonObject>,
    private val userProfileDbHandler: UserProfileDbHandler,
    private val tagRepository: TagRepository,
    private val lifecycleOwner: LifecycleOwner
) : RecyclerView.Adapter<RecyclerView.ViewHolder>() {
    private val selectedItems: MutableList<RealmMyCourse?> = ArrayList()
    private var listener: OnCourseItemSelected? = null
    private var homeItemClickListener: OnHomeItemClickListener? = null
    private var progressMap: HashMap<String?, JsonObject>? = null
    private var ratingChangeListener: OnRatingChangeListener? = null
    private val config: ChipCloudConfig
    private var isAscending = true
    private var isTitleAscending = false
    private var areAllSelected = false
    var userModel: RealmUserModel?= null
    private val tagCache: MutableMap<String, List<RealmTag>> = mutableMapOf()
    private val tagRequestsInProgress: MutableSet<String> = mutableSetOf()

    companion object {
        private const val TAG_PAYLOAD = "payload_tags"
        private const val RATING_PAYLOAD = "payload_rating"
        private const val PROGRESS_PAYLOAD = "payload_progress"
    }

    init {
        if (context is OnHomeItemClickListener) {
            homeItemClickListener = context
        }
        config = Utilities.getCloudConfig().selectMode(ChipCloud.SelectMode.single)
    }

    fun setRatingChangeListener(ratingChangeListener: OnRatingChangeListener?) {
        this.ratingChangeListener = ratingChangeListener
    }

    fun getCourseList(): List<RealmMyCourse?> {
        return courseList
    }

    private fun dispatchDiff(newList: List<RealmMyCourse?>) {
        val diffResult = DiffUtils.calculateDiff(
            courseList,
            newList,
            areItemsTheSame = { old, new -> old?.id == new?.id },
            areContentsTheSame = { old, new ->
                val ratingSame = map[old?.courseId] == map[new?.courseId]
                val progressSame = progressMap?.get(old?.courseId) == progressMap?.get(new?.courseId)

                old?.courseTitle == new?.courseTitle &&
                        old?.description == new?.description &&
                        old?.gradeLevel == new?.gradeLevel &&
                        old?.subjectLevel == new?.subjectLevel &&
                        old?.createdDate == new?.createdDate &&
                        old?.isMyCourse == new?.isMyCourse &&
                        old?.getNumberOfSteps() == new?.getNumberOfSteps() &&
                        ratingSame &&
                        progressSame
            },
            getChangePayload = { old, new ->
                val bundle = Bundle()
                if (map[old?.courseId] != map[new?.courseId]) {
                    bundle.putBoolean(RATING_PAYLOAD, true)
                }
                if (progressMap?.get(old?.courseId) != progressMap?.get(new?.courseId)) {
                    bundle.putBoolean(PROGRESS_PAYLOAD, true)
                }
                if (bundle.isEmpty) null else bundle
            }
        )
        courseList = newList
        diffResult.dispatchUpdatesTo(this)
    }

    fun setCourseList(courseList: List<RealmMyCourse?>) {
        dispatchDiff(courseList)
    }

    private fun sortCourseListByTitle(list: List<RealmMyCourse?>): List<RealmMyCourse?> {
        return list.sortedWith { course1: RealmMyCourse?, course2: RealmMyCourse? ->
            if (isTitleAscending) {
                course1?.courseTitle?.compareTo(course2?.courseTitle ?: "", ignoreCase = true) ?: 0
            } else {
                course2?.courseTitle?.compareTo(course1?.courseTitle ?: "", ignoreCase = true) ?: 0
            }
        }
    }

    private fun sortCourseList(list: List<RealmMyCourse?>): List<RealmMyCourse?> {
        return list.sortedWith { course1, course2 ->
            if (isAscending) {
                course1?.createdDate?.compareTo(course2?.createdDate ?: 0) ?: 0
            } else {
                course2?.createdDate?.compareTo(course1?.createdDate ?: 0) ?: 0
            }
        }
    }

    fun toggleTitleSortOrder() {
        isTitleAscending = !isTitleAscending
        val sortedList = sortCourseListByTitle(courseList)
        dispatchDiff(sortedList)
    }

    fun toggleSortOrder() {
        isAscending = !isAscending
        val sortedList = sortCourseList(courseList)
        dispatchDiff(sortedList)
    }

    fun setProgressMap(progressMap: HashMap<String?, JsonObject>?) {
        this.progressMap = progressMap
    }

    fun setListener(listener: OnCourseItemSelected?) {
        this.listener = listener
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val binding = RowCourseBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHoldercourse(binding)
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder !is ViewHoldercourse) return

        holder.bind(position)
        val course = courseList[position] ?: return

        updateVisibilityForMyCourse(holder, course)
        holder.rowCourseBinding.title.text = course.courseTitle
        configureDescription(holder, course, position)
        configureDateViews(holder, course)
        setTextViewContent(
            holder.rowCourseBinding.gradLevel,
            course.gradeLevel,
            holder.rowCourseBinding.gradLevel,
            context.getString(R.string.grade_level_colon)
        )
        setTextViewContent(
            holder.rowCourseBinding.subjectLevel,
            course.subjectLevel,
            holder.rowCourseBinding.subjectLevel,
            context.getString(R.string.subject_level_colon)
        )
        holder.rowCourseBinding.courseProgress.max = course.getNumberOfSteps()
        displayTagCloud(holder, position)

        userModel = userProfileDbHandler.userModel
        val isGuest = userModel?.isGuest() ?: true
        if (!isGuest) setupRatingBar(holder, course)
        setupCheckbox(holder, course, position, isGuest)

        updateRatingViews(holder, position)
        updateProgressViews(holder, position)

        holder.rowCourseBinding.root.setOnClickListener {
            val newPosition = holder.bindingAdapterPosition
            if (newPosition != RecyclerView.NO_POSITION) {
                openCourse(courseList[newPosition], 0)
            }
        }
    }

    private fun updateVisibilityForMyCourse(holder: ViewHoldercourse, course: RealmMyCourse) {
        if (course.isMyCourse) {
            holder.rowCourseBinding.isMyCourse.visibility = View.VISIBLE
            holder.rowCourseBinding.checkbox.visibility = View.GONE
        } else {
            holder.rowCourseBinding.isMyCourse.visibility = View.GONE
            holder.rowCourseBinding.checkbox.visibility = View.VISIBLE
        }
    }

    private fun configureDescription(holder: ViewHoldercourse, course: RealmMyCourse, position: Int) {
        holder.rowCourseBinding.description.apply {
            text = course.description
            val markdownContentWithLocalPaths = prependBaseUrlToImages(
                course.description,
                "file://${context.getExternalFilesDir(null)}/ole/",
                150,
                100
            )
            setMarkdownText(this, markdownContentWithLocalPaths)

            setOnClickListener {
                homeItemClickListener?.openCallFragment(TakeCourseFragment().apply {
                    arguments = Bundle().apply {
                        putString("id", course.courseId)
                        putInt("position", position)
                    }
                })
            }
        }
    }

    private fun configureDateViews(holder: ViewHoldercourse, course: RealmMyCourse) {
        if (course.gradeLevel.isNullOrEmpty() && course.subjectLevel.isNullOrEmpty()) {
            holder.rowCourseBinding.holder.visibility = View.VISIBLE
            holder.rowCourseBinding.tvDate2.visibility = View.VISIBLE
            holder.rowCourseBinding.tvDate.visibility = View.GONE
            try {
                holder.rowCourseBinding.tvDate2.text = formatDate(course.createdDate, "MMM dd, yyyy")
            } catch (e: Exception) {
                throw RuntimeException(e)
            }
        } else {
            holder.rowCourseBinding.tvDate.visibility = View.VISIBLE
            holder.rowCourseBinding.tvDate2.visibility = View.GONE
            holder.rowCourseBinding.holder.visibility = View.GONE
            try {
                holder.rowCourseBinding.tvDate.text = formatDate(course.createdDate, "MMM dd, yyyy")
            } catch (e: Exception) {
                throw RuntimeException(e)
            }
        }
    }

    private fun setupRatingBar(holder: ViewHoldercourse, course: RealmMyCourse) {
        holder.rowCourseBinding.ratingBar.setOnTouchListener { _: View?, event: MotionEvent ->
            if (event.action == MotionEvent.ACTION_UP) homeItemClickListener?.showRatingDialog(
                "course",
                course.courseId,
                course.courseTitle,
                ratingChangeListener
            )
            true
        }
    }

    private fun setupCheckbox(holder: ViewHoldercourse, course: RealmMyCourse, position: Int, isGuest: Boolean) {
        if (!isGuest) {
            if (course.isMyCourse) {
                holder.rowCourseBinding.checkbox.visibility = View.GONE
            } else {
                holder.rowCourseBinding.checkbox.visibility = View.VISIBLE
                holder.rowCourseBinding.checkbox.isChecked = selectedItems.contains(course)
                holder.rowCourseBinding.checkbox.setOnClickListener { view: View ->
                    holder.rowCourseBinding.checkbox.contentDescription =
                        context.getString(R.string.select_res_course, course.courseTitle)
                    SelectionUtils.handleCheck((view as CheckBox).isChecked, position, selectedItems, courseList)
                    listener?.onSelectedListChange(selectedItems)
                }
            }
        } else {
            holder.rowCourseBinding.checkbox.visibility = View.GONE
        }
    }

    private fun setTextViewContent(textView: TextView?, content: String?, layout: View?, prefix: String) {
        if (content.isNullOrEmpty()) {
            layout?.visibility = View.GONE
        } else {
            layout?.visibility = View.VISIBLE
            textView?.text = context.getString(R.string.prefix_content, prefix, content)
        }
    }

    fun areAllSelected(): Boolean {
        val selectableCourses = courseList.filterNotNull().filter { !it.isMyCourse }
        areAllSelected = selectedItems.size == selectableCourses.size && selectableCourses.isNotEmpty()
        return areAllSelected
    }

    fun selectAllItems(selectAll: Boolean) {
        selectedItems.clear()

        if (selectAll) {
            val selectableCourses = courseList.filterNotNull().filter { !it.isMyCourse }
            selectedItems.addAll(selectableCourses)
        }

        val updatedPositions = mutableListOf<Int>()
        courseList.forEachIndexed { index, course ->
            if (course != null && !course.isMyCourse) {
                updatedPositions.add(index)
            }
        }

        updatedPositions.forEach { position ->
            notifyItemChanged(position)
        }

        listener?.onSelectedListChange(selectedItems)
    }

    override fun onBindViewHolder(
        holder: RecyclerView.ViewHolder,
        position: Int,
        payloads: MutableList<Any>
    ) {
        if (holder !is ViewHoldercourse) {
            super.onBindViewHolder(holder, position, payloads)
            return
        }

        val hasTagPayload = payloads.any { it == TAG_PAYLOAD }
        val bundle = payloads.filterIsInstance<Bundle>().fold(Bundle()) { acc, b -> acc.apply { putAll(b) } }
        val hasRatingPayload = bundle.containsKey(RATING_PAYLOAD)
        val hasProgressPayload = bundle.containsKey(PROGRESS_PAYLOAD)

        if (hasTagPayload || hasRatingPayload || hasProgressPayload) {
            if (hasTagPayload) {
                val courseId = courseList.getOrNull(position)?.id ?: return
                val tags = tagCache[courseId].orEmpty()
                renderTagCloud(holder.rowCourseBinding.flexboxDrawable, tags)
            }
            if (hasRatingPayload) {
                updateRatingViews(holder, position)
            }
            if (hasProgressPayload) {
                updateProgressViews(holder, position)
            }
        } else {
            super.onBindViewHolder(holder, position, payloads)
        }
    }

    private fun displayTagCloud(holder: ViewHoldercourse, position: Int) {
        val flexboxDrawable = holder.rowCourseBinding.flexboxDrawable
        val courseId = courseList.getOrNull(position)?.id
        if (courseId == null) {
            flexboxDrawable.removeAllViews()
            return
        }

        val cachedTags = tagCache[courseId]
        if (cachedTags != null) {
            renderTagCloud(flexboxDrawable, cachedTags)
            return
        }

        flexboxDrawable.removeAllViews()

        if (!tagRequestsInProgress.add(courseId)) {
            return
        }

        lifecycleOwner.lifecycleScope.launch {
            try {
                val tags = tagRepository.getTagsForCourse(courseId)
                tagCache[courseId] = tags
                val adapterPosition = holder.bindingAdapterPosition
                if (adapterPosition != RecyclerView.NO_POSITION) {
                    notifyItemChanged(adapterPosition, TAG_PAYLOAD)
                }
            } finally {
                tagRequestsInProgress.remove(courseId)
            }
        }
    }

    private fun renderTagCloud(flexboxDrawable: FlexboxLayout, tags: List<RealmTag>) {
        flexboxDrawable.removeAllViews()
        if (tags.isEmpty()) {
            return
        }
        val chipCloud = ChipCloud(context, flexboxDrawable, config)
        tags.forEach { tag ->
            chipCloud.addChip(tag.name ?: "")
        }
        chipCloud.setListener { index: Int, _: Boolean, isSelected: Boolean ->
            if (isSelected) {
                tags.getOrNull(index)?.let { selectedTag ->
                    listener?.onTagClicked(selectedTag)
                }
            }
        }
    }

    private fun updateRatingViews(holder: ViewHoldercourse, position: Int) {
        val course = courseList.getOrNull(position) ?: return
        if (map.containsKey(course.courseId)) {
            val ratingObject = map[course.courseId]
            CourseRatingUtils.showRating(
                context,
                ratingObject,
                holder.rowCourseBinding.rating,
                holder.rowCourseBinding.timesRated,
                holder.rowCourseBinding.ratingBar
            )
        } else {
            holder.rowCourseBinding.ratingBar.rating = 0f
            holder.rowCourseBinding.rating.text = context.getString(R.string.zero_point_zero)
            holder.rowCourseBinding.timesRated.text = context.getString(R.string.rating_count_format, 0)
        }
    }

    private fun updateProgressViews(holder: ViewHoldercourse, position: Int) {
        val course = courseList.getOrNull(position) ?: return
        val progress = progressMap?.get(course.courseId)
        if (progress != null) {
            holder.rowCourseBinding.courseProgress.max = getInt("max", progress)
            val currentProgress = getInt("current", progress)
            holder.rowCourseBinding.courseProgress.progress = currentProgress
            if (currentProgress < holder.rowCourseBinding.courseProgress.max) {
                holder.rowCourseBinding.courseProgress.secondaryProgress = currentProgress + 1
            }
            holder.rowCourseBinding.courseProgress.visibility = View.VISIBLE
        } else {
            holder.rowCourseBinding.courseProgress.visibility = View.GONE
        }
    }

    private fun openCourse(realmMyCourses: RealmMyCourse?, step: Int) {
        if (homeItemClickListener != null) {
            val f: Fragment = TakeCourseFragment()
            val b = Bundle()
            b.putString("id", realmMyCourses?.courseId)
            b.putInt("position", step)
            f.arguments = b
            homeItemClickListener?.openCallFragment(f)
        }
    }

    override fun getItemCount(): Int {
        return courseList.size
    }

    internal inner class ViewHoldercourse(val rowCourseBinding: RowCourseBinding) :
        RecyclerView.ViewHolder(rowCourseBinding.root) {
        private var adapterPosition = 0

        init {
            itemView.setOnClickListener {
                if (adapterPosition != RecyclerView.NO_POSITION) {
                    openCourse(courseList[adapterPosition], 0)
                }
            }
            rowCourseBinding.courseProgress.scaleY = 0.3f
            rowCourseBinding.courseProgress.setOnSeekBarChangeListener(object : OnSeekBarChangeListener {
                override fun onProgressChanged(seekBar: SeekBar, i: Int, b: Boolean) {
                    val position = bindingAdapterPosition
                    if (position != RecyclerView.NO_POSITION && position < courseList.size) {
                        if (progressMap?.containsKey(courseList[bindingAdapterPosition]?.courseId) == true) {
                            val ob = progressMap!![courseList[bindingAdapterPosition]?.courseId]
                            val current = getInt("current", ob)
                            if (b && i <= current + 1) {
                                openCourse(courseList[bindingAdapterPosition], seekBar.progress)
                            }
                        }
                    }
                }

                override fun onStartTrackingTouch(seekBar: SeekBar) {}
                override fun onStopTrackingTouch(seekBar: SeekBar) {}
            })
        }

        fun bind(position: Int) {
            adapterPosition = position
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/courses/MyProgressFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.courses

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmResults
import javax.inject.Inject
import org.ole.planet.myplanet.databinding.FragmentMyProgressBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmAnswer
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.service.UserProfileDbHandler

@AndroidEntryPoint
class MyProgressFragment : Fragment() {
    private var _binding: FragmentMyProgressBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMyProgressBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        initializeData()
    }

    private fun initializeData() {
        databaseService.withRealm { realm ->
            val user = userProfileDbHandler.userModel
            val courseData = fetchCourseData(realm, user?.id)
            binding.rvMyprogress.layoutManager = LinearLayoutManager(requireActivity())
            binding.rvMyprogress.adapter = AdapterMyProgress(requireActivity(), courseData)
        }
    }

    companion object {
        fun fetchCourseData(realm: Realm, userId: String?): JsonArray {
            val mycourses = RealmMyCourse.getMyCourseByUserId(
                userId,
                realm.where(RealmMyCourse::class.java).findAll()
            )
            val arr = JsonArray()
            val courseProgress = RealmCourseProgress.getCourseProgress(realm, userId)

            mycourses.forEach { course ->
                val obj = JsonObject()
                obj.addProperty("courseName", course.courseTitle)
                obj.addProperty("courseId", course.courseId)
                obj.add("progress", courseProgress[course.id])

                val submissions = course.courseId?.let { courseId ->
                    realm.where(RealmSubmission::class.java)
                        .equalTo("userId", userId)
                        .contains("parentId", courseId)
                        .equalTo("type", "exam")
                        .findAll()
                }
                val exams = realm.where(RealmStepExam::class.java)
                    .equalTo("courseId", course.courseId)
                    .findAll()
                val examIds: List<String> = exams.map { it.id as String }

                if (submissions != null) {
                    submissionMap(submissions, realm, examIds, obj)
                }
                arr.add(obj)
            }
            return arr
        }

        private fun submissionMap(submissions: RealmResults<RealmSubmission>, realm: Realm, examIds: List<String>, obj: JsonObject) {
            var totalMistakes = 0
            submissions.forEach {
                val answers = realm.where(RealmAnswer::class.java)
                    .equalTo("submissionId", it.id)
                    .findAll()
                val mistakesMap = HashMap<String, Int>()
                answers.forEach { r ->
                    val question = realm.where(RealmExamQuestion::class.java)
                        .equalTo("id", r.questionId)
                        .findFirst()
                    if (examIds.contains(question?.examId)) {
                        totalMistakes += r.mistakes
                        if (mistakesMap.containsKey(question?.examId)) {
                            mistakesMap["${examIds.indexOf(question?.examId)}"] = mistakesMap[question?.examId]!!.plus(r.mistakes)
                        } else {
                            mistakesMap["${examIds.indexOf(question?.examId)}"] = r.mistakes
                        }
                    }
                }
                obj.add("stepMistake", Gson().fromJson(Gson().toJson(mistakesMap), JsonObject::class.java))
                obj.addProperty("mistakes", totalMistakes)
            }
        }

        fun getCourseProgress(courseData: JsonArray, courseId: String): JsonObject? {
            courseData.forEach { element ->
                val course = element.asJsonObject
                if (course.get("courseId").asString == courseId) {
                    return course.getAsJsonObject("progress")
                }
            }
            return null
        }

    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.courses


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmResults
import javax.inject.Inject
import org.ole.planet.myplanet.databinding.FragmentMyProgressBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmAnswer
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.service.UserProfileDbHandler

@AndroidEntryPoint
class MyProgressFragment : Fragment() {
    private var _binding: FragmentMyProgressBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMyProgressBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        initializeData()
    }

    private fun initializeData() {
        databaseService.withRealm { realm ->
            val user = userProfileDbHandler.userModel
            val courseData = fetchCourseData(realm, user?.id)
            binding.rvMyprogress.layoutManager = LinearLayoutManager(requireActivity())
            binding.rvMyprogress.adapter = AdapterMyProgress(requireActivity(), courseData)
        }
    }

    companion object {
        fun fetchCourseData(realm: Realm, userId: String?): JsonArray {
            val mycourses = RealmMyCourse.getMyCourseByUserId(
                userId,
                realm.where(RealmMyCourse::class.java).findAll()
            )
            val arr = JsonArray()
            val courseProgress = RealmCourseProgress.getCourseProgress(realm, userId)

            mycourses.forEach { course ->
                val obj = JsonObject()
                obj.addProperty("courseName", course.courseTitle)
                obj.addProperty("courseId", course.courseId)
                obj.add("progress", courseProgress[course.id])

                val submissions = course.courseId?.let { courseId ->
                    realm.where(RealmSubmission::class.java)
                        .equalTo("userId", userId)
                        .contains("parentId", courseId)
                        .equalTo("type", "exam")
                        .findAll()
                }
                val exams = realm.where(RealmStepExam::class.java)
                    .equalTo("courseId", course.courseId)
                    .findAll()
                val examIds: List<String> = exams.map { it.id as String }

                if (submissions != null) {
                    submissionMap(submissions, realm, examIds, obj)
                }
                arr.add(obj)
            }
            return arr
        }

        private fun submissionMap(submissions: RealmResults<RealmSubmission>, realm: Realm, examIds: List<String>, obj: JsonObject) {
            var totalMistakes = 0
            submissions.forEach {
                val answers = realm.where(RealmAnswer::class.java)
                    .equalTo("submissionId", it.id)
                    .findAll()
                val mistakesMap = HashMap<String, Int>()
                answers.forEach { r ->
                    val question = realm.where(RealmExamQuestion::class.java)
                        .equalTo("id", r.questionId)
                        .findFirst()
                    if (examIds.contains(question?.examId)) {
                        totalMistakes += r.mistakes
                        if (mistakesMap.containsKey(question?.examId)) {
                            mistakesMap["${examIds.indexOf(question?.examId)}"] = mistakesMap[question?.examId]!!.plus(r.mistakes)
                        } else {
                            mistakesMap["${examIds.indexOf(question?.examId)}"] = r.mistakes
                        }
                    }
                }
                obj.add("stepMistake", Gson().fromJson(Gson().toJson(mistakesMap), JsonObject::class.java))
                obj.addProperty("mistakes", totalMistakes)
            }
        }

        fun getCourseProgress(courseData: JsonArray, courseId: String): JsonObject? {
            courseData.forEach { element ->
                val course = element.asJsonObject
                if (course.get("courseId").asString == courseId) {
                    return course.getAsJsonObject("progress")
                }
            }
            return null
        }

    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/courses/AdapterProgressGrid.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.courses

import android.content.Context
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.JsonArray
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowMyProgressGridBinding

class AdapterProgressGrid(private val context: Context, private val list: JsonArray) :
    RecyclerView.Adapter<RecyclerView.ViewHolder>() {
    private lateinit var rowMyProgressGridBinding: RowMyProgressGridBinding

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        rowMyProgressGridBinding = RowMyProgressGridBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderMyProgress(rowMyProgressGridBinding)
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder is ViewHolderMyProgress) {
            if (list[position].asJsonObject.has("percentage")) {
                holder.tvProgress.text = context.getString(R.string.percentage, list[position].asJsonObject["percentage"].asString)
                if (list[position].asJsonObject["completed"].asBoolean) {
                    holder.itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.md_green_500))
                } else {
                    holder.itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.md_yellow_500))
                }
            } else {
                holder.itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.mainColor))
            }
        }
    }

    override fun getItemCount(): Int {
        return list.size()
    }

    internal inner class ViewHolderMyProgress(rowMyProgressGridBinding: RowMyProgressGridBinding) : RecyclerView.ViewHolder(rowMyProgressGridBinding.root) {
        var tvProgress = rowMyProgressGridBinding.tvProgress
    }
}
=======
package org.ole.planet.myplanet.ui.courses


import android.content.Context
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.JsonArray
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowMyProgressGridBinding

class AdapterProgressGrid(private val context: Context, private val list: JsonArray) :
    RecyclerView.Adapter<RecyclerView.ViewHolder>() {
    private lateinit var rowMyProgressGridBinding: RowMyProgressGridBinding

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        rowMyProgressGridBinding = RowMyProgressGridBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderMyProgress(rowMyProgressGridBinding)
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder is ViewHolderMyProgress) {
            if (list[position].asJsonObject.has("percentage")) {
                holder.tvProgress.text = context.getString(R.string.percentage, list[position].asJsonObject["percentage"].asString)
                if (list[position].asJsonObject["completed"].asBoolean) {
                    holder.itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.md_green_500))
                } else {
                    holder.itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.md_yellow_500))
                }
            } else {
                holder.itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.mainColor))
            }
        }
    }

    override fun getItemCount(): Int {
        return list.size()
    }

    internal inner class ViewHolderMyProgress(rowMyProgressGridBinding: RowMyProgressGridBinding) : RecyclerView.ViewHolder(rowMyProgressGridBinding.root) {
        var tvProgress = rowMyProgressGridBinding.tvProgress
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/courses/CourseDetailFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.courses

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.FragmentCourseDetailBinding
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.RatingRepository
import org.ole.planet.myplanet.utilities.Markdown.prependBaseUrlToImages
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText

@AndroidEntryPoint
class CourseDetailFragment : BaseContainerFragment(), OnRatingChangeListener {
    private var _binding: FragmentCourseDetailBinding? = null
    private val binding get() = _binding!!
    var courses: RealmMyCourse? = null
    var user: RealmUserModel? = null
    var id: String? = null
    @Inject
    lateinit var ratingRepository: RatingRepository
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            id = requireArguments().getString("courseId")
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentCourseDetailBinding.inflate(inflater, container, false)
        user = profileDbHandler?.userModel
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewLifecycleOwner.lifecycleScope.launch {
            courses = id?.takeIf { it.isNotBlank() }?.let { courseRepository.getCourseByCourseId(it) }
            initRatingView("course", id ?: courses?.courseId, courses?.courseTitle, this@CourseDetailFragment)
            courses?.let { bindCourseData(it) }
        }
    }

    private suspend fun bindCourseData(course: RealmMyCourse) {
        setTextViewVisibility(binding.subjectLevel, course.subjectLevel, binding.ltSubjectLevel)
        setTextViewVisibility(binding.method, course.method, binding.ltMethod)
        setTextViewVisibility(binding.gradeLevel, course.gradeLevel, binding.ltGradeLevel)
        setTextViewVisibility(binding.language, course.languageOfInstruction, binding.ltLanguage)
        val markdownContentWithLocalPaths = prependBaseUrlToImages(
            course.description,
            "file://" + MainApplication.context.getExternalFilesDir(null) + "/ole/",
            600,
            350
        )
        setMarkdownText(binding.description, markdownContentWithLocalPaths)
        val courseId = course.courseId
        val examCount = courseRepository.getCourseExamCount(courseId)
        binding.noOfExams.text = context?.getString(
            R.string.number_placeholder,
            examCount
        )
        val resources = courseRepository.getCourseOnlineResources(courseId)
        setResourceButton(resources, binding.btnResources)
        val downloadedResources = courseRepository.getCourseOfflineResources(courseId)
        setOpenResourceButton(downloadedResources, binding.btnOpen)
        val steps = courseRepository.getCourseSteps(courseId)
        setStepsList(steps)
        refreshRatings()
    }

    private fun setTextViewVisibility(textView: TextView, content: String?, layout: View) {
        if (content?.isEmpty() == true) {
            layout.visibility = View.GONE
        } else {
            textView.text = content
        }
    }

    private fun setStepsList(steps: List<RealmCourseStep>) {
        binding.stepsList.layoutManager = LinearLayoutManager(activity)
        binding.stepsList.adapter = AdapterSteps(requireActivity(), steps, submissionRepository)
    }

    override fun onRatingChanged() {
        viewLifecycleOwner.lifecycleScope.launch {
            refreshRatings()
        }
    }

    private suspend fun refreshRatings() {
        val courseId = courses?.courseId
        val userId = user?.id
        if (courseId != null && userId != null) {
            val ratingSummary = ratingRepository.getRatingSummary("course", courseId, userId)
            val jsonObject = com.google.gson.JsonObject().apply {
                addProperty("averageRating", ratingSummary.averageRating)
                addProperty("total", ratingSummary.totalRatings)
                ratingSummary.userRating?.let { addProperty("userRating", it) }
            }
            setRatings(jsonObject)
        } else {
            setRatings(null)
        }
    }

    override fun onDownloadComplete() {
        super.onDownloadComplete()
        viewLifecycleOwner.lifecycleScope.launch {
            courses = id?.takeIf { it.isNotBlank() }?.let { courseRepository.getCourseByCourseId(it) } ?: courses
            courses?.let { bindCourseData(it) }
        }
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.courses


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.databinding.FragmentCourseDetailBinding
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.RatingRepository
import org.ole.planet.myplanet.utilities.Markdown.prependBaseUrlToImages
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText

@AndroidEntryPoint
class CourseDetailFragment : BaseContainerFragment(), OnRatingChangeListener {
    private var _binding: FragmentCourseDetailBinding? = null
    private val binding get() = _binding!!
    var courses: RealmMyCourse? = null
    var user: RealmUserModel? = null
    var id: String? = null
    @Inject
    lateinit var ratingRepository: RatingRepository
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            id = requireArguments().getString("courseId")
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentCourseDetailBinding.inflate(inflater, container, false)
        user = profileDbHandler?.userModel
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewLifecycleOwner.lifecycleScope.launch {
            courses = id?.takeIf { it.isNotBlank() }?.let { courseRepository.getCourseByCourseId(it) }
            initRatingView("course", id ?: courses?.courseId, courses?.courseTitle, this@CourseDetailFragment)
            courses?.let { bindCourseData(it) }
        }
    }

    private suspend fun bindCourseData(course: RealmMyCourse) {
        setTextViewVisibility(binding.subjectLevel, course.subjectLevel, binding.ltSubjectLevel)
        setTextViewVisibility(binding.method, course.method, binding.ltMethod)
        setTextViewVisibility(binding.gradeLevel, course.gradeLevel, binding.ltGradeLevel)
        setTextViewVisibility(binding.language, course.languageOfInstruction, binding.ltLanguage)
        val markdownContentWithLocalPaths = prependBaseUrlToImages(
            course.description,
            "file://" + MainApplication.context.getExternalFilesDir(null) + "/ole/",
            600,
            350
        )
        setMarkdownText(binding.description, markdownContentWithLocalPaths)
        val courseId = course.courseId
        val examCount = courseRepository.getCourseExamCount(courseId)
        binding.noOfExams.text = context?.getString(
            R.string.number_placeholder,
            examCount
        )
        val resources = courseRepository.getCourseOnlineResources(courseId)
        setResourceButton(resources, binding.btnResources)
        val downloadedResources = courseRepository.getCourseOfflineResources(courseId)
        setOpenResourceButton(downloadedResources, binding.btnOpen)
        val steps = courseRepository.getCourseSteps(courseId)
        setStepsList(steps)
        refreshRatings()
    }

    private fun setTextViewVisibility(textView: TextView, content: String?, layout: View) {
        if (content?.isEmpty() == true) {
            layout.visibility = View.GONE
        } else {
            textView.text = content
        }
    }

    private fun setStepsList(steps: List<RealmCourseStep>) {
        binding.stepsList.layoutManager = LinearLayoutManager(activity)
        binding.stepsList.adapter = AdapterSteps(requireActivity(), steps, submissionRepository)
    }

    override fun onRatingChanged() {
        viewLifecycleOwner.lifecycleScope.launch {
            refreshRatings()
        }
    }

    private suspend fun refreshRatings() {
        val courseId = courses?.courseId
        val userId = user?.id
        if (courseId != null && userId != null) {
            val ratingSummary = ratingRepository.getRatingSummary("course", courseId, userId)
            val jsonObject = com.google.gson.JsonObject().apply {
                addProperty("averageRating", ratingSummary.averageRating)
                addProperty("total", ratingSummary.totalRatings)
                ratingSummary.userRating?.let { addProperty("userRating", it) }
            }
            setRatings(jsonObject)
        } else {
            setRatings(null)
        }
    }

    override fun onDownloadComplete() {
        super.onDownloadComplete()
        viewLifecycleOwner.lifecycleScope.launch {
            courses = id?.takeIf { it.isNotBlank() }?.let { courseRepository.getCourseByCourseId(it) } ?: courses
            courses?.let { bindCourseData(it) }
        }
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/courses/AdapterSteps.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.courses

import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancelChildren
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowStepsBinding
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.repository.SubmissionRepository

class AdapterSteps(
    private val context: Context,
    private val list: List<RealmCourseStep>,
    private val submissionRepository: SubmissionRepository
) : RecyclerView.Adapter<AdapterSteps.ViewHolder>() {
    private val descriptionVisibilityList: MutableList<Boolean> = ArrayList()
    private var currentlyVisiblePosition = RecyclerView.NO_POSITION
    private val job = SupervisorJob()
    private val coroutineScope = CoroutineScope(job + Dispatchers.Main)
    private val examQuestionCountCache = mutableMapOf<String, Int>()

    init {
        for (i in list.indices) {
            descriptionVisibilityList.add(false)
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val rowStepsBinding = RowStepsBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolder(rowStepsBinding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(position)
    }

    override fun getItemCount(): Int {
        return list.size
    }

    inner class ViewHolder(private val rowStepsBinding: RowStepsBinding) : RecyclerView.ViewHolder(rowStepsBinding.root) {
        private var loadJob: Job? = null

        init {
            itemView.setOnClickListener {
                val position = bindingAdapterPosition
                if (position != RecyclerView.NO_POSITION) {
                    toggleDescriptionVisibility(position)
                }
            }
        }

        fun bind(position: Int) {
            val step = list[position]
            rowStepsBinding.tvTitle.text = step.stepTitle
            rowStepsBinding.tvDescription.text = context.getString(R.string.test_size, 0)
            loadJob?.cancel()

            val stepId = step.id
            if (!stepId.isNullOrEmpty()) {
                val cachedCount = examQuestionCountCache[stepId]
                if (cachedCount != null) {
                    rowStepsBinding.tvDescription.text = context.getString(R.string.test_size, cachedCount)
                } else {
                    val currentPosition = position
                    loadJob = coroutineScope.launch {
                        val size = submissionRepository.getExamQuestionCount(stepId)
                        examQuestionCountCache[stepId] = size
                        if (bindingAdapterPosition == RecyclerView.NO_POSITION) {
                            return@launch
                        }
                        val adapterPosition = bindingAdapterPosition
                        val currentStepId = list.getOrNull(adapterPosition)?.id
                        if (currentStepId == stepId && currentPosition == adapterPosition) {
                            rowStepsBinding.tvDescription.text = context.getString(R.string.test_size, size)
                        }
                    }
                }
            }
            if (descriptionVisibilityList[position]) {
                rowStepsBinding.tvDescription.visibility = View.VISIBLE
            } else {
                rowStepsBinding.tvDescription.visibility = View.GONE
            }
        }

        fun clear() {
            loadJob?.cancel()
            loadJob = null
        }
    }

    private fun toggleDescriptionVisibility(position: Int) {
        if (currentlyVisiblePosition != RecyclerView.NO_POSITION) {
            descriptionVisibilityList[currentlyVisiblePosition] = false
            notifyItemChanged(currentlyVisiblePosition)
        }
        descriptionVisibilityList[position] = !descriptionVisibilityList[position]
        notifyItemChanged(position)
        currentlyVisiblePosition = if (descriptionVisibilityList[position]) position else RecyclerView.NO_POSITION
    }

    override fun onViewRecycled(holder: ViewHolder) {
        super.onViewRecycled(holder)
        holder.clear()
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        super.onDetachedFromRecyclerView(recyclerView)
        job.cancelChildren()
    }
}
=======
package org.ole.planet.myplanet.ui.courses


import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancelChildren
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowStepsBinding
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.repository.SubmissionRepository

class AdapterSteps(
    private val context: Context,
    private val list: List<RealmCourseStep>,
    private val submissionRepository: SubmissionRepository
) : RecyclerView.Adapter<AdapterSteps.ViewHolder>() {
    private val descriptionVisibilityList: MutableList<Boolean> = ArrayList()
    private var currentlyVisiblePosition = RecyclerView.NO_POSITION
    private val job = SupervisorJob()
    private val coroutineScope = CoroutineScope(job + Dispatchers.Main)
    private val examQuestionCountCache = mutableMapOf<String, Int>()

    init {
        for (i in list.indices) {
            descriptionVisibilityList.add(false)
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val rowStepsBinding = RowStepsBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolder(rowStepsBinding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(position)
    }

    override fun getItemCount(): Int {
        return list.size
    }

    inner class ViewHolder(private val rowStepsBinding: RowStepsBinding) : RecyclerView.ViewHolder(rowStepsBinding.root) {
        private var loadJob: Job? = null

        init {
            itemView.setOnClickListener {
                val position = bindingAdapterPosition
                if (position != RecyclerView.NO_POSITION) {
                    toggleDescriptionVisibility(position)
                }
            }
        }

        fun bind(position: Int) {
            val step = list[position]
            rowStepsBinding.tvTitle.text = step.stepTitle
            rowStepsBinding.tvDescription.text = context.getString(R.string.test_size, 0)
            loadJob?.cancel()

            val stepId = step.id
            if (!stepId.isNullOrEmpty()) {
                val cachedCount = examQuestionCountCache[stepId]
                if (cachedCount != null) {
                    rowStepsBinding.tvDescription.text = context.getString(R.string.test_size, cachedCount)
                } else {
                    val currentPosition = position
                    loadJob = coroutineScope.launch {
                        val size = submissionRepository.getExamQuestionCount(stepId)
                        examQuestionCountCache[stepId] = size
                        if (bindingAdapterPosition == RecyclerView.NO_POSITION) {
                            return@launch
                        }
                        val adapterPosition = bindingAdapterPosition
                        val currentStepId = list.getOrNull(adapterPosition)?.id
                        if (currentStepId == stepId && currentPosition == adapterPosition) {
                            rowStepsBinding.tvDescription.text = context.getString(R.string.test_size, size)
                        }
                    }
                }
            }
            if (descriptionVisibilityList[position]) {
                rowStepsBinding.tvDescription.visibility = View.VISIBLE
            } else {
                rowStepsBinding.tvDescription.visibility = View.GONE
            }
        }

        fun clear() {
            loadJob?.cancel()
            loadJob = null
        }
    }

    private fun toggleDescriptionVisibility(position: Int) {
        if (currentlyVisiblePosition != RecyclerView.NO_POSITION) {
            descriptionVisibilityList[currentlyVisiblePosition] = false
            notifyItemChanged(currentlyVisiblePosition)
        }
        descriptionVisibilityList[position] = !descriptionVisibilityList[position]
        notifyItemChanged(position)
        currentlyVisiblePosition = if (descriptionVisibilityList[position]) position else RecyclerView.NO_POSITION
    }

    override fun onViewRecycled(holder: ViewHolder) {
        super.onViewRecycled(holder)
        holder.clear()
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        super.onDetachedFromRecyclerView(recyclerView)
        job.cancelChildren()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/courses/AdapterMyProgress.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.courses

import android.content.Context
import android.content.Intent
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.LinearLayout
import android.widget.TextView
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.JsonArray
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowMyProgressBinding

class AdapterMyProgress(private val context: Context, private val list: JsonArray) :
    RecyclerView.Adapter<RecyclerView.ViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val binding = RowMyProgressBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderMyProgress(binding)
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder is ViewHolderMyProgress) {
            holder.binding.tvTitle.text = list[position].asJsonObject["courseName"].asString
            if (list[position].asJsonObject.has("progress")) {
                holder.binding.tvDescription.text = context.getString(R.string.step_progress, list[position].asJsonObject["progress"].asJsonObject["current"].asInt, list[position].asJsonObject["progress"].asJsonObject["max"].asInt)
                holder.itemView.setOnClickListener {
                    context.startActivity(Intent(context, CourseProgressActivity::class.java).putExtra("courseId", list[position].asJsonObject["courseId"].asString))
                }
            }
            if (list[position].asJsonObject.has("mistakes")) holder.binding.tvTotal.text =
                list[position].asJsonObject["mistakes"].asString
            else holder.binding.tvTotal.text = context.getString(R.string.message_placeholder, "0")
            showStepMistakes(position, holder.binding)
        }
    }

    private fun showStepMistakes(position: Int, binding: RowMyProgressBinding) {
        if (list[position].asJsonObject.has("stepMistake")) {
            val stepMistake = list[position].asJsonObject["stepMistake"].asJsonObject
            binding.llProgress.removeAllViews()

            if (stepMistake.keySet().isNotEmpty()) {
                binding.llHeader.visibility = View.VISIBLE
                val textColor = ContextCompat.getColor(context, R.color.daynight_textColor)
                stepMistake.keySet().forEach { stepKey ->
                    val row = LinearLayout(context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        )
                        orientation = LinearLayout.HORIZONTAL
                        gravity = Gravity.CENTER
                    }

                    val stepView = TextView(context).apply {
                        layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
                        text = "${stepKey.toInt().plus(1)}"
                        gravity = Gravity.CENTER
                        setTextColor(textColor)
                    }

                    val mistakeView = TextView(context).apply {
                        layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
                        text = "${stepMistake[stepKey].asInt}"
                        gravity = Gravity.CENTER
                        setTextColor(textColor)
                    }

                    row.addView(stepView)
                    row.addView(mistakeView)

                    binding.llProgress.addView(row)
                }
            } else {
                binding.llHeader.visibility = View.GONE
            }
        } else {
            binding.llHeader.visibility = View.GONE
        }
    }

    override fun getItemCount(): Int {
        return list.size()
    }

    internal inner class ViewHolderMyProgress(val binding: RowMyProgressBinding) : RecyclerView.ViewHolder(binding.root) {
        val tvTitle = binding.tvTitle
        val tvTotal = binding.tvTotal
        val tvDescription = binding.tvDescription
    }
}
=======
package org.ole.planet.myplanet.ui.courses


import android.content.Context
import android.content.Intent
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.LinearLayout
import android.widget.TextView
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.JsonArray
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowMyProgressBinding

class AdapterMyProgress(private val context: Context, private val list: JsonArray) :
    RecyclerView.Adapter<RecyclerView.ViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val binding = RowMyProgressBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderMyProgress(binding)
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder is ViewHolderMyProgress) {
            holder.binding.tvTitle.text = list[position].asJsonObject["courseName"].asString
            if (list[position].asJsonObject.has("progress")) {
                holder.binding.tvDescription.text = context.getString(R.string.step_progress, list[position].asJsonObject["progress"].asJsonObject["current"].asInt, list[position].asJsonObject["progress"].asJsonObject["max"].asInt)
                holder.itemView.setOnClickListener {
                    context.startActivity(Intent(context, CourseProgressActivity::class.java).putExtra("courseId", list[position].asJsonObject["courseId"].asString))
                }
            }
            if (list[position].asJsonObject.has("mistakes")) holder.binding.tvTotal.text =
                list[position].asJsonObject["mistakes"].asString
            else holder.binding.tvTotal.text = context.getString(R.string.message_placeholder, "0")
            showStepMistakes(position, holder.binding)
        }
    }

    private fun showStepMistakes(position: Int, binding: RowMyProgressBinding) {
        if (list[position].asJsonObject.has("stepMistake")) {
            val stepMistake = list[position].asJsonObject["stepMistake"].asJsonObject
            binding.llProgress.removeAllViews()

            if (stepMistake.keySet().isNotEmpty()) {
                binding.llHeader.visibility = View.VISIBLE
                val textColor = ContextCompat.getColor(context, R.color.daynight_textColor)
                stepMistake.keySet().forEach { stepKey ->
                    val row = LinearLayout(context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        )
                        orientation = LinearLayout.HORIZONTAL
                        gravity = Gravity.CENTER
                    }

                    val stepView = TextView(context).apply {
                        layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
                        text = "${stepKey.toInt().plus(1)}"
                        gravity = Gravity.CENTER
                        setTextColor(textColor)
                    }

                    val mistakeView = TextView(context).apply {
                        layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
                        text = "${stepMistake[stepKey].asInt}"
                        gravity = Gravity.CENTER
                        setTextColor(textColor)
                    }

                    row.addView(stepView)
                    row.addView(mistakeView)

                    binding.llProgress.addView(row)
                }
            } else {
                binding.llHeader.visibility = View.GONE
            }
        } else {
            binding.llHeader.visibility = View.GONE
        }
    }

    override fun getItemCount(): Int {
        return list.size()
    }

    internal inner class ViewHolderMyProgress(val binding: RowMyProgressBinding) : RecyclerView.ViewHolder(binding.root) {
        val tvTitle = binding.tvTitle
        val tvTotal = binding.tvTotal
        val tvDescription = binding.tvDescription
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/courses/CourseStepFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.courses

import android.os.Bundle
import android.text.Spannable
import android.text.method.LinkMovementMethod
import android.text.style.URLSpan
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import java.util.Date
import java.util.UUID
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.databinding.FragmentCourseStepBinding
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.isMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.exam.TakeExamFragment
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission
import org.ole.planet.myplanet.utilities.CameraUtils.ImageCaptureCallback
import org.ole.planet.myplanet.utilities.CameraUtils.capturePhoto
import org.ole.planet.myplanet.utilities.CustomClickableSpan
import org.ole.planet.myplanet.utilities.Markdown.prependBaseUrlToImages
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText

class CourseStepFragment : BaseContainerFragment(), ImageCaptureCallback {
    private lateinit var fragmentCourseStepBinding: FragmentCourseStepBinding
    var stepId: String? = null
    private lateinit var step: RealmCourseStep
    private lateinit var resources: List<RealmMyLibrary>
    private lateinit var stepExams: List<RealmStepExam>
    private lateinit var stepSurvey: List<RealmStepExam>
    var user: RealmUserModel? = null
    private var stepNumber = 0
    private var saveInProgress: Job? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            stepId = requireArguments().getString("stepId")
            stepNumber = requireArguments().getInt("stepNumber")
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        fragmentCourseStepBinding = FragmentCourseStepBinding.inflate(inflater, container, false)
        user = profileDbHandler.userModel
        fragmentCourseStepBinding.btnTakeTest.visibility = View.VISIBLE
        fragmentCourseStepBinding.btnTakeSurvey.visibility = View.VISIBLE
        return fragmentCourseStepBinding.root
    }

    private suspend fun saveCourseProgress(userId: String?, planetCode: String?, parentCode: String?) {
        databaseService.executeTransactionAsync { realm ->
            var courseProgress = realm.where(RealmCourseProgress::class.java)
                .equalTo("courseId", step.courseId)
                .equalTo("userId", userId)
                .equalTo("stepNum", stepNumber)
                .findFirst()
            if (courseProgress == null) {
                courseProgress = realm.createObject(RealmCourseProgress::class.java, UUID.randomUUID().toString())
                courseProgress.createdDate = Date().time
            }
            courseProgress?.courseId = step.courseId
            courseProgress?.stepNum = stepNumber
            if (stepExams.isEmpty()) {
                courseProgress?.passed = true
            }
            courseProgress?.createdOn = planetCode
            courseProgress?.updatedDate = Date().time
            courseProgress?.parentCode = parentCode
            courseProgress?.userId = userId
        }
    }

    private fun launchSaveCourseProgress() {
        if (saveInProgress?.isActive == true) return
        val userId = user?.id
        val planetCode = user?.planetCode
        val parentCode = user?.parentCode
        saveInProgress = lifecycleScope.launch {
            saveCourseProgress(userId, planetCode, parentCode)
        }
        saveInProgress?.invokeOnCompletion { saveInProgress = null }
    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        databaseService.withRealm { realm ->
            step = realm.where(RealmCourseStep::class.java)
                .equalTo("id", stepId)
                .findFirst()
                ?.let { realm.copyFromRealm(it) }!!
            resources = realm.where(RealmMyLibrary::class.java)
                .equalTo("stepId", stepId)
                .findAll()
                .let { realm.copyFromRealm(it) }
            stepExams = realm.where(RealmStepExam::class.java)
                .equalTo("stepId", stepId)
                .equalTo("type", "courses")
                .findAll()
                .let { realm.copyFromRealm(it) }
            stepSurvey = realm.where(RealmStepExam::class.java)
                .equalTo("stepId", stepId)
                .equalTo("type", "surveys")
                .findAll()
                .let { realm.copyFromRealm(it) }
        }
        fragmentCourseStepBinding.btnResources.text = getString(R.string.resources_size, resources.size)
        hideTestIfNoQuestion()
        fragmentCourseStepBinding.tvTitle.text = step.stepTitle
        val markdownContentWithLocalPaths = prependBaseUrlToImages(
            step.description,
            "file://${MainApplication.context.getExternalFilesDir(null)}/ole/",
            600,
            350
        )
        setMarkdownText(fragmentCourseStepBinding.description, markdownContentWithLocalPaths)
        fragmentCourseStepBinding.description.movementMethod = LinkMovementMethod.getInstance()
        val userHasCourse = databaseService.withRealm { realm ->
            isMyCourse(user?.id, step.courseId, realm)
        }
        if (!userHasCourse) {
            fragmentCourseStepBinding.btnTakeTest.visibility = View.GONE
            fragmentCourseStepBinding.btnTakeSurvey.visibility = View.GONE
        }
        setListeners()
        val textWithSpans = fragmentCourseStepBinding.description.text
        if (textWithSpans is Spannable) {
            val urlSpans = textWithSpans.getSpans(0, textWithSpans.length, URLSpan::class.java)
            for (urlSpan in urlSpans) {
                val start = textWithSpans.getSpanStart(urlSpan)
                val end = textWithSpans.getSpanEnd(urlSpan)
                val dynamicTitle = textWithSpans.subSequence(start, end).toString()
                textWithSpans.setSpan(CustomClickableSpan(urlSpan.url, dynamicTitle, requireActivity()), start, end, textWithSpans.getSpanFlags(urlSpan))
                textWithSpans.removeSpan(urlSpan)
            }
        }
        if (isVisible && userHasCourse) {
            launchSaveCourseProgress()
        }
    }

    private fun hideTestIfNoQuestion() {
        fragmentCourseStepBinding.btnTakeTest.visibility = View.GONE
        fragmentCourseStepBinding.btnTakeSurvey.visibility = View.GONE
        viewLifecycleOwner.lifecycleScope.launch {
            if (stepExams.isNotEmpty()) {
                val firstStepId = stepExams[0].id
                val isTestPresent = submissionRepository.hasSubmission(firstStepId, step.courseId, user?.id, "exam")
                fragmentCourseStepBinding.btnTakeTest.text = if (isTestPresent) {
                    getString(R.string.retake_test, stepExams.size)
                } else {
                    getString(R.string.take_test, stepExams.size)
                }
                fragmentCourseStepBinding.btnTakeTest.visibility = View.VISIBLE
            }
            if (stepSurvey.isNotEmpty()) {
                val firstStepId = stepSurvey[0].id
                val isSurveyPresent = submissionRepository.hasSubmission(firstStepId, step.courseId, user?.id, "survey")
                fragmentCourseStepBinding.btnTakeSurvey.text = if (isSurveyPresent) {
                    getString(R.string.redo_survey)
                } else {
                    getString(R.string.record_survey)
                }
                fragmentCourseStepBinding.btnTakeSurvey.visibility = View.VISIBLE
            }
        }
    }

    override fun setMenuVisibility(visible: Boolean) {
        super.setMenuVisibility(visible)
        try {
            if (visible) {
                val userHasCourse = databaseService.withRealm { realm ->
                    isMyCourse(user?.id, step.courseId, realm)
                }
                if (userHasCourse) {
                    launchSaveCourseProgress()
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun setListeners() {
        viewLifecycleOwner.lifecycleScope.launch {
            val notDownloadedResources = libraryRepository.getStepResources(stepId, resourceOffline = false)
            setResourceButton(notDownloadedResources, fragmentCourseStepBinding.btnResources)
            val downloadedResources = libraryRepository.getStepResources(stepId, resourceOffline = true)
            setOpenResourceButton(downloadedResources, fragmentCourseStepBinding.btnOpen)
        }
        fragmentCourseStepBinding.btnTakeTest.setOnClickListener {
            if (stepExams.isNotEmpty()) {
                val takeExam: Fragment = TakeExamFragment()
                val b = Bundle()
                b.putString("stepId", stepId)
                b.putInt("stepNum", stepNumber)
                takeExam.arguments = b
                homeItemClickListener?.openCallFragment(takeExam)
                capturePhoto(this)
            }
        }

        fragmentCourseStepBinding.btnTakeSurvey.setOnClickListener {
            if (stepSurvey.isNotEmpty()) {
                AdapterMySubmission.openSurvey(homeItemClickListener, stepSurvey[0].id, false, false, "")
            }
        }
        fragmentCourseStepBinding.btnResources.visibility = View.GONE
    }

    override fun onDownloadComplete() {
        super.onDownloadComplete()
        setListeners()
    }

    override fun onImageCapture(fileUri: String?) {}

}
=======
package org.ole.planet.myplanet.ui.courses


import android.os.Bundle
import android.text.Spannable
import android.text.method.LinkMovementMethod
import android.text.style.URLSpan
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import java.util.Date
import java.util.UUID
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.databinding.FragmentCourseStepBinding
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.isMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.exam.TakeExamFragment
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission
import org.ole.planet.myplanet.utilities.CameraUtils.ImageCaptureCallback
import org.ole.planet.myplanet.utilities.CameraUtils.capturePhoto
import org.ole.planet.myplanet.utilities.CustomClickableSpan
import org.ole.planet.myplanet.utilities.Markdown.prependBaseUrlToImages
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText

class CourseStepFragment : BaseContainerFragment(), ImageCaptureCallback {
    private lateinit var fragmentCourseStepBinding: FragmentCourseStepBinding
    var stepId: String? = null
    private lateinit var step: RealmCourseStep
    private lateinit var resources: List<RealmMyLibrary>
    private lateinit var stepExams: List<RealmStepExam>
    private lateinit var stepSurvey: List<RealmStepExam>
    var user: RealmUserModel? = null
    private var stepNumber = 0
    private var saveInProgress: Job? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) {
            stepId = requireArguments().getString("stepId")
            stepNumber = requireArguments().getInt("stepNumber")
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        fragmentCourseStepBinding = FragmentCourseStepBinding.inflate(inflater, container, false)
        user = profileDbHandler.userModel
        fragmentCourseStepBinding.btnTakeTest.visibility = View.VISIBLE
        fragmentCourseStepBinding.btnTakeSurvey.visibility = View.VISIBLE
        return fragmentCourseStepBinding.root
    }

    private suspend fun saveCourseProgress(userId: String?, planetCode: String?, parentCode: String?) {
        databaseService.executeTransactionAsync { realm ->
            var courseProgress = realm.where(RealmCourseProgress::class.java)
                .equalTo("courseId", step.courseId)
                .equalTo("userId", userId)
                .equalTo("stepNum", stepNumber)
                .findFirst()
            if (courseProgress == null) {
                courseProgress = realm.createObject(RealmCourseProgress::class.java, UUID.randomUUID().toString())
                courseProgress.createdDate = Date().time
            }
            courseProgress?.courseId = step.courseId
            courseProgress?.stepNum = stepNumber
            if (stepExams.isEmpty()) {
                courseProgress?.passed = true
            }
            courseProgress?.createdOn = planetCode
            courseProgress?.updatedDate = Date().time
            courseProgress?.parentCode = parentCode
            courseProgress?.userId = userId
        }
    }

    private fun launchSaveCourseProgress() {
        if (saveInProgress?.isActive == true) return
        val userId = user?.id
        val planetCode = user?.planetCode
        val parentCode = user?.parentCode
        saveInProgress = lifecycleScope.launch {
            saveCourseProgress(userId, planetCode, parentCode)
        }
        saveInProgress?.invokeOnCompletion { saveInProgress = null }
    }
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        databaseService.withRealm { realm ->
            step = realm.where(RealmCourseStep::class.java)
                .equalTo("id", stepId)
                .findFirst()
                ?.let { realm.copyFromRealm(it) }!!
            resources = realm.where(RealmMyLibrary::class.java)
                .equalTo("stepId", stepId)
                .findAll()
                .let { realm.copyFromRealm(it) }
            stepExams = realm.where(RealmStepExam::class.java)
                .equalTo("stepId", stepId)
                .equalTo("type", "courses")
                .findAll()
                .let { realm.copyFromRealm(it) }
            stepSurvey = realm.where(RealmStepExam::class.java)
                .equalTo("stepId", stepId)
                .equalTo("type", "surveys")
                .findAll()
                .let { realm.copyFromRealm(it) }
        }
        fragmentCourseStepBinding.btnResources.text = getString(R.string.resources_size, resources.size)
        hideTestIfNoQuestion()
        fragmentCourseStepBinding.tvTitle.text = step.stepTitle
        val markdownContentWithLocalPaths = prependBaseUrlToImages(
            step.description,
            "file://${MainApplication.context.getExternalFilesDir(null)}/ole/",
            600,
            350
        )
        setMarkdownText(fragmentCourseStepBinding.description, markdownContentWithLocalPaths)
        fragmentCourseStepBinding.description.movementMethod = LinkMovementMethod.getInstance()
        val userHasCourse = databaseService.withRealm { realm ->
            isMyCourse(user?.id, step.courseId, realm)
        }
        if (!userHasCourse) {
            fragmentCourseStepBinding.btnTakeTest.visibility = View.GONE
            fragmentCourseStepBinding.btnTakeSurvey.visibility = View.GONE
        }
        setListeners()
        val textWithSpans = fragmentCourseStepBinding.description.text
        if (textWithSpans is Spannable) {
            val urlSpans = textWithSpans.getSpans(0, textWithSpans.length, URLSpan::class.java)
            for (urlSpan in urlSpans) {
                val start = textWithSpans.getSpanStart(urlSpan)
                val end = textWithSpans.getSpanEnd(urlSpan)
                val dynamicTitle = textWithSpans.subSequence(start, end).toString()
                textWithSpans.setSpan(CustomClickableSpan(urlSpan.url, dynamicTitle, requireActivity()), start, end, textWithSpans.getSpanFlags(urlSpan))
                textWithSpans.removeSpan(urlSpan)
            }
        }
        if (isVisible && userHasCourse) {
            launchSaveCourseProgress()
        }
    }

    private fun hideTestIfNoQuestion() {
        fragmentCourseStepBinding.btnTakeTest.visibility = View.GONE
        fragmentCourseStepBinding.btnTakeSurvey.visibility = View.GONE
        viewLifecycleOwner.lifecycleScope.launch {
            if (stepExams.isNotEmpty()) {
                val firstStepId = stepExams[0].id
                val isTestPresent = submissionRepository.hasSubmission(firstStepId, step.courseId, user?.id, "exam")
                fragmentCourseStepBinding.btnTakeTest.text = if (isTestPresent) {
                    getString(R.string.retake_test, stepExams.size)
                } else {
                    getString(R.string.take_test, stepExams.size)
                }
                fragmentCourseStepBinding.btnTakeTest.visibility = View.VISIBLE
            }
            if (stepSurvey.isNotEmpty()) {
                val firstStepId = stepSurvey[0].id
                val isSurveyPresent = submissionRepository.hasSubmission(firstStepId, step.courseId, user?.id, "survey")
                fragmentCourseStepBinding.btnTakeSurvey.text = if (isSurveyPresent) {
                    getString(R.string.redo_survey)
                } else {
                    getString(R.string.record_survey)
                }
                fragmentCourseStepBinding.btnTakeSurvey.visibility = View.VISIBLE
            }
        }
    }

    override fun setMenuVisibility(visible: Boolean) {
        super.setMenuVisibility(visible)
        try {
            if (visible) {
                val userHasCourse = databaseService.withRealm { realm ->
                    isMyCourse(user?.id, step.courseId, realm)
                }
                if (userHasCourse) {
                    launchSaveCourseProgress()
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun setListeners() {
        viewLifecycleOwner.lifecycleScope.launch {
            val notDownloadedResources = libraryRepository.getStepResources(stepId, resourceOffline = false)
            setResourceButton(notDownloadedResources, fragmentCourseStepBinding.btnResources)
            val downloadedResources = libraryRepository.getStepResources(stepId, resourceOffline = true)
            setOpenResourceButton(downloadedResources, fragmentCourseStepBinding.btnOpen)
        }
        fragmentCourseStepBinding.btnTakeTest.setOnClickListener {
            if (stepExams.isNotEmpty()) {
                val takeExam: Fragment = TakeExamFragment()
                val b = Bundle()
                b.putString("stepId", stepId)
                b.putInt("stepNum", stepNumber)
                takeExam.arguments = b
                homeItemClickListener?.openCallFragment(takeExam)
                capturePhoto(this)
            }
        }

        fragmentCourseStepBinding.btnTakeSurvey.setOnClickListener {
            if (stepSurvey.isNotEmpty()) {
                AdapterMySubmission.openSurvey(homeItemClickListener, stepSurvey[0].id, false, false, "")
            }
        }
        fragmentCourseStepBinding.btnResources.visibility = View.GONE
    }

    override fun onDownloadComplete() {
        super.onDownloadComplete()
        setListeners()
    }

    override fun onImageCapture(fileUri: String?) {}

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/courses/CoursesPagerAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.courses

import android.os.Bundle
import androidx.fragment.app.Fragment
import androidx.viewpager2.adapter.FragmentStateAdapter

class CoursesPagerAdapter(fm: Fragment, private val courseId: String?, private val steps: Array<String?>) : FragmentStateAdapter(fm) {
    override fun createFragment(position: Int): Fragment {
        val b = Bundle()
        val f: Fragment
        if (position == 0) {
            f = CourseDetailFragment()
            b.putString("courseId", courseId)
        } else {
            f = CourseStepFragment()
            b.putString("stepId", steps[position - 1])
            b.putInt("stepNumber", position)
        }
        f.arguments = b
        return f
    }

    override fun getItemCount(): Int {
        return steps.size + 1
    }
}
=======
package org.ole.planet.myplanet.ui.courses


import android.os.Bundle
import androidx.fragment.app.Fragment
import androidx.viewpager2.adapter.FragmentStateAdapter

class CoursesPagerAdapter(fm: Fragment, private val courseId: String?, private val steps: Array<String?>) : FragmentStateAdapter(fm) {
    override fun createFragment(position: Int): Fragment {
        val b = Bundle()
        val f: Fragment
        if (position == 0) {
            f = CourseDetailFragment()
            b.putString("courseId", courseId)
        } else {
            f = CourseStepFragment()
            b.putString("stepId", steps[position - 1])
            b.putInt("stepNumber", position)
        }
        f.arguments = b
        return f
    }

    override fun getItemCount(): Int {
        return steps.size + 1
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/mylife/LifeFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.mylife

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.ItemTouchHelper
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment
import org.ole.planet.myplanet.databinding.FragmentLifeBinding
import org.ole.planet.myplanet.model.RealmMyLife
import org.ole.planet.myplanet.model.RealmMyLife.Companion.getMyLifeByUserId
import org.ole.planet.myplanet.ui.mylife.helper.OnStartDragListener
import org.ole.planet.myplanet.ui.mylife.helper.SimpleItemTouchHelperCallback
import org.ole.planet.myplanet.utilities.KeyboardUtils.setupUI

class LifeFragment : BaseRecyclerFragment<RealmMyLife?>(), OnStartDragListener {
    private lateinit var adapterMyLife: AdapterMyLife
    private var mItemTouchHelper: ItemTouchHelper? = null
    private var _binding: FragmentLifeBinding? = null
    private val binding get() = checkNotNull(_binding)
    override fun getLayout(): Int = R.layout.fragment_life

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = super.onCreateView(inflater, container, savedInstanceState)
        if (view != null) {
            _binding = FragmentLifeBinding.bind(view)
        }
        return view
    }

    override fun getAdapter(): RecyclerView.Adapter<*> {
        val myLifeList = getMyLifeByUserId(mRealm, model?.id)
        adapterMyLife = AdapterMyLife(requireContext(), myLifeList, mRealm, this)
        return adapterMyLife
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        recyclerView.setHasFixedSize(true)
        setupUI(binding.myLifeParentLayout, requireActivity())
        val callback: ItemTouchHelper.Callback = SimpleItemTouchHelperCallback(adapterMyLife)
        mItemTouchHelper = ItemTouchHelper(callback)
        mItemTouchHelper?.attachToRecyclerView(recyclerView)
        val dividerItemDecoration = DividerItemDecoration(recyclerView.context, RecyclerView.VERTICAL)
        recyclerView.addItemDecoration(dividerItemDecoration)
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }

    override fun onStartDrag(viewHolder: RecyclerView.ViewHolder?) {
        viewHolder?.let { mItemTouchHelper?.startDrag(it) }
    }
}
=======
package org.ole.planet.myplanet.ui.mylife


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.ItemTouchHelper
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment
import org.ole.planet.myplanet.databinding.FragmentLifeBinding
import org.ole.planet.myplanet.model.RealmMyLife
import org.ole.planet.myplanet.model.RealmMyLife.Companion.getMyLifeByUserId
import org.ole.planet.myplanet.ui.mylife.helper.OnStartDragListener
import org.ole.planet.myplanet.ui.mylife.helper.SimpleItemTouchHelperCallback
import org.ole.planet.myplanet.utilities.KeyboardUtils.setupUI

class LifeFragment : BaseRecyclerFragment<RealmMyLife?>(), OnStartDragListener {
    private lateinit var adapterMyLife: AdapterMyLife
    private var mItemTouchHelper: ItemTouchHelper? = null
    private var _binding: FragmentLifeBinding? = null
    private val binding get() = checkNotNull(_binding)
    override fun getLayout(): Int = R.layout.fragment_life

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = super.onCreateView(inflater, container, savedInstanceState)
        if (view != null) {
            _binding = FragmentLifeBinding.bind(view)
        }
        return view
    }

    override fun getAdapter(): RecyclerView.Adapter<*> {
        val myLifeList = getMyLifeByUserId(mRealm, model?.id)
        adapterMyLife = AdapterMyLife(requireContext(), myLifeList, mRealm, this)
        return adapterMyLife
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        recyclerView.setHasFixedSize(true)
        setupUI(binding.myLifeParentLayout, requireActivity())
        val callback: ItemTouchHelper.Callback = SimpleItemTouchHelperCallback(adapterMyLife)
        mItemTouchHelper = ItemTouchHelper(callback)
        mItemTouchHelper?.attachToRecyclerView(recyclerView)
        val dividerItemDecoration = DividerItemDecoration(recyclerView.context, RecyclerView.VERTICAL)
        recyclerView.addItemDecoration(dividerItemDecoration)
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }

    override fun onStartDrag(viewHolder: RecyclerView.ViewHolder?) {
        viewHolder?.let { mItemTouchHelper?.startDrag(it) }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/mylife/helper/ItemTouchHelperViewHolder.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.mylife.helper

import androidx.recyclerview.widget.RecyclerView

interface ItemTouchHelperViewHolder {
    fun onItemSelected()
    fun onItemClear(viewHolder: RecyclerView.ViewHolder?)
}
=======
package org.ole.planet.myplanet.ui.mylife.helper


import androidx.recyclerview.widget.RecyclerView

interface ItemTouchHelperViewHolder {
    fun onItemSelected()
    fun onItemClear(viewHolder: RecyclerView.ViewHolder?)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/mylife/helper/SimpleItemTouchHelperCallback.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.mylife.helper

import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.ItemTouchHelper
import androidx.recyclerview.widget.RecyclerView

class SimpleItemTouchHelperCallback(private val mAdapter: ItemTouchHelperAdapter) :
    ItemTouchHelper.Callback() {
    override fun isLongPressDragEnabled(): Boolean {
        return true
    }

    override fun isItemViewSwipeEnabled(): Boolean {
        return false
    }

    override fun getMovementFlags(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder): Int {
        // Set movement flags based on the layout manager
        return if (recyclerView.layoutManager is GridLayoutManager) {
            val dragFlags = ItemTouchHelper.UP or ItemTouchHelper.DOWN or ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT
            val swipeFlags = 0
            makeMovementFlags(dragFlags, swipeFlags)
        } else {
            val dragFlags = ItemTouchHelper.UP or ItemTouchHelper.DOWN
            val swipeFlags = ItemTouchHelper.START or ItemTouchHelper.END
            makeMovementFlags(dragFlags, swipeFlags)
        }
    }

    override fun onMove(recyclerView: RecyclerView, source: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder): Boolean {
        if (source.itemViewType != target.itemViewType) {
            return false
        }

        // Notify the adapter of the move
        mAdapter.onItemMove(source.bindingAdapterPosition, target.bindingAdapterPosition)
        return true
    }

    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, i: Int) {}
    override fun onSelectedChanged(viewHolder: RecyclerView.ViewHolder?, actionState: Int) {
        // We only want the active item to change
        if (actionState != ItemTouchHelper.ACTION_STATE_IDLE) {
            if (viewHolder is ItemTouchHelperViewHolder) {
                // Let the view holder know that this item is being moved or dragged
                val itemViewHolder = viewHolder as ItemTouchHelperViewHolder
                itemViewHolder.onItemSelected()
            }
        }
        super.onSelectedChanged(viewHolder, actionState)
    }

    override fun clearView(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder) {
        super.clearView(recyclerView, viewHolder)
        viewHolder.itemView.alpha = ALPHA_FULL
        if (viewHolder is ItemTouchHelperViewHolder) {
            // Tell the view holder it's time to restore the idle state
            val itemViewHolder = viewHolder as ItemTouchHelperViewHolder
            itemViewHolder.onItemClear(viewHolder)
        }
    }

    companion object {
        const val ALPHA_FULL = 1.0f
    }
}
=======
package org.ole.planet.myplanet.ui.mylife.helper


import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.ItemTouchHelper
import androidx.recyclerview.widget.RecyclerView

class SimpleItemTouchHelperCallback(private val mAdapter: ItemTouchHelperAdapter) :
    ItemTouchHelper.Callback() {
    override fun isLongPressDragEnabled(): Boolean {
        return true
    }

    override fun isItemViewSwipeEnabled(): Boolean {
        return false
    }

    override fun getMovementFlags(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder): Int {
        // Set movement flags based on the layout manager
        return if (recyclerView.layoutManager is GridLayoutManager) {
            val dragFlags = ItemTouchHelper.UP or ItemTouchHelper.DOWN or ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT
            val swipeFlags = 0
            makeMovementFlags(dragFlags, swipeFlags)
        } else {
            val dragFlags = ItemTouchHelper.UP or ItemTouchHelper.DOWN
            val swipeFlags = ItemTouchHelper.START or ItemTouchHelper.END
            makeMovementFlags(dragFlags, swipeFlags)
        }
    }

    override fun onMove(recyclerView: RecyclerView, source: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder): Boolean {
        if (source.itemViewType != target.itemViewType) {
            return false
        }

        // Notify the adapter of the move
        mAdapter.onItemMove(source.bindingAdapterPosition, target.bindingAdapterPosition)
        return true
    }

    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, i: Int) {}
    override fun onSelectedChanged(viewHolder: RecyclerView.ViewHolder?, actionState: Int) {
        // We only want the active item to change
        if (actionState != ItemTouchHelper.ACTION_STATE_IDLE) {
            if (viewHolder is ItemTouchHelperViewHolder) {
                // Let the view holder know that this item is being moved or dragged
                val itemViewHolder = viewHolder as ItemTouchHelperViewHolder
                itemViewHolder.onItemSelected()
            }
        }
        super.onSelectedChanged(viewHolder, actionState)
    }

    override fun clearView(recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder) {
        super.clearView(recyclerView, viewHolder)
        viewHolder.itemView.alpha = ALPHA_FULL
        if (viewHolder is ItemTouchHelperViewHolder) {
            // Tell the view holder it's time to restore the idle state
            val itemViewHolder = viewHolder as ItemTouchHelperViewHolder
            itemViewHolder.onItemClear(viewHolder)
        }
    }

    companion object {
        const val ALPHA_FULL = 1.0f
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/mylife/helper/OnStartDragListener.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.mylife.helper

import androidx.recyclerview.widget.RecyclerView

interface OnStartDragListener {
    fun onStartDrag(viewHolder: RecyclerView.ViewHolder?)
}
=======
package org.ole.planet.myplanet.ui.mylife.helper


import androidx.recyclerview.widget.RecyclerView

interface OnStartDragListener {
    fun onStartDrag(viewHolder: RecyclerView.ViewHolder?)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/mylife/AdapterMyLife.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.mylife

import android.annotation.SuppressLint
import android.content.Context
import android.content.ContextWrapper
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.RecyclerView
import io.realm.Realm
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.RealmMyLife
import org.ole.planet.myplanet.model.RealmMyLife.Companion.updateVisibility
import org.ole.planet.myplanet.model.RealmMyLife.Companion.updateWeight
import org.ole.planet.myplanet.ui.calendar.CalendarFragment
import org.ole.planet.myplanet.ui.myhealth.MyHealthFragment
import org.ole.planet.myplanet.ui.mylife.helper.ItemTouchHelperAdapter
import org.ole.planet.myplanet.ui.mylife.helper.ItemTouchHelperViewHolder
import org.ole.planet.myplanet.ui.mylife.helper.OnStartDragListener
import org.ole.planet.myplanet.ui.mypersonals.MyPersonalsFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.references.ReferenceFragment
import org.ole.planet.myplanet.ui.submission.MySubmissionFragment
import org.ole.planet.myplanet.ui.submission.MySubmissionFragment.Companion.newInstance
import org.ole.planet.myplanet.ui.userprofile.AchievementFragment
import org.ole.planet.myplanet.utilities.Utilities

class AdapterMyLife(private val context: Context, private val myLifeList: List<RealmMyLife>, private var mRealm: Realm, private val mDragStartListener: OnStartDragListener) : RecyclerView.Adapter<RecyclerView.ViewHolder>(), ItemTouchHelperAdapter {
    private val hide = 0.5f
    private val show = 1f

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val v = LayoutInflater.from(context).inflate(R.layout.row_life, parent, false)
        return ViewHolderMyLife(v)
    }

    @SuppressLint("ClickableViewAccessibility")
    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder is ViewHolderMyLife) {
            holder.title.text = myLifeList[position].title
            holder.imageView.setImageResource(context.resources.getIdentifier(myLifeList[position].imageId, "drawable", context.packageName))
            holder.imageView.contentDescription = context.getString(R.string.icon, myLifeList[position].title)
            val fragment = findFragment(myLifeList[position].imageId)
            if (fragment != null) {
                holder.imageView.setOnClickListener { view: View ->
                    transactionFragment(fragment, view)
                }
            }
            holder.dragImageButton.setOnTouchListener { _: View?, event: MotionEvent ->
                holder.dragImageButton.contentDescription = context.getString(R.string.drag, myLifeList[position].title)
                if (event.actionMasked == MotionEvent.ACTION_DOWN) {
                    mDragStartListener.onStartDrag(holder)
                }
                false
            }
            holder.visibility.setOnClickListener {
                holder.visibility.contentDescription = context.getString(R.string.visibility_of, myLifeList[position].title)
                updateVisibility(holder, holder.bindingAdapterPosition, myLifeList[holder.bindingAdapterPosition].isVisible)
            }
            if (!myLifeList[position].isVisible) {
                changeVisibility(holder, R.drawable.ic_visibility, hide)
            } else {
                changeVisibility(holder, R.drawable.ic_visibility_off, show)
            }
        }
    }

    private fun updateVisibility(holder: RecyclerView.ViewHolder, position: Int, isVisible: Boolean) {
        mRealm.executeTransactionAsync({ realm: Realm? ->
            realm?.let {
                updateVisibility(!isVisible, myLifeList[position]._id)
            }
        }, {
            MainApplication.applicationScope.launch(Dispatchers.Main) {
                if (isVisible) {
                    changeVisibility(holder, R.drawable.ic_visibility, hide)
                    Utilities.toast(context, myLifeList[position].title + context.getString(R.string.is_now_hidden))
                } else {
                    changeVisibility(holder, R.drawable.ic_visibility_off, show)
                    Utilities.toast(context, myLifeList[position].title + context.getString(R.string.is_now_shown))
                }
            }
        }) { }
    }

    private fun changeVisibility(holder: RecyclerView.ViewHolder, imageId: Int, alpha: Float) {
        (holder as ViewHolderMyLife).visibility.setImageResource(imageId)
        holder.rvItemContainer.alpha = alpha
    }

    override fun getItemCount(): Int {
        return myLifeList.size
    }

    override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {
        updateWeight(toPosition + 1, myLifeList[fromPosition]._id, myLifeList[fromPosition].userId)
        notifyItemMoved(fromPosition, toPosition)
        return true
    }

    internal inner class ViewHolderMyLife(itemView: View) : RecyclerView.ViewHolder(itemView),
        ItemTouchHelperViewHolder {
        var title: TextView = itemView.findViewById(R.id.titleTextView)
        var imageView: ImageView = itemView.findViewById(R.id.itemImageView)
        var dragImageButton: ImageButton = itemView.findViewById(R.id.drag_image_button)
        var visibility: ImageButton = itemView.findViewById(R.id.visibility_image_button)
        var rvItemContainer: LinearLayout = itemView.findViewById(R.id.rv_item_parent_layout)

        override fun onItemSelected() {
            itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.user_profile_background))
        }

        override fun onItemClear(viewHolder: RecyclerView.ViewHolder?) {
            itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.daynight_grey))
            if (viewHolder != null) {
                if (!myLifeList[viewHolder.bindingAdapterPosition].isVisible) {
                    (viewHolder as ViewHolderMyLife?)?.rvItemContainer?.alpha = hide
                }
            }
        }
    }

    companion object {
        fun findFragment(frag: String?): Fragment? {
            when (frag) {
                "ic_mypersonals" -> return MyPersonalsFragment()
                "ic_submissions" -> return MySubmissionFragment()
                "ic_my_survey" -> return newInstance("survey")
                "ic_myhealth" -> return MyHealthFragment()
                "ic_calendar" -> return CalendarFragment()
                "ic_references" -> return ReferenceFragment()
                "my_achievement" -> return AchievementFragment()
            }
            return null
        }

        fun transactionFragment(f: Fragment?, view: View) {
            var context = view.context
            while (context is ContextWrapper) {
                if (context is AppCompatActivity) {
                    break
                }
                context = context.baseContext
            }

            val activity = context as? AppCompatActivity
            activity?.let { act ->
                f?.let {
                    NavigationHelper.replaceFragment(
                        act.supportFragmentManager,
                        R.id.fragment_container,
                        it,
                        addToBackStack = true
                    )
                }
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.mylife


import android.annotation.SuppressLint
import android.content.Context
import android.content.ContextWrapper
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.RecyclerView
import io.realm.Realm
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.RealmMyLife
import org.ole.planet.myplanet.model.RealmMyLife.Companion.updateVisibility
import org.ole.planet.myplanet.model.RealmMyLife.Companion.updateWeight
import org.ole.planet.myplanet.ui.calendar.CalendarFragment
import org.ole.planet.myplanet.ui.myhealth.MyHealthFragment
import org.ole.planet.myplanet.ui.mylife.helper.ItemTouchHelperAdapter
import org.ole.planet.myplanet.ui.mylife.helper.ItemTouchHelperViewHolder
import org.ole.planet.myplanet.ui.mylife.helper.OnStartDragListener
import org.ole.planet.myplanet.ui.mypersonals.MyPersonalsFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.references.ReferenceFragment
import org.ole.planet.myplanet.ui.submission.MySubmissionFragment
import org.ole.planet.myplanet.ui.submission.MySubmissionFragment.Companion.newInstance
import org.ole.planet.myplanet.ui.userprofile.AchievementFragment
import org.ole.planet.myplanet.utilities.Utilities

class AdapterMyLife(private val context: Context, private val myLifeList: List<RealmMyLife>, private var mRealm: Realm, private val mDragStartListener: OnStartDragListener) : RecyclerView.Adapter<RecyclerView.ViewHolder>(), ItemTouchHelperAdapter {
    private val hide = 0.5f
    private val show = 1f

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val v = LayoutInflater.from(context).inflate(R.layout.row_life, parent, false)
        return ViewHolderMyLife(v)
    }

    @SuppressLint("ClickableViewAccessibility")
    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        if (holder is ViewHolderMyLife) {
            holder.title.text = myLifeList[position].title
            holder.imageView.setImageResource(context.resources.getIdentifier(myLifeList[position].imageId, "drawable", context.packageName))
            holder.imageView.contentDescription = context.getString(R.string.icon, myLifeList[position].title)
            val fragment = findFragment(myLifeList[position].imageId)
            if (fragment != null) {
                holder.imageView.setOnClickListener { view: View ->
                    transactionFragment(fragment, view)
                }
            }
            holder.dragImageButton.setOnTouchListener { _: View?, event: MotionEvent ->
                holder.dragImageButton.contentDescription = context.getString(R.string.drag, myLifeList[position].title)
                if (event.actionMasked == MotionEvent.ACTION_DOWN) {
                    mDragStartListener.onStartDrag(holder)
                }
                false
            }
            holder.visibility.setOnClickListener {
                holder.visibility.contentDescription = context.getString(R.string.visibility_of, myLifeList[position].title)
                updateVisibility(holder, holder.bindingAdapterPosition, myLifeList[holder.bindingAdapterPosition].isVisible)
            }
            if (!myLifeList[position].isVisible) {
                changeVisibility(holder, R.drawable.ic_visibility, hide)
            } else {
                changeVisibility(holder, R.drawable.ic_visibility_off, show)
            }
        }
    }

    private fun updateVisibility(holder: RecyclerView.ViewHolder, position: Int, isVisible: Boolean) {
        mRealm.executeTransactionAsync({ realm: Realm? ->
            realm?.let {
                updateVisibility(!isVisible, myLifeList[position]._id)
            }
        }, {
            MainApplication.applicationScope.launch(Dispatchers.Main) {
                if (isVisible) {
                    changeVisibility(holder, R.drawable.ic_visibility, hide)
                    Utilities.toast(context, myLifeList[position].title + context.getString(R.string.is_now_hidden))
                } else {
                    changeVisibility(holder, R.drawable.ic_visibility_off, show)
                    Utilities.toast(context, myLifeList[position].title + context.getString(R.string.is_now_shown))
                }
            }
        }) { }
    }

    private fun changeVisibility(holder: RecyclerView.ViewHolder, imageId: Int, alpha: Float) {
        (holder as ViewHolderMyLife).visibility.setImageResource(imageId)
        holder.rvItemContainer.alpha = alpha
    }

    override fun getItemCount(): Int {
        return myLifeList.size
    }

    override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {
        updateWeight(toPosition + 1, myLifeList[fromPosition]._id, myLifeList[fromPosition].userId)
        notifyItemMoved(fromPosition, toPosition)
        return true
    }

    internal inner class ViewHolderMyLife(itemView: View) : RecyclerView.ViewHolder(itemView),
        ItemTouchHelperViewHolder {
        var title: TextView = itemView.findViewById(R.id.titleTextView)
        var imageView: ImageView = itemView.findViewById(R.id.itemImageView)
        var dragImageButton: ImageButton = itemView.findViewById(R.id.drag_image_button)
        var visibility: ImageButton = itemView.findViewById(R.id.visibility_image_button)
        var rvItemContainer: LinearLayout = itemView.findViewById(R.id.rv_item_parent_layout)

        override fun onItemSelected() {
            itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.user_profile_background))
        }

        override fun onItemClear(viewHolder: RecyclerView.ViewHolder?) {
            itemView.setBackgroundColor(ContextCompat.getColor(context, R.color.daynight_grey))
            if (viewHolder != null) {
                if (!myLifeList[viewHolder.bindingAdapterPosition].isVisible) {
                    (viewHolder as ViewHolderMyLife?)?.rvItemContainer?.alpha = hide
                }
            }
        }
    }

    companion object {
        fun findFragment(frag: String?): Fragment? {
            when (frag) {
                "ic_mypersonals" -> return MyPersonalsFragment()
                "ic_submissions" -> return MySubmissionFragment()
                "ic_my_survey" -> return newInstance("survey")
                "ic_myhealth" -> return MyHealthFragment()
                "ic_calendar" -> return CalendarFragment()
                "ic_references" -> return ReferenceFragment()
                "my_achievement" -> return AchievementFragment()
            }
            return null
        }

        fun transactionFragment(f: Fragment?, view: View) {
            var context = view.context
            while (context is ContextWrapper) {
                if (context is AppCompatActivity) {
                    break
                }
                context = context.baseContext
            }

            val activity = context as? AppCompatActivity
            activity?.let { act ->
                f?.let {
                    NavigationHelper.replaceFragment(
                        act.supportFragmentManager,
                        R.id.fragment_container,
                        it,
                        addToBackStack = true
                    )
                }
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/submission/SubmissionDetailFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.submission

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.databinding.FragmentSubmissionDetailBinding

class SubmissionDetailFragment : Fragment() {
    private var _binding: FragmentSubmissionDetailBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentSubmissionDetailBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.submission


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.databinding.FragmentSubmissionDetailBinding

class SubmissionDetailFragment : Fragment() {
    private var _binding: FragmentSubmissionDetailBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentSubmissionDetailBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/submission/MySubmissionFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.submission

import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CompoundButton
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.base.BaseRecyclerFragment.Companion.showNoData
import org.ole.planet.myplanet.databinding.FragmentMySubmissionBinding
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler

@AndroidEntryPoint
class MySubmissionFragment : Fragment(), CompoundButton.OnCheckedChangeListener {
    private var _binding: FragmentMySubmissionBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var submissionRepository: SubmissionRepository
    @Inject
    lateinit var userRepository: UserRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    var type: String? = ""
    var exams: HashMap<String?, RealmStepExam>? = null
    private var submissions: List<RealmSubmission>? = null
    private var allSubmissions: List<RealmSubmission> = emptyList()
    var user: RealmUserModel? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) type = requireArguments().getString("type")
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMySubmissionBinding.inflate(inflater, container, false)
        exams = HashMap()
        user = userProfileDbHandler.userModel
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.rvMysurvey.layoutManager = LinearLayoutManager(activity)
        binding.rvMysurvey.addItemDecoration(
            DividerItemDecoration(activity, DividerItemDecoration.VERTICAL)
        )
        viewLifecycleOwner.lifecycleScope.launch {
            val subs = submissionRepository.getSubmissionsByUserId(user?.id ?: "")
            allSubmissions = subs
            exams = HashMap(submissionRepository.getExamMapForSubmissions(subs))
            setData("")
        }
        binding.etSearch.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
            override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {
                val cleanString = charSequence.toString()
                viewLifecycleOwner.lifecycleScope.launch {
                    setData(cleanString)
                }
            }
            override fun afterTextChanged(editable: Editable) {}
        })
        showHideRadioButton()
    }

    private fun showHideRadioButton() {
        if (type != "survey") {
            binding.rbExam.isChecked = true
            binding.rbExam.setOnCheckedChangeListener(this)
            binding.rbSurvey.setOnCheckedChangeListener(this)
        } else {
            binding.rbSurvey.visibility = View.GONE
            binding.rbExam.visibility = View.GONE
            binding.rgSubmission.visibility = View.GONE
        }
    }

    override fun onCheckedChanged(compoundButton: CompoundButton, b: Boolean) {
        type = if (binding.rbSurvey.isChecked) {
            "survey_submission"
        } else {
            "exam"
        }
        viewLifecycleOwner.lifecycleScope.launch {
            setData("")
        }
    }

    private suspend fun setData(s: String) {
        var filtered = allSubmissions

        filtered = when (type) {
            "survey" -> filtered.filter { it.userId == user?.id && it.type == "survey" }
            "survey_submission" -> filtered.filter {
                it.userId == user?.id && it.type == "survey" && it.status != "pending"
            }
            else -> filtered.filter { it.userId == user?.id && it.type != "survey" }
        }.sortedByDescending { it.lastUpdateTime ?: 0 }

        if (s.isNotEmpty()) {
            val examIds = exams?.filter { (_, exam) ->
                exam?.name?.contains(s, ignoreCase = true) == true
            }?.keys ?: emptySet()
            filtered = filtered.filter { examIds.contains(it.parentId) }
        }

        val uniqueSubmissions = filtered
            .groupBy { it.parentId }
            .mapValues { entry -> entry.value.maxByOrNull { it.lastUpdateTime ?: 0 } }
            .values
            .filterNotNull()
            .toList()

        submissions = uniqueSubmissions

        val submitterIds = uniqueSubmissions.mapNotNull { it.userId }.toSet()
        val userNameMap = submitterIds.mapNotNull { id ->
            val userModel = userRepository.getUserById(id)
            val displayName = userModel?.name
            if (displayName.isNullOrBlank()) {
                null
            } else {
                id to displayName
            }
        }.toMap()

        val adapter = AdapterMySubmission(
            requireActivity(),
            submissions,
            exams,
            nameResolver = { userId -> userId?.let { userNameMap[it] } }
        )
        val itemCount = adapter.itemCount

        if (s.isEmpty()) {
            binding.llSearch.visibility = View.VISIBLE
            binding.title.visibility = View.VISIBLE
            if (binding.rbSurvey.isChecked || type == "survey") {
                binding.tvFragmentInfo.text = "mySurveys"
                showNoData(binding.tvMessage, itemCount, "survey_submission")
            } else {
                binding.tvFragmentInfo.text = "mySubmissions"
                showNoData(binding.tvMessage, itemCount, "exam_submission")
            }

            if (itemCount == 0) {
                binding.title.visibility = View.GONE
                binding.tlSearch.visibility = View.GONE
            } else {
                binding.tvMessage.visibility = View.GONE
                binding.title.visibility = View.VISIBLE
                binding.tlSearch.visibility = View.VISIBLE
            }
        }

        adapter.setType(type)
        binding.rvMysurvey.adapter = adapter
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }

    companion object {
        @JvmStatic
        fun newInstance(type: String?): Fragment {
            val fragment = MySubmissionFragment()
            val b = Bundle()
            b.putString("type", type)
            fragment.arguments = b
            return fragment
        }
    }
}
=======
package org.ole.planet.myplanet.ui.submission


import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CompoundButton
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.base.BaseRecyclerFragment.Companion.showNoData
import org.ole.planet.myplanet.databinding.FragmentMySubmissionBinding
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler

@AndroidEntryPoint
class MySubmissionFragment : Fragment(), CompoundButton.OnCheckedChangeListener {
    private var _binding: FragmentMySubmissionBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var submissionRepository: SubmissionRepository
    @Inject
    lateinit var userRepository: UserRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    var type: String? = ""
    var exams: HashMap<String?, RealmStepExam>? = null
    private var submissions: List<RealmSubmission>? = null
    private var allSubmissions: List<RealmSubmission> = emptyList()
    var user: RealmUserModel? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (arguments != null) type = requireArguments().getString("type")
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMySubmissionBinding.inflate(inflater, container, false)
        exams = HashMap()
        user = userProfileDbHandler.userModel
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.rvMysurvey.layoutManager = LinearLayoutManager(activity)
        binding.rvMysurvey.addItemDecoration(
            DividerItemDecoration(activity, DividerItemDecoration.VERTICAL)
        )
        viewLifecycleOwner.lifecycleScope.launch {
            val subs = submissionRepository.getSubmissionsByUserId(user?.id ?: "")
            allSubmissions = subs
            exams = HashMap(submissionRepository.getExamMapForSubmissions(subs))
            setData("")
        }
        binding.etSearch.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}
            override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {
                val cleanString = charSequence.toString()
                viewLifecycleOwner.lifecycleScope.launch {
                    setData(cleanString)
                }
            }
            override fun afterTextChanged(editable: Editable) {}
        })
        showHideRadioButton()
    }

    private fun showHideRadioButton() {
        if (type != "survey") {
            binding.rbExam.isChecked = true
            binding.rbExam.setOnCheckedChangeListener(this)
            binding.rbSurvey.setOnCheckedChangeListener(this)
        } else {
            binding.rbSurvey.visibility = View.GONE
            binding.rbExam.visibility = View.GONE
            binding.rgSubmission.visibility = View.GONE
        }
    }

    override fun onCheckedChanged(compoundButton: CompoundButton, b: Boolean) {
        type = if (binding.rbSurvey.isChecked) {
            "survey_submission"
        } else {
            "exam"
        }
        viewLifecycleOwner.lifecycleScope.launch {
            setData("")
        }
    }

    private suspend fun setData(s: String) {
        var filtered = allSubmissions

        filtered = when (type) {
            "survey" -> filtered.filter { it.userId == user?.id && it.type == "survey" }
            "survey_submission" -> filtered.filter {
                it.userId == user?.id && it.type == "survey" && it.status != "pending"
            }
            else -> filtered.filter { it.userId == user?.id && it.type != "survey" }
        }.sortedByDescending { it.lastUpdateTime ?: 0 }

        if (s.isNotEmpty()) {
            val examIds = exams?.filter { (_, exam) ->
                exam?.name?.contains(s, ignoreCase = true) == true
            }?.keys ?: emptySet()
            filtered = filtered.filter { examIds.contains(it.parentId) }
        }

        val uniqueSubmissions = filtered
            .groupBy { it.parentId }
            .mapValues { entry -> entry.value.maxByOrNull { it.lastUpdateTime ?: 0 } }
            .values
            .filterNotNull()
            .toList()

        submissions = uniqueSubmissions

        val submitterIds = uniqueSubmissions.mapNotNull { it.userId }.toSet()
        val userNameMap = submitterIds.mapNotNull { id ->
            val userModel = userRepository.getUserById(id)
            val displayName = userModel?.name
            if (displayName.isNullOrBlank()) {
                null
            } else {
                id to displayName
            }
        }.toMap()

        val adapter = AdapterMySubmission(
            requireActivity(),
            submissions,
            exams,
            nameResolver = { userId -> userId?.let { userNameMap[it] } }
        )
        val itemCount = adapter.itemCount

        if (s.isEmpty()) {
            binding.llSearch.visibility = View.VISIBLE
            binding.title.visibility = View.VISIBLE
            if (binding.rbSurvey.isChecked || type == "survey") {
                binding.tvFragmentInfo.text = "mySurveys"
                showNoData(binding.tvMessage, itemCount, "survey_submission")
            } else {
                binding.tvFragmentInfo.text = "mySubmissions"
                showNoData(binding.tvMessage, itemCount, "exam_submission")
            }

            if (itemCount == 0) {
                binding.title.visibility = View.GONE
                binding.tlSearch.visibility = View.GONE
            } else {
                binding.tvMessage.visibility = View.GONE
                binding.title.visibility = View.VISIBLE
                binding.tlSearch.visibility = View.VISIBLE
            }
        }

        adapter.setType(type)
        binding.rvMysurvey.adapter = adapter
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }

    companion object {
        @JvmStatic
        fun newInstance(type: String?): Fragment {
            val fragment = MySubmissionFragment()
            val b = Bundle()
            b.putString("type", type)
            fragment.arguments = b
            return fragment
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/submission/AdapterMySubmission.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.submission

import android.content.Context
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.json.JSONObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.RowMysurveyBinding
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.ui.exam.TakeExamFragment
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission.ViewHolderMySurvey
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDate

class AdapterMySubmission(
    private val context: Context,
    list: List<RealmSubmission>?,
    private val examHashMap: HashMap<String?, RealmStepExam>?,
    private val nameResolver: (String?) -> String?,
) : ListAdapter<RealmSubmission, ViewHolderMySurvey>(
    DiffUtils.itemCallback(
        areItemsTheSame = { oldItem, newItem ->
            oldItem.id == newItem.id
        },
        areContentsTheSame = { oldItem, newItem ->
            oldItem.id == newItem.id &&
                oldItem.status == newItem.status &&
                oldItem.lastUpdateTime == newItem.lastUpdateTime
        }
    )
) {
    private var listener: OnHomeItemClickListener? = null
    private var type = ""

    init {
        if (context is OnHomeItemClickListener) {
            listener = context
        }
        if (list != null && list.isEmpty()) {
            Toast.makeText(
                context.applicationContext,
                context.getString(R.string.no_items),
                Toast.LENGTH_SHORT
            ).show()
        }
        submitList(list)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderMySurvey {
        val binding = RowMysurveyBinding.inflate(LayoutInflater.from(context), parent, false)
        return ViewHolderMySurvey(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderMySurvey, position: Int) {
        val submission = getItem(position)
        val binding = holder.binding
        binding.status.text = submission.status
        binding.date.text = getFormattedDate(submission.startTime)
        showSubmittedBy(binding, submission)
        if (examHashMap?.containsKey(submission.parentId) == true) {
            binding.title.text = examHashMap[submission.parentId]?.name
        }
        holder.itemView.setOnClickListener {
            logSubmissionResponses(submission)
            if (type == "survey") {
                openSurvey(listener, submission.id, true, false, "")
            } else {
                openSubmissionDetail(listener, submission.id)
            }
        }
    }

    private fun showSubmittedBy(binding: RowMysurveyBinding, submission: RealmSubmission) {
        val embeddedName = runCatching {
            submission.user?.takeIf { it.isNotBlank() }?.let { userJson ->
                JSONObject(userJson).optString("name").takeIf { name -> name.isNotBlank() }
            }
        }.getOrNull()

        val resolvedName = embeddedName ?: nameResolver(submission.userId)

        if (resolvedName.isNullOrBlank()) {
            binding.submittedBy.visibility = View.GONE
            binding.submittedBy.text = ""
        } else {
            binding.submittedBy.visibility = View.VISIBLE
            binding.submittedBy.text = resolvedName
        }
    }

    private fun logSubmissionResponses(submission: RealmSubmission) {
        val submissionTitle = examHashMap?.get(submission.parentId)?.name ?: "Unknown"
        val answerCount = submission.answers?.size ?: 0

        Log.d("SubmissionResponses", "=== Submission Clicked ===")
        Log.d("SubmissionResponses", "Title: $submissionTitle")
        Log.d("SubmissionResponses", "Submission ID: ${submission.id}")
        Log.d("SubmissionResponses", "Status: ${submission.status}")
        Log.d("SubmissionResponses", "Total Answers: $answerCount")
        Log.d("SubmissionResponses", "")

        submission.answers?.forEachIndexed { index, answer ->
            Log.d("SubmissionResponses", "Answer ${index + 1}:")
            Log.d("SubmissionResponses", "  Question ID: ${answer.questionId}")
            Log.d("SubmissionResponses", "  Value: ${answer.value}")
            Log.d("SubmissionResponses", "  Value Choices: ${answer.valueChoices?.joinToString(", ")}")
            Log.d("SubmissionResponses", "  Passed: ${answer.isPassed}")
            Log.d("SubmissionResponses", "  Mistakes: ${answer.mistakes}")
            Log.d("SubmissionResponses", "")
        }

        Log.d("SubmissionResponses", "=== End of Submission ===")
    }

    private fun openSubmissionDetail(listener: OnHomeItemClickListener?, id: String?) {
        if (listener != null) {
            val b = Bundle()
            b.putString("id", id)
            val f: Fragment = SubmissionDetailFragment()
            f.arguments = b
            listener.openCallFragment(f)
        }
    }

    fun setType(type: String?) {
        if (type != null) {
            this.type = type
        }
    }

    class ViewHolderMySurvey(val binding: RowMysurveyBinding) : RecyclerView.ViewHolder(binding.root)

    companion object {
        @JvmStatic
        fun openSurvey(listener: OnHomeItemClickListener?, id: String?, isMySurvey: Boolean, isTeam: Boolean, teamId: String?) {
            if (listener != null) {
                val b = Bundle()
                b.putString("type", "survey")
                b.putString("id", id)
                b.putBoolean("isMySurvey", isMySurvey)
                b.putBoolean("isTeam", isTeam)
                b.putString("teamId", teamId)
                val f: Fragment = TakeExamFragment()
                f.arguments = b
                listener.openCallFragment(f)
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.submission


import android.content.Context
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.json.JSONObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.RowMysurveyBinding
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.ui.exam.TakeExamFragment
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission.ViewHolderMySurvey
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDate

class AdapterMySubmission(
    private val context: Context,
    list: List<RealmSubmission>?,
    private val examHashMap: HashMap<String?, RealmStepExam>?,
    private val nameResolver: (String?) -> String?,
) : ListAdapter<RealmSubmission, ViewHolderMySurvey>(
    DiffUtils.itemCallback(
        areItemsTheSame = { oldItem, newItem ->
            oldItem.id == newItem.id
        },
        areContentsTheSame = { oldItem, newItem ->
            oldItem.id == newItem.id &&
                oldItem.status == newItem.status &&
                oldItem.lastUpdateTime == newItem.lastUpdateTime
        }
    )
) {
    private var listener: OnHomeItemClickListener? = null
    private var type = ""

    init {
        if (context is OnHomeItemClickListener) {
            listener = context
        }
        if (list != null && list.isEmpty()) {
            Toast.makeText(
                context.applicationContext,
                context.getString(R.string.no_items),
                Toast.LENGTH_SHORT
            ).show()
        }
        submitList(list)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderMySurvey {
        val binding = RowMysurveyBinding.inflate(LayoutInflater.from(context), parent, false)
        return ViewHolderMySurvey(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderMySurvey, position: Int) {
        val submission = getItem(position)
        val binding = holder.binding
        binding.status.text = submission.status
        binding.date.text = getFormattedDate(submission.startTime)
        showSubmittedBy(binding, submission)
        if (examHashMap?.containsKey(submission.parentId) == true) {
            binding.title.text = examHashMap[submission.parentId]?.name
        }
        holder.itemView.setOnClickListener {
            logSubmissionResponses(submission)
            if (type == "survey") {
                openSurvey(listener, submission.id, true, false, "")
            } else {
                openSubmissionDetail(listener, submission.id)
            }
        }
    }

    private fun showSubmittedBy(binding: RowMysurveyBinding, submission: RealmSubmission) {
        val embeddedName = runCatching {
            submission.user?.takeIf { it.isNotBlank() }?.let { userJson ->
                JSONObject(userJson).optString("name").takeIf { name -> name.isNotBlank() }
            }
        }.getOrNull()

        val resolvedName = embeddedName ?: nameResolver(submission.userId)

        if (resolvedName.isNullOrBlank()) {
            binding.submittedBy.visibility = View.GONE
            binding.submittedBy.text = ""
        } else {
            binding.submittedBy.visibility = View.VISIBLE
            binding.submittedBy.text = resolvedName
        }
    }

    private fun logSubmissionResponses(submission: RealmSubmission) {
        val submissionTitle = examHashMap?.get(submission.parentId)?.name ?: "Unknown"
        val answerCount = submission.answers?.size ?: 0

        Log.d("SubmissionResponses", "=== Submission Clicked ===")
        Log.d("SubmissionResponses", "Title: $submissionTitle")
        Log.d("SubmissionResponses", "Submission ID: ${submission.id}")
        Log.d("SubmissionResponses", "Status: ${submission.status}")
        Log.d("SubmissionResponses", "Total Answers: $answerCount")
        Log.d("SubmissionResponses", "")

        submission.answers?.forEachIndexed { index, answer ->
            Log.d("SubmissionResponses", "Answer ${index + 1}:")
            Log.d("SubmissionResponses", "  Question ID: ${answer.questionId}")
            Log.d("SubmissionResponses", "  Value: ${answer.value}")
            Log.d("SubmissionResponses", "  Value Choices: ${answer.valueChoices?.joinToString(", ")}")
            Log.d("SubmissionResponses", "  Passed: ${answer.isPassed}")
            Log.d("SubmissionResponses", "  Mistakes: ${answer.mistakes}")
            Log.d("SubmissionResponses", "")
        }

        Log.d("SubmissionResponses", "=== End of Submission ===")
    }

    private fun openSubmissionDetail(listener: OnHomeItemClickListener?, id: String?) {
        if (listener != null) {
            val b = Bundle()
            b.putString("id", id)
            val f: Fragment = SubmissionDetailFragment()
            f.arguments = b
            listener.openCallFragment(f)
        }
    }

    fun setType(type: String?) {
        if (type != null) {
            this.type = type
        }
    }

    class ViewHolderMySurvey(val binding: RowMysurveyBinding) : RecyclerView.ViewHolder(binding.root)

    companion object {
        @JvmStatic
        fun openSurvey(listener: OnHomeItemClickListener?, id: String?, isMySurvey: Boolean, isTeam: Boolean, teamId: String?) {
            if (listener != null) {
                val b = Bundle()
                b.putString("type", "survey")
                b.putString("id", id)
                b.putBoolean("isMySurvey", isMySurvey)
                b.putBoolean("isTeam", isTeam)
                b.putString("teamId", teamId)
                val f: Fragment = TakeExamFragment()
                f.arguments = b
                listener.openCallFragment(f)
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/viewer/CSVViewerActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.viewer

import android.os.Bundle
import android.text.Spannable
import android.text.SpannableStringBuilder
import android.text.style.ForegroundColorSpan
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.opencsv.CSVParserBuilder
import com.opencsv.CSVReaderBuilder
import java.io.File
import java.io.FileReader
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityCsvviewerBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils

class CSVViewerActivity : AppCompatActivity() {
    private lateinit var binding: ActivityCsvviewerBinding
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityCsvviewerBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        renderCSVFile()
    }

    private fun renderCSVFile() {
        val csvFileOpenIntent = intent
        val fileName = csvFileOpenIntent.getStringExtra("TOUCHED_FILE")
        if (!fileName.isNullOrEmpty()) {
            binding.csvFileName.text = FileUtils.nameWithoutExtension(fileName)
            binding.csvFileName.visibility = View.VISIBLE
        } else {
            binding.csvFileName.text = getString(R.string.message_placeholder, "No file selected")
            binding.csvFileName.visibility = View.VISIBLE
        }

        try {
            val csvFile: File = if (fileName?.startsWith("/") == true) {
                File(fileName)
            } else {
                val basePath = getExternalFilesDir(null)
                File(basePath, "ole/$fileName")
            }
            val reader = CSVReaderBuilder(FileReader(csvFile))
                .withCSVParser(CSVParserBuilder().withSeparator(',').withQuoteChar('"').build())
                .build()

            val allRows = reader.readAll()
            val spannableContent = SpannableStringBuilder()
            for (row in allRows) {
                val rowText = row.contentToString() + "\n"
                val start = spannableContent.length
                spannableContent.append(rowText)
                spannableContent.setSpan(
                    ForegroundColorSpan(ContextCompat.getColor(this, R.color.daynight_textColor)),
                    start, spannableContent.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                )
            }
            binding.csvFileContent.text = spannableContent
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}
=======
package org.ole.planet.myplanet.ui.viewer


import android.os.Bundle
import android.text.Spannable
import android.text.SpannableStringBuilder
import android.text.style.ForegroundColorSpan
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.opencsv.CSVParserBuilder
import com.opencsv.CSVReaderBuilder
import java.io.File
import java.io.FileReader
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityCsvviewerBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils

class CSVViewerActivity : AppCompatActivity() {
    private lateinit var binding: ActivityCsvviewerBinding
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityCsvviewerBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        renderCSVFile()
    }

    private fun renderCSVFile() {
        val csvFileOpenIntent = intent
        val fileName = csvFileOpenIntent.getStringExtra("TOUCHED_FILE")
        if (!fileName.isNullOrEmpty()) {
            binding.csvFileName.text = FileUtils.nameWithoutExtension(fileName)
            binding.csvFileName.visibility = View.VISIBLE
        } else {
            binding.csvFileName.text = getString(R.string.message_placeholder, "No file selected")
            binding.csvFileName.visibility = View.VISIBLE
        }

        try {
            val csvFile: File = if (fileName?.startsWith("/") == true) {
                File(fileName)
            } else {
                val basePath = getExternalFilesDir(null)
                File(basePath, "ole/$fileName")
            }
            val reader = CSVReaderBuilder(FileReader(csvFile))
                .withCSVParser(CSVParserBuilder().withSeparator(',').withQuoteChar('"').build())
                .build()

            val allRows = reader.readAll()
            val spannableContent = SpannableStringBuilder()
            for (row in allRows) {
                val rowText = row.contentToString() + "\n"
                val start = spannableContent.length
                spannableContent.append(rowText)
                spannableContent.setSpan(
                    ForegroundColorSpan(ContextCompat.getColor(this, R.color.daynight_textColor)),
                    start, spannableContent.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                )
            }
            binding.csvFileContent.text = spannableContent
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/viewer/PDFReaderActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.viewer

import android.graphics.pdf.PdfRenderer
import android.os.Bundle
import android.os.ParcelFileDescriptor
import android.text.TextUtils
import android.view.View
import android.widget.ImageView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.graphics.createBitmap
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import java.io.File
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityPdfreaderBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.repository.LibraryRepository
import org.ole.planet.myplanet.repository.MyPersonalRepository
import org.ole.planet.myplanet.service.AudioRecorderService
import org.ole.planet.myplanet.service.AudioRecorderService.AudioRecordListener
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.resources.AddResourceFragment
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.IntentUtils.openAudioFile
import org.ole.planet.myplanet.utilities.NotificationUtils.cancelAll
import org.ole.planet.myplanet.utilities.NotificationUtils.create
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class PDFReaderActivity : AppCompatActivity(), AudioRecordListener {
    private lateinit var binding: ActivityPdfreaderBinding
    private lateinit var audioRecorderService: AudioRecorderService
    private var fileName: String? = null
    @Inject
    lateinit var myPersonalRepository: MyPersonalRepository
    @Inject
    lateinit var libraryRepository: LibraryRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private lateinit var library: RealmMyLibrary
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityPdfreaderBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        audioRecorderService = AudioRecorderService().setAudioRecordListener(this)
        audioRecorderService.setCaller(this, this)
        if (intent.hasExtra("resourceId")) {
            val resourceID = intent.getStringExtra("resourceId")
            lifecycleScope.launch {
                resourceID?.let {
                    library = libraryRepository.getLibraryItemById(it)!!
                }
            }
        }
        renderPdfFile()
        binding.fabRecord.setOnClickListener { audioRecorderService.onRecordClicked()}
        binding.fabPlay.setOnClickListener {
            if (this::library.isInitialized && !TextUtils.isEmpty(library.translationAudioPath)) {
                openAudioFile(this, library.translationAudioPath)
            }
        }
    }

    private fun renderPdfFile() {
        val pdfOpenIntent = intent
        fileName = pdfOpenIntent.getStringExtra("TOUCHED_FILE")
        if (!fileName.isNullOrEmpty()) {
            binding.pdfFileName.text = FileUtils.nameWithoutExtension(fileName)
            binding.pdfFileName.visibility = View.VISIBLE
        } else {
            binding.pdfFileName.text = getString(R.string.message_placeholder, "No file selected")
            binding.pdfFileName.visibility = View.VISIBLE
        }
        val file = File(getExternalFilesDir(null), "ole/$fileName")
        if (file.exists()) {
            try {
                val fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)
                val pdfRenderer = PdfRenderer(fileDescriptor)
                val page = pdfRenderer.openPage(0)
                val bitmap = createBitmap(page.width, page.height)
                page.render(bitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)

                val imageView = ImageView(this)
                imageView.setImageBitmap(bitmap)
                imageView.scaleType = ImageView.ScaleType.FIT_CENTER

                binding.pdfPlaceholder.visibility = View.GONE
                val parent = binding.pdfPlaceholder.parent as android.view.ViewGroup
                parent.addView(imageView, android.view.ViewGroup.LayoutParams(android.view.ViewGroup.LayoutParams.MATCH_PARENT, 0))
                (imageView.layoutParams as android.widget.LinearLayout.LayoutParams).weight = 1f

                page.close()
                pdfRenderer.close()
                fileDescriptor.close()
            } catch (e: Exception) {
                e.printStackTrace()
                Toast.makeText(applicationContext, getString(R.string.unable_to_load) + fileName, Toast.LENGTH_LONG).show()
            }
        } else {
            Toast.makeText(applicationContext, "File not found: $fileName", Toast.LENGTH_LONG)
                .show()
        }
    }


    override fun onRecordStarted() {
        Utilities.toast(this, getString(R.string.recording_started))
        create(this, R.drawable.ic_mic, "Recording Audio", getString(R.string.ole_is_recording_audio))
        binding.fabRecord.setImageResource(R.drawable.ic_stop)
    }

    override fun onRecordStopped(outputFile: String?) {
        Utilities.toast(this, getString(R.string.recording_stopped))
        cancelAll(this)
        updateTranslation(outputFile)
        val userModel = userProfileDbHandler.userModel
        if (userModel != null) {
            AddResourceFragment.showAlert(
                this,
                outputFile,
                myPersonalRepository,
                userModel.id,
                userModel.name,
                lifecycleScope
            ) {}
        }
        binding.fabRecord.setImageResource(R.drawable.ic_mic)
    }

    private fun updateTranslation(outputFile: String?) {
        if (this::library.isInitialized) {
            lifecycleScope.launch {
                libraryRepository.updateLibraryItem(library.id!!) {
                    it.translationAudioPath = outputFile
                }
                library.translationAudioPath = outputFile
                Utilities.toast(
                    this@PDFReaderActivity,
                    getString(R.string.audio_file_saved_in_database)
                )
            }
        }
    }

    override fun onDestroy() {
        if (this::audioRecorderService.isInitialized && audioRecorderService.isRecording()) {
            audioRecorderService.stopRecording()
        }
        super.onDestroy()
    }

    override fun onError(error: String?) {
        cancelAll(this)
        Utilities.toast(this, error)
        binding.fabRecord.setImageResource(R.drawable.ic_mic)
    }
}
=======
package org.ole.planet.myplanet.ui.viewer


import android.graphics.pdf.PdfRenderer
import android.os.Bundle
import android.os.ParcelFileDescriptor
import android.text.TextUtils
import android.view.View
import android.widget.ImageView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.graphics.createBitmap
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import java.io.File
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityPdfreaderBinding
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.repository.LibraryRepository
import org.ole.planet.myplanet.repository.MyPersonalRepository
import org.ole.planet.myplanet.service.AudioRecorderService
import org.ole.planet.myplanet.service.AudioRecorderService.AudioRecordListener
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.resources.AddResourceFragment
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.IntentUtils.openAudioFile
import org.ole.planet.myplanet.utilities.NotificationUtils.cancelAll
import org.ole.planet.myplanet.utilities.NotificationUtils.create
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class PDFReaderActivity : AppCompatActivity(), AudioRecordListener {
    private lateinit var binding: ActivityPdfreaderBinding
    private lateinit var audioRecorderService: AudioRecorderService
    private var fileName: String? = null
    @Inject
    lateinit var myPersonalRepository: MyPersonalRepository
    @Inject
    lateinit var libraryRepository: LibraryRepository
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    private lateinit var library: RealmMyLibrary
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityPdfreaderBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        audioRecorderService = AudioRecorderService().setAudioRecordListener(this)
        audioRecorderService.setCaller(this, this)
        if (intent.hasExtra("resourceId")) {
            val resourceID = intent.getStringExtra("resourceId")
            lifecycleScope.launch {
                resourceID?.let {
                    library = libraryRepository.getLibraryItemById(it)!!
                }
            }
        }
        renderPdfFile()
        binding.fabRecord.setOnClickListener { audioRecorderService.onRecordClicked()}
        binding.fabPlay.setOnClickListener {
            if (this::library.isInitialized && !TextUtils.isEmpty(library.translationAudioPath)) {
                openAudioFile(this, library.translationAudioPath)
            }
        }
    }

    private fun renderPdfFile() {
        val pdfOpenIntent = intent
        fileName = pdfOpenIntent.getStringExtra("TOUCHED_FILE")
        if (!fileName.isNullOrEmpty()) {
            binding.pdfFileName.text = FileUtils.nameWithoutExtension(fileName)
            binding.pdfFileName.visibility = View.VISIBLE
        } else {
            binding.pdfFileName.text = getString(R.string.message_placeholder, "No file selected")
            binding.pdfFileName.visibility = View.VISIBLE
        }
        val file = File(getExternalFilesDir(null), "ole/$fileName")
        if (file.exists()) {
            try {
                val fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)
                val pdfRenderer = PdfRenderer(fileDescriptor)
                val page = pdfRenderer.openPage(0)
                val bitmap = createBitmap(page.width, page.height)
                page.render(bitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)

                val imageView = ImageView(this)
                imageView.setImageBitmap(bitmap)
                imageView.scaleType = ImageView.ScaleType.FIT_CENTER

                binding.pdfPlaceholder.visibility = View.GONE
                val parent = binding.pdfPlaceholder.parent as android.view.ViewGroup
                parent.addView(imageView, android.view.ViewGroup.LayoutParams(android.view.ViewGroup.LayoutParams.MATCH_PARENT, 0))
                (imageView.layoutParams as android.widget.LinearLayout.LayoutParams).weight = 1f

                page.close()
                pdfRenderer.close()
                fileDescriptor.close()
            } catch (e: Exception) {
                e.printStackTrace()
                Toast.makeText(applicationContext, getString(R.string.unable_to_load) + fileName, Toast.LENGTH_LONG).show()
            }
        } else {
            Toast.makeText(applicationContext, "File not found: $fileName", Toast.LENGTH_LONG)
                .show()
        }
    }


    override fun onRecordStarted() {
        Utilities.toast(this, getString(R.string.recording_started))
        create(this, R.drawable.ic_mic, "Recording Audio", getString(R.string.ole_is_recording_audio))
        binding.fabRecord.setImageResource(R.drawable.ic_stop)
    }

    override fun onRecordStopped(outputFile: String?) {
        Utilities.toast(this, getString(R.string.recording_stopped))
        cancelAll(this)
        updateTranslation(outputFile)
        val userModel = userProfileDbHandler.userModel
        if (userModel != null) {
            AddResourceFragment.showAlert(
                this,
                outputFile,
                myPersonalRepository,
                userModel.id,
                userModel.name,
                lifecycleScope
            ) {}
        }
        binding.fabRecord.setImageResource(R.drawable.ic_mic)
    }

    private fun updateTranslation(outputFile: String?) {
        if (this::library.isInitialized) {
            lifecycleScope.launch {
                libraryRepository.updateLibraryItem(library.id!!) {
                    it.translationAudioPath = outputFile
                }
                library.translationAudioPath = outputFile
                Utilities.toast(
                    this@PDFReaderActivity,
                    getString(R.string.audio_file_saved_in_database)
                )
            }
        }
    }

    override fun onDestroy() {
        if (this::audioRecorderService.isInitialized && audioRecorderService.isRecording()) {
            audioRecorderService.stopRecording()
        }
        super.onDestroy()
    }

    override fun onError(error: String?) {
        cancelAll(this)
        Utilities.toast(this, error)
        binding.fabRecord.setImageResource(R.drawable.ic_mic)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/viewer/MarkdownViewerActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.viewer

import android.os.Bundle
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import java.io.File
import java.io.IOException
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityMarkdownViewerBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText

class MarkdownViewerActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMarkdownViewerBinding
    private var fileName: String? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMarkdownViewerBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        renderMarkdownFile()
    }

    private fun renderMarkdownFile() {
        val markdownOpenIntent = intent
        fileName = markdownOpenIntent.getStringExtra("TOUCHED_FILE")
        if (!fileName.isNullOrEmpty()) {

            binding.markdownFileName.text = FileUtils.nameWithoutExtension(fileName)
            binding.markdownFileName.visibility = View.VISIBLE
        } else {
            binding.markdownFileName.text = getString(R.string.message_placeholder, "No file selected")
            binding.markdownFileName.visibility = View.VISIBLE
        }
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val basePath = getExternalFilesDir(null)
                val markdownFile = File(basePath, "ole/$fileName")
                if (markdownFile.exists()) {
                    val markdownContent = readMarkdownFile(markdownFile)
                    withContext(Dispatchers.Main) {
                        setMarkdownText(binding.markdownView, markdownContent)
                    }
                } else {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(
                            this@MarkdownViewerActivity,
                            getString(R.string.unable_to_load) + fileName,
                            Toast.LENGTH_LONG
                        ).show()
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    @Throws(IOException::class)
    private fun readMarkdownFile(file: File): String {
        return file.useLines { sequence ->
            sequence.joinToString("\n")
        }
    }
}
=======
package org.ole.planet.myplanet.ui.viewer


import android.os.Bundle
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import java.io.File
import java.io.IOException
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityMarkdownViewerBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText

class MarkdownViewerActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMarkdownViewerBinding
    private var fileName: String? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMarkdownViewerBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        renderMarkdownFile()
    }

    private fun renderMarkdownFile() {
        val markdownOpenIntent = intent
        fileName = markdownOpenIntent.getStringExtra("TOUCHED_FILE")
        if (!fileName.isNullOrEmpty()) {

            binding.markdownFileName.text = FileUtils.nameWithoutExtension(fileName)
            binding.markdownFileName.visibility = View.VISIBLE
        } else {
            binding.markdownFileName.text = getString(R.string.message_placeholder, "No file selected")
            binding.markdownFileName.visibility = View.VISIBLE
        }
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val basePath = getExternalFilesDir(null)
                val markdownFile = File(basePath, "ole/$fileName")
                if (markdownFile.exists()) {
                    val markdownContent = readMarkdownFile(markdownFile)
                    withContext(Dispatchers.Main) {
                        setMarkdownText(binding.markdownView, markdownContent)
                    }
                } else {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(
                            this@MarkdownViewerActivity,
                            getString(R.string.unable_to_load) + fileName,
                            Toast.LENGTH_LONG
                        ).show()
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    @Throws(IOException::class)
    private fun readMarkdownFile(file: File): String {
        return file.useLines { sequence ->
            sequence.joinToString("\n")
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/viewer/WebViewActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.viewer

import android.content.pm.ActivityInfo
import android.graphics.Bitmap
import android.os.Build
import android.os.Bundle
import android.text.TextUtils
import android.view.View
import android.webkit.CookieManager
import android.webkit.WebChromeClient
import android.webkit.WebResourceRequest
import android.webkit.WebResourceResponse
import android.webkit.WebSettings
import android.webkit.WebView
import android.webkit.WebViewClient
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.net.toUri
import java.io.File
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityWebViewBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils

class WebViewActivity : AppCompatActivity() {
    private lateinit var activityWebViewBinding: ActivityWebViewBinding
    private var fromDeepLink = false
    private lateinit var link: String

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        activityWebViewBinding = ActivityWebViewBinding.inflate(layoutInflater)
        setContentView(activityWebViewBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, activityWebViewBinding.root)
        val dataFromDeepLink = intent.dataString
        fromDeepLink = !TextUtils.isEmpty(dataFromDeepLink)
        val title: String? = intent.getStringExtra("title")
        link = intent.getStringExtra("link") ?: ""
        val resourceId = intent.getStringExtra("RESOURCE_ID")
        clearCookie()
        if (!TextUtils.isEmpty(title)) {
            activityWebViewBinding.contentWebView.webTitle.text = title
        }
        activityWebViewBinding.contentWebView.pBar.max = 100
        activityWebViewBinding.contentWebView.pBar.progress = 0

        setupWebView()
        setListeners()

        if (resourceId != null) {
            val directory = File(getExternalFilesDir(null), "ole/$resourceId")
            val indexFile = File(directory, "index.html")

            if (indexFile.exists()) {
                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
                activityWebViewBinding.contentWebView.wv.loadUrl("file://${indexFile.absolutePath}")
            }
        } else {
            activityWebViewBinding.contentWebView.wv.loadUrl(link)
        }

        activityWebViewBinding.contentWebView.finish.setOnClickListener { finish() }
        setWebClient()
    }

    private fun setupWebView() {
        activityWebViewBinding.contentWebView.wv.settings.apply {
            // Only enable JavaScript for local resources that need it
            val isLocalResource = intent.getStringExtra("RESOURCE_ID") != null
            javaScriptEnabled = isLocalResource
            javaScriptCanOpenWindowsAutomatically = false

            // File access settings - only allow for local resources
            allowFileAccess = isLocalResource
            allowContentAccess = false
            allowFileAccessFromFileURLs = false
            allowUniversalAccessFromFileURLs = false

            // Safe settings
            domStorageEnabled = true
            defaultTextEncodingName = "utf-8"

            // Security settings
            setSupportZoom(false)
            builtInZoomControls = false
            displayZoomControls = false

            // Disable geolocation
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN) {
                setGeolocationEnabled(false)
            }

            // Disable save password
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
                setSavePassword(false)
            }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                val nightModeFlags = resources.configuration.uiMode and android.content.res.Configuration.UI_MODE_NIGHT_MASK
                when (nightModeFlags) {
                    android.content.res.Configuration.UI_MODE_NIGHT_YES -> {
                        forceDark = WebSettings.FORCE_DARK_ON
                        activityWebViewBinding.contentWebView.webTitle.setTextColor(ContextCompat.getColor(this@WebViewActivity, R.color.md_white_1000))
                        activityWebViewBinding.contentWebView.webSource.setTextColor(ContextCompat.getColor(this@WebViewActivity, R.color.md_white_1000))
                        activityWebViewBinding.contentWebView.contentWebView.setBackgroundColor(ContextCompat.getColor(this@WebViewActivity, R.color.md_black_1000))
                    }

                    android.content.res.Configuration.UI_MODE_NIGHT_NO -> {
                        forceDark = WebSettings.FORCE_DARK_OFF
                        activityWebViewBinding.contentWebView.webTitle.setTextColor(ContextCompat.getColor(this@WebViewActivity, R.color.md_black_1000))
                        activityWebViewBinding.contentWebView.webSource.setTextColor(ContextCompat.getColor(this@WebViewActivity, R.color.md_black_1000))
                    }
                }
            }
        }
    }

    private fun setWebClient() {
        activityWebViewBinding.contentWebView.wv.webViewClient = object : WebViewClient() {
            override fun onPageStarted(view: WebView, url: String, favicon: Bitmap?) {
                super.onPageStarted(view, url, favicon)

                // Validate URL before loading
                if (!isUrlSafe(url)) {
                    view.stopLoading()
                    finish()
                    return
                }

                if (!url.startsWith("file://") && url.endsWith("/eng/")) {
                    finish()
                }
                if (url.startsWith("file://")) {
                    activityWebViewBinding.contentWebView.webSource.text = getString(R.string.local_resource)
                } else {
                    val i = url.toUri()
                    activityWebViewBinding.contentWebView.webSource.text = i.host
                }
            }

            override fun shouldOverrideUrlLoading(view: WebView?, request: WebResourceRequest?): Boolean {
                val url = request?.url?.toString() ?: return true

                // Use our comprehensive URL safety check
                return !isUrlSafe(url) // Block unsafe URLs, allow safe ones
            }

            override fun onPageFinished(view: WebView, url: String) {
                super.onPageFinished(view, url)

                val nightModeFlags = resources.configuration.uiMode and android.content.res.Configuration.UI_MODE_NIGHT_MASK
                if (nightModeFlags == android.content.res.Configuration.UI_MODE_NIGHT_YES) {
                    view.evaluateJavascript(
                        """
                            (function() {
                                document.documentElement.setAttribute('dark', 'true');
                                document.documentElement.style.backgroundColor = '#000';
                                document.documentElement.style.color = '#FFF';
                                const elements = document.querySelectorAll('*');
                                elements.forEach(el => {
                                    if (window.getComputedStyle(el).color === 'rgb(0, 0, 0)') {
                                        el.style.color = '#FFF';
                                    }
                                });
                            })();
                            """.trimIndent(),
                        null
                    )
                } else {
                    view.evaluateJavascript(
                        """
                            (function() {
                                document.documentElement.removeAttribute('dark');
                                document.documentElement.style.backgroundColor = '#FFF';
                                document.documentElement.style.color = '#000';
                                const elements = document.querySelectorAll('*');
                                elements.forEach(el => {
                                    if (window.getComputedStyle(el).color === 'rgb(255, 255, 255)') {
                                        el.style.color = '#000';
                                    }
                                });
                            })();
                            """.trimIndent(),
                        null
                    )
                }
            }

            override fun onReceivedError(view: WebView?, errorCode: Int, description: String?, failingUrl: String?) {
                super.onReceivedError(view, errorCode, description, failingUrl)
            }

            override fun shouldInterceptRequest(view: WebView, request: WebResourceRequest): WebResourceResponse? {
                return super.shouldInterceptRequest(view, request)
            }
        }
    }

    private fun clearCookie() {
        val cookieManager = CookieManager.getInstance()
        cookieManager.removeAllCookies(null)
        cookieManager.flush()
    }

    private fun isUrlSafe(url: String): Boolean {
        return try {
            val uri = url.toUri()
            when {
                // Allow HTTPS URLs
                uri.scheme == "https" -> true

                // Allow HTTP URLs only for trusted Planet servers
                uri.scheme == "http" -> isTrustedPlanetServer(uri.host)

                // Allow file URLs only for local resources and only from app's directory
                uri.scheme == "file" -> {
                    val resourceId = intent.getStringExtra("RESOURCE_ID")
                    if (resourceId != null) {
                        val appDir = getExternalFilesDir(null)?.absolutePath ?: ""
                        url.startsWith("file://$appDir")
                    } else {
                        false
                    }
                }
                // Block everything else
                else -> false
            }
        } catch (e: Exception) {
            false
        }
    }

    private fun isTrustedPlanetServer(host: String?): Boolean {
        if (host == null) return false

        val trustedUrls = listOfNotNull(
            BuildConfig.PLANET_LEARNING_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_GUATEMALA_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_SANPABLO_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_SANPABLO_CLONE_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_EARTH_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_SOMALIA_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_VI_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_XELA_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_URIUR_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_URIUR_CLONE_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_RUIRU_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_EMBAKASI_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_EMBAKASI_CLONE_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_CAMBRIDGE_URL.takeIf { it.isNotEmpty() }
        )

        return trustedUrls.any { url ->
            host == url || host.endsWith(".$url")
        }
    }

    private fun setListeners() {
        activityWebViewBinding.contentWebView.wv.webChromeClient = object : WebChromeClient() {
            override fun onProgressChanged(view: WebView, newProgress: Int) {
                activityWebViewBinding.contentWebView.pBar.progress = newProgress
                if (view.url?.startsWith("file://") == false && view.url?.endsWith("/eng/") == true) {
                    finish()
                }
                activityWebViewBinding.contentWebView.pBar.incrementProgressBy(newProgress)
                if (newProgress == 100 && activityWebViewBinding.contentWebView.pBar.isShown) {
                    activityWebViewBinding.contentWebView.pBar.visibility = View.GONE
                }
            }

            override fun onReceivedTitle(view: WebView, title: String) {
                val sanitizedTitle = title.take(100).filter { it.isLetterOrDigit() || it.isWhitespace() || it in ".,!?-_" }
                activityWebViewBinding.contentWebView.webTitle.text = sanitizedTitle
                super.onReceivedTitle(view, sanitizedTitle)
            }

            override fun onConsoleMessage(message: String?, lineNumber: Int, sourceID: String?) {
                if (BuildConfig.DEBUG) {
                    super.onConsoleMessage(message, lineNumber, sourceID)
                }
            }

            override fun onShowFileChooser(
                webView: WebView?,
                filePathCallback: android.webkit.ValueCallback<Array<android.net.Uri>>?,
                fileChooserParams: FileChooserParams?
            ): Boolean {
                return false
            }

            override fun onGeolocationPermissionsShowPrompt(
                origin: String?,
                callback: android.webkit.GeolocationPermissions.Callback?
            ) {
                callback?.invoke(origin, false, false)
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.viewer


import android.content.pm.ActivityInfo
import android.graphics.Bitmap
import android.os.Build
import android.os.Bundle
import android.text.TextUtils
import android.view.View
import android.webkit.CookieManager
import android.webkit.WebChromeClient
import android.webkit.WebResourceRequest
import android.webkit.WebResourceResponse
import android.webkit.WebSettings
import android.webkit.WebView
import android.webkit.WebViewClient
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.core.net.toUri
import java.io.File
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityWebViewBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils

class WebViewActivity : AppCompatActivity() {
    private lateinit var activityWebViewBinding: ActivityWebViewBinding
    private var fromDeepLink = false
    private lateinit var link: String

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        activityWebViewBinding = ActivityWebViewBinding.inflate(layoutInflater)
        setContentView(activityWebViewBinding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, activityWebViewBinding.root)
        val dataFromDeepLink = intent.dataString
        fromDeepLink = !TextUtils.isEmpty(dataFromDeepLink)
        val title: String? = intent.getStringExtra("title")
        link = intent.getStringExtra("link") ?: ""
        val resourceId = intent.getStringExtra("RESOURCE_ID")
        clearCookie()
        if (!TextUtils.isEmpty(title)) {
            activityWebViewBinding.contentWebView.webTitle.text = title
        }
        activityWebViewBinding.contentWebView.pBar.max = 100
        activityWebViewBinding.contentWebView.pBar.progress = 0

        setupWebView()
        setListeners()

        if (resourceId != null) {
            val directory = File(getExternalFilesDir(null), "ole/$resourceId")
            val indexFile = File(directory, "index.html")

            if (indexFile.exists()) {
                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
                activityWebViewBinding.contentWebView.wv.loadUrl("file://${indexFile.absolutePath}")
            }
        } else {
            activityWebViewBinding.contentWebView.wv.loadUrl(link)
        }

        activityWebViewBinding.contentWebView.finish.setOnClickListener { finish() }
        setWebClient()
    }

    private fun setupWebView() {
        activityWebViewBinding.contentWebView.wv.settings.apply {
            // Only enable JavaScript for local resources that need it
            val isLocalResource = intent.getStringExtra("RESOURCE_ID") != null
            javaScriptEnabled = isLocalResource
            javaScriptCanOpenWindowsAutomatically = false

            // File access settings - only allow for local resources
            allowFileAccess = isLocalResource
            allowContentAccess = false
            allowFileAccessFromFileURLs = false
            allowUniversalAccessFromFileURLs = false

            // Safe settings
            domStorageEnabled = true
            defaultTextEncodingName = "utf-8"

            // Security settings
            setSupportZoom(false)
            builtInZoomControls = false
            displayZoomControls = false

            // Disable geolocation
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN) {
                setGeolocationEnabled(false)
            }

            // Disable save password
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
                setSavePassword(false)
            }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                val nightModeFlags = resources.configuration.uiMode and android.content.res.Configuration.UI_MODE_NIGHT_MASK
                when (nightModeFlags) {
                    android.content.res.Configuration.UI_MODE_NIGHT_YES -> {
                        forceDark = WebSettings.FORCE_DARK_ON
                        activityWebViewBinding.contentWebView.webTitle.setTextColor(ContextCompat.getColor(this@WebViewActivity, R.color.md_white_1000))
                        activityWebViewBinding.contentWebView.webSource.setTextColor(ContextCompat.getColor(this@WebViewActivity, R.color.md_white_1000))
                        activityWebViewBinding.contentWebView.contentWebView.setBackgroundColor(ContextCompat.getColor(this@WebViewActivity, R.color.md_black_1000))
                    }

                    android.content.res.Configuration.UI_MODE_NIGHT_NO -> {
                        forceDark = WebSettings.FORCE_DARK_OFF
                        activityWebViewBinding.contentWebView.webTitle.setTextColor(ContextCompat.getColor(this@WebViewActivity, R.color.md_black_1000))
                        activityWebViewBinding.contentWebView.webSource.setTextColor(ContextCompat.getColor(this@WebViewActivity, R.color.md_black_1000))
                    }
                }
            }
        }
    }

    private fun setWebClient() {
        activityWebViewBinding.contentWebView.wv.webViewClient = object : WebViewClient() {
            override fun onPageStarted(view: WebView, url: String, favicon: Bitmap?) {
                super.onPageStarted(view, url, favicon)

                // Validate URL before loading
                if (!isUrlSafe(url)) {
                    view.stopLoading()
                    finish()
                    return
                }

                if (!url.startsWith("file://") && url.endsWith("/eng/")) {
                    finish()
                }
                if (url.startsWith("file://")) {
                    activityWebViewBinding.contentWebView.webSource.text = getString(R.string.local_resource)
                } else {
                    val i = url.toUri()
                    activityWebViewBinding.contentWebView.webSource.text = i.host
                }
            }

            override fun shouldOverrideUrlLoading(view: WebView?, request: WebResourceRequest?): Boolean {
                val url = request?.url?.toString() ?: return true

                // Use our comprehensive URL safety check
                return !isUrlSafe(url) // Block unsafe URLs, allow safe ones
            }

            override fun onPageFinished(view: WebView, url: String) {
                super.onPageFinished(view, url)

                val nightModeFlags = resources.configuration.uiMode and android.content.res.Configuration.UI_MODE_NIGHT_MASK
                if (nightModeFlags == android.content.res.Configuration.UI_MODE_NIGHT_YES) {
                    view.evaluateJavascript(
                        """
                            (function() {
                                document.documentElement.setAttribute('dark', 'true');
                                document.documentElement.style.backgroundColor = '#000';
                                document.documentElement.style.color = '#FFF';
                                const elements = document.querySelectorAll('*');
                                elements.forEach(el => {
                                    if (window.getComputedStyle(el).color === 'rgb(0, 0, 0)') {
                                        el.style.color = '#FFF';
                                    }
                                });
                            })();
                            """.trimIndent(),
                        null
                    )
                } else {
                    view.evaluateJavascript(
                        """
                            (function() {
                                document.documentElement.removeAttribute('dark');
                                document.documentElement.style.backgroundColor = '#FFF';
                                document.documentElement.style.color = '#000';
                                const elements = document.querySelectorAll('*');
                                elements.forEach(el => {
                                    if (window.getComputedStyle(el).color === 'rgb(255, 255, 255)') {
                                        el.style.color = '#000';
                                    }
                                });
                            })();
                            """.trimIndent(),
                        null
                    )
                }
            }

            override fun onReceivedError(view: WebView?, errorCode: Int, description: String?, failingUrl: String?) {
                super.onReceivedError(view, errorCode, description, failingUrl)
            }

            override fun shouldInterceptRequest(view: WebView, request: WebResourceRequest): WebResourceResponse? {
                return super.shouldInterceptRequest(view, request)
            }
        }
    }

    private fun clearCookie() {
        val cookieManager = CookieManager.getInstance()
        cookieManager.removeAllCookies(null)
        cookieManager.flush()
    }

    private fun isUrlSafe(url: String): Boolean {
        return try {
            val uri = url.toUri()
            when {
                // Allow HTTPS URLs
                uri.scheme == "https" -> true

                // Allow HTTP URLs only for trusted Planet servers
                uri.scheme == "http" -> isTrustedPlanetServer(uri.host)

                // Allow file URLs only for local resources and only from app's directory
                uri.scheme == "file" -> {
                    val resourceId = intent.getStringExtra("RESOURCE_ID")
                    if (resourceId != null) {
                        val appDir = getExternalFilesDir(null)?.absolutePath ?: ""
                        url.startsWith("file://$appDir")
                    } else {
                        false
                    }
                }
                // Block everything else
                else -> false
            }
        } catch (e: Exception) {
            false
        }
    }

    private fun isTrustedPlanetServer(host: String?): Boolean {
        if (host == null) return false

        val trustedUrls = listOfNotNull(
            BuildConfig.PLANET_LEARNING_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_GUATEMALA_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_SANPABLO_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_SANPABLO_CLONE_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_EARTH_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_SOMALIA_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_VI_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_XELA_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_URIUR_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_URIUR_CLONE_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_RUIRU_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_EMBAKASI_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_EMBAKASI_CLONE_URL.takeIf { it.isNotEmpty() },
            BuildConfig.PLANET_CAMBRIDGE_URL.takeIf { it.isNotEmpty() }
        )

        return trustedUrls.any { url ->
            host == url || host.endsWith(".$url")
        }
    }

    private fun setListeners() {
        activityWebViewBinding.contentWebView.wv.webChromeClient = object : WebChromeClient() {
            override fun onProgressChanged(view: WebView, newProgress: Int) {
                activityWebViewBinding.contentWebView.pBar.progress = newProgress
                if (view.url?.startsWith("file://") == false && view.url?.endsWith("/eng/") == true) {
                    finish()
                }
                activityWebViewBinding.contentWebView.pBar.incrementProgressBy(newProgress)
                if (newProgress == 100 && activityWebViewBinding.contentWebView.pBar.isShown) {
                    activityWebViewBinding.contentWebView.pBar.visibility = View.GONE
                }
            }

            override fun onReceivedTitle(view: WebView, title: String) {
                val sanitizedTitle = title.take(100).filter { it.isLetterOrDigit() || it.isWhitespace() || it in ".,!?-_" }
                activityWebViewBinding.contentWebView.webTitle.text = sanitizedTitle
                super.onReceivedTitle(view, sanitizedTitle)
            }

            override fun onConsoleMessage(message: String?, lineNumber: Int, sourceID: String?) {
                if (BuildConfig.DEBUG) {
                    super.onConsoleMessage(message, lineNumber, sourceID)
                }
            }

            override fun onShowFileChooser(
                webView: WebView?,
                filePathCallback: android.webkit.ValueCallback<Array<android.net.Uri>>?,
                fileChooserParams: FileChooserParams?
            ): Boolean {
                return false
            }

            override fun onGeolocationPermissionsShowPrompt(
                origin: String?,
                callback: android.webkit.GeolocationPermissions.Callback?
            ) {
                callback?.invoke(origin, false, false)
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/viewer/TextFileViewerActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.viewer

import android.os.Bundle
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import java.io.File
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityTextfileViewerBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils

class TextFileViewerActivity : AppCompatActivity() {
    private lateinit var binding: ActivityTextfileViewerBinding
    private var fileName: String? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityTextfileViewerBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        renderTextFile()
    }

    private fun renderTextFile() {
        val textFileOpenIntent = intent
        fileName = textFileOpenIntent.getStringExtra("TOUCHED_FILE")
        if (!fileName.isNullOrEmpty()) {
            binding.textFileName.text = FileUtils.nameWithoutExtension(fileName)
            binding.textFileName.visibility = View.VISIBLE
        } else {
            binding.textFileName.text = getString(R.string.message_placeholder, "No file selected")
            binding.textFileName.visibility = View.VISIBLE
        }
        renderTextFileThread()
    }
    private fun renderTextFileThread() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val basePath = getExternalFilesDir(null)
                val file = File(basePath, "ole/$fileName")
                val text = file.readText()
                withContext(Dispatchers.Main) {
                    binding.textFileContent.text = text
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.viewer


import android.os.Bundle
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import java.io.File
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityTextfileViewerBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils

class TextFileViewerActivity : AppCompatActivity() {
    private lateinit var binding: ActivityTextfileViewerBinding
    private var fileName: String? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityTextfileViewerBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        renderTextFile()
    }

    private fun renderTextFile() {
        val textFileOpenIntent = intent
        fileName = textFileOpenIntent.getStringExtra("TOUCHED_FILE")
        if (!fileName.isNullOrEmpty()) {
            binding.textFileName.text = FileUtils.nameWithoutExtension(fileName)
            binding.textFileName.visibility = View.VISIBLE
        } else {
            binding.textFileName.text = getString(R.string.message_placeholder, "No file selected")
            binding.textFileName.visibility = View.VISIBLE
        }
        renderTextFileThread()
    }
    private fun renderTextFileThread() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val basePath = getExternalFilesDir(null)
                val file = File(basePath, "ole/$fileName")
                val text = file.readText()
                withContext(Dispatchers.Main) {
                    binding.textFileContent.text = text
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/viewer/ImageViewerActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.viewer

import android.os.Bundle
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.bumptech.glide.request.RequestOptions
import java.io.File
import java.util.regex.Pattern
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityImageViewerBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils

class ImageViewerActivity : AppCompatActivity() {
    private lateinit var binding: ActivityImageViewerBinding
    var fileName: String? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityImageViewerBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        renderImageFile()
    }

    private fun renderImageFile() {
        val isFullPath = intent.getBooleanExtra("isFullPath", false)
        val imageOpenIntent = intent
        fileName = imageOpenIntent.getStringExtra("TOUCHED_FILE")
        if (!fileName.isNullOrEmpty()) {
            binding.imageFileName.text = FileUtils.nameWithoutExtension(fileName)
            binding.imageFileName.visibility = View.VISIBLE
        } else {
            binding.imageFileName.text = getString(R.string.message_placeholder, "No file selected")
            binding.imageFileName.visibility = View.VISIBLE
        }

        if (fileName?.matches(".*[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}.*".toRegex()) == true) {
            displayCapturedImage()
        } else {
            try {
                val imageFile: File? = if (isFullPath) {
                    fileName?.let { File(it) }
                } else {
                    val basePath = getExternalFilesDir(null)
                    File(basePath, "ole/$fileName")
                }
                Glide.with(applicationContext).load(imageFile).into(binding.imageViewer)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    private fun displayCapturedImage() {
        val uuidPattern = Pattern.compile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/")
        val matcher = fileName?.let { uuidPattern.matcher(it) }
        if (matcher != null) {
            if (matcher.find()) {
                fileName = fileName?.substring(matcher.group().length)
            }
        }
        val requestOptions = RequestOptions()
            .diskCacheStrategy(DiskCacheStrategy.NONE)
            .skipMemoryCache(true)
        Glide.with(this)
            .load(fileName)
            .apply(requestOptions)
            .into(binding.imageViewer)
    }
}
=======
package org.ole.planet.myplanet.ui.viewer


import android.os.Bundle
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.bumptech.glide.request.RequestOptions
import java.io.File
import java.util.regex.Pattern
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityImageViewerBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils

class ImageViewerActivity : AppCompatActivity() {
    private lateinit var binding: ActivityImageViewerBinding
    var fileName: String? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityImageViewerBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        renderImageFile()
    }

    private fun renderImageFile() {
        val isFullPath = intent.getBooleanExtra("isFullPath", false)
        val imageOpenIntent = intent
        fileName = imageOpenIntent.getStringExtra("TOUCHED_FILE")
        if (!fileName.isNullOrEmpty()) {
            binding.imageFileName.text = FileUtils.nameWithoutExtension(fileName)
            binding.imageFileName.visibility = View.VISIBLE
        } else {
            binding.imageFileName.text = getString(R.string.message_placeholder, "No file selected")
            binding.imageFileName.visibility = View.VISIBLE
        }

        if (fileName?.matches(".*[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}.*".toRegex()) == true) {
            displayCapturedImage()
        } else {
            try {
                val imageFile: File? = if (isFullPath) {
                    fileName?.let { File(it) }
                } else {
                    val basePath = getExternalFilesDir(null)
                    File(basePath, "ole/$fileName")
                }
                Glide.with(applicationContext).load(imageFile).into(binding.imageViewer)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    private fun displayCapturedImage() {
        val uuidPattern = Pattern.compile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/")
        val matcher = fileName?.let { uuidPattern.matcher(it) }
        if (matcher != null) {
            if (matcher.find()) {
                fileName = fileName?.substring(matcher.group().length)
            }
        }
        val requestOptions = RequestOptions()
            .diskCacheStrategy(DiskCacheStrategy.NONE)
            .skipMemoryCache(true)
        Glide.with(this)
            .load(fileName)
            .apply(requestOptions)
            .into(binding.imageViewer)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/viewer/VideoPlayerActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.viewer

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.media.AudioManager
import android.os.Bundle
import androidx.activity.OnBackPressedCallback
import androidx.annotation.OptIn
import androidx.appcompat.app.AppCompatActivity
import androidx.core.net.toUri
import androidx.media3.common.AudioAttributes
import androidx.media3.common.C
import androidx.media3.common.MediaItem
import androidx.media3.common.util.UnstableApi
import androidx.media3.datasource.DataSource
import androidx.media3.datasource.DataSpec
import androidx.media3.datasource.DefaultHttpDataSource
import androidx.media3.datasource.FileDataSource
import androidx.media3.exoplayer.DefaultLoadControl
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.exoplayer.source.MediaSource
import androidx.media3.exoplayer.source.ProgressiveMediaSource
import androidx.media3.exoplayer.trackselection.DefaultTrackSelector
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityExoPlayerVideoBinding
import org.ole.planet.myplanet.datamanager.auth.AuthSessionUpdater
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class VideoPlayerActivity : AppCompatActivity(), AuthSessionUpdater.AuthCallback {
    private lateinit var binding: ActivityExoPlayerVideoBinding
    private var exoPlayer: ExoPlayer? = null
    private var auth: String = ""
    private var videoURL: String = ""
    private var videoType: String? = null
    private var playWhenReady = true
    private var currentPosition = 0L
    private var isActivityVisible = false
    @Inject
    lateinit var authSessionUpdaterFactory: AuthSessionUpdater.Factory
    private var authSessionUpdater: AuthSessionUpdater? = null

    private val audioBecomingNoisyReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            if (intent?.action == AudioManager.ACTION_AUDIO_BECOMING_NOISY) {
                exoPlayer?.pause()
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityExoPlayerVideoBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)

        val extras = intent.extras
        videoType = extras?.getString("videoType")
        videoURL = extras?.getString("videoURL") ?: ""
        auth = extras?.getString("Auth") ?: ""

        registerAudioNoisyReceiver()

        when (videoType) {
            "offline" -> prepareExoPlayerFromFileUri(videoURL)
            "online" -> {
                authSessionUpdater = authSessionUpdaterFactory.create(this)
            }
        }

        val callback = object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                releasePlayer()
                finish()
            }
        }
        onBackPressedDispatcher.addCallback(this, callback)
    }

    override fun setAuthSession(responseHeader: Map<String, List<String>>) {
        val headerAuth = responseHeader["Set-Cookie"]?.get(0)?.split(";") ?: return
        auth = headerAuth[0]
        runOnUiThread {
            streamVideoFromUrl(videoURL, auth)
            if (videoType == "online" && !FileUtils.checkFileExist(this, videoURL)) {
                try {
                    DownloadUtils.openDownloadService(this, arrayListOf(videoURL), false)
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }
    }

    override fun onError(s: String) {
        runOnUiThread { Utilities.toast(this, getString(R.string.connection_failed_reason) + s) }
    }

    override fun onStart() {
        super.onStart()
        isActivityVisible = true
    }

    override fun onResume() {
        super.onResume()
        isActivityVisible = true
        if (exoPlayer == null) {
            when {
                videoURL.startsWith("http") -> {
                    streamVideoFromUrl(videoURL, auth)
                    if (videoType == "online" && !FileUtils.checkFileExist(this, videoURL)) {
                        try {
                            DownloadUtils.openDownloadService(this, arrayListOf(videoURL), false)
                        } catch (e: Exception) {
                            e.printStackTrace()
                        }
                    }
                }
                else -> prepareExoPlayerFromFileUri(videoURL)
            }
        }
    }

    override fun onPause() {
        super.onPause()
        isActivityVisible = false
        pauseAndReleasePlayer()
    }

    override fun onStop() {
        super.onStop()
        isActivityVisible = false
        pauseAndReleasePlayer()
    }

    private fun pauseAndReleasePlayer() {
        exoPlayer?.pause()
        releasePlayer()
    }

    private fun releasePlayer() {
        exoPlayer?.let { player ->
            try {
                playWhenReady = player.playWhenReady
                currentPosition = player.currentPosition
                player.stop()
                player.clearMediaItems()
                player.release()
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                exoPlayer = null
            }
        }
    }

    @OptIn(UnstableApi::class)
    private fun streamVideoFromUrl(videoUrl: String, auth: String) {
        if (!isActivityVisible) return

        val trackSelectorDef = DefaultTrackSelector(this)

        exoPlayer = ExoPlayer.Builder(this)
            .setTrackSelector(trackSelectorDef)
            .setAudioAttributes(
                AudioAttributes.Builder()
                    .setUsage(C.USAGE_MEDIA)
                    .setContentType(C.AUDIO_CONTENT_TYPE_MOVIE)
                    .build(),
                true
            )
            .build()

        val videoUri = videoUrl.toUri()
        val requestProperties = hashMapOf("Cookie" to auth)
        val defaultHttpDataSourceFactory = DefaultHttpDataSource.Factory()
            .setUserAgent("ExoPlayer")
            .setAllowCrossProtocolRedirects(true)
            .setDefaultRequestProperties(requestProperties)

        val mediaSource: MediaSource = ProgressiveMediaSource.Factory(defaultHttpDataSourceFactory)
            .createMediaSource(MediaItem.fromUri(videoUri))

        binding.exoPlayerSimple.player = exoPlayer
        exoPlayer?.apply {
            setMediaSource(mediaSource)
            seekTo(currentPosition)
            playWhenReady = this@VideoPlayerActivity.playWhenReady
            prepare()
        }
    }

    @OptIn(UnstableApi::class)
    private fun prepareExoPlayerFromFileUri(uriString: String) {
        if (!isActivityVisible) return

        val uri = uriString.toUri()
        val trackSelectorDef = DefaultTrackSelector(this)

        exoPlayer = ExoPlayer.Builder(this)
            .setTrackSelector(trackSelectorDef)
            .setLoadControl(DefaultLoadControl())
            .setAudioAttributes(
                AudioAttributes.Builder()
                    .setUsage(C.USAGE_MEDIA)
                    .setContentType(C.AUDIO_CONTENT_TYPE_MOVIE)
                    .build(),
                true
            )
            .build()

        val dataSpec = DataSpec(uri)
        val fileDataSource = FileDataSource()
        try {
            fileDataSource.open(dataSpec)
            val factory = DataSource.Factory { fileDataSource }

            fileDataSource.uri?.let { uri ->
                val audioSource = ProgressiveMediaSource.Factory(factory)
                    .createMediaSource(MediaItem.fromUri(uri))

                binding.exoPlayerSimple.player = exoPlayer
                exoPlayer?.apply {
                    setMediaSource(audioSource)
                    seekTo(currentPosition)
                    playWhenReady = this@VideoPlayerActivity.playWhenReady
                    prepare()
                }
            }
        } catch (e: FileDataSource.FileDataSourceException) {
            e.printStackTrace()
        }
    }

    private fun registerAudioNoisyReceiver() {
        val filter = IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY)
        registerReceiver(audioBecomingNoisyReceiver, filter)
    }

    override fun onDestroy() {
        authSessionUpdater?.stop()
        try {
            unregisterReceiver(audioBecomingNoisyReceiver)
        } catch (e: IllegalArgumentException) {
            e.printStackTrace()
        }
        super.onDestroy()
    }
}
=======
package org.ole.planet.myplanet.ui.viewer


import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.media.AudioManager
import android.os.Bundle
import androidx.activity.OnBackPressedCallback
import androidx.annotation.OptIn
import androidx.appcompat.app.AppCompatActivity
import androidx.core.net.toUri
import androidx.media3.common.AudioAttributes
import androidx.media3.common.C
import androidx.media3.common.MediaItem
import androidx.media3.common.util.UnstableApi
import androidx.media3.datasource.DataSource
import androidx.media3.datasource.DataSpec
import androidx.media3.datasource.DefaultHttpDataSource
import androidx.media3.datasource.FileDataSource
import androidx.media3.exoplayer.DefaultLoadControl
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.exoplayer.source.MediaSource
import androidx.media3.exoplayer.source.ProgressiveMediaSource
import androidx.media3.exoplayer.trackselection.DefaultTrackSelector
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityExoPlayerVideoBinding
import org.ole.planet.myplanet.datamanager.auth.AuthSessionUpdater
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
class VideoPlayerActivity : AppCompatActivity(), AuthSessionUpdater.AuthCallback {
    private lateinit var binding: ActivityExoPlayerVideoBinding
    private var exoPlayer: ExoPlayer? = null
    private var auth: String = ""
    private var videoURL: String = ""
    private var videoType: String? = null
    private var playWhenReady = true
    private var currentPosition = 0L
    private var isActivityVisible = false
    @Inject
    lateinit var authSessionUpdaterFactory: AuthSessionUpdater.Factory
    private var authSessionUpdater: AuthSessionUpdater? = null

    private val audioBecomingNoisyReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            if (intent?.action == AudioManager.ACTION_AUDIO_BECOMING_NOISY) {
                exoPlayer?.pause()
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityExoPlayerVideoBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)

        val extras = intent.extras
        videoType = extras?.getString("videoType")
        videoURL = extras?.getString("videoURL") ?: ""
        auth = extras?.getString("Auth") ?: ""

        registerAudioNoisyReceiver()

        when (videoType) {
            "offline" -> prepareExoPlayerFromFileUri(videoURL)
            "online" -> {
                authSessionUpdater = authSessionUpdaterFactory.create(this)
            }
        }

        val callback = object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                releasePlayer()
                finish()
            }
        }
        onBackPressedDispatcher.addCallback(this, callback)
    }

    override fun setAuthSession(responseHeader: Map<String, List<String>>) {
        val headerAuth = responseHeader["Set-Cookie"]?.get(0)?.split(";") ?: return
        auth = headerAuth[0]
        runOnUiThread {
            streamVideoFromUrl(videoURL, auth)
            if (videoType == "online" && !FileUtils.checkFileExist(this, videoURL)) {
                try {
                    DownloadUtils.openDownloadService(this, arrayListOf(videoURL), false)
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }
    }

    override fun onError(s: String) {
        runOnUiThread { Utilities.toast(this, getString(R.string.connection_failed_reason) + s) }
    }

    override fun onStart() {
        super.onStart()
        isActivityVisible = true
    }

    override fun onResume() {
        super.onResume()
        isActivityVisible = true
        if (exoPlayer == null) {
            when {
                videoURL.startsWith("http") -> {
                    streamVideoFromUrl(videoURL, auth)
                    if (videoType == "online" && !FileUtils.checkFileExist(this, videoURL)) {
                        try {
                            DownloadUtils.openDownloadService(this, arrayListOf(videoURL), false)
                        } catch (e: Exception) {
                            e.printStackTrace()
                        }
                    }
                }
                else -> prepareExoPlayerFromFileUri(videoURL)
            }
        }
    }

    override fun onPause() {
        super.onPause()
        isActivityVisible = false
        pauseAndReleasePlayer()
    }

    override fun onStop() {
        super.onStop()
        isActivityVisible = false
        pauseAndReleasePlayer()
    }

    private fun pauseAndReleasePlayer() {
        exoPlayer?.pause()
        releasePlayer()
    }

    private fun releasePlayer() {
        exoPlayer?.let { player ->
            try {
                playWhenReady = player.playWhenReady
                currentPosition = player.currentPosition
                player.stop()
                player.clearMediaItems()
                player.release()
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                exoPlayer = null
            }
        }
    }

    @OptIn(UnstableApi::class)
    private fun streamVideoFromUrl(videoUrl: String, auth: String) {
        if (!isActivityVisible) return

        val trackSelectorDef = DefaultTrackSelector(this)

        exoPlayer = ExoPlayer.Builder(this)
            .setTrackSelector(trackSelectorDef)
            .setAudioAttributes(
                AudioAttributes.Builder()
                    .setUsage(C.USAGE_MEDIA)
                    .setContentType(C.AUDIO_CONTENT_TYPE_MOVIE)
                    .build(),
                true
            )
            .build()

        val videoUri = videoUrl.toUri()
        val requestProperties = hashMapOf("Cookie" to auth)
        val defaultHttpDataSourceFactory = DefaultHttpDataSource.Factory()
            .setUserAgent("ExoPlayer")
            .setAllowCrossProtocolRedirects(true)
            .setDefaultRequestProperties(requestProperties)

        val mediaSource: MediaSource = ProgressiveMediaSource.Factory(defaultHttpDataSourceFactory)
            .createMediaSource(MediaItem.fromUri(videoUri))

        binding.exoPlayerSimple.player = exoPlayer
        exoPlayer?.apply {
            setMediaSource(mediaSource)
            seekTo(currentPosition)
            playWhenReady = this@VideoPlayerActivity.playWhenReady
            prepare()
        }
    }

    @OptIn(UnstableApi::class)
    private fun prepareExoPlayerFromFileUri(uriString: String) {
        if (!isActivityVisible) return

        val uri = uriString.toUri()
        val trackSelectorDef = DefaultTrackSelector(this)

        exoPlayer = ExoPlayer.Builder(this)
            .setTrackSelector(trackSelectorDef)
            .setLoadControl(DefaultLoadControl())
            .setAudioAttributes(
                AudioAttributes.Builder()
                    .setUsage(C.USAGE_MEDIA)
                    .setContentType(C.AUDIO_CONTENT_TYPE_MOVIE)
                    .build(),
                true
            )
            .build()

        val dataSpec = DataSpec(uri)
        val fileDataSource = FileDataSource()
        try {
            fileDataSource.open(dataSpec)
            val factory = DataSource.Factory { fileDataSource }

            fileDataSource.uri?.let { uri ->
                val audioSource = ProgressiveMediaSource.Factory(factory)
                    .createMediaSource(MediaItem.fromUri(uri))

                binding.exoPlayerSimple.player = exoPlayer
                exoPlayer?.apply {
                    setMediaSource(audioSource)
                    seekTo(currentPosition)
                    playWhenReady = this@VideoPlayerActivity.playWhenReady
                    prepare()
                }
            }
        } catch (e: FileDataSource.FileDataSourceException) {
            e.printStackTrace()
        }
    }

    private fun registerAudioNoisyReceiver() {
        val filter = IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY)
        registerReceiver(audioBecomingNoisyReceiver, filter)
    }

    override fun onDestroy() {
        authSessionUpdater?.stop()
        try {
            unregisterReceiver(audioBecomingNoisyReceiver)
        } catch (e: IllegalArgumentException) {
            e.printStackTrace()
        }
        super.onDestroy()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/viewer/AudioPlayerActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.viewer

import android.content.res.Configuration
import android.os.Bundle
import android.view.MenuItem
import android.view.View
import android.widget.FrameLayout
import android.widget.ImageButton
import android.widget.ImageView
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.media3.common.MediaItem
import androidx.media3.common.PlaybackException
import androidx.media3.common.Player
import androidx.media3.common.util.UnstableApi
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.DefaultTimeBar
import com.bumptech.glide.Glide
import java.io.File
import java.util.regex.Pattern
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityAudioPlayerBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.Utilities

class AudioPlayerActivity : AppCompatActivity() {

    private lateinit var binding: ActivityAudioPlayerBinding
    private var exoPlayer: ExoPlayer? = null
    private var filePath: String? = null
    private var isFullPath = false
    private lateinit var playButton: ImageButton
    private lateinit var pauseButton: ImageButton


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityAudioPlayerBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)

        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        filePath = intent.getStringExtra("TOUCHED_FILE")
        isFullPath = intent.getBooleanExtra("isFullPath", false)

        val extractedFileName = FileUtils.nameWithoutExtension(filePath).toString()
        val resourceTitle = intent.getStringExtra("RESOURCE_TITLE") ?: "Unknown Artist"

        supportActionBar?.title = "Audio Player"
        supportActionBar?.subtitle = extractedFileName

        binding.trackTitle.text = extractedFileName
        binding.artistName.text = resourceTitle
        playButton = binding.playerView.findViewById(R.id.exo_play)
        pauseButton = binding.playerView.findViewById(R.id.exo_pause)

        val overlay = binding.playerView.findViewById<FrameLayout>(R.id.exo_overlay)


        val blurredImageView = ImageView(this).apply {
            layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.MATCH_PARENT
            )
            scaleType = ImageView.ScaleType.CENTER_CROP
        }

        Glide.with(this)
            .load(getThemeBackground()) // or from URL or filePath
            .into(blurredImageView)

        overlay.addView(blurredImageView, 0)
        val controller = binding.playerView.findViewById<View>(R.id.exo_controller)
        controller?.setBackgroundColor(android.graphics.Color.TRANSPARENT)


        initializeExoPlayer()

        setupPlayPauseButtons()
    }

    @androidx.annotation.OptIn(UnstableApi::class)
    private fun initializeExoPlayer() {
        val fullPath = resolveFullPath(filePath)

        try {
            exoPlayer = ExoPlayer.Builder(this).build().also { player ->
                binding.playerView.player = player
                player.setMediaItem(MediaItem.fromUri(fullPath))
                player.prepare()
                player.playWhenReady = true

                val controller = binding.playerView.findViewById<View>(R.id.exo_controller)
                controller?.setBackgroundColor(android.graphics.Color.TRANSPARENT)

                val timeBar = binding.playerView.findViewById<DefaultTimeBar>(
                    androidx.media3.ui.R.id.exo_progress
                )
                timeBar?.apply {
                    setPlayedColor(ContextCompat.getColor(this@AudioPlayerActivity, R.color.daynight_textColor))
                    setScrubberColor(ContextCompat.getColor(this@AudioPlayerActivity, R.color.daynight_textColor))
                    setBufferedColor(ContextCompat.getColor(this@AudioPlayerActivity, R.color.hint_color))
                    setUnplayedColor(ContextCompat.getColor(this@AudioPlayerActivity, R.color.disable_color))
                }

                player.addListener(object : Player.Listener {
                    override fun onPlayerError(error: PlaybackException) {
                        Utilities.toast(this@AudioPlayerActivity, "Unable to play audio.")
                    }

                    override fun onPlaybackStateChanged(playbackState: Int) {
                        if (playbackState == Player.STATE_ENDED) {
                            player.seekTo(0)
                        }
                    }
                })
            }
        } catch (e: Exception) {
            Utilities.toast(this, "Unable to play audio.")
        }
    }

    private fun resolveFullPath(originalPath: String?): String {
        return if (isFullPath) {
            originalPath ?: ""
        } else {
            val processedPath = originalPath?.let {
                val uuidPattern = Pattern.compile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/")
                val matcher = uuidPattern.matcher(it)
                if (matcher.find()) it.substring(matcher.end()) else it
            }

            File(getExternalFilesDir(null), "ole/$processedPath").absolutePath
        }
    }

    private fun getThemeBackground(): Int {
        val isDarkMode = resources.configuration.uiMode and
                Configuration.UI_MODE_NIGHT_MASK == Configuration.UI_MODE_NIGHT_YES
        return if (isDarkMode) R.drawable.bg_player_dark else R.drawable.bg_player_white
    }

    private fun setupPlayPauseButtons() {
        playButton.setOnClickListener {
            playAudio()
        }

        pauseButton.setOnClickListener {
            pauseAudio()
        }
    }

    private fun playAudio() {
        exoPlayer?.play()
        playButton.visibility = View.GONE
        pauseButton.visibility = View.VISIBLE
    }

    private fun pauseAudio() {
        exoPlayer?.pause()
        pauseButton.visibility = View.GONE
        playButton.visibility = View.VISIBLE
    }



    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == android.R.id.home) {
            finish()
            return true
        }
        return super.onOptionsItemSelected(item)
    }


    override fun onPause() {
        super.onPause()
        pauseAudio()
    }

    override fun onDestroy() {
        binding.playerView.player = null
        exoPlayer?.release()
        exoPlayer = null
        super.onDestroy()
    }
}
=======
package org.ole.planet.myplanet.ui.viewer


import android.content.res.Configuration
import android.os.Bundle
import android.view.MenuItem
import android.view.View
import android.widget.FrameLayout
import android.widget.ImageButton
import android.widget.ImageView
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.media3.common.MediaItem
import androidx.media3.common.PlaybackException
import androidx.media3.common.Player
import androidx.media3.common.util.UnstableApi
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.DefaultTimeBar
import com.bumptech.glide.Glide
import java.io.File
import java.util.regex.Pattern
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ActivityAudioPlayerBinding
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.Utilities

class AudioPlayerActivity : AppCompatActivity() {

    private lateinit var binding: ActivityAudioPlayerBinding
    private var exoPlayer: ExoPlayer? = null
    private var filePath: String? = null
    private var isFullPath = false
    private lateinit var playButton: ImageButton
    private lateinit var pauseButton: ImageButton


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityAudioPlayerBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)

        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        filePath = intent.getStringExtra("TOUCHED_FILE")
        isFullPath = intent.getBooleanExtra("isFullPath", false)

        val extractedFileName = FileUtils.nameWithoutExtension(filePath).toString()
        val resourceTitle = intent.getStringExtra("RESOURCE_TITLE") ?: "Unknown Artist"

        supportActionBar?.title = "Audio Player"
        supportActionBar?.subtitle = extractedFileName

        binding.trackTitle.text = extractedFileName
        binding.artistName.text = resourceTitle
        playButton = binding.playerView.findViewById(R.id.exo_play)
        pauseButton = binding.playerView.findViewById(R.id.exo_pause)

        val overlay = binding.playerView.findViewById<FrameLayout>(R.id.exo_overlay)


        val blurredImageView = ImageView(this).apply {
            layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.MATCH_PARENT
            )
            scaleType = ImageView.ScaleType.CENTER_CROP
        }

        Glide.with(this)
            .load(getThemeBackground()) // or from URL or filePath
            .into(blurredImageView)

        overlay.addView(blurredImageView, 0)
        val controller = binding.playerView.findViewById<View>(R.id.exo_controller)
        controller?.setBackgroundColor(android.graphics.Color.TRANSPARENT)


        initializeExoPlayer()

        setupPlayPauseButtons()
    }

    @androidx.annotation.OptIn(UnstableApi::class)
    private fun initializeExoPlayer() {
        val fullPath = resolveFullPath(filePath)

        try {
            exoPlayer = ExoPlayer.Builder(this).build().also { player ->
                binding.playerView.player = player
                player.setMediaItem(MediaItem.fromUri(fullPath))
                player.prepare()
                player.playWhenReady = true

                val controller = binding.playerView.findViewById<View>(R.id.exo_controller)
                controller?.setBackgroundColor(android.graphics.Color.TRANSPARENT)

                val timeBar = binding.playerView.findViewById<DefaultTimeBar>(
                    androidx.media3.ui.R.id.exo_progress
                )
                timeBar?.apply {
                    setPlayedColor(ContextCompat.getColor(this@AudioPlayerActivity, R.color.daynight_textColor))
                    setScrubberColor(ContextCompat.getColor(this@AudioPlayerActivity, R.color.daynight_textColor))
                    setBufferedColor(ContextCompat.getColor(this@AudioPlayerActivity, R.color.hint_color))
                    setUnplayedColor(ContextCompat.getColor(this@AudioPlayerActivity, R.color.disable_color))
                }

                player.addListener(object : Player.Listener {
                    override fun onPlayerError(error: PlaybackException) {
                        Utilities.toast(this@AudioPlayerActivity, "Unable to play audio.")
                    }

                    override fun onPlaybackStateChanged(playbackState: Int) {
                        if (playbackState == Player.STATE_ENDED) {
                            player.seekTo(0)
                        }
                    }
                })
            }
        } catch (e: Exception) {
            Utilities.toast(this, "Unable to play audio.")
        }
    }

    private fun resolveFullPath(originalPath: String?): String {
        return if (isFullPath) {
            originalPath ?: ""
        } else {
            val processedPath = originalPath?.let {
                val uuidPattern = Pattern.compile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/")
                val matcher = uuidPattern.matcher(it)
                if (matcher.find()) it.substring(matcher.end()) else it
            }

            File(getExternalFilesDir(null), "ole/$processedPath").absolutePath
        }
    }

    private fun getThemeBackground(): Int {
        val isDarkMode = resources.configuration.uiMode and
                Configuration.UI_MODE_NIGHT_MASK == Configuration.UI_MODE_NIGHT_YES
        return if (isDarkMode) R.drawable.bg_player_dark else R.drawable.bg_player_white
    }

    private fun setupPlayPauseButtons() {
        playButton.setOnClickListener {
            playAudio()
        }

        pauseButton.setOnClickListener {
            pauseAudio()
        }
    }

    private fun playAudio() {
        exoPlayer?.play()
        playButton.visibility = View.GONE
        pauseButton.visibility = View.VISIBLE
    }

    private fun pauseAudio() {
        exoPlayer?.pause()
        pauseButton.visibility = View.GONE
        playButton.visibility = View.VISIBLE
    }



    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == android.R.id.home) {
            finish()
            return true
        }
        return super.onOptionsItemSelected(item)
    }


    override fun onPause() {
        super.onPause()
        pauseAudio()
    }

    override fun onDestroy() {
        binding.playerView.player = null
        exoPlayer?.release()
        exoPlayer = null
        super.onDestroy()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/chat/ChatDetailFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.chat

import android.content.Context
import android.content.SharedPreferences
import android.graphics.Typeface
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TableRow
import androidx.core.content.ContextCompat
import androidx.core.view.isNotEmpty
import androidx.fragment.app.Fragment
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.google.gson.reflect.TypeToken
import dagger.hilt.android.AndroidEntryPoint
import java.util.Date
import java.util.Locale
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentChatDetailBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.AiProvider
import org.ole.planet.myplanet.model.ChatModel
import org.ole.planet.myplanet.model.ChatRequestModel
import org.ole.planet.myplanet.model.ContentData
import org.ole.planet.myplanet.model.ContinueChatModel
import org.ole.planet.myplanet.model.Conversation
import org.ole.planet.myplanet.model.Data
import org.ole.planet.myplanet.model.RealmChatHistory
import org.ole.planet.myplanet.model.RealmChatHistory.Companion.addConversationToChatHistory
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

@AndroidEntryPoint
class ChatDetailFragment : Fragment() {
    private var _binding: FragmentChatDetailBinding? = null
    private val binding get() = _binding!!
    private lateinit var mAdapter: ChatAdapter
    private lateinit var sharedViewModel: ChatViewModel
    private var _id: String = ""
    private var _rev: String = ""
    private var currentID: String = ""
    private var aiName: String = ""
    private var aiModel: String = ""
    var user: RealmUserModel? = null
    private var isUserLoaded = false
    private var isAiUnavailable = false
    private var newsId: String? = null
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    lateinit var customProgressDialog: DialogUtils.CustomProgressDialog
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var chatApiHelper: ChatApiHelper
    @Inject
    lateinit var userRepository: UserRepository
    private val gson = Gson()
    private val serverUrlMapper = ServerUrlMapper()
    private val jsonMediaType = "application/json".toMediaTypeOrNull()
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        sharedViewModel = ViewModelProvider(requireActivity())[ChatViewModel::class.java]
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentChatDetailBinding.inflate(inflater, container, false)
        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        initChatComponents()
        val newsRev = arguments?.getString("newsRev")
        val newsConversations = arguments?.getString("conversations")
        checkAiProviders()
        setupSendButton()
        setupMessageInputListeners()
        if (newsId != null) {
            loadNewsConversations(newsId, newsRev, newsConversations)
        } else {
            observeViewModelData()
        }
        view.post { clearChatDetail() }
    }

    private fun initChatComponents() {
        isUserLoaded = false
        isAiUnavailable = false
        refreshInputState()
        viewLifecycleOwner.lifecycleScope.launch {
            val userId = settings.getString("userId", "") ?: ""
            user = withContext(Dispatchers.IO) { userRepository.getUserById(userId) }
            isUserLoaded = true
            refreshInputState()
        }
        mAdapter = ChatAdapter(requireContext(), binding.recyclerGchat)
        binding.recyclerGchat.apply {
            adapter = mAdapter
            layoutManager = LinearLayoutManager(requireContext())
            isNestedScrollingEnabled = true
            setHasFixedSize(true)
        }
        newsId = arguments?.getString("newsId")
        if (mAdapter.itemCount > 0) {
            binding.recyclerGchat.scrollToPosition(mAdapter.itemCount - 1)
            binding.recyclerGchat.smoothScrollToPosition(mAdapter.itemCount - 1)
        }
    }

    private fun setupSendButton() {
        binding.buttonGchatSend.setOnClickListener {
            val aiProvider = AiProvider(name = aiName, model = aiModel)
            binding.textGchatIndicator.visibility = View.GONE
            if (TextUtils.isEmpty("${binding.editGchatMessage.text}".trim())) {
                binding.textGchatIndicator.visibility = View.VISIBLE
                binding.textGchatIndicator.text = context?.getString(R.string.kindly_enter_message)
            } else {
                val message = "${binding.editGchatMessage.text}".replace("\n", " ")
                mAdapter.addQuery(message)
                when {
                    _id.isNotEmpty() -> {
                        val newRev = getLatestRev(_id) ?: _rev
                        val requestBody = createContinueChatRequest(message, aiProvider, _id, newRev)
                        launchRequest(requestBody, message, _id)
                    }
                    currentID.isNotEmpty() -> {
                        val requestBody = createContinueChatRequest(message, aiProvider, currentID, _rev)
                        launchRequest(requestBody, message, currentID)
                    }
                    else -> {
                        val requestBody = createChatRequest(message, aiProvider)
                        launchRequest(requestBody, message, null)
                    }
                }
                binding.editGchatMessage.text.clear()
                binding.textGchatIndicator.visibility = View.GONE
            }
        }
    }

    private fun setupMessageInputListeners() {
        binding.editGchatMessage.setOnKeyListener { _, _, event ->
            if (event.action == KeyEvent.ACTION_DOWN) {
                if (event.keyCode == KeyEvent.KEYCODE_ENTER && event.isShiftPressed) {
                    binding.editGchatMessage.append("\n")
                    return@setOnKeyListener true
                } else if (event.keyCode == KeyEvent.KEYCODE_ENTER) {
                    binding.buttonGchatSend.performClick()
                    return@setOnKeyListener true
                }
            }
            false
        }
        binding.editGchatMessage.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                binding.textGchatIndicator.visibility = View.GONE
            }
            override fun afterTextChanged(s: Editable?) {}
        })
    }

    private fun loadNewsConversations(newsId: String?, newsRev: String?, newsConversations: String?) {
        _id = newsId ?: ""
        _rev = newsRev ?: ""
        val conversations = gson.fromJson(newsConversations, Array<Conversation>::class.java).toList()
        for (conversation in conversations) {
            conversation.query?.let { mAdapter.addQuery(it) }
            mAdapter.responseSource = ChatAdapter.RESPONSE_SOURCE_SHARED_VIEW_MODEL
            conversation.response?.let { mAdapter.addResponse(it) }
        }
    }

    private fun observeViewModelData() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                launch {
                    sharedViewModel.selectedChatHistory.collect { conversations ->
                        mAdapter.clearData()
                        binding.editGchatMessage.text.clear()
                        binding.textGchatIndicator.visibility = View.GONE
                        if (!conversations.isNullOrEmpty()) {
                            for (conversation in conversations) {
                                conversation.query?.let { mAdapter.addQuery(it) }
                                mAdapter.responseSource = ChatAdapter.RESPONSE_SOURCE_SHARED_VIEW_MODEL
                                conversation.response?.let { mAdapter.addResponse(it) }
                            }
                            binding.recyclerGchat.post {
                                binding.recyclerGchat.scrollToPosition(mAdapter.itemCount - 1)
                            }
                        }
                    }
                }
                launch {
                    sharedViewModel.selectedAiProvider.collect { selectedAiProvider ->
                        aiName = selectedAiProvider ?: aiName
                        if (binding.aiTableRow.isNotEmpty()) {
                            for (i in 0 until binding.aiTableRow.childCount) {
                                val view = binding.aiTableRow.getChildAt(i)
                                if (view is Button && view.text.toString().equals(selectedAiProvider, ignoreCase = true)) {
                                    val modelName = getModelsMap()[selectedAiProvider?.lowercase()] ?: "default-model"
                                    selectAI(view, "$selectedAiProvider", modelName)
                                    break
                                }
                            }
                        }
                    }
                }
                launch {
                    sharedViewModel.selectedId.collect { selectedId ->
                        _id = selectedId
                    }
                }
                launch {
                    sharedViewModel.selectedRev.collect { selectedRev ->
                        _rev = selectedRev
                    }
                }
            }
        }
    }

    private fun checkAiProviders() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        viewLifecycleOwner.lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                customProgressDialog.setText("${context?.getString(R.string.fetching_ai_providers)}")
                customProgressDialog.show()
                chatApiHelper.fetchAiProviders { providers ->
                    customProgressDialog.dismiss()
                    if (providers == null || providers.values.all { !it }) {
                        onFailError()
                    } else {
                        updateAIButtons(providers)
                    }
                }
            }
        }
    }

    private fun updateAIButtons(aiProvidersResponse: Map<String, Boolean>) {
        if (!isAdded || context == null) return

        val aiTableRow = binding.aiTableRow
        aiTableRow.removeAllViews()

        val currentContext = requireContext()
        val modelsMap = getModelsMap()

        val providersMap = aiProvidersResponse.filter { it.value }

        if (providersMap.isEmpty()) return

        providersMap.keys.forEachIndexed { index, providerName ->
            val modelName = modelsMap[providerName.lowercase()] ?: "default-model"

            aiTableRow.addView(createProviderButton(currentContext, providerName, modelName))

            if (index < providersMap.size - 1) {
                aiTableRow.addView(createDivider(currentContext))
            }
        }
        aiTableRow.getChildAt(0)?.performClick()
        isAiUnavailable = false
        refreshInputState()
    }

    private fun createProviderButton(context: Context, providerName: String, modelName: String): Button =
        Button(context).apply {
            text = providerName.lowercase(Locale.getDefault())
            setTextColor(ContextCompat.getColor(context, R.color.md_black_1000))
            textSize = 18f
            setTypeface(null, Typeface.BOLD)
            setPadding(16, 8, 16, 8)
            isAllCaps = false
            setBackgroundColor(ContextCompat.getColor(context, R.color.disable_color))
            setOnClickListener { selectAI(this, providerName, modelName) }
        }

    private fun createDivider(context: Context): View =
        View(context).apply {
            layoutParams = TableRow.LayoutParams(1, TableRow.LayoutParams.MATCH_PARENT).apply {
                setMargins(8, 0, 8, 0)
            }
            setBackgroundColor(ContextCompat.getColor(context, R.color.hint_color))
        }

    private fun selectAI(selectedButton: Button, providerName: String, modelName: String) {
        val aiTableRow = binding.aiTableRow
        val context = requireContext()

        if (aiName != providerName && aiName.isNotEmpty()) {
            clearConversation()
        }

        currentID = ""
        mAdapter.lastAnimatedPosition = -1
        mAdapter.animatedMessages.clear()

        updateButtonStyles(selectedButton, aiTableRow, context)

        aiName = providerName
        aiModel = modelName

        binding.textGchatIndicator.visibility = View.GONE
    }

    private fun updateButtonStyles(selectedButton: Button, aiTableRow: TableRow, context: Context) {
        for (i in 0 until aiTableRow.childCount) {
            val view = aiTableRow.getChildAt(i)
            if (view is Button) {
                if (view == selectedButton) {
                    view.setBackgroundColor(ContextCompat.getColor(context, R.color.mainColor))
                    view.setTextColor(ContextCompat.getColor(context, R.color.textColorPrimary))
                } else {
                    view.setBackgroundColor(ContextCompat.getColor(context, R.color.disable_color))
                    view.setTextColor(ContextCompat.getColor(context, R.color.md_black_1000))
                }
            }
        }
    }

    private fun clearConversation() {
        mAdapter.clearData()
        _id = ""
        _rev = ""
        currentID = ""
        binding.editGchatMessage.text.clear()
        binding.textGchatIndicator.visibility = View.GONE
    }

    private fun onFailError() {
        isAiUnavailable = true
        binding.textGchatIndicator.visibility = View.VISIBLE
        binding.textGchatIndicator.text = context?.getString(R.string.virtual_assistant_currently_not_available)
        refreshInputState()
    }

    private fun launchRequest(content: RequestBody, query: String, id: String?) {
        disableUI()
        val mapping = processServerUrl()
        viewLifecycleOwner.lifecycleScope.launch {
            withContext(Dispatchers.IO) { updateServerIfNecessary(mapping) }
            sendChatRequest(content, query, id, id == null)
        }
    }

    private fun disableUI() {
        _binding?.let { binding ->
            binding.buttonGchatSend.isEnabled = false
            binding.editGchatMessage.isEnabled = false
            binding.imageGchatLoading.visibility = View.VISIBLE
        } ?: return
    }

    private fun enableUI() {
        _binding?.let { binding ->
            binding.imageGchatLoading.visibility = View.INVISIBLE
            refreshInputState()
        } ?: return
    }

    private fun refreshInputState() {
        _binding?.let { binding ->
            val enableInput = isUserLoaded && !isAiUnavailable
            binding.buttonGchatSend.isEnabled = enableInput
            binding.editGchatMessage.isEnabled = enableInput
        }
    }

    private fun processServerUrl(): ServerUrlMapper.UrlMapping =
        serverUrlMapper.processUrl(serverUrl)

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun getModelsMap(): Map<String, String> {
        val modelsString = settings.getString("ai_models", null)
        return if (modelsString != null) {
            gson.fromJson(modelsString, object : TypeToken<Map<String, String>>() {}.type)
        } else {
            emptyMap()
        }
    }

    private fun jsonRequestBody(json: String): RequestBody =
        json.toRequestBody(jsonMediaType)

    private fun createContinueChatRequest(message: String, aiProvider: AiProvider, id: String, rev: String): RequestBody {
        val continueChatData = ContinueChatModel(data = Data("${user?.name}", message, aiProvider, id, rev), save = true)
        val jsonContent = gson.toJson(continueChatData)
        return jsonRequestBody(jsonContent)
    }

    private fun createChatRequest(message: String, aiProvider: AiProvider): RequestBody {
        val chatData = ChatRequestModel(data = ContentData("${user?.name}", message, aiProvider), save = true)
        val jsonContent = gson.toJson(chatData)
        return jsonRequestBody(jsonContent)
    }

    private fun getLatestRev(id: String): String? {
        return try {
            databaseService.withRealm { realm ->
                realm.refresh()
                realm.where(RealmChatHistory::class.java)
                    .equalTo("_id", id)
                    .findAll()
                    .maxByOrNull { rev -> rev._rev?.split("-")?.get(0)?.toIntOrNull() ?: 0 }
                    ?._rev
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private fun sendChatRequest(content: RequestBody, query: String, id: String?, newChat: Boolean) {
        viewLifecycleOwner.lifecycleScope.launch {
            chatApiHelper.sendChatRequest(content, object : Callback<ChatModel> {
                override fun onResponse(call: Call<ChatModel>, response: Response<ChatModel>) {
                    handleResponse(response, query, id)
                }

                override fun onFailure(call: Call<ChatModel>, t: Throwable) {
                    handleFailure(t.message, query, id)
                }
            })
        }
    }

    private fun handleResponse(response: Response<ChatModel>, query: String, id: String?) {
        val responseBody = response.body()
        if (response.isSuccessful && responseBody != null) {
            if (responseBody.status == "Success") {
                responseBody.chat?.let { chatResponse ->
                    processSuccessfulResponse(chatResponse, responseBody, query, id)
                }
            } else {
                showError(responseBody.message)
            }
        } else {
            showError(response.message() ?: context?.getString(R.string.request_failed_please_retry))
            id?.let { continueConversationRealm(it, query, "") }
        }
        enableUI()
    }

    private fun processSuccessfulResponse(chatResponse: String, responseBody: ChatModel, query: String, id: String?) {
        mAdapter.responseSource = ChatAdapter.RESPONSE_SOURCE_NETWORK
        mAdapter.addResponse(chatResponse)
        responseBody.couchDBResponse?.rev?.let { _rev = it }
        id?.let { continueConversationRealm(it, query, chatResponse) } ?: saveNewChat(query, chatResponse, responseBody)
    }

    private fun handleFailure(errorMessage: String?, query: String, id: String?) {
        showError(errorMessage)
        id?.let { continueConversationRealm(it, query, "") }
        enableUI()
    }

    private fun showError(message: String?) {
        _binding?.let { binding ->
            binding.textGchatIndicator.visibility = View.VISIBLE
            binding.textGchatIndicator.text = context?.getString(R.string.message_placeholder, message)
        }
    }

    private fun saveNewChat(query: String, chatResponse: String, responseBody: ChatModel) {
        val jsonObject = buildChatHistoryObject(query, chatResponse, responseBody)
        viewLifecycleOwner.lifecycleScope.launch {
            try {
                databaseService.executeTransactionAsync { realm ->
                    RealmChatHistory.insert(realm, jsonObject)
                }
                if (isAdded && activity is DashboardActivity) {
                    (activity as DashboardActivity).refreshChatHistoryList()
                }
            } catch (e: Exception) {
                if (isAdded) {
                    Snackbar.make(binding.root, getString(R.string.failed_to_save_chat), Snackbar.LENGTH_LONG).show()
                }
            }
        }
    }

    private fun buildChatHistoryObject(query: String, chatResponse: String, responseBody: ChatModel): JsonObject =
        JsonObject().apply {
            val id = responseBody.couchDBResponse?.id
            val rev = responseBody.couchDBResponse?.rev
            if (id != null) {
                currentID = id
            }
            if (rev != null) {
                _rev = rev
            }
            addProperty("_rev", responseBody.couchDBResponse?.rev ?: "")
            addProperty("_id", responseBody.couchDBResponse?.id ?: "")
            addProperty("aiProvider", aiName)
            addProperty("user", user?.name)
            addProperty("title", query)
            addProperty("createdTime", Date().time)
            addProperty("updatedDate", "")

            val conversationsArray = JsonArray()
            val conversationObject = JsonObject().apply {
                addProperty("query", query)
                addProperty("response", chatResponse)
            }
            conversationsArray.add(conversationObject)
            add("conversations", conversationsArray)
        }

    private fun continueConversationRealm(id: String, query: String, chatResponse: String) {
        val realmChatId = when {
            id.isNotBlank() -> id
            _id.isNotBlank() -> _id
            currentID.isNotBlank() -> currentID
            else -> return
        }

        if (query.isBlank() && chatResponse.isBlank()) return

        viewLifecycleOwner.lifecycleScope.launch {
            try {
                databaseService.executeTransactionAsync { realm ->
                    addConversationToChatHistory(realm, realmChatId, query, chatResponse, _rev)
                }
                withContext(Dispatchers.Main) {
                    if (isAdded && activity is DashboardActivity) {
                        (activity as DashboardActivity).refreshChatHistoryList()
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    if (isAdded) {
                        Snackbar.make(binding.root, getString(R.string.failed_to_save_chat), Snackbar.LENGTH_LONG).show()
                    }
                }
            }
        }
    }

    private fun clearChatDetail() {
        if (newsId == null && sharedViewModel.selectedChatHistory.value.isNullOrEmpty()) {
            if (::mAdapter.isInitialized) {
                mAdapter.clearData()
                _id = ""
                _rev = ""
            }
        }
    }

    override fun onDestroyView() {
        val editor = settings.edit()
        if (settings.getBoolean("isAlternativeUrl", false)) {
            editor.putString("alternativeUrl", "")
            editor.putString("processedAlternativeUrl", "")
            editor.putBoolean("isAlternativeUrl", false)
            editor.apply()
        }
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.chat


import android.content.Context
import android.content.SharedPreferences
import android.graphics.Typeface
import android.os.Bundle
import android.text.Editable
import android.text.TextUtils
import android.text.TextWatcher
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TableRow
import androidx.core.content.ContextCompat
import androidx.core.view.isNotEmpty
import androidx.fragment.app.Fragment
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.snackbar.Snackbar
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.google.gson.reflect.TypeToken
import dagger.hilt.android.AndroidEntryPoint
import java.util.Date
import java.util.Locale
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentChatDetailBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.AiProvider
import org.ole.planet.myplanet.model.ChatModel
import org.ole.planet.myplanet.model.ChatRequestModel
import org.ole.planet.myplanet.model.ContentData
import org.ole.planet.myplanet.model.ContinueChatModel
import org.ole.planet.myplanet.model.Conversation
import org.ole.planet.myplanet.model.Data
import org.ole.planet.myplanet.model.RealmChatHistory
import org.ole.planet.myplanet.model.RealmChatHistory.Companion.addConversationToChatHistory
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

@AndroidEntryPoint
class ChatDetailFragment : Fragment() {
    private var _binding: FragmentChatDetailBinding? = null
    private val binding get() = _binding!!
    private lateinit var mAdapter: ChatAdapter
    private lateinit var sharedViewModel: ChatViewModel
    private var _id: String = ""
    private var _rev: String = ""
    private var currentID: String = ""
    private var aiName: String = ""
    private var aiModel: String = ""
    var user: RealmUserModel? = null
    private var isUserLoaded = false
    private var isAiUnavailable = false
    private var newsId: String? = null
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    lateinit var customProgressDialog: DialogUtils.CustomProgressDialog
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var chatApiHelper: ChatApiHelper
    @Inject
    lateinit var userRepository: UserRepository
    private val gson = Gson()
    private val serverUrlMapper = ServerUrlMapper()
    private val jsonMediaType = "application/json".toMediaTypeOrNull()
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        sharedViewModel = ViewModelProvider(requireActivity())[ChatViewModel::class.java]
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentChatDetailBinding.inflate(inflater, container, false)
        customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        initChatComponents()
        val newsRev = arguments?.getString("newsRev")
        val newsConversations = arguments?.getString("conversations")
        checkAiProviders()
        setupSendButton()
        setupMessageInputListeners()
        if (newsId != null) {
            loadNewsConversations(newsId, newsRev, newsConversations)
        } else {
            observeViewModelData()
        }
        view.post { clearChatDetail() }
    }

    private fun initChatComponents() {
        isUserLoaded = false
        isAiUnavailable = false
        refreshInputState()
        viewLifecycleOwner.lifecycleScope.launch {
            val userId = settings.getString("userId", "") ?: ""
            user = withContext(Dispatchers.IO) { userRepository.getUserById(userId) }
            isUserLoaded = true
            refreshInputState()
        }
        mAdapter = ChatAdapter(requireContext(), binding.recyclerGchat)
        binding.recyclerGchat.apply {
            adapter = mAdapter
            layoutManager = LinearLayoutManager(requireContext())
            isNestedScrollingEnabled = true
            setHasFixedSize(true)
        }
        newsId = arguments?.getString("newsId")
        if (mAdapter.itemCount > 0) {
            binding.recyclerGchat.scrollToPosition(mAdapter.itemCount - 1)
            binding.recyclerGchat.smoothScrollToPosition(mAdapter.itemCount - 1)
        }
    }

    private fun setupSendButton() {
        binding.buttonGchatSend.setOnClickListener {
            val aiProvider = AiProvider(name = aiName, model = aiModel)
            binding.textGchatIndicator.visibility = View.GONE
            if (TextUtils.isEmpty("${binding.editGchatMessage.text}".trim())) {
                binding.textGchatIndicator.visibility = View.VISIBLE
                binding.textGchatIndicator.text = context?.getString(R.string.kindly_enter_message)
            } else {
                val message = "${binding.editGchatMessage.text}".replace("\n", " ")
                mAdapter.addQuery(message)
                when {
                    _id.isNotEmpty() -> {
                        val newRev = getLatestRev(_id) ?: _rev
                        val requestBody = createContinueChatRequest(message, aiProvider, _id, newRev)
                        launchRequest(requestBody, message, _id)
                    }
                    currentID.isNotEmpty() -> {
                        val requestBody = createContinueChatRequest(message, aiProvider, currentID, _rev)
                        launchRequest(requestBody, message, currentID)
                    }
                    else -> {
                        val requestBody = createChatRequest(message, aiProvider)
                        launchRequest(requestBody, message, null)
                    }
                }
                binding.editGchatMessage.text.clear()
                binding.textGchatIndicator.visibility = View.GONE
            }
        }
    }

    private fun setupMessageInputListeners() {
        binding.editGchatMessage.setOnKeyListener { _, _, event ->
            if (event.action == KeyEvent.ACTION_DOWN) {
                if (event.keyCode == KeyEvent.KEYCODE_ENTER && event.isShiftPressed) {
                    binding.editGchatMessage.append("\n")
                    return@setOnKeyListener true
                } else if (event.keyCode == KeyEvent.KEYCODE_ENTER) {
                    binding.buttonGchatSend.performClick()
                    return@setOnKeyListener true
                }
            }
            false
        }
        binding.editGchatMessage.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                binding.textGchatIndicator.visibility = View.GONE
            }
            override fun afterTextChanged(s: Editable?) {}
        })
    }

    private fun loadNewsConversations(newsId: String?, newsRev: String?, newsConversations: String?) {
        _id = newsId ?: ""
        _rev = newsRev ?: ""
        val conversations = gson.fromJson(newsConversations, Array<Conversation>::class.java).toList()
        for (conversation in conversations) {
            conversation.query?.let { mAdapter.addQuery(it) }
            mAdapter.responseSource = ChatAdapter.RESPONSE_SOURCE_SHARED_VIEW_MODEL
            conversation.response?.let { mAdapter.addResponse(it) }
        }
    }

    private fun observeViewModelData() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                launch {
                    sharedViewModel.selectedChatHistory.collect { conversations ->
                        mAdapter.clearData()
                        binding.editGchatMessage.text.clear()
                        binding.textGchatIndicator.visibility = View.GONE
                        if (!conversations.isNullOrEmpty()) {
                            for (conversation in conversations) {
                                conversation.query?.let { mAdapter.addQuery(it) }
                                mAdapter.responseSource = ChatAdapter.RESPONSE_SOURCE_SHARED_VIEW_MODEL
                                conversation.response?.let { mAdapter.addResponse(it) }
                            }
                            binding.recyclerGchat.post {
                                binding.recyclerGchat.scrollToPosition(mAdapter.itemCount - 1)
                            }
                        }
                    }
                }
                launch {
                    sharedViewModel.selectedAiProvider.collect { selectedAiProvider ->
                        aiName = selectedAiProvider ?: aiName
                        if (binding.aiTableRow.isNotEmpty()) {
                            for (i in 0 until binding.aiTableRow.childCount) {
                                val view = binding.aiTableRow.getChildAt(i)
                                if (view is Button && view.text.toString().equals(selectedAiProvider, ignoreCase = true)) {
                                    val modelName = getModelsMap()[selectedAiProvider?.lowercase()] ?: "default-model"
                                    selectAI(view, "$selectedAiProvider", modelName)
                                    break
                                }
                            }
                        }
                    }
                }
                launch {
                    sharedViewModel.selectedId.collect { selectedId ->
                        _id = selectedId
                    }
                }
                launch {
                    sharedViewModel.selectedRev.collect { selectedRev ->
                        _rev = selectedRev
                    }
                }
            }
        }
    }

    private fun checkAiProviders() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        viewLifecycleOwner.lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                customProgressDialog.setText("${context?.getString(R.string.fetching_ai_providers)}")
                customProgressDialog.show()
                chatApiHelper.fetchAiProviders { providers ->
                    customProgressDialog.dismiss()
                    if (providers == null || providers.values.all { !it }) {
                        onFailError()
                    } else {
                        updateAIButtons(providers)
                    }
                }
            }
        }
    }

    private fun updateAIButtons(aiProvidersResponse: Map<String, Boolean>) {
        if (!isAdded || context == null) return

        val aiTableRow = binding.aiTableRow
        aiTableRow.removeAllViews()

        val currentContext = requireContext()
        val modelsMap = getModelsMap()

        val providersMap = aiProvidersResponse.filter { it.value }

        if (providersMap.isEmpty()) return

        providersMap.keys.forEachIndexed { index, providerName ->
            val modelName = modelsMap[providerName.lowercase()] ?: "default-model"

            aiTableRow.addView(createProviderButton(currentContext, providerName, modelName))

            if (index < providersMap.size - 1) {
                aiTableRow.addView(createDivider(currentContext))
            }
        }
        aiTableRow.getChildAt(0)?.performClick()
        isAiUnavailable = false
        refreshInputState()
    }

    private fun createProviderButton(context: Context, providerName: String, modelName: String): Button =
        Button(context).apply {
            text = providerName.lowercase(Locale.getDefault())
            setTextColor(ContextCompat.getColor(context, R.color.md_black_1000))
            textSize = 18f
            setTypeface(null, Typeface.BOLD)
            setPadding(16, 8, 16, 8)
            isAllCaps = false
            setBackgroundColor(ContextCompat.getColor(context, R.color.disable_color))
            setOnClickListener { selectAI(this, providerName, modelName) }
        }

    private fun createDivider(context: Context): View =
        View(context).apply {
            layoutParams = TableRow.LayoutParams(1, TableRow.LayoutParams.MATCH_PARENT).apply {
                setMargins(8, 0, 8, 0)
            }
            setBackgroundColor(ContextCompat.getColor(context, R.color.hint_color))
        }

    private fun selectAI(selectedButton: Button, providerName: String, modelName: String) {
        val aiTableRow = binding.aiTableRow
        val context = requireContext()

        if (aiName != providerName && aiName.isNotEmpty()) {
            clearConversation()
        }

        currentID = ""
        mAdapter.lastAnimatedPosition = -1
        mAdapter.animatedMessages.clear()

        updateButtonStyles(selectedButton, aiTableRow, context)

        aiName = providerName
        aiModel = modelName

        binding.textGchatIndicator.visibility = View.GONE
    }

    private fun updateButtonStyles(selectedButton: Button, aiTableRow: TableRow, context: Context) {
        for (i in 0 until aiTableRow.childCount) {
            val view = aiTableRow.getChildAt(i)
            if (view is Button) {
                if (view == selectedButton) {
                    view.setBackgroundColor(ContextCompat.getColor(context, R.color.mainColor))
                    view.setTextColor(ContextCompat.getColor(context, R.color.textColorPrimary))
                } else {
                    view.setBackgroundColor(ContextCompat.getColor(context, R.color.disable_color))
                    view.setTextColor(ContextCompat.getColor(context, R.color.md_black_1000))
                }
            }
        }
    }

    private fun clearConversation() {
        mAdapter.clearData()
        _id = ""
        _rev = ""
        currentID = ""
        binding.editGchatMessage.text.clear()
        binding.textGchatIndicator.visibility = View.GONE
    }

    private fun onFailError() {
        isAiUnavailable = true
        binding.textGchatIndicator.visibility = View.VISIBLE
        binding.textGchatIndicator.text = context?.getString(R.string.virtual_assistant_currently_not_available)
        refreshInputState()
    }

    private fun launchRequest(content: RequestBody, query: String, id: String?) {
        disableUI()
        val mapping = processServerUrl()
        viewLifecycleOwner.lifecycleScope.launch {
            withContext(Dispatchers.IO) { updateServerIfNecessary(mapping) }
            sendChatRequest(content, query, id, id == null)
        }
    }

    private fun disableUI() {
        _binding?.let { binding ->
            binding.buttonGchatSend.isEnabled = false
            binding.editGchatMessage.isEnabled = false
            binding.imageGchatLoading.visibility = View.VISIBLE
        } ?: return
    }

    private fun enableUI() {
        _binding?.let { binding ->
            binding.imageGchatLoading.visibility = View.INVISIBLE
            refreshInputState()
        } ?: return
    }

    private fun refreshInputState() {
        _binding?.let { binding ->
            val enableInput = isUserLoaded && !isAiUnavailable
            binding.buttonGchatSend.isEnabled = enableInput
            binding.editGchatMessage.isEnabled = enableInput
        }
    }

    private fun processServerUrl(): ServerUrlMapper.UrlMapping =
        serverUrlMapper.processUrl(serverUrl)

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    private fun getModelsMap(): Map<String, String> {
        val modelsString = settings.getString("ai_models", null)
        return if (modelsString != null) {
            gson.fromJson(modelsString, object : TypeToken<Map<String, String>>() {}.type)
        } else {
            emptyMap()
        }
    }

    private fun jsonRequestBody(json: String): RequestBody =
        json.toRequestBody(jsonMediaType)

    private fun createContinueChatRequest(message: String, aiProvider: AiProvider, id: String, rev: String): RequestBody {
        val continueChatData = ContinueChatModel(data = Data("${user?.name}", message, aiProvider, id, rev), save = true)
        val jsonContent = gson.toJson(continueChatData)
        return jsonRequestBody(jsonContent)
    }

    private fun createChatRequest(message: String, aiProvider: AiProvider): RequestBody {
        val chatData = ChatRequestModel(data = ContentData("${user?.name}", message, aiProvider), save = true)
        val jsonContent = gson.toJson(chatData)
        return jsonRequestBody(jsonContent)
    }

    private fun getLatestRev(id: String): String? {
        return try {
            databaseService.withRealm { realm ->
                realm.refresh()
                realm.where(RealmChatHistory::class.java)
                    .equalTo("_id", id)
                    .findAll()
                    .maxByOrNull { rev -> rev._rev?.split("-")?.get(0)?.toIntOrNull() ?: 0 }
                    ?._rev
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private fun sendChatRequest(content: RequestBody, query: String, id: String?, newChat: Boolean) {
        viewLifecycleOwner.lifecycleScope.launch {
            chatApiHelper.sendChatRequest(content, object : Callback<ChatModel> {
                override fun onResponse(call: Call<ChatModel>, response: Response<ChatModel>) {
                    handleResponse(response, query, id)
                }

                override fun onFailure(call: Call<ChatModel>, t: Throwable) {
                    handleFailure(t.message, query, id)
                }
            })
        }
    }

    private fun handleResponse(response: Response<ChatModel>, query: String, id: String?) {
        val responseBody = response.body()
        if (response.isSuccessful && responseBody != null) {
            if (responseBody.status == "Success") {
                responseBody.chat?.let { chatResponse ->
                    processSuccessfulResponse(chatResponse, responseBody, query, id)
                }
            } else {
                showError(responseBody.message)
            }
        } else {
            showError(response.message() ?: context?.getString(R.string.request_failed_please_retry))
            id?.let { continueConversationRealm(it, query, "") }
        }
        enableUI()
    }

    private fun processSuccessfulResponse(chatResponse: String, responseBody: ChatModel, query: String, id: String?) {
        mAdapter.responseSource = ChatAdapter.RESPONSE_SOURCE_NETWORK
        mAdapter.addResponse(chatResponse)
        responseBody.couchDBResponse?.rev?.let { _rev = it }
        id?.let { continueConversationRealm(it, query, chatResponse) } ?: saveNewChat(query, chatResponse, responseBody)
    }

    private fun handleFailure(errorMessage: String?, query: String, id: String?) {
        showError(errorMessage)
        id?.let { continueConversationRealm(it, query, "") }
        enableUI()
    }

    private fun showError(message: String?) {
        _binding?.let { binding ->
            binding.textGchatIndicator.visibility = View.VISIBLE
            binding.textGchatIndicator.text = context?.getString(R.string.message_placeholder, message)
        }
    }

    private fun saveNewChat(query: String, chatResponse: String, responseBody: ChatModel) {
        val jsonObject = buildChatHistoryObject(query, chatResponse, responseBody)
        viewLifecycleOwner.lifecycleScope.launch {
            try {
                databaseService.executeTransactionAsync { realm ->
                    RealmChatHistory.insert(realm, jsonObject)
                }
                if (isAdded && activity is DashboardActivity) {
                    (activity as DashboardActivity).refreshChatHistoryList()
                }
            } catch (e: Exception) {
                if (isAdded) {
                    Snackbar.make(binding.root, getString(R.string.failed_to_save_chat), Snackbar.LENGTH_LONG).show()
                }
            }
        }
    }

    private fun buildChatHistoryObject(query: String, chatResponse: String, responseBody: ChatModel): JsonObject =
        JsonObject().apply {
            val id = responseBody.couchDBResponse?.id
            val rev = responseBody.couchDBResponse?.rev
            if (id != null) {
                currentID = id
            }
            if (rev != null) {
                _rev = rev
            }
            addProperty("_rev", responseBody.couchDBResponse?.rev ?: "")
            addProperty("_id", responseBody.couchDBResponse?.id ?: "")
            addProperty("aiProvider", aiName)
            addProperty("user", user?.name)
            addProperty("title", query)
            addProperty("createdTime", Date().time)
            addProperty("updatedDate", "")

            val conversationsArray = JsonArray()
            val conversationObject = JsonObject().apply {
                addProperty("query", query)
                addProperty("response", chatResponse)
            }
            conversationsArray.add(conversationObject)
            add("conversations", conversationsArray)
        }

    private fun continueConversationRealm(id: String, query: String, chatResponse: String) {
        val realmChatId = when {
            id.isNotBlank() -> id
            _id.isNotBlank() -> _id
            currentID.isNotBlank() -> currentID
            else -> return
        }

        if (query.isBlank() && chatResponse.isBlank()) return

        viewLifecycleOwner.lifecycleScope.launch {
            try {
                databaseService.executeTransactionAsync { realm ->
                    addConversationToChatHistory(realm, realmChatId, query, chatResponse, _rev)
                }
                withContext(Dispatchers.Main) {
                    if (isAdded && activity is DashboardActivity) {
                        (activity as DashboardActivity).refreshChatHistoryList()
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    if (isAdded) {
                        Snackbar.make(binding.root, getString(R.string.failed_to_save_chat), Snackbar.LENGTH_LONG).show()
                    }
                }
            }
        }
    }

    private fun clearChatDetail() {
        if (newsId == null && sharedViewModel.selectedChatHistory.value.isNullOrEmpty()) {
            if (::mAdapter.isInitialized) {
                mAdapter.clearData()
                _id = ""
                _rev = ""
            }
        }
    }

    override fun onDestroyView() {
        val editor = settings.edit()
        if (settings.getBoolean("isAlternativeUrl", false)) {
            editor.putString("alternativeUrl", "")
            editor.putString("processedAlternativeUrl", "")
            editor.putBoolean("isAlternativeUrl", false)
            editor.apply()
        }
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/chat/ChatViewModel.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.chat

import androidx.lifecycle.ViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import org.ole.planet.myplanet.model.Conversation

class ChatViewModel : ViewModel() {
    private val _selectedChatHistory = MutableStateFlow<List<Conversation>?>(null)
    val selectedChatHistory: StateFlow<List<Conversation>?> = _selectedChatHistory.asStateFlow()

    private val _selectedId = MutableStateFlow("")
    val selectedId: StateFlow<String> = _selectedId.asStateFlow()

    private val _selectedRev = MutableStateFlow("")
    val selectedRev: StateFlow<String> = _selectedRev.asStateFlow()

    private val _selectedAiProvider = MutableStateFlow<String?>(null)
    val selectedAiProvider: StateFlow<String?> = _selectedAiProvider.asStateFlow()

    fun setSelectedChatHistory(conversations: List<Conversation>) {
        _selectedChatHistory.value = conversations
    }

    fun setSelectedId(id: String) {
        _selectedId.value = id
    }

    fun setSelectedRev(rev: String) {
        _selectedRev.value = rev
    }

    fun setSelectedAiProvider(aiProvider: String?) {
        _selectedAiProvider.value = aiProvider
    }

    fun clearChatState() {
        _selectedChatHistory.value = null
        _selectedId.value = ""
        _selectedRev.value = ""
        _selectedAiProvider.value = null
    }
}
=======
package org.ole.planet.myplanet.ui.chat


import androidx.lifecycle.ViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import org.ole.planet.myplanet.model.Conversation

class ChatViewModel : ViewModel() {
    private val _selectedChatHistory = MutableStateFlow<List<Conversation>?>(null)
    val selectedChatHistory: StateFlow<List<Conversation>?> = _selectedChatHistory.asStateFlow()

    private val _selectedId = MutableStateFlow("")
    val selectedId: StateFlow<String> = _selectedId.asStateFlow()

    private val _selectedRev = MutableStateFlow("")
    val selectedRev: StateFlow<String> = _selectedRev.asStateFlow()

    private val _selectedAiProvider = MutableStateFlow<String?>(null)
    val selectedAiProvider: StateFlow<String?> = _selectedAiProvider.asStateFlow()

    fun setSelectedChatHistory(conversations: List<Conversation>) {
        _selectedChatHistory.value = conversations
    }

    fun setSelectedId(id: String) {
        _selectedId.value = id
    }

    fun setSelectedRev(rev: String) {
        _selectedRev.value = rev
    }

    fun setSelectedAiProvider(aiProvider: String?) {
        _selectedAiProvider.value = aiProvider
    }

    fun clearChatState() {
        _selectedChatHistory.value = null
        _selectedId.value = ""
        _selectedRev.value = ""
        _selectedAiProvider.value = null
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/chat/ChatAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.chat

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ItemAiResponseMessageBinding
import org.ole.planet.myplanet.databinding.ItemUserMessageBinding
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.Utilities

class ChatAdapter(val context: Context, private val recyclerView: RecyclerView) :
    ListAdapter<String, RecyclerView.ViewHolder>(
        DiffUtils.itemCallback(
            { old, new -> old == new },
            { old, new -> old == new }
        )
    ) {
    var responseSource: Int = RESPONSE_SOURCE_UNKNOWN
    private val viewTypeQuery = 1
    private val viewTypeResponse = 2
    val animatedMessages = HashMap<Int, Boolean>()
    var lastAnimatedPosition: Int = -1
    private val coroutineScope = CoroutineScope(Dispatchers.Main)
    private val messages = mutableListOf<String>()

    interface OnChatItemClickListener {
        fun onChatItemClick(position: Int, chatItem: String)
    }

    private var chatItemClickListener: OnChatItemClickListener? = null

    fun setOnChatItemClickListener(listener: OnChatItemClickListener) {
        this.chatItemClickListener = listener
    }

    class QueryViewHolder(private val textUserMessageBinding: ItemUserMessageBinding, private val copyToClipboard: (String) -> Unit) : RecyclerView.ViewHolder(textUserMessageBinding.root) {
        fun bind(query: String) {
            textUserMessageBinding.textGchatMessageMe.text = query

            textUserMessageBinding.textGchatMessageMe.setOnLongClickListener {
                copyToClipboard(query)
                true
            }
        }
    }

    class ResponseViewHolder(
        private val textAiMessageBinding: ItemAiResponseMessageBinding,
        private val copyToClipboard: (String) -> Unit,
        val context: Context,
        private val recyclerView: RecyclerView,
        private val coroutineScope: CoroutineScope
    ) : RecyclerView.ViewHolder(textAiMessageBinding.root) {
        fun bind(response: String, responseSource: Int,  shouldAnimate: Boolean, markAnimated: () -> Unit) {
            textAiMessageBinding.textGchatMessageOther.visibility = View.VISIBLE
            if (responseSource == RESPONSE_SOURCE_NETWORK) {
                if (shouldAnimate) {
                    textAiMessageBinding.textGchatMessageOther.text = context.getString(R.string.empty_text)
                    coroutineScope.launch {
                        animateTyping(response, markAnimated)
                    }
                } else{
                    textAiMessageBinding.textGchatMessageOther.text = response
                }

            } else if (responseSource == RESPONSE_SOURCE_SHARED_VIEW_MODEL) {
                if (response.isNotEmpty()) {
                    textAiMessageBinding.textGchatMessageOther.text = response
                } else{
                    textAiMessageBinding.textGchatMessageOther.visibility = View.GONE
                }
            }
            textAiMessageBinding.textGchatMessageOther.setOnLongClickListener {
                copyToClipboard(response)
                true
            }
        }

        private suspend fun animateTyping(response: String, markAnimated: () -> Unit) {
            var currentIndex = 0
            while (currentIndex < response.length) {
                textAiMessageBinding.textGchatMessageOther.text = response.substring(0, currentIndex + 1)
                recyclerView.scrollToPosition(bindingAdapterPosition)
                currentIndex++
                delay(10L)
            }
            markAnimated()
        }
    }

    private fun copyToClipboard(text: String) {
        val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        val clip = ClipData.newPlainText("copied Text", text)
        clipboard.setPrimaryClip(clip)
        Utilities.toast(
            context,
            context.getString(R.string.copied_to_clipboard),
            android.widget.Toast.LENGTH_SHORT
        )
    }

    fun addQuery(query: String) {
        messages.add(query)
        submitList(messages.toList()) {
            scrollToLastItem()
        }
    }

    fun addResponse(response: String) {
        messages.add(response)
        lastAnimatedPosition = messages.size - 1
        submitList(messages.toList()) {
            scrollToLastItem()
        }
    }

    fun clearData() {
        messages.clear()
        animatedMessages.clear()
        lastAnimatedPosition = -1
        submitList(emptyList())
    }

    private fun scrollToLastItem() {
        val lastPosition = messages.size - 1
        if (lastPosition >= 0) {
            recyclerView.scrollToPosition(lastPosition)
        }
    }

    override fun getItemViewType(position: Int): Int {
        return if (position % 2 == 0) viewTypeQuery else viewTypeResponse
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        return when (viewType) {
            viewTypeQuery -> {
                val userMessageBinding = ItemUserMessageBinding.inflate(LayoutInflater.from(context), parent, false)
                QueryViewHolder(userMessageBinding, this::copyToClipboard)
            }
            viewTypeResponse -> {
                val aiMessageBinding = ItemAiResponseMessageBinding.inflate(LayoutInflater.from(context), parent, false)
                ResponseViewHolder(aiMessageBinding, this::copyToClipboard, context, recyclerView, coroutineScope)
            }
            else -> throw IllegalArgumentException("Invalid view type")
        }
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        val chatItem = getItem(position)
        when (holder.itemViewType) {
            viewTypeQuery -> {
                val queryViewHolder = holder as QueryViewHolder
                queryViewHolder.bind(chatItem)
            }
            viewTypeResponse -> {
                val responseViewHolder = holder as ResponseViewHolder
                val shouldAnimate = (position == lastAnimatedPosition && !animatedMessages.containsKey(position))
                responseViewHolder.bind(chatItem,responseSource, shouldAnimate) {
                    animatedMessages[position] = true
                }
            }
            else -> throw IllegalArgumentException("Invalid view type")
        }
        holder.itemView.setOnClickListener {
            chatItemClickListener?.onChatItemClick(position, chatItem)
        }
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        super.onDetachedFromRecyclerView(recyclerView)
        coroutineScope.cancel()
    }

    companion object {
        const val RESPONSE_SOURCE_SHARED_VIEW_MODEL = 1
        const val RESPONSE_SOURCE_NETWORK = 2
        const val RESPONSE_SOURCE_UNKNOWN = 0
    }
}
=======
package org.ole.planet.myplanet.ui.chat


import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.ItemAiResponseMessageBinding
import org.ole.planet.myplanet.databinding.ItemUserMessageBinding
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.Utilities

class ChatAdapter(val context: Context, private val recyclerView: RecyclerView) :
    ListAdapter<String, RecyclerView.ViewHolder>(
        DiffUtils.itemCallback(
            { old, new -> old == new },
            { old, new -> old == new }
        )
    ) {
    var responseSource: Int = RESPONSE_SOURCE_UNKNOWN
    private val viewTypeQuery = 1
    private val viewTypeResponse = 2
    val animatedMessages = HashMap<Int, Boolean>()
    var lastAnimatedPosition: Int = -1
    private val coroutineScope = CoroutineScope(Dispatchers.Main)
    private val messages = mutableListOf<String>()

    interface OnChatItemClickListener {
        fun onChatItemClick(position: Int, chatItem: String)
    }

    private var chatItemClickListener: OnChatItemClickListener? = null

    fun setOnChatItemClickListener(listener: OnChatItemClickListener) {
        this.chatItemClickListener = listener
    }

    class QueryViewHolder(private val textUserMessageBinding: ItemUserMessageBinding, private val copyToClipboard: (String) -> Unit) : RecyclerView.ViewHolder(textUserMessageBinding.root) {
        fun bind(query: String) {
            textUserMessageBinding.textGchatMessageMe.text = query

            textUserMessageBinding.textGchatMessageMe.setOnLongClickListener {
                copyToClipboard(query)
                true
            }
        }
    }

    class ResponseViewHolder(
        private val textAiMessageBinding: ItemAiResponseMessageBinding,
        private val copyToClipboard: (String) -> Unit,
        val context: Context,
        private val recyclerView: RecyclerView,
        private val coroutineScope: CoroutineScope
    ) : RecyclerView.ViewHolder(textAiMessageBinding.root) {
        fun bind(response: String, responseSource: Int,  shouldAnimate: Boolean, markAnimated: () -> Unit) {
            textAiMessageBinding.textGchatMessageOther.visibility = View.VISIBLE
            if (responseSource == RESPONSE_SOURCE_NETWORK) {
                if (shouldAnimate) {
                    textAiMessageBinding.textGchatMessageOther.text = context.getString(R.string.empty_text)
                    coroutineScope.launch {
                        animateTyping(response, markAnimated)
                    }
                } else{
                    textAiMessageBinding.textGchatMessageOther.text = response
                }

            } else if (responseSource == RESPONSE_SOURCE_SHARED_VIEW_MODEL) {
                if (response.isNotEmpty()) {
                    textAiMessageBinding.textGchatMessageOther.text = response
                } else{
                    textAiMessageBinding.textGchatMessageOther.visibility = View.GONE
                }
            }
            textAiMessageBinding.textGchatMessageOther.setOnLongClickListener {
                copyToClipboard(response)
                true
            }
        }

        private suspend fun animateTyping(response: String, markAnimated: () -> Unit) {
            var currentIndex = 0
            while (currentIndex < response.length) {
                textAiMessageBinding.textGchatMessageOther.text = response.substring(0, currentIndex + 1)
                recyclerView.scrollToPosition(bindingAdapterPosition)
                currentIndex++
                delay(10L)
            }
            markAnimated()
        }
    }

    private fun copyToClipboard(text: String) {
        val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        val clip = ClipData.newPlainText("copied Text", text)
        clipboard.setPrimaryClip(clip)
        Utilities.toast(
            context,
            context.getString(R.string.copied_to_clipboard),
            android.widget.Toast.LENGTH_SHORT
        )
    }

    fun addQuery(query: String) {
        messages.add(query)
        submitList(messages.toList()) {
            scrollToLastItem()
        }
    }

    fun addResponse(response: String) {
        messages.add(response)
        lastAnimatedPosition = messages.size - 1
        submitList(messages.toList()) {
            scrollToLastItem()
        }
    }

    fun clearData() {
        messages.clear()
        animatedMessages.clear()
        lastAnimatedPosition = -1
        submitList(emptyList())
    }

    private fun scrollToLastItem() {
        val lastPosition = messages.size - 1
        if (lastPosition >= 0) {
            recyclerView.scrollToPosition(lastPosition)
        }
    }

    override fun getItemViewType(position: Int): Int {
        return if (position % 2 == 0) viewTypeQuery else viewTypeResponse
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        return when (viewType) {
            viewTypeQuery -> {
                val userMessageBinding = ItemUserMessageBinding.inflate(LayoutInflater.from(context), parent, false)
                QueryViewHolder(userMessageBinding, this::copyToClipboard)
            }
            viewTypeResponse -> {
                val aiMessageBinding = ItemAiResponseMessageBinding.inflate(LayoutInflater.from(context), parent, false)
                ResponseViewHolder(aiMessageBinding, this::copyToClipboard, context, recyclerView, coroutineScope)
            }
            else -> throw IllegalArgumentException("Invalid view type")
        }
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        val chatItem = getItem(position)
        when (holder.itemViewType) {
            viewTypeQuery -> {
                val queryViewHolder = holder as QueryViewHolder
                queryViewHolder.bind(chatItem)
            }
            viewTypeResponse -> {
                val responseViewHolder = holder as ResponseViewHolder
                val shouldAnimate = (position == lastAnimatedPosition && !animatedMessages.containsKey(position))
                responseViewHolder.bind(chatItem,responseSource, shouldAnimate) {
                    animatedMessages[position] = true
                }
            }
            else -> throw IllegalArgumentException("Invalid view type")
        }
        holder.itemView.setOnClickListener {
            chatItemClickListener?.onChatItemClick(position, chatItem)
        }
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        super.onDetachedFromRecyclerView(recyclerView)
        coroutineScope.cancel()
    }

    companion object {
        const val RESPONSE_SOURCE_SHARED_VIEW_MODEL = 1
        const val RESPONSE_SOURCE_NETWORK = 2
        const val RESPONSE_SOURCE_UNKNOWN = 0
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/chat/ChatApiHelper.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.chat

import android.content.Context
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton
import okhttp3.RequestBody
import okhttp3.ResponseBody
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.model.ChatModel
import org.ole.planet.myplanet.utilities.UrlUtils
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

@Singleton
class ChatApiHelper @Inject constructor(
    private val apiInterface: ApiInterface,
    @ApplicationContext private val context: Context
) {
    fun fetchAiProviders(result: (Map<String, Boolean>?) -> Unit) {
        try {
            val hostUrl = UrlUtils.hostUrl
            if (hostUrl.isBlank()) {
                result(null)
                return
            }

            val checkProvidersUrl = "${hostUrl}checkProviders/"

            apiInterface.checkAiProviders(checkProvidersUrl).enqueue(object : Callback<ResponseBody> {
                override fun onResponse(call: Call<ResponseBody>, response: Response<ResponseBody>) {
                    try {
                        when {
                            !response.isSuccessful -> {
                                result(null)
                                return
                            }

                            response.body() == null -> {
                                result(null)
                                return
                            }
                        }

                        val responseString = response.body()?.string()
                        if (responseString.isNullOrBlank()) {
                            result(null)
                            return
                        }

                        val providers: Map<String, Boolean> = Gson().fromJson(
                            responseString,
                            object : TypeToken<Map<String, Boolean>>() {}.type
                        )
                        result(providers)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        result(null)
                    }
                }

                override fun onFailure(call: Call<ResponseBody>, t: Throwable) {
                    try {
                        t.printStackTrace()
                        result(null)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        result(null)
                    }
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
            result(null)
        }
    }

    fun sendChatRequest(content: RequestBody, callback: Callback<ChatModel>) {
        try {
            val hostUrl = UrlUtils.hostUrl
            if (hostUrl.isBlank()) {
                callback.onFailure(
                    apiInterface.chatGpt(hostUrl, content),
                    IllegalArgumentException("Host URL is not available")
                )
                return
            }

            apiInterface.chatGpt(hostUrl, content).enqueue(object : Callback<ChatModel> {
                override fun onResponse(call: Call<ChatModel>, response: Response<ChatModel>) {
                    try {
                        callback.onResponse(call, response)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        callback.onFailure(call, e)
                    }
                }

                override fun onFailure(call: Call<ChatModel>, t: Throwable) {
                    try {
                        t.printStackTrace()
                        callback.onFailure(call, t)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        callback.onFailure(call, e)
                    }
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
            try {
                callback.onFailure(
                    apiInterface.chatGpt(UrlUtils.hostUrl, content),
                    e
                )
            } catch (callbackError: Exception) {
                callbackError.printStackTrace()
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.chat


import android.content.Context
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton
import okhttp3.RequestBody
import okhttp3.ResponseBody
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.model.ChatModel
import org.ole.planet.myplanet.utilities.UrlUtils
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

@Singleton
class ChatApiHelper @Inject constructor(
    private val apiInterface: ApiInterface,
    @ApplicationContext private val context: Context
) {
    fun fetchAiProviders(result: (Map<String, Boolean>?) -> Unit) {
        try {
            val hostUrl = UrlUtils.hostUrl
            if (hostUrl.isBlank()) {
                result(null)
                return
            }

            val checkProvidersUrl = "${hostUrl}checkProviders/"

            apiInterface.checkAiProviders(checkProvidersUrl).enqueue(object : Callback<ResponseBody> {
                override fun onResponse(call: Call<ResponseBody>, response: Response<ResponseBody>) {
                    try {
                        when {
                            !response.isSuccessful -> {
                                result(null)
                                return
                            }

                            response.body() == null -> {
                                result(null)
                                return
                            }
                        }

                        val responseString = response.body()?.string()
                        if (responseString.isNullOrBlank()) {
                            result(null)
                            return
                        }

                        val providers: Map<String, Boolean> = Gson().fromJson(
                            responseString,
                            object : TypeToken<Map<String, Boolean>>() {}.type
                        )
                        result(providers)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        result(null)
                    }
                }

                override fun onFailure(call: Call<ResponseBody>, t: Throwable) {
                    try {
                        t.printStackTrace()
                        result(null)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        result(null)
                    }
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
            result(null)
        }
    }

    fun sendChatRequest(content: RequestBody, callback: Callback<ChatModel>) {
        try {
            val hostUrl = UrlUtils.hostUrl
            if (hostUrl.isBlank()) {
                callback.onFailure(
                    apiInterface.chatGpt(hostUrl, content),
                    IllegalArgumentException("Host URL is not available")
                )
                return
            }

            apiInterface.chatGpt(hostUrl, content).enqueue(object : Callback<ChatModel> {
                override fun onResponse(call: Call<ChatModel>, response: Response<ChatModel>) {
                    try {
                        callback.onResponse(call, response)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        callback.onFailure(call, e)
                    }
                }

                override fun onFailure(call: Call<ChatModel>, t: Throwable) {
                    try {
                        t.printStackTrace()
                        callback.onFailure(call, t)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        callback.onFailure(call, e)
                    }
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
            try {
                callback.onFailure(
                    apiInterface.chatGpt(UrlUtils.hostUrl, content),
                    e
                )
            } catch (callbackError: Exception) {
                callbackError.printStackTrace()
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/chat/ChatHistoryListAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.chat

import android.app.AlertDialog
import android.content.Context
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.core.graphics.drawable.toDrawable
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.Gson
import java.text.Normalizer
import java.util.Date
import java.util.Locale
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AddNoteDialogBinding
import org.ole.planet.myplanet.databinding.ChatShareDialogBinding
import org.ole.planet.myplanet.databinding.GrandChildRecyclerviewDialogBinding
import org.ole.planet.myplanet.databinding.RowChatHistoryBinding
import org.ole.planet.myplanet.model.Conversation
import org.ole.planet.myplanet.model.RealmChatHistory
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.news.ExpandableListAdapter
import org.ole.planet.myplanet.ui.news.GrandChildAdapter
import org.ole.planet.myplanet.utilities.DiffUtils

data class ChatShareTargets(
    val community: RealmMyTeam?,
    val teams: List<RealmMyTeam>,
    val enterprises: List<RealmMyTeam>,
)

class ChatHistoryListAdapter(
    private val context: Context,
    private var chatHistory: List<RealmChatHistory>,
    private var currentUser: RealmUserModel?,
    private var newsList: List<RealmNews>,
    private var shareTargets: ChatShareTargets,
    private val onShareChat: (HashMap<String?, String>, RealmChatHistory) -> Unit,
) : ListAdapter<RealmChatHistory, ChatHistoryListAdapter.ViewHolderChat>(
    DiffUtils.itemCallback(
        areItemsTheSame = { oldItem, newItem ->
            val oldId = oldItem._id
            val newId = newItem._id
            oldId != null && newId != null && oldId == newId
        },
        areContentsTheSame = { oldItem, newItem ->
            oldItem._rev == newItem._rev &&
                oldItem.lastUsed == newItem.lastUsed &&
                oldItem.title == newItem.title &&
                oldItem.conversations?.firstOrNull()?.query ==
                newItem.conversations?.firstOrNull()?.query
        }
    )
) {
    private lateinit var rowChatHistoryBinding: RowChatHistoryBinding
    private var chatHistoryItemClickListener: ChatHistoryItemClickListener? = null
    private var chatTitle: String? = ""
    private lateinit var expandableListAdapter: ExpandableListAdapter
    private lateinit var expandableTitleList: List<String>
    private lateinit var expandableDetailList: HashMap<String, List<String>>

    init {
        chatHistory = chatHistory.sortedByDescending { it.lastUsed }
        submitList(chatHistory)
    }

    fun updateCachedData(user: RealmUserModel?, sharedNews: List<RealmNews>) {
        currentUser = user
        newsList = sharedNews
    }

    fun updateShareTargets(newTargets: ChatShareTargets) {
        shareTargets = newTargets
    }

    fun notifyChatShared(chatId: String?) {
        val position = currentList.indexOfFirst { it._id == chatId }
        if (position != -1) {
            notifyItemChanged(position)
        }
    }

    interface ChatHistoryItemClickListener {
        fun onChatHistoryItemClicked(conversations: List<Conversation>?, id: String, rev: String?, aiProvider: String?)
    }

    fun setChatHistoryItemClickListener(listener: ChatHistoryItemClickListener) {
        chatHistoryItemClickListener = listener
    }

    fun filter(query: String) {
        val filteredChatHistory = chatHistory.filter { chat ->
            if (chat.conversations != null && chat.conversations?.isNotEmpty() == true) {
                chat.conversations?.get(0)?.query?.contains(query, ignoreCase = true) == true
            } else {
                chat.title?.contains(query, ignoreCase = true) == true
            }
        }
        submitList(filteredChatHistory)
    }

    private fun normalizeText(str: String): String {
        return Normalizer.normalize(str.lowercase(Locale.getDefault()), Normalizer.Form.NFD)
            .replace(Regex("\\p{InCombiningDiacriticalMarks}+"), "")
    }

    fun search(s: String, isFullSearch: Boolean, isQuestion: Boolean) {
        val results = if (isFullSearch) {
            fullConvoSearch(s, isQuestion)
        } else {
            searchByTitle(s)
        }
        submitList(results)
    }

    private fun fullConvoSearch(s: String, isQuestion: Boolean): List<RealmChatHistory> {
        var conversation: String?
        val queryParts = s.split(" ").filterNot { it.isEmpty() }
        val normalizedQuery = normalizeText(s)
        val inTitleStartQuery = mutableListOf<RealmChatHistory>()
        val inTitleContainsQuery = mutableListOf<RealmChatHistory>()
        val startsWithQuery = mutableListOf<RealmChatHistory>()
        val containsQuery = mutableListOf<RealmChatHistory>()

        for (chat in chatHistory) {
            if (chat.conversations != null && chat.conversations?.isNotEmpty() == true) {
                for (i in 0 until chat.conversations!!.size) {
                    conversation = if (isQuestion) {
                        chat.conversations?.get(i)?.query?.let { normalizeText(it) }
                    } else {
                        chat.conversations?.get(i)?.response?.let { normalizeText(it) }
                    }
                    if (conversation == null) continue
                    if (conversation.startsWith(normalizedQuery, ignoreCase = true)) {
                        if (i == 0) inTitleStartQuery.add(chat) else startsWithQuery.add(chat)
                        break
                    } else if (queryParts.all { conversation.contains(normalizeText(it), ignoreCase = true) }) {
                        if (i == 0) inTitleContainsQuery.add(chat) else containsQuery.add(chat)
                        break
                    }
                }
            }
        }
        return inTitleStartQuery + inTitleContainsQuery + startsWithQuery + containsQuery
    }

    private fun searchByTitle(s: String): List<RealmChatHistory> {
        var title: String?
        val queryParts = s.split(" ").filterNot { it.isEmpty() }
        val normalizedQuery = normalizeText(s)
        val startsWithQuery = mutableListOf<RealmChatHistory>()
        val containsQuery = mutableListOf<RealmChatHistory>()

        for (chat in chatHistory) {
            title = if (chat.conversations != null && chat.conversations?.isNotEmpty() == true) {
                chat.conversations?.get(0)?.query?.let { normalizeText(it) }
            } else {
                chat.title?.let { normalizeText(it) }
            }
            if (title == null) continue
            if (title.startsWith(normalizedQuery, ignoreCase = true)) {
                startsWithQuery.add(chat)
            } else if (queryParts.all { title.contains(normalizeText(it), ignoreCase = true) }) {
                containsQuery.add(chat)
            }
        }
        return startsWithQuery + containsQuery
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderChat {
        rowChatHistoryBinding = RowChatHistoryBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderChat(rowChatHistoryBinding)
    }

    fun updateChatHistory(newChatHistory: List<RealmChatHistory>) {
        chatHistory = newChatHistory.sortedByDescending { it.lastUsed }
        submitList(chatHistory)
    }

    override fun onBindViewHolder(holder: ViewHolderChat, position: Int) {
        val item = getItem(position)
        if (item.conversations != null && item.conversations?.isNotEmpty() == true) {
            holder.rowChatHistoryBinding.chatTitle.text = item.conversations?.get(0)?.query
            holder.rowChatHistoryBinding.chatTitle.contentDescription = item.conversations?.get(0)?.query
            chatTitle = item.conversations?.get(0)?.query
        } else {
            holder.rowChatHistoryBinding.chatTitle.text = item.title
            holder.rowChatHistoryBinding.chatTitle.contentDescription = item.title
            chatTitle = item.title
        }

        holder.rowChatHistoryBinding.root.setOnClickListener {
            holder.rowChatHistoryBinding.chatCardView.contentDescription = chatTitle
            chatHistoryItemClickListener?.onChatHistoryItemClicked(
                item.conversations?.toList(),
                "${item._id}",
                item._rev,
                item.aiProvider
            )
        }

        val isInNewsList = newsList.any { newsItem ->
            newsItem.newsId == item._id
        }

        if (isInNewsList) {
            holder.rowChatHistoryBinding.shareChat.setImageResource(R.drawable.baseline_check_24)
        } else {
            holder.rowChatHistoryBinding.shareChat.setImageResource(R.drawable.baseline_share_24)
            holder.rowChatHistoryBinding.shareChat.setOnClickListener {
                val chatShareDialogBinding = ChatShareDialogBinding.inflate(LayoutInflater.from(context))
                var dialog: AlertDialog? = null

                expandableDetailList = getData() as HashMap<String, List<String>>
                expandableTitleList = ArrayList(expandableDetailList.keys)
                expandableListAdapter = ExpandableListAdapter(context, expandableTitleList, expandableDetailList)
                chatShareDialogBinding.listView.setAdapter(expandableListAdapter)

                chatShareDialogBinding.listView.setOnChildClickListener { _, _, groupPosition, childPosition, _ ->
                    if (expandableTitleList[groupPosition] == context.getString(R.string.share_with_team_enterprise)) {
                        val section = expandableDetailList[expandableTitleList[groupPosition]]?.get(childPosition)
                        if (section == context.getString(R.string.teams)) {
                            showGrandChildRecyclerView(shareTargets.teams, context.getString(R.string.teams), item)
                        } else {
                            showGrandChildRecyclerView(shareTargets.enterprises, context.getString(R.string.enterprises), item)
                        }
                    } else {
                        showEditTextAndShareButton(shareTargets.community, context.getString(R.string.community), item)
                    }
                    dialog?.dismiss()
                    false
                }

                val builder = AlertDialog.Builder(context)
                builder.setView(chatShareDialogBinding.root)
                builder.setPositiveButton(context.getString(R.string.close)) { _, _ ->
                    dialog?.dismiss()
                }
                dialog = builder.create()

                val backgroundColor = ContextCompat.getColor(context, R.color.daynight_grey)
                dialog.window?.setBackgroundDrawable(backgroundColor.toDrawable())

                dialog.show()
            }
        }
    }

    private fun showGrandChildRecyclerView(items: List<RealmMyTeam>, section: String, realmChatHistory: RealmChatHistory) {
        val grandChildDialogBinding = GrandChildRecyclerviewDialogBinding.inflate(LayoutInflater.from(context))
        var dialog: AlertDialog? = null

        grandChildDialogBinding.title.text = if (section == context.getString(R.string.teams)) {
            context.getString(R.string.team)
        } else {
            context.getString(R.string.enterprises)
        }

        val grandChildAdapter = GrandChildAdapter(section) { selectedItem ->
            showEditTextAndShareButton(selectedItem, section, realmChatHistory)
            dialog?.dismiss()
        }
        grandChildDialogBinding.recyclerView.layoutManager = LinearLayoutManager(context)
        grandChildDialogBinding.recyclerView.adapter = grandChildAdapter
        grandChildAdapter.submitList(items)

        val builder = AlertDialog.Builder(context, R.style.CustomAlertDialog)
        builder.setView(grandChildDialogBinding.root)
        builder.setPositiveButton(context.getString(R.string.close)) { _, _ ->
            dialog?.dismiss()
        }
        dialog = builder.create()
        val backgroundColor = ContextCompat.getColor(context, R.color.daynight_grey)
        dialog.window?.setBackgroundDrawable(backgroundColor.toDrawable())
        dialog.show()
    }

    private fun showEditTextAndShareButton(team: RealmMyTeam? = null, section: String, chatHistory: RealmChatHistory) {
        val addNoteDialogBinding = AddNoteDialogBinding.inflate(LayoutInflater.from(context))
        val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
        builder.setView(addNoteDialogBinding.root)
        builder.setPositiveButton(context.getString(R.string.share_chat)) { dialog, _ ->
            val serializedConversations = chatHistory.conversations?.map { serializeConversation(it) }
            val serializedMap = HashMap<String?, String>()
            serializedMap["_id"] = chatHistory._id ?: ""
            serializedMap["_rev"] = chatHistory._rev ?: ""
            serializedMap["title"] = "${chatHistory.title}".trim()
            serializedMap["user"] = chatHistory.user ?: ""
            serializedMap["aiProvider"] = chatHistory.aiProvider ?: ""
            serializedMap["createdDate"] = "${Date().time}"
            serializedMap["updatedDate"] = "${Date().time}"
            serializedMap["conversations"] = Gson().toJson(serializedConversations)

            val map = HashMap<String?, String>()
            map["message"] = "${addNoteDialogBinding.editText.text}"
            map["viewInId"] = team?._id ?: ""
            map["viewInSection"] = section
            map["messageType"] = team?.teamType ?: ""
            map["messagePlanetCode"] = team?.teamPlanetCode ?: ""
            map["chat"] = "true"
            map["news"] = Gson().toJson(serializedMap)

            onShareChat(map, chatHistory)
            dialog.dismiss()
        }
        builder.setNegativeButton(context.getString(R.string.cancel)) { dialog, _ ->
            dialog.dismiss()
        }
        val dialog = builder.create()
        dialog.show()
    }

    private fun serializeConversation(conversation: Conversation): HashMap<String?, String> {
        val conversationMap = HashMap<String?, String>()
        conversationMap["query"] = conversation.query ?: ""
        conversationMap["response"] = conversation.response ?: ""
        return conversationMap
    }

    private fun getData(): Map<String, List<String>> {
        val expandableListDetail: MutableMap<String, List<String>> = HashMap()
        val community: MutableList<String> = ArrayList()
        community.add(context.getString(R.string.community))

        val teams: MutableList<String> = ArrayList()
        teams.add(context.getString(R.string.teams))
        teams.add(context.getString(R.string.enterprises))

        expandableListDetail[context.getString(R.string.share_with_community)] = community
        expandableListDetail[context.getString(R.string.share_with_team_enterprise)] = teams
        return expandableListDetail
    }

    class ViewHolderChat(val rowChatHistoryBinding: RowChatHistoryBinding) : RecyclerView.ViewHolder(rowChatHistoryBinding.root)
}
=======
package org.ole.planet.myplanet.ui.chat


import android.app.AlertDialog
import android.content.Context
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.core.graphics.drawable.toDrawable
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.gson.Gson
import java.text.Normalizer
import java.util.Date
import java.util.Locale
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AddNoteDialogBinding
import org.ole.planet.myplanet.databinding.ChatShareDialogBinding
import org.ole.planet.myplanet.databinding.GrandChildRecyclerviewDialogBinding
import org.ole.planet.myplanet.databinding.RowChatHistoryBinding
import org.ole.planet.myplanet.model.Conversation
import org.ole.planet.myplanet.model.RealmChatHistory
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.news.ExpandableListAdapter
import org.ole.planet.myplanet.ui.news.GrandChildAdapter
import org.ole.planet.myplanet.utilities.DiffUtils

data class ChatShareTargets(
    val community: RealmMyTeam?,
    val teams: List<RealmMyTeam>,
    val enterprises: List<RealmMyTeam>,
)

class ChatHistoryListAdapter(
    private val context: Context,
    private var chatHistory: List<RealmChatHistory>,
    private var currentUser: RealmUserModel?,
    private var newsList: List<RealmNews>,
    private var shareTargets: ChatShareTargets,
    private val onShareChat: (HashMap<String?, String>, RealmChatHistory) -> Unit,
) : ListAdapter<RealmChatHistory, ChatHistoryListAdapter.ViewHolderChat>(
    DiffUtils.itemCallback(
        areItemsTheSame = { oldItem, newItem ->
            val oldId = oldItem._id
            val newId = newItem._id
            oldId != null && newId != null && oldId == newId
        },
        areContentsTheSame = { oldItem, newItem ->
            oldItem._rev == newItem._rev &&
                oldItem.lastUsed == newItem.lastUsed &&
                oldItem.title == newItem.title &&
                oldItem.conversations?.firstOrNull()?.query ==
                newItem.conversations?.firstOrNull()?.query
        }
    )
) {
    private lateinit var rowChatHistoryBinding: RowChatHistoryBinding
    private var chatHistoryItemClickListener: ChatHistoryItemClickListener? = null
    private var chatTitle: String? = ""
    private lateinit var expandableListAdapter: ExpandableListAdapter
    private lateinit var expandableTitleList: List<String>
    private lateinit var expandableDetailList: HashMap<String, List<String>>

    init {
        chatHistory = chatHistory.sortedByDescending { it.lastUsed }
        submitList(chatHistory)
    }

    fun updateCachedData(user: RealmUserModel?, sharedNews: List<RealmNews>) {
        currentUser = user
        newsList = sharedNews
    }

    fun updateShareTargets(newTargets: ChatShareTargets) {
        shareTargets = newTargets
    }

    fun notifyChatShared(chatId: String?) {
        val position = currentList.indexOfFirst { it._id == chatId }
        if (position != -1) {
            notifyItemChanged(position)
        }
    }

    interface ChatHistoryItemClickListener {
        fun onChatHistoryItemClicked(conversations: List<Conversation>?, id: String, rev: String?, aiProvider: String?)
    }

    fun setChatHistoryItemClickListener(listener: ChatHistoryItemClickListener) {
        chatHistoryItemClickListener = listener
    }

    fun filter(query: String) {
        val filteredChatHistory = chatHistory.filter { chat ->
            if (chat.conversations != null && chat.conversations?.isNotEmpty() == true) {
                chat.conversations?.get(0)?.query?.contains(query, ignoreCase = true) == true
            } else {
                chat.title?.contains(query, ignoreCase = true) == true
            }
        }
        submitList(filteredChatHistory)
    }

    private fun normalizeText(str: String): String {
        return Normalizer.normalize(str.lowercase(Locale.getDefault()), Normalizer.Form.NFD)
            .replace(Regex("\\p{InCombiningDiacriticalMarks}+"), "")
    }

    fun search(s: String, isFullSearch: Boolean, isQuestion: Boolean) {
        val results = if (isFullSearch) {
            fullConvoSearch(s, isQuestion)
        } else {
            searchByTitle(s)
        }
        submitList(results)
    }

    private fun fullConvoSearch(s: String, isQuestion: Boolean): List<RealmChatHistory> {
        var conversation: String?
        val queryParts = s.split(" ").filterNot { it.isEmpty() }
        val normalizedQuery = normalizeText(s)
        val inTitleStartQuery = mutableListOf<RealmChatHistory>()
        val inTitleContainsQuery = mutableListOf<RealmChatHistory>()
        val startsWithQuery = mutableListOf<RealmChatHistory>()
        val containsQuery = mutableListOf<RealmChatHistory>()

        for (chat in chatHistory) {
            if (chat.conversations != null && chat.conversations?.isNotEmpty() == true) {
                for (i in 0 until chat.conversations!!.size) {
                    conversation = if (isQuestion) {
                        chat.conversations?.get(i)?.query?.let { normalizeText(it) }
                    } else {
                        chat.conversations?.get(i)?.response?.let { normalizeText(it) }
                    }
                    if (conversation == null) continue
                    if (conversation.startsWith(normalizedQuery, ignoreCase = true)) {
                        if (i == 0) inTitleStartQuery.add(chat) else startsWithQuery.add(chat)
                        break
                    } else if (queryParts.all { conversation.contains(normalizeText(it), ignoreCase = true) }) {
                        if (i == 0) inTitleContainsQuery.add(chat) else containsQuery.add(chat)
                        break
                    }
                }
            }
        }
        return inTitleStartQuery + inTitleContainsQuery + startsWithQuery + containsQuery
    }

    private fun searchByTitle(s: String): List<RealmChatHistory> {
        var title: String?
        val queryParts = s.split(" ").filterNot { it.isEmpty() }
        val normalizedQuery = normalizeText(s)
        val startsWithQuery = mutableListOf<RealmChatHistory>()
        val containsQuery = mutableListOf<RealmChatHistory>()

        for (chat in chatHistory) {
            title = if (chat.conversations != null && chat.conversations?.isNotEmpty() == true) {
                chat.conversations?.get(0)?.query?.let { normalizeText(it) }
            } else {
                chat.title?.let { normalizeText(it) }
            }
            if (title == null) continue
            if (title.startsWith(normalizedQuery, ignoreCase = true)) {
                startsWithQuery.add(chat)
            } else if (queryParts.all { title.contains(normalizeText(it), ignoreCase = true) }) {
                containsQuery.add(chat)
            }
        }
        return startsWithQuery + containsQuery
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderChat {
        rowChatHistoryBinding = RowChatHistoryBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderChat(rowChatHistoryBinding)
    }

    fun updateChatHistory(newChatHistory: List<RealmChatHistory>) {
        chatHistory = newChatHistory.sortedByDescending { it.lastUsed }
        submitList(chatHistory)
    }

    override fun onBindViewHolder(holder: ViewHolderChat, position: Int) {
        val item = getItem(position)
        if (item.conversations != null && item.conversations?.isNotEmpty() == true) {
            holder.rowChatHistoryBinding.chatTitle.text = item.conversations?.get(0)?.query
            holder.rowChatHistoryBinding.chatTitle.contentDescription = item.conversations?.get(0)?.query
            chatTitle = item.conversations?.get(0)?.query
        } else {
            holder.rowChatHistoryBinding.chatTitle.text = item.title
            holder.rowChatHistoryBinding.chatTitle.contentDescription = item.title
            chatTitle = item.title
        }

        holder.rowChatHistoryBinding.root.setOnClickListener {
            holder.rowChatHistoryBinding.chatCardView.contentDescription = chatTitle
            chatHistoryItemClickListener?.onChatHistoryItemClicked(
                item.conversations?.toList(),
                "${item._id}",
                item._rev,
                item.aiProvider
            )
        }

        val isInNewsList = newsList.any { newsItem ->
            newsItem.newsId == item._id
        }

        if (isInNewsList) {
            holder.rowChatHistoryBinding.shareChat.setImageResource(R.drawable.baseline_check_24)
        } else {
            holder.rowChatHistoryBinding.shareChat.setImageResource(R.drawable.baseline_share_24)
            holder.rowChatHistoryBinding.shareChat.setOnClickListener {
                val chatShareDialogBinding = ChatShareDialogBinding.inflate(LayoutInflater.from(context))
                var dialog: AlertDialog? = null

                expandableDetailList = getData() as HashMap<String, List<String>>
                expandableTitleList = ArrayList(expandableDetailList.keys)
                expandableListAdapter = ExpandableListAdapter(context, expandableTitleList, expandableDetailList)
                chatShareDialogBinding.listView.setAdapter(expandableListAdapter)

                chatShareDialogBinding.listView.setOnChildClickListener { _, _, groupPosition, childPosition, _ ->
                    if (expandableTitleList[groupPosition] == context.getString(R.string.share_with_team_enterprise)) {
                        val section = expandableDetailList[expandableTitleList[groupPosition]]?.get(childPosition)
                        if (section == context.getString(R.string.teams)) {
                            showGrandChildRecyclerView(shareTargets.teams, context.getString(R.string.teams), item)
                        } else {
                            showGrandChildRecyclerView(shareTargets.enterprises, context.getString(R.string.enterprises), item)
                        }
                    } else {
                        showEditTextAndShareButton(shareTargets.community, context.getString(R.string.community), item)
                    }
                    dialog?.dismiss()
                    false
                }

                val builder = AlertDialog.Builder(context)
                builder.setView(chatShareDialogBinding.root)
                builder.setPositiveButton(context.getString(R.string.close)) { _, _ ->
                    dialog?.dismiss()
                }
                dialog = builder.create()

                val backgroundColor = ContextCompat.getColor(context, R.color.daynight_grey)
                dialog.window?.setBackgroundDrawable(backgroundColor.toDrawable())

                dialog.show()
            }
        }
    }

    private fun showGrandChildRecyclerView(items: List<RealmMyTeam>, section: String, realmChatHistory: RealmChatHistory) {
        val grandChildDialogBinding = GrandChildRecyclerviewDialogBinding.inflate(LayoutInflater.from(context))
        var dialog: AlertDialog? = null

        grandChildDialogBinding.title.text = if (section == context.getString(R.string.teams)) {
            context.getString(R.string.team)
        } else {
            context.getString(R.string.enterprises)
        }

        val grandChildAdapter = GrandChildAdapter(section) { selectedItem ->
            showEditTextAndShareButton(selectedItem, section, realmChatHistory)
            dialog?.dismiss()
        }
        grandChildDialogBinding.recyclerView.layoutManager = LinearLayoutManager(context)
        grandChildDialogBinding.recyclerView.adapter = grandChildAdapter
        grandChildAdapter.submitList(items)

        val builder = AlertDialog.Builder(context, R.style.CustomAlertDialog)
        builder.setView(grandChildDialogBinding.root)
        builder.setPositiveButton(context.getString(R.string.close)) { _, _ ->
            dialog?.dismiss()
        }
        dialog = builder.create()
        val backgroundColor = ContextCompat.getColor(context, R.color.daynight_grey)
        dialog.window?.setBackgroundDrawable(backgroundColor.toDrawable())
        dialog.show()
    }

    private fun showEditTextAndShareButton(team: RealmMyTeam? = null, section: String, chatHistory: RealmChatHistory) {
        val addNoteDialogBinding = AddNoteDialogBinding.inflate(LayoutInflater.from(context))
        val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
        builder.setView(addNoteDialogBinding.root)
        builder.setPositiveButton(context.getString(R.string.share_chat)) { dialog, _ ->
            val serializedConversations = chatHistory.conversations?.map { serializeConversation(it) }
            val serializedMap = HashMap<String?, String>()
            serializedMap["_id"] = chatHistory._id ?: ""
            serializedMap["_rev"] = chatHistory._rev ?: ""
            serializedMap["title"] = "${chatHistory.title}".trim()
            serializedMap["user"] = chatHistory.user ?: ""
            serializedMap["aiProvider"] = chatHistory.aiProvider ?: ""
            serializedMap["createdDate"] = "${Date().time}"
            serializedMap["updatedDate"] = "${Date().time}"
            serializedMap["conversations"] = Gson().toJson(serializedConversations)

            val map = HashMap<String?, String>()
            map["message"] = "${addNoteDialogBinding.editText.text}"
            map["viewInId"] = team?._id ?: ""
            map["viewInSection"] = section
            map["messageType"] = team?.teamType ?: ""
            map["messagePlanetCode"] = team?.teamPlanetCode ?: ""
            map["chat"] = "true"
            map["news"] = Gson().toJson(serializedMap)

            onShareChat(map, chatHistory)
            dialog.dismiss()
        }
        builder.setNegativeButton(context.getString(R.string.cancel)) { dialog, _ ->
            dialog.dismiss()
        }
        val dialog = builder.create()
        dialog.show()
    }

    private fun serializeConversation(conversation: Conversation): HashMap<String?, String> {
        val conversationMap = HashMap<String?, String>()
        conversationMap["query"] = conversation.query ?: ""
        conversationMap["response"] = conversation.response ?: ""
        return conversationMap
    }

    private fun getData(): Map<String, List<String>> {
        val expandableListDetail: MutableMap<String, List<String>> = HashMap()
        val community: MutableList<String> = ArrayList()
        community.add(context.getString(R.string.community))

        val teams: MutableList<String> = ArrayList()
        teams.add(context.getString(R.string.teams))
        teams.add(context.getString(R.string.enterprises))

        expandableListDetail[context.getString(R.string.share_with_community)] = community
        expandableListDetail[context.getString(R.string.share_with_team_enterprise)] = teams
        return expandableListDetail
    }

    class ViewHolderChat(val rowChatHistoryBinding: RowChatHistoryBinding) : RecyclerView.ViewHolder(rowChatHistoryBinding.root)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/chat/ChatHistoryListFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.chat

import android.content.SharedPreferences
import android.content.res.ColorStateList
import android.content.res.Resources
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.activity.OnBackPressedCallback
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.slidingpanelayout.widget.SlidingPaneLayout
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import java.util.HashMap
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment.Companion.showNoData
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.databinding.FragmentChatHistoryListBinding
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.Conversation
import org.ole.planet.myplanet.model.RealmChatHistory
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.ChatRepository
import org.ole.planet.myplanet.repository.NewsRepository
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager

@AndroidEntryPoint
class ChatHistoryListFragment : Fragment() {
    private var _binding: FragmentChatHistoryListBinding? = null
    private val binding get() = _binding!!
    private lateinit var sharedViewModel: ChatViewModel
    var user: RealmUserModel? = null
    private var isFullSearch: Boolean = false
    private var isQuestion: Boolean = false
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    lateinit var prefManager: SharedPrefManager
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    private val serverUrlMapper = ServerUrlMapper()
    private var sharedNewsMessages: List<RealmNews> = emptyList()
    private var shareTargets = ChatShareTargets(null, emptyList(), emptyList())

    @Inject
    lateinit var syncManager: SyncManager
    @Inject
    lateinit var chatRepository: ChatRepository
    @Inject
    lateinit var userRepository: UserRepository
    @Inject
    lateinit var teamRepository: TeamRepository
    @Inject
    lateinit var newsRepository: NewsRepository
    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()
    private lateinit var realtimeSyncListener: BaseRealtimeSyncListener
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        sharedViewModel = ViewModelProvider(requireActivity())[ChatViewModel::class.java]
        prefManager = SharedPrefManager(requireContext())
        startChatHistorySync()
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentChatHistoryListBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val slidingPaneLayout = binding.slidingPaneLayout
        slidingPaneLayout.lockMode = SlidingPaneLayout.LOCK_MODE_LOCKED
        requireActivity().onBackPressedDispatcher.addCallback(viewLifecycleOwner, ChatHistoryListOnBackPressedCallback(slidingPaneLayout))

        setupRealtimeSync()
        binding.toggleGroup.visibility = View.GONE
        binding.newChat.setOnClickListener {
            sharedViewModel.clearChatState()
            if (resources.getBoolean(R.bool.isLargeScreen)) {
                val chatHistoryListFragment = ChatHistoryListFragment()
                NavigationHelper.replaceFragment(
                    parentFragmentManager,
                    R.id.fragment_container,
                    chatHistoryListFragment,
                    addToBackStack = true,
                    tag = "ChatHistoryList"
                )
            } else {
                val chatDetailFragment = ChatDetailFragment()
                NavigationHelper.replaceFragment(
                    parentFragmentManager,
                    R.id.fragment_container,
                    chatDetailFragment,
                    addToBackStack = true,
                    tag = "ChatDetail"
                )
            }
        }

        refreshChatHistoryList()

        binding.searchBar.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                (binding.recyclerView.adapter as? ChatHistoryListAdapter)?.search(s.toString(), isFullSearch, isQuestion)
            }

            override fun afterTextChanged(s: Editable?) {}
        })

        binding.fullSearch.setOnCheckedChangeListener { _, isChecked ->
            val density = Resources.getSystem().displayMetrics.density
            val params = binding.fullSearch.layoutParams as ViewGroup.MarginLayoutParams
            if (isChecked) {
                isFullSearch = true
                binding.toggleGroup.visibility = View.VISIBLE
                params.topMargin = (0 * density).toInt()
            } else {
                isFullSearch = false
                binding.toggleGroup.visibility = View.GONE
                params.topMargin = (20 * density).toInt()
            }
            binding.fullSearch.layoutParams = params
        }

        binding.toggleGroup.addOnButtonCheckedListener { _, checkedId, isChecked ->
            if(isChecked){
                when (checkedId) {
                    R.id.btnQuestions -> {
                        isQuestion = true
                        binding.btnQuestions.strokeColor = ColorStateList.valueOf(ContextCompat.getColor(requireContext(), R.color.mainColor))
                        binding.btnResponses.strokeColor = ColorStateList.valueOf(ContextCompat.getColor(requireContext(), R.color.hint_color))

                        binding.btnQuestions.setTextColor(ContextCompat.getColor(requireContext(), R.color.mainColor))
                        binding.btnResponses.setTextColor(ContextCompat.getColor(requireContext(), R.color.hint_color))
                    }
                    R.id.btnResponses -> {
                        isQuestion = false
                        binding.btnResponses.strokeColor = ColorStateList.valueOf(ContextCompat.getColor(requireContext(), R.color.mainColor))
                        binding.btnQuestions.strokeColor = ColorStateList.valueOf(ContextCompat.getColor(requireContext(), R.color.hint_color))

                        binding.btnResponses.setTextColor(ContextCompat.getColor(requireContext(), R.color.mainColor))
                        binding.btnQuestions.setTextColor(ContextCompat.getColor(requireContext(), R.color.hint_color))
                    }
                }
            }
        }
    }

    override fun onResume() {
        super.onResume()
        refreshChatHistoryList()
    }

    private fun startChatHistorySync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isChatHistorySynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                if (view != null && isAdded) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        if (isAdded && !requireActivity().isFinishing) {
                            customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                            customProgressDialog?.setText(getString(R.string.syncing_chat_history))
                            customProgressDialog?.show()
                        }
                    }
                }
            }

            override fun onSyncComplete() {
                if (view != null && isAdded) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        if (isAdded) {
                            customProgressDialog?.dismiss()
                            customProgressDialog = null
                            prefManager.setChatHistorySynced(true)

                            refreshChatHistoryList()
                        }
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                if (view != null && isAdded) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        if (isAdded) {
                            customProgressDialog?.dismiss()
                            customProgressDialog = null
                            refreshChatHistoryList()

                            Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG)
                                .setAction("Retry") { startChatHistorySync() }.show()
                        }
                    }
                }
            } }, "full", listOf("chat_history"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    fun refreshChatHistoryList() {
        viewLifecycleOwner.lifecycleScope.launch {
            val currentUser = loadCurrentUser()
            sharedNewsMessages = chatRepository.getPlanetNewsMessages(currentUser?.planetCode)
            val list = chatRepository.getChatHistoryForUser(currentUser?.name)
            shareTargets = loadShareTargets()

            val adapter = binding.recyclerView.adapter as? ChatHistoryListAdapter
            if (adapter == null) {
                val newAdapter = ChatHistoryListAdapter(
                    requireContext(),
                    list,
                    currentUser,
                    sharedNewsMessages,
                    shareTargets,
                    ::shareChat,
                )
                newAdapter.setChatHistoryItemClickListener(object : ChatHistoryListAdapter.ChatHistoryItemClickListener {
                    override fun onChatHistoryItemClicked(conversations: List<Conversation>?, id: String, rev: String?, aiProvider: String?) {
                        conversations?.let { sharedViewModel.setSelectedChatHistory(it) }
                        sharedViewModel.setSelectedId(id)
                        rev?.let { sharedViewModel.setSelectedRev(it) }
                        aiProvider?.let { sharedViewModel.setSelectedAiProvider(it) }
                        binding.slidingPaneLayout.openPane()
                    }
                })
                binding.recyclerView.adapter = newAdapter
            } else {
                adapter.updateCachedData(currentUser, sharedNewsMessages)
                adapter.updateShareTargets(shareTargets)
                adapter.updateChatHistory(list)
                binding.searchBar.visibility = View.VISIBLE
                binding.recyclerView.visibility = View.VISIBLE
            }

            showNoData(binding.noChats, list.size, "chatHistory")
            if (list.isEmpty()) {
                binding.searchBar.visibility = View.GONE
                binding.recyclerView.visibility = View.GONE
            }
        }
    }

    private suspend fun loadCurrentUser(): RealmUserModel? {
        val cachedUser = user
        if (cachedUser != null) {
            return cachedUser
        }
        val userId = settings.getString("userId", "")
        if (userId.isNullOrEmpty()) {
            return null
        }
        val fetchedUser = userRepository.getUserById(userId)
        user = fetchedUser
        return fetchedUser
    }

    private suspend fun loadShareTargets(): ChatShareTargets {
        val teams = teamRepository.getShareableTeams()
        val enterprises = teamRepository.getShareableEnterprises()
        val parentCode = settings.getString("parentCode", "")
        val communityName = settings.getString("communityName", "")
        val communityId = if (!communityName.isNullOrBlank() && !parentCode.isNullOrBlank()) {
            "$communityName@$parentCode"
        } else {
            null
        }
        val community = communityId?.let { teamRepository.getTeamById(it) }
        return ChatShareTargets(community, teams, enterprises)
    }

    private fun shareChat(map: HashMap<String?, String>, chatHistory: RealmChatHistory) {
        if (!isAdded || _binding == null) {
            return
        }
        viewLifecycleOwner.lifecycleScope.launch {
            val currentUser = loadCurrentUser()
            val createdNews = newsRepository.createNews(map, currentUser)
            if (currentUser?.planetCode != null) {
                sharedNewsMessages = sharedNewsMessages + createdNews
            }
            (binding.recyclerView.adapter as? ChatHistoryListAdapter)?.let { adapter ->
                adapter.updateCachedData(currentUser, sharedNewsMessages)
                adapter.notifyChatShared(chatHistory._id)
            }
        }
    }

    private fun setupRealtimeSync() {
        realtimeSyncListener = object : BaseRealtimeSyncListener() {
            override fun onTableDataUpdated(update: TableDataUpdate) {
                if (update.table == "chats" && update.shouldRefreshUI) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        refreshChatHistoryList()
                    }
                }
            }
        }
        syncCoordinator.addListener(realtimeSyncListener)
    }

    override fun onDestroyView() {
        if (::realtimeSyncListener.isInitialized) {
            syncCoordinator.removeListener(realtimeSyncListener)
        }
        _binding = null
        super.onDestroyView()
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        super.onDestroy()
    }
}

class ChatHistoryListOnBackPressedCallback(private val slidingPaneLayout: SlidingPaneLayout) :
    OnBackPressedCallback(slidingPaneLayout.isSlideable && slidingPaneLayout.isOpen),
    SlidingPaneLayout.PanelSlideListener {
    init {
        slidingPaneLayout.addPanelSlideListener(this)
    }
    override fun handleOnBackPressed() {
        slidingPaneLayout.closePane()
    }

    override fun onPanelSlide(panel: View, slideOffset: Float) {}

    override fun onPanelOpened(panel: View) {
        isEnabled = true
    }

    override fun onPanelClosed(panel: View) {
        isEnabled = false
    }
}
=======
package org.ole.planet.myplanet.ui.chat


import android.content.SharedPreferences
import android.content.res.ColorStateList
import android.content.res.Resources
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.activity.OnBackPressedCallback
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.slidingpanelayout.widget.SlidingPaneLayout
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import java.util.HashMap
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment.Companion.showNoData
import org.ole.planet.myplanet.callback.BaseRealtimeSyncListener
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.callback.TableDataUpdate
import org.ole.planet.myplanet.databinding.FragmentChatHistoryListBinding
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.Conversation
import org.ole.planet.myplanet.model.RealmChatHistory
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.ChatRepository
import org.ole.planet.myplanet.repository.NewsRepository
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.sync.RealtimeSyncCoordinator
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.SharedPrefManager

@AndroidEntryPoint
class ChatHistoryListFragment : Fragment() {
    private var _binding: FragmentChatHistoryListBinding? = null
    private val binding get() = _binding!!
    private lateinit var sharedViewModel: ChatViewModel
    var user: RealmUserModel? = null
    private var isFullSearch: Boolean = false
    private var isQuestion: Boolean = false
    private var customProgressDialog: DialogUtils.CustomProgressDialog? = null
    lateinit var prefManager: SharedPrefManager
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    private val serverUrlMapper = ServerUrlMapper()
    private var sharedNewsMessages: List<RealmNews> = emptyList()
    private var shareTargets = ChatShareTargets(null, emptyList(), emptyList())

    @Inject
    lateinit var syncManager: SyncManager
    @Inject
    lateinit var chatRepository: ChatRepository
    @Inject
    lateinit var userRepository: UserRepository
    @Inject
    lateinit var teamRepository: TeamRepository
    @Inject
    lateinit var newsRepository: NewsRepository
    private val syncCoordinator = RealtimeSyncCoordinator.getInstance()
    private lateinit var realtimeSyncListener: BaseRealtimeSyncListener
    private val serverUrl: String
        get() = settings.getString("serverURL", "") ?: ""

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        sharedViewModel = ViewModelProvider(requireActivity())[ChatViewModel::class.java]
        prefManager = SharedPrefManager(requireContext())
        startChatHistorySync()
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentChatHistoryListBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val slidingPaneLayout = binding.slidingPaneLayout
        slidingPaneLayout.lockMode = SlidingPaneLayout.LOCK_MODE_LOCKED
        requireActivity().onBackPressedDispatcher.addCallback(viewLifecycleOwner, ChatHistoryListOnBackPressedCallback(slidingPaneLayout))

        setupRealtimeSync()
        binding.toggleGroup.visibility = View.GONE
        binding.newChat.setOnClickListener {
            sharedViewModel.clearChatState()
            if (resources.getBoolean(R.bool.isLargeScreen)) {
                val chatHistoryListFragment = ChatHistoryListFragment()
                NavigationHelper.replaceFragment(
                    parentFragmentManager,
                    R.id.fragment_container,
                    chatHistoryListFragment,
                    addToBackStack = true,
                    tag = "ChatHistoryList"
                )
            } else {
                val chatDetailFragment = ChatDetailFragment()
                NavigationHelper.replaceFragment(
                    parentFragmentManager,
                    R.id.fragment_container,
                    chatDetailFragment,
                    addToBackStack = true,
                    tag = "ChatDetail"
                )
            }
        }

        refreshChatHistoryList()

        binding.searchBar.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                (binding.recyclerView.adapter as? ChatHistoryListAdapter)?.search(s.toString(), isFullSearch, isQuestion)
            }

            override fun afterTextChanged(s: Editable?) {}
        })

        binding.fullSearch.setOnCheckedChangeListener { _, isChecked ->
            val density = Resources.getSystem().displayMetrics.density
            val params = binding.fullSearch.layoutParams as ViewGroup.MarginLayoutParams
            if (isChecked) {
                isFullSearch = true
                binding.toggleGroup.visibility = View.VISIBLE
                params.topMargin = (0 * density).toInt()
            } else {
                isFullSearch = false
                binding.toggleGroup.visibility = View.GONE
                params.topMargin = (20 * density).toInt()
            }
            binding.fullSearch.layoutParams = params
        }

        binding.toggleGroup.addOnButtonCheckedListener { _, checkedId, isChecked ->
            if(isChecked){
                when (checkedId) {
                    R.id.btnQuestions -> {
                        isQuestion = true
                        binding.btnQuestions.strokeColor = ColorStateList.valueOf(ContextCompat.getColor(requireContext(), R.color.mainColor))
                        binding.btnResponses.strokeColor = ColorStateList.valueOf(ContextCompat.getColor(requireContext(), R.color.hint_color))

                        binding.btnQuestions.setTextColor(ContextCompat.getColor(requireContext(), R.color.mainColor))
                        binding.btnResponses.setTextColor(ContextCompat.getColor(requireContext(), R.color.hint_color))
                    }
                    R.id.btnResponses -> {
                        isQuestion = false
                        binding.btnResponses.strokeColor = ColorStateList.valueOf(ContextCompat.getColor(requireContext(), R.color.mainColor))
                        binding.btnQuestions.strokeColor = ColorStateList.valueOf(ContextCompat.getColor(requireContext(), R.color.hint_color))

                        binding.btnResponses.setTextColor(ContextCompat.getColor(requireContext(), R.color.mainColor))
                        binding.btnQuestions.setTextColor(ContextCompat.getColor(requireContext(), R.color.hint_color))
                    }
                }
            }
        }
    }

    override fun onResume() {
        super.onResume()
        refreshChatHistoryList()
    }

    private fun startChatHistorySync() {
        val isFastSync = settings.getBoolean("fastSync", false)
        if (isFastSync && !prefManager.isChatHistorySynced()) {
            checkServerAndStartSync()
        }
    }

    private fun checkServerAndStartSync() {
        val mapping = serverUrlMapper.processUrl(serverUrl)

        lifecycleScope.launch(Dispatchers.IO) {
            updateServerIfNecessary(mapping)
            withContext(Dispatchers.Main) {
                startSyncManager()
            }
        }
    }

    private fun startSyncManager() {
        syncManager.start(object : SyncListener {
            override fun onSyncStarted() {
                if (view != null && isAdded) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        if (isAdded && !requireActivity().isFinishing) {
                            customProgressDialog = DialogUtils.CustomProgressDialog(requireContext())
                            customProgressDialog?.setText(getString(R.string.syncing_chat_history))
                            customProgressDialog?.show()
                        }
                    }
                }
            }

            override fun onSyncComplete() {
                if (view != null && isAdded) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        if (isAdded) {
                            customProgressDialog?.dismiss()
                            customProgressDialog = null
                            prefManager.setChatHistorySynced(true)

                            refreshChatHistoryList()
                        }
                    }
                }
            }

            override fun onSyncFailed(msg: String?) {
                if (view != null && isAdded) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        if (isAdded) {
                            customProgressDialog?.dismiss()
                            customProgressDialog = null
                            refreshChatHistoryList()

                            Snackbar.make(binding.root, "Sync failed: ${msg ?: "Unknown error"}", Snackbar.LENGTH_LONG)
                                .setAction("Retry") { startChatHistorySync() }.show()
                        }
                    }
                }
            } }, "full", listOf("chat_history"))
    }

    private suspend fun updateServerIfNecessary(mapping: ServerUrlMapper.UrlMapping) {
        serverUrlMapper.updateServerIfNecessary(mapping, settings) { url ->
            isServerReachable(url)
        }
    }

    fun refreshChatHistoryList() {
        viewLifecycleOwner.lifecycleScope.launch {
            val currentUser = loadCurrentUser()
            sharedNewsMessages = chatRepository.getPlanetNewsMessages(currentUser?.planetCode)
            val list = chatRepository.getChatHistoryForUser(currentUser?.name)
            shareTargets = loadShareTargets()

            val adapter = binding.recyclerView.adapter as? ChatHistoryListAdapter
            if (adapter == null) {
                val newAdapter = ChatHistoryListAdapter(
                    requireContext(),
                    list,
                    currentUser,
                    sharedNewsMessages,
                    shareTargets,
                    ::shareChat,
                )
                newAdapter.setChatHistoryItemClickListener(object : ChatHistoryListAdapter.ChatHistoryItemClickListener {
                    override fun onChatHistoryItemClicked(conversations: List<Conversation>?, id: String, rev: String?, aiProvider: String?) {
                        conversations?.let { sharedViewModel.setSelectedChatHistory(it) }
                        sharedViewModel.setSelectedId(id)
                        rev?.let { sharedViewModel.setSelectedRev(it) }
                        aiProvider?.let { sharedViewModel.setSelectedAiProvider(it) }
                        binding.slidingPaneLayout.openPane()
                    }
                })
                binding.recyclerView.adapter = newAdapter
            } else {
                adapter.updateCachedData(currentUser, sharedNewsMessages)
                adapter.updateShareTargets(shareTargets)
                adapter.updateChatHistory(list)
                binding.searchBar.visibility = View.VISIBLE
                binding.recyclerView.visibility = View.VISIBLE
            }

            showNoData(binding.noChats, list.size, "chatHistory")
            if (list.isEmpty()) {
                binding.searchBar.visibility = View.GONE
                binding.recyclerView.visibility = View.GONE
            }
        }
    }

    private suspend fun loadCurrentUser(): RealmUserModel? {
        val cachedUser = user
        if (cachedUser != null) {
            return cachedUser
        }
        val userId = settings.getString("userId", "")
        if (userId.isNullOrEmpty()) {
            return null
        }
        val fetchedUser = userRepository.getUserById(userId)
        user = fetchedUser
        return fetchedUser
    }

    private suspend fun loadShareTargets(): ChatShareTargets {
        val teams = teamRepository.getShareableTeams()
        val enterprises = teamRepository.getShareableEnterprises()
        val parentCode = settings.getString("parentCode", "")
        val communityName = settings.getString("communityName", "")
        val communityId = if (!communityName.isNullOrBlank() && !parentCode.isNullOrBlank()) {
            "$communityName@$parentCode"
        } else {
            null
        }
        val community = communityId?.let { teamRepository.getTeamById(it) }
        return ChatShareTargets(community, teams, enterprises)
    }

    private fun shareChat(map: HashMap<String?, String>, chatHistory: RealmChatHistory) {
        if (!isAdded || _binding == null) {
            return
        }
        viewLifecycleOwner.lifecycleScope.launch {
            val currentUser = loadCurrentUser()
            val createdNews = newsRepository.createNews(map, currentUser)
            if (currentUser?.planetCode != null) {
                sharedNewsMessages = sharedNewsMessages + createdNews
            }
            (binding.recyclerView.adapter as? ChatHistoryListAdapter)?.let { adapter ->
                adapter.updateCachedData(currentUser, sharedNewsMessages)
                adapter.notifyChatShared(chatHistory._id)
            }
        }
    }

    private fun setupRealtimeSync() {
        realtimeSyncListener = object : BaseRealtimeSyncListener() {
            override fun onTableDataUpdated(update: TableDataUpdate) {
                if (update.table == "chats" && update.shouldRefreshUI) {
                    viewLifecycleOwner.lifecycleScope.launch {
                        refreshChatHistoryList()
                    }
                }
            }
        }
        syncCoordinator.addListener(realtimeSyncListener)
    }

    override fun onDestroyView() {
        if (::realtimeSyncListener.isInitialized) {
            syncCoordinator.removeListener(realtimeSyncListener)
        }
        _binding = null
        super.onDestroyView()
    }

    override fun onDestroy() {
        customProgressDialog?.dismiss()
        customProgressDialog = null
        super.onDestroy()
    }
}

class ChatHistoryListOnBackPressedCallback(private val slidingPaneLayout: SlidingPaneLayout) :
    OnBackPressedCallback(slidingPaneLayout.isSlideable && slidingPaneLayout.isOpen),
    SlidingPaneLayout.PanelSlideListener {
    init {
        slidingPaneLayout.addPanelSlideListener(this)
    }
    override fun handleOnBackPressed() {
        slidingPaneLayout.closePane()
    }

    override fun onPanelSlide(panel: View, slideOffset: Float) {}

    override fun onPanelOpened(panel: View) {
        isEnabled = true
    }

    override fun onPanelClosed(panel: View) {
        isEnabled = false
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/DisclaimerFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import android.os.Bundle
import android.text.method.LinkMovementMethod
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.text.HtmlCompat
import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentDisclaimerBinding

class DisclaimerFragment : Fragment() {
    private var _binding: FragmentDisclaimerBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentDisclaimerBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.tvDisclaimer.text = HtmlCompat.fromHtml(getString(R.string.disclaimer), HtmlCompat.FROM_HTML_MODE_LEGACY)
        binding.tvDisclaimer.movementMethod = LinkMovementMethod.getInstance()
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard


import android.os.Bundle
import android.text.method.LinkMovementMethod
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.text.HtmlCompat
import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentDisclaimerBinding

class DisclaimerFragment : Fragment() {
    private var _binding: FragmentDisclaimerBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentDisclaimerBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.tvDisclaimer.text = HtmlCompat.fromHtml(getString(R.string.disclaimer), HtmlCompat.FROM_HTML_MODE_LEGACY)
        binding.tvDisclaimer.movementMethod = LinkMovementMethod.getInstance()
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/SurveyAdapter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R

class SurveyAdapter(
    private val onItemClick: (Int) -> Unit,
    private val dialog: AlertDialog
) : ListAdapter<String, SurveyAdapter.SurveyViewHolder>(DIFF_CALLBACK) {

    inner class SurveyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        val textView: TextView = itemView.findViewById(android.R.id.text1)

        init {
            itemView.setOnClickListener {
                onItemClick(bindingAdapterPosition)
                dialog.dismiss()
            }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): SurveyViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(android.R.layout.simple_list_item_1, parent, false)
        return SurveyViewHolder(view)
    }

    override fun onBindViewHolder(holder: SurveyViewHolder, position: Int) {
        holder.textView.text = getItem(position)
        holder.textView.setTextColor(
            ContextCompat.getColor(
                holder.itemView.context,
                R.color.daynight_textColor
            )
        )
    }

    companion object {
        private val DIFF_CALLBACK = object : DiffUtil.ItemCallback<String>() {
            override fun areItemsTheSame(oldItem: String, newItem: String): Boolean {
                return oldItem == newItem
            }

            override fun areContentsTheSame(oldItem: String, newItem: String): Boolean {
                return oldItem == newItem
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard


import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.R

class SurveyAdapter(
    private val onItemClick: (Int) -> Unit,
    private val dialog: AlertDialog
) : ListAdapter<String, SurveyAdapter.SurveyViewHolder>(DIFF_CALLBACK) {

    inner class SurveyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        val textView: TextView = itemView.findViewById(android.R.id.text1)

        init {
            itemView.setOnClickListener {
                onItemClick(bindingAdapterPosition)
                dialog.dismiss()
            }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): SurveyViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(android.R.layout.simple_list_item_1, parent, false)
        return SurveyViewHolder(view)
    }

    override fun onBindViewHolder(holder: SurveyViewHolder, position: Int) {
        holder.textView.text = getItem(position)
        holder.textView.setTextColor(
            ContextCompat.getColor(
                holder.itemView.context,
                R.color.daynight_textColor
            )
        )
    }

    companion object {
        private val DIFF_CALLBACK = object : DiffUtil.ItemCallback<String>() {
            override fun areItemsTheSame(oldItem: String, newItem: String): Boolean {
                return oldItem == newItem
            }

            override fun areContentsTheSame(oldItem: String, newItem: String): Boolean {
                return oldItem == newItem
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/ChallengeHelper.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import android.content.SharedPreferences
import androidx.fragment.app.FragmentManager
import com.google.gson.JsonObject
import io.realm.Realm
import java.text.SimpleDateFormat
import java.time.LocalDate
import java.util.Date
import java.util.Locale
import org.json.JSONArray
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmUserChallengeActions
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.courses.MyProgressFragment
import org.ole.planet.myplanet.ui.courses.TakeCourseFragment
import org.ole.planet.myplanet.utilities.MarkdownDialog

class ChallengeHelper(
    private val activity: DashboardActivity,
    private val realm: Realm,
    private val user: RealmUserModel?,
    private val settings: SharedPreferences,
    private val editor: SharedPreferences.Editor,
    private val viewModel: DashboardViewModel
) {
    private val fragmentManager: FragmentManager
        get() = activity.supportFragmentManager

    fun evaluateChallengeDialog() {
        val startTime = 1730419200000
        val endTime = 1734307200000

        val uniqueDates = fetchVoiceDates(startTime, endTime, user?.id)
        val allUniqueDates = fetchVoiceDates(startTime, endTime, null)

        val courseId = "4e6b78800b6ad18b4e8b0e1e38a98cac"
        val courseData = MyProgressFragment.fetchCourseData(realm, user?.id)
        val progress = MyProgressFragment.getCourseProgress(courseData, courseId)
        val courseName = realm.where(RealmMyCourse::class.java)
            .equalTo("courseId", courseId)
            .findFirst()?.courseTitle

        val hasUnfinishedSurvey = hasPendingSurvey(courseId)

        val validUrls = listOf(
            "https://${BuildConfig.PLANET_GUATEMALA_URL}",
            "http://${BuildConfig.PLANET_XELA_URL}",
            "http://${BuildConfig.PLANET_URIUR_URL}",
            "http://${BuildConfig.PLANET_SANPABLO_URL}",
            "http://${BuildConfig.PLANET_EMBAKASI_URL}",
            "https://${BuildConfig.PLANET_VI_URL}"
        )

        val today = LocalDate.now()
        if (user?.id?.startsWith("guest") == false && shouldPromptChallenge(today, validUrls)) {
            val courseStatus = getCourseStatus(progress, courseName)
            challengeDialog(uniqueDates.size, courseStatus, allUniqueDates.size, hasUnfinishedSurvey)
        }
    }

    private fun fetchVoiceDates(start: Long, end: Long, userId: String?): List<String> {
        val query = realm.where(RealmNews::class.java)
            .greaterThanOrEqualTo("time", start)
            .lessThanOrEqualTo("time", end)
        if (userId != null) query.equalTo("userId", userId)
        val results = query.findAll()
        return results.filter { isCommunitySection(it) }
            .map { getDateFromTimestamp(it.time) }
            .distinct()
    }

    private fun isCommunitySection(news: RealmNews): Boolean {
        news.viewIn?.let { viewInStr ->
            try {
                val viewInArray = JSONArray(viewInStr)
                for (i in 0 until viewInArray.length()) {
                    val viewInObj = viewInArray.getJSONObject(i)
                    if (viewInObj.optString("section") == "community") {
                        return true
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
        return false
    }

    private fun getDateFromTimestamp(timestamp: Long): String {
        val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        return dateFormat.format(Date(timestamp))
    }

    private fun hasPendingSurvey(courseId: String): Boolean {
        return realm.where(RealmStepExam::class.java)
            .equalTo("courseId", courseId)
            .equalTo("type", "survey")
            .findAll()
            .any { survey -> !TakeCourseFragment.existsSubmission(realm, survey.id, "survey") }
    }

    private fun getCourseStatus(progress: JsonObject?, courseName: String?): String {
        return if (progress != null) {
            val max = progress.get("max").asInt
            val current = progress.get("current").asInt
            if (current == max) {
                activity.getString(R.string.course_completed, courseName)
            } else {
                activity.getString(R.string.course_in_progress, courseName, current, max)
            }
        } else {
            activity.getString(R.string.course_not_started, courseName)
        }
    }

    private fun shouldPromptChallenge(today: LocalDate, validUrls: List<String>): Boolean {
        val endDate = LocalDate.of(2025, 1, 16)
        return today.isAfter(LocalDate.of(2024, 11, 30)) &&
            today.isBefore(endDate) &&
            settings.getString("serverURL", "") in validUrls
    }

    private fun challengeDialog(
        voiceCount: Int,
        courseStatus: String,
        allVoiceCount: Int,
        hasUnfinishedSurvey: Boolean
    ) {
        val voiceTaskDone = if (voiceCount >= 5) "" else "[ ]"
        val prereqsMet = courseStatus.contains("terminado", ignoreCase = true) && voiceCount >= 5
        var hasValidSync = false
        val syncTaskDone = if (prereqsMet) {
            hasValidSync = realm.where(RealmUserChallengeActions::class.java)
                .equalTo("userId", user?.id)
                .equalTo("actionType", "sync")
                .count() > 0

            if (hasValidSync) "" else "[ ]"
        } else "[ ]"
        val courseTaskDone = if (courseStatus.contains("terminado", ignoreCase = true)) " $courseStatus" else "[ ] $courseStatus"

        val isCompleted = syncTaskDone.startsWith("") && voiceTaskDone.startsWith("") && courseTaskDone.startsWith("")

        val hasShownCongrats = settings.getBoolean("has_shown_congrats", false)

        if (isCompleted && hasShownCongrats) return

        if (isCompleted && !hasShownCongrats) {
            editor.putBoolean("has_shown_congrats", true).apply()
            val markdownContent = """
        ${activity.getString(R.string.community_earnings, viewModel.calculateCommunityProgress(allVoiceCount, hasUnfinishedSurvey))}
        ${activity.getString(R.string.your_earnings, viewModel.calculateIndividualProgress(voiceCount, hasUnfinishedSurvey))}
        ### ${activity.getString(R.string.congratulations)} <br/>
    """.trimIndent()
            MarkdownDialog.newInstance(markdownContent, courseStatus, voiceCount, allVoiceCount, hasUnfinishedSurvey)
                .show(fragmentManager, "markdown_dialog")
        } else {
            val cappedVoiceCount = minOf(voiceCount, 5)
            val voicesText = if (cappedVoiceCount > 0) {
                "$cappedVoiceCount ${activity.getString(R.string.daily_voices)}"
            } else {
                ""
            }
            val markdownContent = """
        ${activity.getString(R.string.community_earnings, viewModel.calculateCommunityProgress(allVoiceCount, hasUnfinishedSurvey))}
        ${activity.getString(R.string.your_earnings, viewModel.calculateIndividualProgress(voiceCount, hasUnfinishedSurvey))}
        ### ${activity.getString(R.string.per_survey, courseTaskDone)} <br/>
        ### ${activity.getString(R.string.share_opinion)} $voicesText <br/>
        ### ${activity.getString(R.string.remember_sync)} <br/>
    """.trimIndent()
            MarkdownDialog.newInstance(markdownContent, courseStatus, voiceCount, allVoiceCount, hasUnfinishedSurvey)
                .show(fragmentManager, "markdown_dialog")
        }
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard


import android.content.SharedPreferences
import androidx.fragment.app.FragmentManager
import com.google.gson.JsonObject
import io.realm.Realm
import java.text.SimpleDateFormat
import java.time.LocalDate
import java.util.Date
import java.util.Locale
import org.json.JSONArray
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmUserChallengeActions
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.courses.MyProgressFragment
import org.ole.planet.myplanet.ui.courses.TakeCourseFragment
import org.ole.planet.myplanet.utilities.MarkdownDialog

class ChallengeHelper(
    private val activity: DashboardActivity,
    private val realm: Realm,
    private val user: RealmUserModel?,
    private val settings: SharedPreferences,
    private val editor: SharedPreferences.Editor,
    private val viewModel: DashboardViewModel
) {
    private val fragmentManager: FragmentManager
        get() = activity.supportFragmentManager

    fun evaluateChallengeDialog() {
        val startTime = 1730419200000
        val endTime = 1734307200000

        val uniqueDates = fetchVoiceDates(startTime, endTime, user?.id)
        val allUniqueDates = fetchVoiceDates(startTime, endTime, null)

        val courseId = "4e6b78800b6ad18b4e8b0e1e38a98cac"
        val courseData = MyProgressFragment.fetchCourseData(realm, user?.id)
        val progress = MyProgressFragment.getCourseProgress(courseData, courseId)
        val courseName = realm.where(RealmMyCourse::class.java)
            .equalTo("courseId", courseId)
            .findFirst()?.courseTitle

        val hasUnfinishedSurvey = hasPendingSurvey(courseId)

        val validUrls = listOf(
            "https://${BuildConfig.PLANET_GUATEMALA_URL}",
            "http://${BuildConfig.PLANET_XELA_URL}",
            "http://${BuildConfig.PLANET_URIUR_URL}",
            "http://${BuildConfig.PLANET_SANPABLO_URL}",
            "http://${BuildConfig.PLANET_EMBAKASI_URL}",
            "https://${BuildConfig.PLANET_VI_URL}"
        )

        val today = LocalDate.now()
        if (user?.id?.startsWith("guest") == false && shouldPromptChallenge(today, validUrls)) {
            val courseStatus = getCourseStatus(progress, courseName)
            challengeDialog(uniqueDates.size, courseStatus, allUniqueDates.size, hasUnfinishedSurvey)
        }
    }

    private fun fetchVoiceDates(start: Long, end: Long, userId: String?): List<String> {
        val query = realm.where(RealmNews::class.java)
            .greaterThanOrEqualTo("time", start)
            .lessThanOrEqualTo("time", end)
        if (userId != null) query.equalTo("userId", userId)
        val results = query.findAll()
        return results.filter { isCommunitySection(it) }
            .map { getDateFromTimestamp(it.time) }
            .distinct()
    }

    private fun isCommunitySection(news: RealmNews): Boolean {
        news.viewIn?.let { viewInStr ->
            try {
                val viewInArray = JSONArray(viewInStr)
                for (i in 0 until viewInArray.length()) {
                    val viewInObj = viewInArray.getJSONObject(i)
                    if (viewInObj.optString("section") == "community") {
                        return true
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
        return false
    }

    private fun getDateFromTimestamp(timestamp: Long): String {
        val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        return dateFormat.format(Date(timestamp))
    }

    private fun hasPendingSurvey(courseId: String): Boolean {
        return realm.where(RealmStepExam::class.java)
            .equalTo("courseId", courseId)
            .equalTo("type", "survey")
            .findAll()
            .any { survey -> !TakeCourseFragment.existsSubmission(realm, survey.id, "survey") }
    }

    private fun getCourseStatus(progress: JsonObject?, courseName: String?): String {
        return if (progress != null) {
            val max = progress.get("max").asInt
            val current = progress.get("current").asInt
            if (current == max) {
                activity.getString(R.string.course_completed, courseName)
            } else {
                activity.getString(R.string.course_in_progress, courseName, current, max)
            }
        } else {
            activity.getString(R.string.course_not_started, courseName)
        }
    }

    private fun shouldPromptChallenge(today: LocalDate, validUrls: List<String>): Boolean {
        val endDate = LocalDate.of(2025, 1, 16)
        return today.isAfter(LocalDate.of(2024, 11, 30)) &&
            today.isBefore(endDate) &&
            settings.getString("serverURL", "") in validUrls
    }

    private fun challengeDialog(
        voiceCount: Int,
        courseStatus: String,
        allVoiceCount: Int,
        hasUnfinishedSurvey: Boolean
    ) {
        val voiceTaskDone = if (voiceCount >= 5) "" else "[ ]"
        val prereqsMet = courseStatus.contains("terminado", ignoreCase = true) && voiceCount >= 5
        var hasValidSync = false
        val syncTaskDone = if (prereqsMet) {
            hasValidSync = realm.where(RealmUserChallengeActions::class.java)
                .equalTo("userId", user?.id)
                .equalTo("actionType", "sync")
                .count() > 0

            if (hasValidSync) "" else "[ ]"
        } else "[ ]"
        val courseTaskDone = if (courseStatus.contains("terminado", ignoreCase = true)) " $courseStatus" else "[ ] $courseStatus"

        val isCompleted = syncTaskDone.startsWith("") && voiceTaskDone.startsWith("") && courseTaskDone.startsWith("")

        val hasShownCongrats = settings.getBoolean("has_shown_congrats", false)

        if (isCompleted && hasShownCongrats) return

        if (isCompleted && !hasShownCongrats) {
            editor.putBoolean("has_shown_congrats", true).apply()
            val markdownContent = """
        ${activity.getString(R.string.community_earnings, viewModel.calculateCommunityProgress(allVoiceCount, hasUnfinishedSurvey))}
        ${activity.getString(R.string.your_earnings, viewModel.calculateIndividualProgress(voiceCount, hasUnfinishedSurvey))}
        ### ${activity.getString(R.string.congratulations)} <br/>
    """.trimIndent()
            MarkdownDialog.newInstance(markdownContent, courseStatus, voiceCount, allVoiceCount, hasUnfinishedSurvey)
                .show(fragmentManager, "markdown_dialog")
        } else {
            val cappedVoiceCount = minOf(voiceCount, 5)
            val voicesText = if (cappedVoiceCount > 0) {
                "$cappedVoiceCount ${activity.getString(R.string.daily_voices)}"
            } else {
                ""
            }
            val markdownContent = """
        ${activity.getString(R.string.community_earnings, viewModel.calculateCommunityProgress(allVoiceCount, hasUnfinishedSurvey))}
        ${activity.getString(R.string.your_earnings, viewModel.calculateIndividualProgress(voiceCount, hasUnfinishedSurvey))}
        ### ${activity.getString(R.string.per_survey, courseTaskDone)} <br/>
        ### ${activity.getString(R.string.share_opinion)} $voicesText <br/>
        ### ${activity.getString(R.string.remember_sync)} <br/>
    """.trimIndent()
            MarkdownDialog.newInstance(markdownContent, courseStatus, voiceCount, allVoiceCount, hasUnfinishedSurvey)
                .show(fragmentManager, "markdown_dialog")
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/DashboardActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import android.app.AlertDialog
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.res.Configuration
import android.graphics.Color
import android.graphics.PorterDuff
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.widget.TextView
import androidx.activity.OnBackPressedCallback
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatDelegate
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import androidx.core.content.res.ResourcesCompat
import androidx.core.view.MenuItemCompat
import androidx.drawerlayout.widget.DrawerLayout
import androidx.fragment.app.Fragment
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import com.google.android.material.navigation.NavigationBarView
import com.google.android.material.snackbar.Snackbar
import com.google.android.material.tabs.TabLayout
import com.google.android.material.tabs.TabLayout.OnTabSelectedListener
import com.mikepenz.materialdrawer.AccountHeader
import com.mikepenz.materialdrawer.AccountHeaderBuilder
import com.mikepenz.materialdrawer.Drawer
import com.mikepenz.materialdrawer.DrawerBuilder
import com.mikepenz.materialdrawer.holder.DimenHolder
import com.mikepenz.materialdrawer.model.PrimaryDrawerItem
import com.mikepenz.materialdrawer.model.interfaces.IDrawerItem
import com.mikepenz.materialdrawer.model.interfaces.Nameable
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Case
import io.realm.Realm
import io.realm.RealmChangeListener
import io.realm.RealmObject
import io.realm.RealmResults
import javax.inject.Inject
import kotlin.math.ceil
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.ActivityDashboardBinding
import org.ole.planet.myplanet.databinding.CustomTabBinding
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNotification
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.SettingActivity
import org.ole.planet.myplanet.ui.chat.ChatHistoryListFragment
import org.ole.planet.myplanet.ui.community.CommunityTabFragment
import org.ole.planet.myplanet.ui.courses.CoursesFragment
import org.ole.planet.myplanet.ui.dashboard.notification.NotificationListener
import org.ole.planet.myplanet.ui.dashboard.notification.NotificationsFragment
import org.ole.planet.myplanet.ui.feedback.FeedbackListFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.resources.ResourceDetailFragment
import org.ole.planet.myplanet.ui.resources.ResourcesFragment
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission
import org.ole.planet.myplanet.ui.survey.SendSurveyFragment
import org.ole.planet.myplanet.ui.survey.SurveyFragment
import org.ole.planet.myplanet.ui.sync.DashboardElementActivity
import org.ole.planet.myplanet.ui.team.TeamDetailFragment
import org.ole.planet.myplanet.ui.team.TeamFragment
import org.ole.planet.myplanet.ui.team.TeamPageConfig.JoinRequestsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.TasksPage
import org.ole.planet.myplanet.ui.userprofile.BecomeMemberActivity
import org.ole.planet.myplanet.utilities.Constants.isBetaWifiFeatureEnabled
import org.ole.planet.myplanet.utilities.DialogUtils.guestDialog
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.KeyboardUtils.setupUI
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.NotificationUtils
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities.toast

@AndroidEntryPoint
class DashboardActivity : DashboardElementActivity(), OnHomeItemClickListener, NavigationBarView.OnItemSelectedListener, NotificationListener {

    private lateinit var binding: ActivityDashboardBinding
    private var headerResult: AccountHeader? = null
    var user: RealmUserModel? = null
    var result: Drawer? = null
    private var tl: TabLayout? = null
    private var dl: DrawerLayout? = null
    private val realmListeners = mutableListOf<RealmListener>()
    private val dashboardViewModel: DashboardViewModel by viewModels()
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    @Inject
    lateinit var teamRepository: TeamRepository
    private lateinit var challengeHelper: ChallengeHelper
    private lateinit var notificationManager: NotificationUtils.NotificationManager
    private var notificationsShownThisSession = false
    private var lastNotificationCheckTime = 0L
    private val notificationCheckThrottleMs = 5000L
    private var systemNotificationReceiver: BroadcastReceiver? = null
    private lateinit var mRealm: Realm

    private interface RealmListener {
        fun removeListener()
    }

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(base))
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        mRealm = databaseService.realmInstance
        checkUser()
        initViews()
        updateAppTitle()
        notificationManager = NotificationUtils.getInstance(this)
        if (handleGuestAccess()) return
        setupNavigation()
        handleInitialFragment()
        setupToolbarActions()
        hideWifi()
        setupRealmListeners()
        setupSystemNotificationReceiver()
        checkIfShouldShowNotifications()
        addBackPressCallback()
        challengeHelper = ChallengeHelper(this, mRealm, user, settings, editor, dashboardViewModel)
        challengeHelper.evaluateChallengeDialog()
        handleNotificationIntent(intent)
        collectUiState()
    }

    private fun collectUiState() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                dashboardViewModel.uiState.collect { state ->
                    updateNotificationBadge(state.unreadNotifications) {
                        openNotificationsList(user?.id ?: "")
                    }
                }
            }
        }
    }

    private fun initViews() {
        binding = ActivityDashboardBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        setupUI(binding.activityDashboardParentLayout, this@DashboardActivity)
        setSupportActionBar(binding.myToolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(false)
        supportActionBar?.setTitle(R.string.app_project_name)
        binding.myToolbar.setTitleTextColor(Color.WHITE)
        binding.myToolbar.setSubtitleTextColor(Color.WHITE)
        navigationView = binding.topBarNavigation
        navigationView.labelVisibilityMode = NavigationBarView.LABEL_VISIBILITY_LABELED
        binding.appBarBell.bellToolbar.inflateMenu(R.menu.menu_bell_dashboard)
        service = Service(this)
        tl = findViewById(R.id.tab_layout)
        binding.root.viewTreeObserver.addOnGlobalLayoutListener { topBarVisible() }
        binding.appBarBell.ivSetting.setOnClickListener {
            startActivity(Intent(this, SettingActivity::class.java))
        }
    }

    private fun updateAppTitle() {
        try {
            val userProfileModel = profileDbHandler.userModel
            if (userProfileModel != null) {
                var name: String? = userProfileModel.getFullName()
                if (name.isNullOrBlank()) {
                    name = profileDbHandler.userModel?.name
                }
                val communityName = settings.getString("communityName", "")
                binding.appBarBell.appTitleName.text = if (user?.planetCode == "") {
                    "${getString(R.string.planet)} $communityName"
                } else {
                    "${getString(R.string.planet)} ${user?.planetCode}"
                }
            } else {
                binding.appBarBell.appTitleName.text = getString(R.string.app_project_name)
            }
        } catch (err: Exception) {
            throw RuntimeException(err)
        }
    }

    private fun handleGuestAccess(): Boolean {
        if (user != null && user?.rolesList?.isEmpty() == true && !user?.userAdmin!!) {
            navigationView.visibility = View.GONE
            openCallFragment(InactiveDashboardFragment(), "Dashboard")
            return true
        }
        navigationView.setOnItemSelectedListener(this)
        val isTopBarVisible = userProfileDbHandler.userModel?.isShowTopbar == true
        navigationView.visibility = if (isTopBarVisible) {
            View.VISIBLE
        } else {
            View.GONE
        }
        return false
    }

    private fun setupNavigation() {
        headerResult = accountHeader
        createDrawer()
        supportFragmentManager.addOnBackStackChangedListener {
            val frag = supportFragmentManager.findFragmentById(R.id.fragment_container)
            val idToSelect = when (frag) {
                is BellDashboardFragment -> 0L
                is ResourcesFragment -> {
                    val isMy = frag.arguments?.getBoolean("isMyCourseLib", false) == true
                    if (isMy) 1L else 3L
                }
                is CoursesFragment -> {
                    val isMy = frag.arguments?.getBoolean("isMyCourseLib", false) == true
                    if (isMy) 2L else 4L
                }
                is TeamFragment -> {
                    val isDashboard = frag.arguments?.getBoolean("fromDashboard", false) == true
                    val isEnterprise = frag.arguments?.getString("type") == "enterprise"
                    if (isDashboard) 0L else if (isEnterprise) 6L else 5L
                }
                is CommunityTabFragment -> 7L
                is SurveyFragment -> 8L
                else -> null
            }
            idToSelect?.let { result?.setSelection(it, false) }
        }
        result?.actionBarDrawerToggle?.isDrawerIndicatorEnabled = true
        dl = result?.drawerLayout
        topbarSetting()

        lifecycleScope.launch {
            delay(50)
            if (!(user?.id?.startsWith("guest") == true && profileDbHandler.offlineVisits >= 3) &&
                resources.configuration.orientation == Configuration.ORIENTATION_PORTRAIT
            ) {
                result?.openDrawer()
            }
        }
    }

    private fun handleInitialFragment() {
        if (intent != null && intent.hasExtra("fragmentToOpen")) {
            val fragmentToOpen = intent.getStringExtra("fragmentToOpen")
            if ("feedbackList" == fragmentToOpen) {
                openMyFragment(FeedbackListFragment())
            }
        } else {
            openCallFragment(BellDashboardFragment())
            binding.appBarBell.bellToolbar.visibility = View.VISIBLE
        }
    }

    private fun setupToolbarActions() {
        binding.appBarBell.ivSync.setOnClickListener { logSyncInSharedPrefs() }
        binding.appBarBell.imgLogo.setOnClickListener { result?.openDrawer() }
        binding.appBarBell.bellToolbar.setOnMenuItemClickListener { item ->
            handleToolbarMenuItem(item.itemId)
            true
        }
    }

    private fun handleToolbarMenuItem(itemId: Int) {
        when (itemId) {
            R.id.action_chat -> {
                if (user?.id?.startsWith("guest") == false) {
                    openCallFragment(
                        ChatHistoryListFragment(),
                        ChatHistoryListFragment::class.java.simpleName
                    )
                } else {
                    guestDialog(this)
                }
            }
            R.id.menu_goOnline -> wifiStatusSwitch()
            R.id.action_sync -> logSyncInSharedPrefs()
            R.id.action_feedback -> {
                if (user?.id?.startsWith("guest") == false) {
                    openCallFragment(
                        FeedbackListFragment(),
                        FeedbackListFragment::class.java.simpleName
                    )
                } else {
                    guestDialog(this)
                }
            }
            R.id.action_settings -> startActivity(Intent(this@DashboardActivity, SettingActivity::class.java))
            R.id.action_disclaimer -> openCallFragment(DisclaimerFragment(), DisclaimerFragment::class.java.simpleName)
            R.id.action_about -> openCallFragment(AboutFragment(), AboutFragment::class.java.simpleName)
            R.id.action_logout -> logout()
            R.id.change_language -> SettingActivity.SettingFragment.languageChanger(this)
            else -> {}
        }
    }

    private fun addBackPressCallback() {
        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                if (result != null && result?.isDrawerOpen == true) {
                    result?.closeDrawer()
                } else {
                    if (supportFragmentManager.backStackEntryCount > 1) {
                        NavigationHelper.popBackStack(supportFragmentManager)
                    } else {
                        if (!doubleBackToExitPressedOnce) {
                            doubleBackToExitPressedOnce = true
                            toast(MainApplication.context, getString(R.string.press_back_again_to_exit))
                            lifecycleScope.launch {
                                delay(2000)
                                doubleBackToExitPressedOnce = false
                            }
                        } else {
                            val fragment = supportFragmentManager.findFragmentById(R.id.fragment_container)
                            if (!BuildConfig.LITE && fragment is BaseContainerFragment) {
                                fragment.handleBackPressed()
                            }
                            finish()
                        }
                    }
                }
            }
        })
    }

    private fun handleNotificationIntent(intent: Intent?) {
        val fromNotification = intent?.getBooleanExtra("from_notification", false) ?: false
        if (fromNotification) {
            val notificationType = intent.getStringExtra("notification_type")
            val notificationId = intent.getStringExtra("notification_id")

            notificationId?.let {
                notificationManager.clearNotification(it)
                markDatabaseNotificationAsRead(it)
            }

            when (notificationType) {
                NotificationUtils.TYPE_SURVEY -> {
                    val surveyId = intent.getStringExtra("surveyId")
                    if (surveyId != null) {
                        openCallFragment(SurveyFragment().apply {
                            arguments = Bundle().apply {
                                putString("surveyId", surveyId)
                            }
                        })
                    } else {
                        openNotificationsList(user?.id ?: "")
                    }
                }
                NotificationUtils.TYPE_TASK -> {
                    val taskId = intent.getStringExtra("taskId")
                    if (taskId != null) {
                        openMyFragment(TeamFragment().apply {
                            arguments = Bundle().apply {
                                putString("taskId", taskId)
                            }
                        })
                    } else {
                        openNotificationsList(user?.id ?: "")
                    }
                }
                NotificationUtils.TYPE_STORAGE -> {
                    startActivity(Intent(this, SettingActivity::class.java))
                }
                NotificationUtils.TYPE_JOIN_REQUEST -> {
                    val teamName = intent.getStringExtra("teamName")
                    openMyFragment(TeamFragment().apply {
                        arguments = Bundle().apply {
                            teamName?.let { putString("teamName", it) }
                        }
                    })
                }
                else -> {
                    openNotificationsList(user?.id ?: "")
                }
            }
        }

        if (intent?.getBooleanExtra("auto_navigate", false) == true) {
            isFromNotificationAction = true
            result?.closeDrawer()

            val notificationType = intent.getStringExtra("notification_type")
            val relatedId = intent.getStringExtra("related_id")

            when (notificationType) {
                NotificationUtils.TYPE_SURVEY -> {
                    lifecycleScope.launch {
                        handleSurveyNavigation(relatedId)
                    }
                }
                NotificationUtils.TYPE_TASK -> {
                    lifecycleScope.launch {
                        handleTaskNavigation(relatedId)
                    }
                }
                NotificationUtils.TYPE_JOIN_REQUEST -> {
                    lifecycleScope.launch {
                        handleJoinRequestNavigation(relatedId)
                    }
                }
                NotificationUtils.TYPE_RESOURCE -> {
                    openCallFragment(ResourcesFragment(), "Resources")
                }
            }

            lifecycleScope.launch {
                delay(1000)
                isFromNotificationAction = false
            }
        }
    }

    private suspend fun handleSurveyNavigation(surveyId: String?) {
        if (surveyId != null) {
            val currentStepExam = withContext(Dispatchers.IO) {
                Realm.getDefaultInstance().use { realm ->
                    realm.where(RealmStepExam::class.java).equalTo("name", surveyId)
                        .findFirst()?.let {
                            realm.copyFromRealm(it)
                        }
                }
            }
            AdapterMySubmission.openSurvey(this, currentStepExam?.id, false, false, "")
        }
    }

    private suspend fun handleTaskNavigation(taskId: String?) {
        if (taskId == null) return

        val teamData = teamRepository.getTaskTeamInfo(taskId)

        teamData?.let { (teamId, teamName, teamType) ->
            val f = TeamDetailFragment.newInstance(
                teamId = teamId,
                teamName = teamName,
                teamType = teamType,
                isMyTeam = true,
                navigateToPage = TasksPage
            )
            openCallFragment(f)
        }
    }

    private suspend fun handleJoinRequestNavigation(requestId: String?) {
        if (requestId != null) {
            val actualJoinRequestId = if (requestId.startsWith("join_request_")) {
                requestId.removePrefix("join_request_")
            } else {
                requestId
            }

            val teamId = teamRepository.getJoinRequestTeamId(actualJoinRequestId)

            if (teamId?.isNotEmpty() == true) {
                val f = TeamDetailFragment()
                val b = Bundle()
                b.putString("id", teamId)
                b.putBoolean("isMyTeam", true)
                b.putString("navigateToPage", JoinRequestsPage.id)
                f.arguments = b
                openCallFragment(f)
            }
        }
    }
    private fun setupRealmListeners() {
        if (mRealm.isInTransaction) {
            mRealm.commitTransaction()
        }
        setupListener {
            mRealm.where(RealmMyLibrary::class.java).findAllAsync()
        }

        setupListener {
            mRealm.where(RealmSubmission::class.java)
                .equalTo("userId", user?.id)
                .equalTo("type", "survey")
                .equalTo("status", "pending", Case.INSENSITIVE)
                .findAllAsync()
        }

        setupListener {
            mRealm.where(RealmTeamTask::class.java)
                .notEqualTo("status", "archived")
                .equalTo("completed", false)
                .equalTo("assignee", user?.id)
                .findAllAsync()
        }
    }

    private inline fun <reified T : RealmObject> setupListener(crossinline query: () -> RealmResults<T>) {
        val results = query()
        val listener = RealmChangeListener<RealmResults<T>> { _ ->
            if (notificationsShownThisSession) {
                val currentTime = System.currentTimeMillis()
                if (currentTime - lastNotificationCheckTime > notificationCheckThrottleMs) {
                    lastNotificationCheckTime = currentTime
                    checkAndCreateNewNotifications()
                }
            }
        }
        results.addChangeListener(listener)
        realmListeners.add(object : RealmListener {
            override fun removeListener() {
                results.removeChangeListener(listener)
            }
        })
    }

    private fun setupSystemNotificationReceiver() {
        systemNotificationReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context?, intent: Intent?) {
                if (intent?.action == "org.ole.planet.myplanet.NOTIFICATION_READ_FROM_SYSTEM") {
                    val userId = user?.id
                    if (userId != null) {
                        val fragment = supportFragmentManager.findFragmentById(R.id.fragment_container)
                        if (fragment is NotificationsFragment) {
                            fragment.view?.post {
                                fragment.refreshNotificationsList()
                            }
                        } else {
                            lifecycleScope.launch {
                                delay(300)
                                try {
                                    mRealm.refresh()
                                    val unreadCount = dashboardViewModel.getUnreadNotificationsSize(userId)
                                    onNotificationCountUpdated(unreadCount)
                                } catch (e: Exception) {
                                    e.printStackTrace()
                                    delay(300)
                                    try {
                                        mRealm.refresh()
                                        val unreadCount = dashboardViewModel.getUnreadNotificationsSize(userId)
                                        onNotificationCountUpdated(unreadCount)
                                    } catch (e2: Exception) {
                                        e2.printStackTrace()
                                    }
                                }
                            }
                        }
                    } else {
                        android.util.Log.w("DashboardActivity", "SystemNotificationReceiver: User ID is null")
                    }
                }
            }
        }

        val filter = IntentFilter("org.ole.planet.myplanet.NOTIFICATION_READ_FROM_SYSTEM")
        if (Build.VERSION.SDK_INT >= 33) {
            registerReceiver(systemNotificationReceiver, filter, RECEIVER_NOT_EXPORTED)
        } else {
            @Suppress("UnspecifiedRegisterReceiverFlag")
            registerReceiver(systemNotificationReceiver, filter)
        }
    }

    private fun checkIfShouldShowNotifications() {
        val fromLogin = intent.getBooleanExtra("from_login", false)
        if (fromLogin || !notificationsShownThisSession) {
            notificationsShownThisSession = true
            lifecycleScope.launch {
                kotlinx.coroutines.delay(1000)
                checkAndCreateNewNotifications()
            }
        }
    }

    private fun checkAndCreateNewNotifications() {
        val userId = user?.id

        lifecycleScope.launch(Dispatchers.IO) {
            var unreadCount = 0
            val newNotifications = mutableListOf<NotificationUtils.NotificationConfig>()

            try {
                dashboardViewModel.updateResourceNotification(userId)
                databaseService.realmInstance.use { backgroundRealm ->
                    val createdNotifications = createNotifications(backgroundRealm, userId)
                    newNotifications.addAll(createdNotifications)

                    unreadCount = dashboardViewModel.getUnreadNotificationsSize(userId)
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }

            withContext(Dispatchers.Main) {
                try {
                    onNotificationCountUpdated(unreadCount)

                    val groupedNotifications = newNotifications.groupBy { it.type }

                    groupedNotifications.forEach { (type, notifications) ->
                        when {
                            notifications.size == 1 -> {
                                notificationManager.showNotification(notifications.first())
                            }
                            notifications.size > 1 -> {
                                val summaryConfig = createSummaryNotification(type, notifications.size)
                                notificationManager.showNotification(summaryConfig)
                            }
                        }
                    }

                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }
    }

    private fun markDatabaseNotificationAsRead(notificationId: String) {
        try {
            val userId = user?.id
            if (notificationId.startsWith("summary_")) {
                val type = notificationId.removePrefix("summary_")
                mRealm.executeTransactionAsync { realm ->
                    realm.where(RealmNotification::class.java)
                        .equalTo("userId", userId)
                        .equalTo("type", type)
                        .equalTo("isRead", false)
                        .findAll()
                        .forEach { it.isRead = true }
                }
            } else {
                mRealm.executeTransactionAsync { realm ->
                    val notification = realm.where(RealmNotification::class.java)
                        .equalTo("id", notificationId)
                        .findFirst()
                    notification?.isRead = true
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun createSummaryNotification(type: String, count: Int): NotificationUtils.NotificationConfig {
        val summaryId = "summary_${type}"

        return when (type) {
            "survey" -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " New Surveys Available",
                message = "$count new surveys are waiting for you",
                priority = NotificationCompat.PRIORITY_HIGH,
                category = NotificationCompat.CATEGORY_REMINDER
            )
            "task" -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " New Tasks Assigned",
                message = "$count new tasks have been assigned to you",
                priority = NotificationCompat.PRIORITY_HIGH,
                category = NotificationCompat.CATEGORY_REMINDER
            )
            "join_request" -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " Team Join Requests",
                message = "$count new team join requests to review",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_SOCIAL
            )
            "resource" -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " New Resources Available",
                message = "$count new resources have been added",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_RECOMMENDATION
            )
            "storage" -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " Storage Warnings",
                message = "$count storage warnings need attention",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_STATUS
            )
            else -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " App Notifications",
                message = "$count new notifications",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_MESSAGE
            )
        }
    }

    private suspend fun createNotifications(
        realm: Realm,
        userId: String?,
    ): List<NotificationUtils.NotificationConfig> {
        val surveyTitles = collectSurveyData(realm, userId)
        val taskData = collectTaskData(realm, userId)
        val joinRequestData = collectJoinRequestData(realm, userId)
        val storageRatio = FileUtils.totalAvailableMemoryRatio(this)

        val notificationConfigs = realm.where(RealmNotification::class.java)
            .equalTo("userId", userId)
            .equalTo("isRead", false)
            .findAll()
            .mapNotNull { dbNotification ->
                createNotificationConfigFromDatabase(dbNotification)
            }
            .toMutableList()

        surveyTitles.forEach { title ->
            dashboardViewModel.createNotificationIfMissing("survey", title, title, userId)
        }

        taskData.forEach { (title, deadline, id) ->
            dashboardViewModel.createNotificationIfMissing("task", "$title $deadline", id, userId)
        }

        if (storageRatio > 85) {
            dashboardViewModel.createNotificationIfMissing("storage", "$storageRatio%", "storage", userId)
        }
        dashboardViewModel.createNotificationIfMissing("storage", "90%", "storage_test", userId)

        joinRequestData.forEach { (message, id) ->
            dashboardViewModel.createNotificationIfMissing("join_request", message, id, userId)
        }
        return notificationConfigs
    }

    private fun collectSurveyData(realm: Realm, userId: String?): List<String> {
        return realm.where(RealmSubmission::class.java)
            .equalTo("userId", userId)
            .equalTo("status", "pending")
            .equalTo("type", "survey")
            .findAll()
            .mapNotNull { submission ->
                val examId = submission.parentId?.split("@")?.firstOrNull() ?: ""
                realm.where(RealmStepExam::class.java)
                    .equalTo("id", examId)
                    .findFirst()
                    ?.name
            }
    }

    private fun collectTaskData(realm: Realm, userId: String?): List<Triple<String, String, String>> {
        return realm.where(RealmTeamTask::class.java)
            .notEqualTo("status", "archived")
            .equalTo("completed", false)
            .equalTo("assignee", userId)
            .findAll()
            .mapNotNull { task ->
                val title = task.title ?: return@mapNotNull null
                val id = task.id ?: return@mapNotNull null
                Triple(title, formatDate(task.deadline), id)
            }
    }

    private fun collectJoinRequestData(realm: Realm, userId: String?): List<Pair<String, String>> {
        return realm.where(RealmMyTeam::class.java)
            .equalTo("userId", userId)
            .equalTo("docType", "membership")
            .equalTo("isLeader", true)
            .findAll()
            .flatMap { leadership ->
                realm.where(RealmMyTeam::class.java)
                    .equalTo("teamId", leadership.teamId)
                    .equalTo("docType", "request")
                    .findAll()
                    .mapNotNull { joinRequest ->
                        joinRequest._id?.let { requestId ->
                            val team = realm.where(RealmMyTeam::class.java)
                                .equalTo("_id", leadership.teamId)
                                .findFirst()

                            val requester = realm.where(RealmUserModel::class.java)
                                .equalTo("id", joinRequest.userId)
                                .findFirst()

                            val requesterName = requester?.name ?: "Unknown User"
                            val teamName = team?.name ?: "Unknown Team"
                            val message = getString(R.string.user_requested_to_join_team, requesterName, teamName)

                            Pair(message, requestId)
                        }
                    }
            }
    }

    private fun createNotificationConfigFromDatabase(dbNotification: RealmNotification): NotificationUtils.NotificationConfig? {
        return when (dbNotification.type.lowercase()) {
            "survey" -> notificationManager.createSurveyNotification(
                dbNotification.id,
                dbNotification.message
            ).copy(
                extras = mapOf("surveyId" to (dbNotification.relatedId ?: dbNotification.id))
            )
            "task" -> {
                val parts = dbNotification.message.split(" ")
                val taskTitle = parts.dropLast(3).joinToString(" ")
                val deadline = parts.takeLast(3).joinToString(" ")
                notificationManager.createTaskNotification(dbNotification.id, taskTitle, deadline).copy(
                    extras = mapOf("taskId" to (dbNotification.relatedId ?: dbNotification.id))
                )
            }
            "resource" -> notificationManager.createResourceNotification(
                dbNotification.id,
                dbNotification.message.toIntOrNull() ?: 0
            )
            "storage" -> {
                val storageValue = dbNotification.message.replace("%", "").toIntOrNull() ?: 0
                notificationManager.createStorageWarningNotification(storageValue, dbNotification.id)
            }
            "join_request" -> notificationManager.createJoinRequestNotification(
                dbNotification.id,
                "New Request",
                dbNotification.message
            ).copy(
                extras = mapOf("requestId" to (dbNotification.relatedId ?: dbNotification.id), "teamName" to dbNotification.message)
            )
            else -> null
        }
    }


    private fun openNotificationsList(userId: String) {
        val fragment = NotificationsFragment().apply {
            arguments = Bundle().apply {
                putString("userId", userId)
            }
            setNotificationUpdateListener(this@DashboardActivity)
        }
        openCallFragment(fragment)
    }

    override fun onNotificationCountUpdated(unreadCount: Int) {
        dashboardViewModel.setUnreadNotifications(unreadCount)
    }

    private fun updateNotificationBadge(count: Int, onClickListener: View.OnClickListener) {
        val menuItem = binding.appBarBell.bellToolbar.menu.findItem(R.id.action_notifications)
        val actionView = MenuItemCompat.getActionView(menuItem)
        val smsCountTxt = actionView.findViewById<TextView>(R.id.notification_badge)
        smsCountTxt.text = "$count"
        smsCountTxt.visibility = if (count > 0) View.VISIBLE else View.GONE
        actionView.setOnClickListener(onClickListener)
    }

    fun refreshChatHistoryList() {
        val fragment = supportFragmentManager.findFragmentById(R.id.fragment_container)
        if (fragment is ChatHistoryListFragment) {
            fragment.refreshChatHistoryList()
        }
    }

    private fun hideWifi() {
        val navMenu = binding.appBarBell.bellToolbar.menu
        navMenu.findItem(R.id.menu_goOnline)
            .setVisible(isBetaWifiFeatureEnabled(this))
    }

    private fun checkUser() {
        user = userProfileDbHandler.userModel
        if (user == null) {
            toast(this, getString(R.string.session_expired))
            logout()
            return
        }
        if (user?.id?.startsWith("guest") == true && profileDbHandler.offlineVisits >= 3) {
            val builder = AlertDialog.Builder(this, R.style.AlertDialogTheme)
            builder.setTitle(getString(R.string.become_a_member))
            builder.setMessage(getString(R.string.trial_period_ended))
            builder.setCancelable(false)
            builder.setPositiveButton(getString(R.string.become_a_member), null)
            builder.setNegativeButton(getString(R.string.menu_logout), null)
            val dialog = builder.create()
            dialog.show()
            val becomeMember = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            val logout = dialog.getButton(AlertDialog.BUTTON_NEGATIVE)
            becomeMember.contentDescription = getString(R.string.confirm_membership)
            logout.contentDescription = getString(R.string.menu_logout)
            becomeMember.setOnClickListener {
                val guest = true
                val intent = Intent(this, BecomeMemberActivity::class.java)
                intent.putExtra("username", profileDbHandler.userModel?.name)
                intent.putExtra("guest", guest)
                setResult(RESULT_OK, intent)
                startActivity(intent)
            }
            logout.setOnClickListener {
                dialog.dismiss()
                logout()
            }
        }
    }

    private fun topBarVisible(){
        val isLandscape = resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE
        val tabLayout = findViewById<TabLayout>(R.id.tab_layout)

        tabLayout.visibility = if (isLandscape) {
            View.VISIBLE
        } else {
            View.GONE
        }
    }

    private fun topbarSetting() {
        UITheme()
        val tabLayout = findViewById<TabLayout>(R.id.tab_layout)
        tabLayout.addOnTabSelectedListener(object : OnTabSelectedListener {
            override fun onTabSelected(tab: TabLayout.Tab) {
                onClickTabItems(tab.position)
            }

            override fun onTabUnselected(tab: TabLayout.Tab) {}
            override fun onTabReselected(tab: TabLayout.Tab) {
                onClickTabItems(tab.position)
            }
        })
        for (i in 0 until tabLayout.tabCount) {
            val customTabBinding = CustomTabBinding.inflate(LayoutInflater.from(this))
            val title = customTabBinding.title
            val icon = customTabBinding.icon
            title.text = tabLayout.getTabAt(i)?.text
            icon.setImageResource(R.drawable.ic_home)
            icon.setImageDrawable(tabLayout.getTabAt(i)?.icon)
            tabLayout.getTabAt(i)?.setCustomView(customTabBinding.root)
        }
        tabLayout.isTabIndicatorFullWidth = false
    }

    private fun UITheme() {
        binding.appBarBell.bellToolbar.visibility = View.VISIBLE
        binding.myToolbar.visibility = View.GONE
        navigationView.visibility = View.GONE
    }

    override fun onPrepareOptionsMenu(menu: Menu): Boolean {
        updateGoOnlineVisibility()
        return super.onPrepareOptionsMenu(menu)
    }

    private val accountHeader: AccountHeader
        get() {
            val displayMetrics = resources.displayMetrics
            val screenWidth = displayMetrics.widthPixels
            val screenHeight = displayMetrics.heightPixels
            val density = displayMetrics.density

            var paddingVerticalPx = screenHeight * 0.15
            var paddingHorizontalPx = screenWidth * 0.15
            if(screenWidth > screenHeight){ //sizing for tablets
                paddingVerticalPx = screenHeight * 0.05
                paddingHorizontalPx = screenWidth * 0.05
            }

            val paddingVerticalDp = (paddingVerticalPx / density).toInt()
            val paddingHorizontalDp = (paddingHorizontalPx / density).toInt()
            val resourceId = resources.getIdentifier("status_bar_height", "dimen", "android")
            val statusBarHeight = if (resourceId > 0) {
                resources.getDimensionPixelSize(resourceId)
            } else {
                ceil(25 * density).toInt()
            }

            val header = AccountHeaderBuilder()
                .withActivity(this@DashboardActivity)
                .withTextColor(ContextCompat.getColor(this, R.color.bg_white))
                .withHeaderBackground(R.drawable.ole_logo)
                .withDividerBelowHeader(false)
                .withTranslucentStatusBar(false)
                .withHeightDp(paddingVerticalDp + 20 * 2 + (statusBarHeight / density).toInt())
                .build()
            val headerBackground = header.headerBackgroundView
            headerBackground.setPadding(
                paddingHorizontalDp, paddingVerticalDp + statusBarHeight + 25,
                paddingHorizontalDp, paddingVerticalDp + 50
            )

            val currentNightMode = resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK
            if (AppCompatDelegate.getDefaultNightMode() == AppCompatDelegate.MODE_NIGHT_NO ||
                (AppCompatDelegate.getDefaultNightMode() == AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM && currentNightMode == Configuration.UI_MODE_NIGHT_NO)) {
                headerBackground.setColorFilter(
                    ContextCompat.getColor(this, R.color.md_white_1000),
                    PorterDuff.Mode.SRC_IN
                )
            }
            return header
        }

    private fun createDrawer() {
        val resourceId = resources.getIdentifier("status_bar_height", "dimen", "android")
        val statusBarHeight = if (resourceId > 0) {
            resources.getDimensionPixelSize(resourceId)
        } else {
            ceil(25 * resources.displayMetrics.density).toInt()
        }

        val headerHeight = 160 + (statusBarHeight / resources.displayMetrics.density).toInt()
        val dimenHolder = DimenHolder.fromDp(headerHeight)

        result = headerResult?.let {
            DrawerBuilder().withActivity(this).withFullscreen(true).withTranslucentStatusBar(true).withTranslucentNavigationBar(true)
                .withSliderBackgroundColor(ContextCompat.getColor(this, R.color.colorPrimary))
                .withToolbar(binding.myToolbar)
                .withAccountHeader(it).withHeaderHeight(dimenHolder)
                .addDrawerItems(*drawerItems).addStickyDrawerItems(*drawerItemsFooter)
                .withOnDrawerItemClickListener { _: View?, _: Int, drawerItem: IDrawerItem<*, *>? ->
                    if (drawerItem != null) {
                        result?.setSelection(drawerItem.identifier, false)
                        menuAction((drawerItem as Nameable<*>).name.textRes)
                    }
                    false
                }.withDrawerWidthDp(200).build()
        }
        result?.stickyFooter?.setBackgroundColor(ContextCompat.getColor(this, R.color.colorPrimary))
    }

    private fun menuAction(selectedMenuId: Int) {
        handleDrawerSelection(selectedMenuId)
    }

    private fun handleDrawerSelection(selectedMenuId: Int) {
        when (selectedMenuId) {
            R.string.menu_myplanet -> openCallFragment(BellDashboardFragment())
            R.string.menu_library -> openCallFragment(ResourcesFragment())
            R.string.menu_surveys -> openCallFragment(SurveyFragment())
            R.string.menu_courses -> openCallFragment(CoursesFragment())
            R.string.menu_community -> openCallFragment(CommunityTabFragment())
            R.string.txt_myLibrary -> {
                if (user?.id?.startsWith("guest") == true) {
                    guestDialog(this)
                } else {
                    openMyFragment(ResourcesFragment())
                }
            }
            R.string.team -> openMyFragment(TeamFragment().apply {
                arguments = Bundle().apply {
                    putBoolean("fromDashboard", false)
                }
            })
            R.string.txt_myCourses -> {
                if (user?.id?.startsWith("guest") == true) {
                    guestDialog(this)
                } else {
                    openMyFragment(CoursesFragment())
                }
            }
            R.string.enterprises -> openEnterpriseFragment()
            R.string.menu_logout -> logout()
            else -> openCallFragment(BellDashboardFragment())
        }
    }

    override fun openMyFragment(f: Fragment) {
        val fragmentName = f::class.java.simpleName
        var tag = "My$fragmentName"
        val isDashboard = f.arguments?.getBoolean("fromDashboard", false) == true
        if(tag != "MyTeamFragment") {
            val b = Bundle()
            b.putBoolean("isMyCourseLib", true)
            f.arguments = b
        }
        if (isDashboard) {
            tag = "MyTeamDashboardFragment"
        }
        when (tag) {
            "MyCoursesFragment" -> result?.setSelection(2, false)
            "MyResourcesFragment" -> result?.setSelection(1, false)
            "MyTeamDashboardFragment" -> result?.setSelection(0, false)
            "MyTeamFragment" ->  result?.setSelection(5, false)
            else -> {
                result?.setSelection(0, false)
            }
        }
        openCallFragment(f, tag)
    }

    override fun onDestroy() {
        realmListeners.forEach { it.removeListener() }
        realmListeners.clear()

        systemNotificationReceiver?.let {
            unregisterReceiver(it)
            systemNotificationReceiver = null
        }

        if (::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        super.onDestroy()
    }

    override fun openCallFragment(f: Fragment) {
        val tag = f::class.java.simpleName
        openCallFragment(f,tag)
    }

    override fun openLibraryDetailFragment(library: RealmMyLibrary?) {
        val f: Fragment = ResourceDetailFragment()
        val b = Bundle()
        b.putString("libraryId", library?.resourceId)
        f.arguments = b
        openCallFragment(f)
    }

    override fun sendSurvey(current: RealmStepExam?) {
        val f = SendSurveyFragment()
        val b = Bundle()
        b.putString("surveyId", current?.id)
        f.arguments = b
        f.show(supportFragmentManager, "")
    }

    private val drawerItems: Array<IDrawerItem<*, *>>
        get() {
            val menuImageList = ArrayList<Drawable>()
            ResourcesCompat.getDrawable(resources, R.drawable.myplanet, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.ourlibrary, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.ourcourses, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.mylibrary, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.mycourses, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.team, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.business, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.community, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.survey, null)?.let { menuImageList.add(it) }
            return arrayOf(
                changeUX(R.string.menu_myplanet, menuImageList[0]).withIdentifier(0),
                changeUX(R.string.txt_myLibrary, menuImageList[1]).withIdentifier(1),
                changeUX(R.string.txt_myCourses, menuImageList[2]).withIdentifier(2),
                changeUX(R.string.menu_library, menuImageList[3]).withIdentifier(3),
                changeUX(R.string.menu_courses, menuImageList[4]).withIdentifier(4),
                changeUX(R.string.team, menuImageList[5]).withIdentifier(5),
                changeUX(R.string.enterprises, menuImageList[6]).withIdentifier(6),
                changeUX(R.string.menu_community, menuImageList[7]).withIdentifier(7),
                changeUX(R.string.menu_surveys, menuImageList[8]).withIdentifier(8)
            )
        }

    private val drawerItemsFooter: Array<IDrawerItem<*, *>>
        get() {
            val menuImageListFooter = ArrayList<Drawable>()
            ResourcesCompat.getDrawable(resources, R.drawable.logout, null)?.let { menuImageListFooter.add(it) }
            return arrayOf(changeUX(R.string.menu_logout, menuImageListFooter[0]))
        }

    private fun changeUX(iconText: Int, drawable: Drawable?): PrimaryDrawerItem {
        return PrimaryDrawerItem().withName(iconText)
            .withIcon(drawable)
            .withTextColor(ContextCompat.getColor(this, R.color.textColorPrimary))
            .withSelectedTextColor(ContextCompat.getColor(this, R.color.primary_dark))
            .withIconColor(ContextCompat.getColor(this, R.color.textColorPrimary))
            .withSelectedIconColor(ContextCompat.getColor(this, R.color.primary_dark))
            .withSelectedColor(ContextCompat.getColor(this, R.color.textColorPrimary))
            .withIconTintingEnabled(true)
    }

    override fun onNavigationItemSelected(item: MenuItem): Boolean {
        item.isChecked = true
        when (item.itemId) {
            R.id.menu_library -> {
                openCallFragment(ResourcesFragment())
            }
            R.id.menu_courses -> {
                openCallFragment(CoursesFragment())
            }
            R.id.menu_mycourses -> {
                if (user?.id?.startsWith("guest") == true) {
                    guestDialog(this)
                } else {
                    openMyFragment(CoursesFragment())
                }
            }
            R.id.menu_mylibrary -> {
                if (user?.id?.startsWith("guest") == true) {
                    guestDialog(this)
                } else {
                    openMyFragment(ResourcesFragment())
                }
            }
            R.id.menu_enterprises -> {
                openEnterpriseFragment()
            }
            R.id.menu_home -> {
                openCallFragment(BellDashboardFragment())
            }
        }
        item.isChecked = true
        return true
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.menu_bell_dashboard, menu)
        bindGoOnlineMenu(menu)
        return super.onCreateOptionsMenu(menu)
    }

    override fun onResume() {
        super.onResume()
        checkNotificationPermissionStatus()
    }

    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        setIntent(intent)
        handleNotificationIntent(intent)

        if (intent?.action == "REFRESH_NOTIFICATION_BADGE") {
            val userId = user?.id
            if (userId != null) {
                lifecycleScope.launch {
                    delay(100)
                    try {
                        mRealm.refresh()
                        val unreadCount = dashboardViewModel.getUnreadNotificationsSize(userId)
                        onNotificationCountUpdated(unreadCount)
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
        }
    }

    override fun onNotificationPermissionGranted() {
        super.onNotificationPermissionGranted()
        if (notificationsShownThisSession) {
            checkAndCreateNewNotifications()
        }
    }

    override fun onNotificationPermissionChanged(isEnabled: Boolean) {
        super.onNotificationPermissionChanged(isEnabled)
        if (!isEnabled) {
            showNotificationDisabledReminder()
        }
    }

    private fun showNotificationDisabledReminder() {
        val snackbar = Snackbar.make(
            binding.root,
            "Notifications are disabled. You might miss important updates.",
            Snackbar.LENGTH_LONG
        )
        snackbar.setAction("Enable") {
            ensureNotificationPermission(true)
        }
        snackbar.show()
    }

    companion object {
        const val MESSAGE_PROGRESS = "message_progress"
        @JvmStatic
        var isFromNotificationAction = false
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard


import android.app.AlertDialog
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.res.Configuration
import android.graphics.Color
import android.graphics.PorterDuff
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.widget.TextView
import androidx.activity.OnBackPressedCallback
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatDelegate
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import androidx.core.content.res.ResourcesCompat
import androidx.core.view.MenuItemCompat
import androidx.drawerlayout.widget.DrawerLayout
import androidx.fragment.app.Fragment
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import com.google.android.material.navigation.NavigationBarView
import com.google.android.material.snackbar.Snackbar
import com.google.android.material.tabs.TabLayout
import com.google.android.material.tabs.TabLayout.OnTabSelectedListener
import com.mikepenz.materialdrawer.AccountHeader
import com.mikepenz.materialdrawer.AccountHeaderBuilder
import com.mikepenz.materialdrawer.Drawer
import com.mikepenz.materialdrawer.DrawerBuilder
import com.mikepenz.materialdrawer.holder.DimenHolder
import com.mikepenz.materialdrawer.model.PrimaryDrawerItem
import com.mikepenz.materialdrawer.model.interfaces.IDrawerItem
import com.mikepenz.materialdrawer.model.interfaces.Nameable
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Case
import io.realm.Realm
import io.realm.RealmChangeListener
import io.realm.RealmObject
import io.realm.RealmResults
import javax.inject.Inject
import kotlin.math.ceil
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.ActivityDashboardBinding
import org.ole.planet.myplanet.databinding.CustomTabBinding
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNotification
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.SettingActivity
import org.ole.planet.myplanet.ui.chat.ChatHistoryListFragment
import org.ole.planet.myplanet.ui.community.CommunityTabFragment
import org.ole.planet.myplanet.ui.courses.CoursesFragment
import org.ole.planet.myplanet.ui.dashboard.notification.NotificationListener
import org.ole.planet.myplanet.ui.dashboard.notification.NotificationsFragment
import org.ole.planet.myplanet.ui.feedback.FeedbackListFragment
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.resources.ResourceDetailFragment
import org.ole.planet.myplanet.ui.resources.ResourcesFragment
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission
import org.ole.planet.myplanet.ui.survey.SendSurveyFragment
import org.ole.planet.myplanet.ui.survey.SurveyFragment
import org.ole.planet.myplanet.ui.sync.DashboardElementActivity
import org.ole.planet.myplanet.ui.team.TeamDetailFragment
import org.ole.planet.myplanet.ui.team.TeamFragment
import org.ole.planet.myplanet.ui.team.TeamPageConfig.JoinRequestsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.TasksPage
import org.ole.planet.myplanet.ui.userprofile.BecomeMemberActivity
import org.ole.planet.myplanet.utilities.Constants.isBetaWifiFeatureEnabled
import org.ole.planet.myplanet.utilities.DialogUtils.guestDialog
import org.ole.planet.myplanet.utilities.EdgeToEdgeUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.KeyboardUtils.setupUI
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.NotificationUtils
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.Utilities.toast

@AndroidEntryPoint
class DashboardActivity : DashboardElementActivity(), OnHomeItemClickListener, NavigationBarView.OnItemSelectedListener, NotificationListener {

    private lateinit var binding: ActivityDashboardBinding
    private var headerResult: AccountHeader? = null
    var user: RealmUserModel? = null
    var result: Drawer? = null
    private var tl: TabLayout? = null
    private var dl: DrawerLayout? = null
    private val realmListeners = mutableListOf<RealmListener>()
    private val dashboardViewModel: DashboardViewModel by viewModels()
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    @Inject
    lateinit var teamRepository: TeamRepository
    private lateinit var challengeHelper: ChallengeHelper
    private lateinit var notificationManager: NotificationUtils.NotificationManager
    private var notificationsShownThisSession = false
    private var lastNotificationCheckTime = 0L
    private val notificationCheckThrottleMs = 5000L
    private var systemNotificationReceiver: BroadcastReceiver? = null
    private lateinit var mRealm: Realm

    private interface RealmListener {
        fun removeListener()
    }

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(base))
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        mRealm = databaseService.realmInstance
        checkUser()
        initViews()
        updateAppTitle()
        notificationManager = NotificationUtils.getInstance(this)
        if (handleGuestAccess()) return
        setupNavigation()
        handleInitialFragment()
        setupToolbarActions()
        hideWifi()
        setupRealmListeners()
        setupSystemNotificationReceiver()
        checkIfShouldShowNotifications()
        addBackPressCallback()
        challengeHelper = ChallengeHelper(this, mRealm, user, settings, editor, dashboardViewModel)
        challengeHelper.evaluateChallengeDialog()
        handleNotificationIntent(intent)
        collectUiState()
    }

    private fun collectUiState() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                dashboardViewModel.uiState.collect { state ->
                    updateNotificationBadge(state.unreadNotifications) {
                        openNotificationsList(user?.id ?: "")
                    }
                }
            }
        }
    }

    private fun initViews() {
        binding = ActivityDashboardBinding.inflate(layoutInflater)
        setContentView(binding.root)
        EdgeToEdgeUtils.setupEdgeToEdge(this, binding.root)
        setupUI(binding.activityDashboardParentLayout, this@DashboardActivity)
        setSupportActionBar(binding.myToolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(false)
        supportActionBar?.setTitle(R.string.app_project_name)
        binding.myToolbar.setTitleTextColor(Color.WHITE)
        binding.myToolbar.setSubtitleTextColor(Color.WHITE)
        navigationView = binding.topBarNavigation
        navigationView.labelVisibilityMode = NavigationBarView.LABEL_VISIBILITY_LABELED
        binding.appBarBell.bellToolbar.inflateMenu(R.menu.menu_bell_dashboard)
        service = Service(this)
        tl = findViewById(R.id.tab_layout)
        binding.root.viewTreeObserver.addOnGlobalLayoutListener { topBarVisible() }
        binding.appBarBell.ivSetting.setOnClickListener {
            startActivity(Intent(this, SettingActivity::class.java))
        }
    }

    private fun updateAppTitle() {
        try {
            val userProfileModel = profileDbHandler.userModel
            if (userProfileModel != null) {
                var name: String? = userProfileModel.getFullName()
                if (name.isNullOrBlank()) {
                    name = profileDbHandler.userModel?.name
                }
                val communityName = settings.getString("communityName", "")
                binding.appBarBell.appTitleName.text = if (user?.planetCode == "") {
                    "${getString(R.string.planet)} $communityName"
                } else {
                    "${getString(R.string.planet)} ${user?.planetCode}"
                }
            } else {
                binding.appBarBell.appTitleName.text = getString(R.string.app_project_name)
            }
        } catch (err: Exception) {
            throw RuntimeException(err)
        }
    }

    private fun handleGuestAccess(): Boolean {
        if (user != null && user?.rolesList?.isEmpty() == true && !user?.userAdmin!!) {
            navigationView.visibility = View.GONE
            openCallFragment(InactiveDashboardFragment(), "Dashboard")
            return true
        }
        navigationView.setOnItemSelectedListener(this)
        val isTopBarVisible = userProfileDbHandler.userModel?.isShowTopbar == true
        navigationView.visibility = if (isTopBarVisible) {
            View.VISIBLE
        } else {
            View.GONE
        }
        return false
    }

    private fun setupNavigation() {
        headerResult = accountHeader
        createDrawer()
        supportFragmentManager.addOnBackStackChangedListener {
            val frag = supportFragmentManager.findFragmentById(R.id.fragment_container)
            val idToSelect = when (frag) {
                is BellDashboardFragment -> 0L
                is ResourcesFragment -> {
                    val isMy = frag.arguments?.getBoolean("isMyCourseLib", false) == true
                    if (isMy) 1L else 3L
                }
                is CoursesFragment -> {
                    val isMy = frag.arguments?.getBoolean("isMyCourseLib", false) == true
                    if (isMy) 2L else 4L
                }
                is TeamFragment -> {
                    val isDashboard = frag.arguments?.getBoolean("fromDashboard", false) == true
                    val isEnterprise = frag.arguments?.getString("type") == "enterprise"
                    if (isDashboard) 0L else if (isEnterprise) 6L else 5L
                }
                is CommunityTabFragment -> 7L
                is SurveyFragment -> 8L
                else -> null
            }
            idToSelect?.let { result?.setSelection(it, false) }
        }
        result?.actionBarDrawerToggle?.isDrawerIndicatorEnabled = true
        dl = result?.drawerLayout
        topbarSetting()

        lifecycleScope.launch {
            delay(50)
            if (!(user?.id?.startsWith("guest") == true && profileDbHandler.offlineVisits >= 3) &&
                resources.configuration.orientation == Configuration.ORIENTATION_PORTRAIT
            ) {
                result?.openDrawer()
            }
        }
    }

    private fun handleInitialFragment() {
        if (intent != null && intent.hasExtra("fragmentToOpen")) {
            val fragmentToOpen = intent.getStringExtra("fragmentToOpen")
            if ("feedbackList" == fragmentToOpen) {
                openMyFragment(FeedbackListFragment())
            }
        } else {
            openCallFragment(BellDashboardFragment())
            binding.appBarBell.bellToolbar.visibility = View.VISIBLE
        }
    }

    private fun setupToolbarActions() {
        binding.appBarBell.ivSync.setOnClickListener { logSyncInSharedPrefs() }
        binding.appBarBell.imgLogo.setOnClickListener { result?.openDrawer() }
        binding.appBarBell.bellToolbar.setOnMenuItemClickListener { item ->
            handleToolbarMenuItem(item.itemId)
            true
        }
    }

    private fun handleToolbarMenuItem(itemId: Int) {
        when (itemId) {
            R.id.action_chat -> {
                if (user?.id?.startsWith("guest") == false) {
                    openCallFragment(
                        ChatHistoryListFragment(),
                        ChatHistoryListFragment::class.java.simpleName
                    )
                } else {
                    guestDialog(this)
                }
            }
            R.id.menu_goOnline -> wifiStatusSwitch()
            R.id.action_sync -> logSyncInSharedPrefs()
            R.id.action_feedback -> {
                if (user?.id?.startsWith("guest") == false) {
                    openCallFragment(
                        FeedbackListFragment(),
                        FeedbackListFragment::class.java.simpleName
                    )
                } else {
                    guestDialog(this)
                }
            }
            R.id.action_settings -> startActivity(Intent(this@DashboardActivity, SettingActivity::class.java))
            R.id.action_disclaimer -> openCallFragment(DisclaimerFragment(), DisclaimerFragment::class.java.simpleName)
            R.id.action_about -> openCallFragment(AboutFragment(), AboutFragment::class.java.simpleName)
            R.id.action_logout -> logout()
            R.id.change_language -> SettingActivity.SettingFragment.languageChanger(this)
            else -> {}
        }
    }

    private fun addBackPressCallback() {
        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                if (result != null && result?.isDrawerOpen == true) {
                    result?.closeDrawer()
                } else {
                    if (supportFragmentManager.backStackEntryCount > 1) {
                        NavigationHelper.popBackStack(supportFragmentManager)
                    } else {
                        if (!doubleBackToExitPressedOnce) {
                            doubleBackToExitPressedOnce = true
                            toast(MainApplication.context, getString(R.string.press_back_again_to_exit))
                            lifecycleScope.launch {
                                delay(2000)
                                doubleBackToExitPressedOnce = false
                            }
                        } else {
                            val fragment = supportFragmentManager.findFragmentById(R.id.fragment_container)
                            if (!BuildConfig.LITE && fragment is BaseContainerFragment) {
                                fragment.handleBackPressed()
                            }
                            finish()
                        }
                    }
                }
            }
        })
    }

    private fun handleNotificationIntent(intent: Intent?) {
        val fromNotification = intent?.getBooleanExtra("from_notification", false) ?: false
        if (fromNotification) {
            val notificationType = intent.getStringExtra("notification_type")
            val notificationId = intent.getStringExtra("notification_id")

            notificationId?.let {
                notificationManager.clearNotification(it)
                markDatabaseNotificationAsRead(it)
            }

            when (notificationType) {
                NotificationUtils.TYPE_SURVEY -> {
                    val surveyId = intent.getStringExtra("surveyId")
                    if (surveyId != null) {
                        openCallFragment(SurveyFragment().apply {
                            arguments = Bundle().apply {
                                putString("surveyId", surveyId)
                            }
                        })
                    } else {
                        openNotificationsList(user?.id ?: "")
                    }
                }
                NotificationUtils.TYPE_TASK -> {
                    val taskId = intent.getStringExtra("taskId")
                    if (taskId != null) {
                        openMyFragment(TeamFragment().apply {
                            arguments = Bundle().apply {
                                putString("taskId", taskId)
                            }
                        })
                    } else {
                        openNotificationsList(user?.id ?: "")
                    }
                }
                NotificationUtils.TYPE_STORAGE -> {
                    startActivity(Intent(this, SettingActivity::class.java))
                }
                NotificationUtils.TYPE_JOIN_REQUEST -> {
                    val teamName = intent.getStringExtra("teamName")
                    openMyFragment(TeamFragment().apply {
                        arguments = Bundle().apply {
                            teamName?.let { putString("teamName", it) }
                        }
                    })
                }
                else -> {
                    openNotificationsList(user?.id ?: "")
                }
            }
        }

        if (intent?.getBooleanExtra("auto_navigate", false) == true) {
            isFromNotificationAction = true
            result?.closeDrawer()

            val notificationType = intent.getStringExtra("notification_type")
            val relatedId = intent.getStringExtra("related_id")

            when (notificationType) {
                NotificationUtils.TYPE_SURVEY -> {
                    lifecycleScope.launch {
                        handleSurveyNavigation(relatedId)
                    }
                }
                NotificationUtils.TYPE_TASK -> {
                    lifecycleScope.launch {
                        handleTaskNavigation(relatedId)
                    }
                }
                NotificationUtils.TYPE_JOIN_REQUEST -> {
                    lifecycleScope.launch {
                        handleJoinRequestNavigation(relatedId)
                    }
                }
                NotificationUtils.TYPE_RESOURCE -> {
                    openCallFragment(ResourcesFragment(), "Resources")
                }
            }

            lifecycleScope.launch {
                delay(1000)
                isFromNotificationAction = false
            }
        }
    }

    private suspend fun handleSurveyNavigation(surveyId: String?) {
        if (surveyId != null) {
            val currentStepExam = withContext(Dispatchers.IO) {
                Realm.getDefaultInstance().use { realm ->
                    realm.where(RealmStepExam::class.java).equalTo("name", surveyId)
                        .findFirst()?.let {
                            realm.copyFromRealm(it)
                        }
                }
            }
            AdapterMySubmission.openSurvey(this, currentStepExam?.id, false, false, "")
        }
    }

    private suspend fun handleTaskNavigation(taskId: String?) {
        if (taskId == null) return

        val teamData = teamRepository.getTaskTeamInfo(taskId)

        teamData?.let { (teamId, teamName, teamType) ->
            val f = TeamDetailFragment.newInstance(
                teamId = teamId,
                teamName = teamName,
                teamType = teamType,
                isMyTeam = true,
                navigateToPage = TasksPage
            )
            openCallFragment(f)
        }
    }

    private suspend fun handleJoinRequestNavigation(requestId: String?) {
        if (requestId != null) {
            val actualJoinRequestId = if (requestId.startsWith("join_request_")) {
                requestId.removePrefix("join_request_")
            } else {
                requestId
            }

            val teamId = teamRepository.getJoinRequestTeamId(actualJoinRequestId)

            if (teamId?.isNotEmpty() == true) {
                val f = TeamDetailFragment()
                val b = Bundle()
                b.putString("id", teamId)
                b.putBoolean("isMyTeam", true)
                b.putString("navigateToPage", JoinRequestsPage.id)
                f.arguments = b
                openCallFragment(f)
            }
        }
    }
    private fun setupRealmListeners() {
        if (mRealm.isInTransaction) {
            mRealm.commitTransaction()
        }
        setupListener {
            mRealm.where(RealmMyLibrary::class.java).findAllAsync()
        }

        setupListener {
            mRealm.where(RealmSubmission::class.java)
                .equalTo("userId", user?.id)
                .equalTo("type", "survey")
                .equalTo("status", "pending", Case.INSENSITIVE)
                .findAllAsync()
        }

        setupListener {
            mRealm.where(RealmTeamTask::class.java)
                .notEqualTo("status", "archived")
                .equalTo("completed", false)
                .equalTo("assignee", user?.id)
                .findAllAsync()
        }
    }

    private inline fun <reified T : RealmObject> setupListener(crossinline query: () -> RealmResults<T>) {
        val results = query()
        val listener = RealmChangeListener<RealmResults<T>> { _ ->
            if (notificationsShownThisSession) {
                val currentTime = System.currentTimeMillis()
                if (currentTime - lastNotificationCheckTime > notificationCheckThrottleMs) {
                    lastNotificationCheckTime = currentTime
                    checkAndCreateNewNotifications()
                }
            }
        }
        results.addChangeListener(listener)
        realmListeners.add(object : RealmListener {
            override fun removeListener() {
                results.removeChangeListener(listener)
            }
        })
    }

    private fun setupSystemNotificationReceiver() {
        systemNotificationReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context?, intent: Intent?) {
                if (intent?.action == "org.ole.planet.myplanet.NOTIFICATION_READ_FROM_SYSTEM") {
                    val userId = user?.id
                    if (userId != null) {
                        val fragment = supportFragmentManager.findFragmentById(R.id.fragment_container)
                        if (fragment is NotificationsFragment) {
                            fragment.view?.post {
                                fragment.refreshNotificationsList()
                            }
                        } else {
                            lifecycleScope.launch {
                                delay(300)
                                try {
                                    mRealm.refresh()
                                    val unreadCount = dashboardViewModel.getUnreadNotificationsSize(userId)
                                    onNotificationCountUpdated(unreadCount)
                                } catch (e: Exception) {
                                    e.printStackTrace()
                                    delay(300)
                                    try {
                                        mRealm.refresh()
                                        val unreadCount = dashboardViewModel.getUnreadNotificationsSize(userId)
                                        onNotificationCountUpdated(unreadCount)
                                    } catch (e2: Exception) {
                                        e2.printStackTrace()
                                    }
                                }
                            }
                        }
                    } else {
                        android.util.Log.w("DashboardActivity", "SystemNotificationReceiver: User ID is null")
                    }
                }
            }
        }

        val filter = IntentFilter("org.ole.planet.myplanet.NOTIFICATION_READ_FROM_SYSTEM")
        if (Build.VERSION.SDK_INT >= 33) {
            registerReceiver(systemNotificationReceiver, filter, RECEIVER_NOT_EXPORTED)
        } else {
            @Suppress("UnspecifiedRegisterReceiverFlag")
            registerReceiver(systemNotificationReceiver, filter)
        }
    }

    private fun checkIfShouldShowNotifications() {
        val fromLogin = intent.getBooleanExtra("from_login", false)
        if (fromLogin || !notificationsShownThisSession) {
            notificationsShownThisSession = true
            lifecycleScope.launch {
                kotlinx.coroutines.delay(1000)
                checkAndCreateNewNotifications()
            }
        }
    }

    private fun checkAndCreateNewNotifications() {
        val userId = user?.id

        lifecycleScope.launch(Dispatchers.IO) {
            var unreadCount = 0
            val newNotifications = mutableListOf<NotificationUtils.NotificationConfig>()

            try {
                dashboardViewModel.updateResourceNotification(userId)
                databaseService.realmInstance.use { backgroundRealm ->
                    val createdNotifications = createNotifications(backgroundRealm, userId)
                    newNotifications.addAll(createdNotifications)

                    unreadCount = dashboardViewModel.getUnreadNotificationsSize(userId)
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }

            withContext(Dispatchers.Main) {
                try {
                    onNotificationCountUpdated(unreadCount)

                    val groupedNotifications = newNotifications.groupBy { it.type }

                    groupedNotifications.forEach { (type, notifications) ->
                        when {
                            notifications.size == 1 -> {
                                notificationManager.showNotification(notifications.first())
                            }
                            notifications.size > 1 -> {
                                val summaryConfig = createSummaryNotification(type, notifications.size)
                                notificationManager.showNotification(summaryConfig)
                            }
                        }
                    }

                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }
    }

    private fun markDatabaseNotificationAsRead(notificationId: String) {
        try {
            val userId = user?.id
            if (notificationId.startsWith("summary_")) {
                val type = notificationId.removePrefix("summary_")
                mRealm.executeTransactionAsync { realm ->
                    realm.where(RealmNotification::class.java)
                        .equalTo("userId", userId)
                        .equalTo("type", type)
                        .equalTo("isRead", false)
                        .findAll()
                        .forEach { it.isRead = true }
                }
            } else {
                mRealm.executeTransactionAsync { realm ->
                    val notification = realm.where(RealmNotification::class.java)
                        .equalTo("id", notificationId)
                        .findFirst()
                    notification?.isRead = true
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun createSummaryNotification(type: String, count: Int): NotificationUtils.NotificationConfig {
        val summaryId = "summary_${type}"

        return when (type) {
            "survey" -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " New Surveys Available",
                message = "$count new surveys are waiting for you",
                priority = NotificationCompat.PRIORITY_HIGH,
                category = NotificationCompat.CATEGORY_REMINDER
            )
            "task" -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " New Tasks Assigned",
                message = "$count new tasks have been assigned to you",
                priority = NotificationCompat.PRIORITY_HIGH,
                category = NotificationCompat.CATEGORY_REMINDER
            )
            "join_request" -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " Team Join Requests",
                message = "$count new team join requests to review",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_SOCIAL
            )
            "resource" -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " New Resources Available",
                message = "$count new resources have been added",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_RECOMMENDATION
            )
            "storage" -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " Storage Warnings",
                message = "$count storage warnings need attention",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_STATUS
            )
            else -> NotificationUtils.NotificationConfig(
                id = summaryId,
                type = type,
                title = " App Notifications",
                message = "$count new notifications",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_MESSAGE
            )
        }
    }

    private suspend fun createNotifications(
        realm: Realm,
        userId: String?,
    ): List<NotificationUtils.NotificationConfig> {
        val surveyTitles = collectSurveyData(realm, userId)
        val taskData = collectTaskData(realm, userId)
        val joinRequestData = collectJoinRequestData(realm, userId)
        val storageRatio = FileUtils.totalAvailableMemoryRatio(this)

        val notificationConfigs = realm.where(RealmNotification::class.java)
            .equalTo("userId", userId)
            .equalTo("isRead", false)
            .findAll()
            .mapNotNull { dbNotification ->
                createNotificationConfigFromDatabase(dbNotification)
            }
            .toMutableList()

        surveyTitles.forEach { title ->
            dashboardViewModel.createNotificationIfMissing("survey", title, title, userId)
        }

        taskData.forEach { (title, deadline, id) ->
            dashboardViewModel.createNotificationIfMissing("task", "$title $deadline", id, userId)
        }

        if (storageRatio > 85) {
            dashboardViewModel.createNotificationIfMissing("storage", "$storageRatio%", "storage", userId)
        }
        dashboardViewModel.createNotificationIfMissing("storage", "90%", "storage_test", userId)

        joinRequestData.forEach { (message, id) ->
            dashboardViewModel.createNotificationIfMissing("join_request", message, id, userId)
        }
        return notificationConfigs
    }

    private fun collectSurveyData(realm: Realm, userId: String?): List<String> {
        return realm.where(RealmSubmission::class.java)
            .equalTo("userId", userId)
            .equalTo("status", "pending")
            .equalTo("type", "survey")
            .findAll()
            .mapNotNull { submission ->
                val examId = submission.parentId?.split("@")?.firstOrNull() ?: ""
                realm.where(RealmStepExam::class.java)
                    .equalTo("id", examId)
                    .findFirst()
                    ?.name
            }
    }

    private fun collectTaskData(realm: Realm, userId: String?): List<Triple<String, String, String>> {
        return realm.where(RealmTeamTask::class.java)
            .notEqualTo("status", "archived")
            .equalTo("completed", false)
            .equalTo("assignee", userId)
            .findAll()
            .mapNotNull { task ->
                val title = task.title ?: return@mapNotNull null
                val id = task.id ?: return@mapNotNull null
                Triple(title, formatDate(task.deadline), id)
            }
    }

    private fun collectJoinRequestData(realm: Realm, userId: String?): List<Pair<String, String>> {
        return realm.where(RealmMyTeam::class.java)
            .equalTo("userId", userId)
            .equalTo("docType", "membership")
            .equalTo("isLeader", true)
            .findAll()
            .flatMap { leadership ->
                realm.where(RealmMyTeam::class.java)
                    .equalTo("teamId", leadership.teamId)
                    .equalTo("docType", "request")
                    .findAll()
                    .mapNotNull { joinRequest ->
                        joinRequest._id?.let { requestId ->
                            val team = realm.where(RealmMyTeam::class.java)
                                .equalTo("_id", leadership.teamId)
                                .findFirst()

                            val requester = realm.where(RealmUserModel::class.java)
                                .equalTo("id", joinRequest.userId)
                                .findFirst()

                            val requesterName = requester?.name ?: "Unknown User"
                            val teamName = team?.name ?: "Unknown Team"
                            val message = getString(R.string.user_requested_to_join_team, requesterName, teamName)

                            Pair(message, requestId)
                        }
                    }
            }
    }

    private fun createNotificationConfigFromDatabase(dbNotification: RealmNotification): NotificationUtils.NotificationConfig? {
        return when (dbNotification.type.lowercase()) {
            "survey" -> notificationManager.createSurveyNotification(
                dbNotification.id,
                dbNotification.message
            ).copy(
                extras = mapOf("surveyId" to (dbNotification.relatedId ?: dbNotification.id))
            )
            "task" -> {
                val parts = dbNotification.message.split(" ")
                val taskTitle = parts.dropLast(3).joinToString(" ")
                val deadline = parts.takeLast(3).joinToString(" ")
                notificationManager.createTaskNotification(dbNotification.id, taskTitle, deadline).copy(
                    extras = mapOf("taskId" to (dbNotification.relatedId ?: dbNotification.id))
                )
            }
            "resource" -> notificationManager.createResourceNotification(
                dbNotification.id,
                dbNotification.message.toIntOrNull() ?: 0
            )
            "storage" -> {
                val storageValue = dbNotification.message.replace("%", "").toIntOrNull() ?: 0
                notificationManager.createStorageWarningNotification(storageValue, dbNotification.id)
            }
            "join_request" -> notificationManager.createJoinRequestNotification(
                dbNotification.id,
                "New Request",
                dbNotification.message
            ).copy(
                extras = mapOf("requestId" to (dbNotification.relatedId ?: dbNotification.id), "teamName" to dbNotification.message)
            )
            else -> null
        }
    }


    private fun openNotificationsList(userId: String) {
        val fragment = NotificationsFragment().apply {
            arguments = Bundle().apply {
                putString("userId", userId)
            }
            setNotificationUpdateListener(this@DashboardActivity)
        }
        openCallFragment(fragment)
    }

    override fun onNotificationCountUpdated(unreadCount: Int) {
        dashboardViewModel.setUnreadNotifications(unreadCount)
    }

    private fun updateNotificationBadge(count: Int, onClickListener: View.OnClickListener) {
        val menuItem = binding.appBarBell.bellToolbar.menu.findItem(R.id.action_notifications)
        val actionView = MenuItemCompat.getActionView(menuItem)
        val smsCountTxt = actionView.findViewById<TextView>(R.id.notification_badge)
        smsCountTxt.text = "$count"
        smsCountTxt.visibility = if (count > 0) View.VISIBLE else View.GONE
        actionView.setOnClickListener(onClickListener)
    }

    fun refreshChatHistoryList() {
        val fragment = supportFragmentManager.findFragmentById(R.id.fragment_container)
        if (fragment is ChatHistoryListFragment) {
            fragment.refreshChatHistoryList()
        }
    }

    private fun hideWifi() {
        val navMenu = binding.appBarBell.bellToolbar.menu
        navMenu.findItem(R.id.menu_goOnline)
            .setVisible(isBetaWifiFeatureEnabled(this))
    }

    private fun checkUser() {
        user = userProfileDbHandler.userModel
        if (user == null) {
            toast(this, getString(R.string.session_expired))
            logout()
            return
        }
        if (user?.id?.startsWith("guest") == true && profileDbHandler.offlineVisits >= 3) {
            val builder = AlertDialog.Builder(this, R.style.AlertDialogTheme)
            builder.setTitle(getString(R.string.become_a_member))
            builder.setMessage(getString(R.string.trial_period_ended))
            builder.setCancelable(false)
            builder.setPositiveButton(getString(R.string.become_a_member), null)
            builder.setNegativeButton(getString(R.string.menu_logout), null)
            val dialog = builder.create()
            dialog.show()
            val becomeMember = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            val logout = dialog.getButton(AlertDialog.BUTTON_NEGATIVE)
            becomeMember.contentDescription = getString(R.string.confirm_membership)
            logout.contentDescription = getString(R.string.menu_logout)
            becomeMember.setOnClickListener {
                val guest = true
                val intent = Intent(this, BecomeMemberActivity::class.java)
                intent.putExtra("username", profileDbHandler.userModel?.name)
                intent.putExtra("guest", guest)
                setResult(RESULT_OK, intent)
                startActivity(intent)
            }
            logout.setOnClickListener {
                dialog.dismiss()
                logout()
            }
        }
    }

    private fun topBarVisible(){
        val isLandscape = resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE
        val tabLayout = findViewById<TabLayout>(R.id.tab_layout)

        tabLayout.visibility = if (isLandscape) {
            View.VISIBLE
        } else {
            View.GONE
        }
    }

    private fun topbarSetting() {
        UITheme()
        val tabLayout = findViewById<TabLayout>(R.id.tab_layout)
        tabLayout.addOnTabSelectedListener(object : OnTabSelectedListener {
            override fun onTabSelected(tab: TabLayout.Tab) {
                onClickTabItems(tab.position)
            }

            override fun onTabUnselected(tab: TabLayout.Tab) {}
            override fun onTabReselected(tab: TabLayout.Tab) {
                onClickTabItems(tab.position)
            }
        })
        for (i in 0 until tabLayout.tabCount) {
            val customTabBinding = CustomTabBinding.inflate(LayoutInflater.from(this))
            val title = customTabBinding.title
            val icon = customTabBinding.icon
            title.text = tabLayout.getTabAt(i)?.text
            icon.setImageResource(R.drawable.ic_home)
            icon.setImageDrawable(tabLayout.getTabAt(i)?.icon)
            tabLayout.getTabAt(i)?.setCustomView(customTabBinding.root)
        }
        tabLayout.isTabIndicatorFullWidth = false
    }

    private fun UITheme() {
        binding.appBarBell.bellToolbar.visibility = View.VISIBLE
        binding.myToolbar.visibility = View.GONE
        navigationView.visibility = View.GONE
    }

    override fun onPrepareOptionsMenu(menu: Menu): Boolean {
        updateGoOnlineVisibility()
        return super.onPrepareOptionsMenu(menu)
    }

    private val accountHeader: AccountHeader
        get() {
            val displayMetrics = resources.displayMetrics
            val screenWidth = displayMetrics.widthPixels
            val screenHeight = displayMetrics.heightPixels
            val density = displayMetrics.density

            var paddingVerticalPx = screenHeight * 0.15
            var paddingHorizontalPx = screenWidth * 0.15
            if(screenWidth > screenHeight){ //sizing for tablets
                paddingVerticalPx = screenHeight * 0.05
                paddingHorizontalPx = screenWidth * 0.05
            }

            val paddingVerticalDp = (paddingVerticalPx / density).toInt()
            val paddingHorizontalDp = (paddingHorizontalPx / density).toInt()
            val resourceId = resources.getIdentifier("status_bar_height", "dimen", "android")
            val statusBarHeight = if (resourceId > 0) {
                resources.getDimensionPixelSize(resourceId)
            } else {
                ceil(25 * density).toInt()
            }

            val header = AccountHeaderBuilder()
                .withActivity(this@DashboardActivity)
                .withTextColor(ContextCompat.getColor(this, R.color.bg_white))
                .withHeaderBackground(R.drawable.ole_logo)
                .withDividerBelowHeader(false)
                .withTranslucentStatusBar(false)
                .withHeightDp(paddingVerticalDp + 20 * 2 + (statusBarHeight / density).toInt())
                .build()
            val headerBackground = header.headerBackgroundView
            headerBackground.setPadding(
                paddingHorizontalDp, paddingVerticalDp + statusBarHeight + 25,
                paddingHorizontalDp, paddingVerticalDp + 50
            )

            val currentNightMode = resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK
            if (AppCompatDelegate.getDefaultNightMode() == AppCompatDelegate.MODE_NIGHT_NO ||
                (AppCompatDelegate.getDefaultNightMode() == AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM && currentNightMode == Configuration.UI_MODE_NIGHT_NO)) {
                headerBackground.setColorFilter(
                    ContextCompat.getColor(this, R.color.md_white_1000),
                    PorterDuff.Mode.SRC_IN
                )
            }
            return header
        }

    private fun createDrawer() {
        val resourceId = resources.getIdentifier("status_bar_height", "dimen", "android")
        val statusBarHeight = if (resourceId > 0) {
            resources.getDimensionPixelSize(resourceId)
        } else {
            ceil(25 * resources.displayMetrics.density).toInt()
        }

        val headerHeight = 160 + (statusBarHeight / resources.displayMetrics.density).toInt()
        val dimenHolder = DimenHolder.fromDp(headerHeight)

        result = headerResult?.let {
            DrawerBuilder().withActivity(this).withFullscreen(true).withTranslucentStatusBar(true).withTranslucentNavigationBar(true)
                .withSliderBackgroundColor(ContextCompat.getColor(this, R.color.colorPrimary))
                .withToolbar(binding.myToolbar)
                .withAccountHeader(it).withHeaderHeight(dimenHolder)
                .addDrawerItems(*drawerItems).addStickyDrawerItems(*drawerItemsFooter)
                .withOnDrawerItemClickListener { _: View?, _: Int, drawerItem: IDrawerItem<*, *>? ->
                    if (drawerItem != null) {
                        result?.setSelection(drawerItem.identifier, false)
                        menuAction((drawerItem as Nameable<*>).name.textRes)
                    }
                    false
                }.withDrawerWidthDp(200).build()
        }
        result?.stickyFooter?.setBackgroundColor(ContextCompat.getColor(this, R.color.colorPrimary))
    }

    private fun menuAction(selectedMenuId: Int) {
        handleDrawerSelection(selectedMenuId)
    }

    private fun handleDrawerSelection(selectedMenuId: Int) {
        when (selectedMenuId) {
            R.string.menu_myplanet -> openCallFragment(BellDashboardFragment())
            R.string.menu_library -> openCallFragment(ResourcesFragment())
            R.string.menu_surveys -> openCallFragment(SurveyFragment())
            R.string.menu_courses -> openCallFragment(CoursesFragment())
            R.string.menu_community -> openCallFragment(CommunityTabFragment())
            R.string.txt_myLibrary -> {
                if (user?.id?.startsWith("guest") == true) {
                    guestDialog(this)
                } else {
                    openMyFragment(ResourcesFragment())
                }
            }
            R.string.team -> openMyFragment(TeamFragment().apply {
                arguments = Bundle().apply {
                    putBoolean("fromDashboard", false)
                }
            })
            R.string.txt_myCourses -> {
                if (user?.id?.startsWith("guest") == true) {
                    guestDialog(this)
                } else {
                    openMyFragment(CoursesFragment())
                }
            }
            R.string.enterprises -> openEnterpriseFragment()
            R.string.menu_logout -> logout()
            else -> openCallFragment(BellDashboardFragment())
        }
    }

    override fun openMyFragment(f: Fragment) {
        val fragmentName = f::class.java.simpleName
        var tag = "My$fragmentName"
        val isDashboard = f.arguments?.getBoolean("fromDashboard", false) == true
        if(tag != "MyTeamFragment") {
            val b = Bundle()
            b.putBoolean("isMyCourseLib", true)
            f.arguments = b
        }
        if (isDashboard) {
            tag = "MyTeamDashboardFragment"
        }
        when (tag) {
            "MyCoursesFragment" -> result?.setSelection(2, false)
            "MyResourcesFragment" -> result?.setSelection(1, false)
            "MyTeamDashboardFragment" -> result?.setSelection(0, false)
            "MyTeamFragment" ->  result?.setSelection(5, false)
            else -> {
                result?.setSelection(0, false)
            }
        }
        openCallFragment(f, tag)
    }

    override fun onDestroy() {
        realmListeners.forEach { it.removeListener() }
        realmListeners.clear()

        systemNotificationReceiver?.let {
            unregisterReceiver(it)
            systemNotificationReceiver = null
        }

        if (::mRealm.isInitialized && !mRealm.isClosed) {
            mRealm.close()
        }
        super.onDestroy()
    }

    override fun openCallFragment(f: Fragment) {
        val tag = f::class.java.simpleName
        openCallFragment(f,tag)
    }

    override fun openLibraryDetailFragment(library: RealmMyLibrary?) {
        val f: Fragment = ResourceDetailFragment()
        val b = Bundle()
        b.putString("libraryId", library?.resourceId)
        f.arguments = b
        openCallFragment(f)
    }

    override fun sendSurvey(current: RealmStepExam?) {
        val f = SendSurveyFragment()
        val b = Bundle()
        b.putString("surveyId", current?.id)
        f.arguments = b
        f.show(supportFragmentManager, "")
    }

    private val drawerItems: Array<IDrawerItem<*, *>>
        get() {
            val menuImageList = ArrayList<Drawable>()
            ResourcesCompat.getDrawable(resources, R.drawable.myplanet, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.ourlibrary, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.ourcourses, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.mylibrary, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.mycourses, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.team, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.business, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.community, null)?.let { menuImageList.add(it) }
            ResourcesCompat.getDrawable(resources, R.drawable.survey, null)?.let { menuImageList.add(it) }
            return arrayOf(
                changeUX(R.string.menu_myplanet, menuImageList[0]).withIdentifier(0),
                changeUX(R.string.txt_myLibrary, menuImageList[1]).withIdentifier(1),
                changeUX(R.string.txt_myCourses, menuImageList[2]).withIdentifier(2),
                changeUX(R.string.menu_library, menuImageList[3]).withIdentifier(3),
                changeUX(R.string.menu_courses, menuImageList[4]).withIdentifier(4),
                changeUX(R.string.team, menuImageList[5]).withIdentifier(5),
                changeUX(R.string.enterprises, menuImageList[6]).withIdentifier(6),
                changeUX(R.string.menu_community, menuImageList[7]).withIdentifier(7),
                changeUX(R.string.menu_surveys, menuImageList[8]).withIdentifier(8)
            )
        }

    private val drawerItemsFooter: Array<IDrawerItem<*, *>>
        get() {
            val menuImageListFooter = ArrayList<Drawable>()
            ResourcesCompat.getDrawable(resources, R.drawable.logout, null)?.let { menuImageListFooter.add(it) }
            return arrayOf(changeUX(R.string.menu_logout, menuImageListFooter[0]))
        }

    private fun changeUX(iconText: Int, drawable: Drawable?): PrimaryDrawerItem {
        return PrimaryDrawerItem().withName(iconText)
            .withIcon(drawable)
            .withTextColor(ContextCompat.getColor(this, R.color.textColorPrimary))
            .withSelectedTextColor(ContextCompat.getColor(this, R.color.primary_dark))
            .withIconColor(ContextCompat.getColor(this, R.color.textColorPrimary))
            .withSelectedIconColor(ContextCompat.getColor(this, R.color.primary_dark))
            .withSelectedColor(ContextCompat.getColor(this, R.color.textColorPrimary))
            .withIconTintingEnabled(true)
    }

    override fun onNavigationItemSelected(item: MenuItem): Boolean {
        item.isChecked = true
        when (item.itemId) {
            R.id.menu_library -> {
                openCallFragment(ResourcesFragment())
            }
            R.id.menu_courses -> {
                openCallFragment(CoursesFragment())
            }
            R.id.menu_mycourses -> {
                if (user?.id?.startsWith("guest") == true) {
                    guestDialog(this)
                } else {
                    openMyFragment(CoursesFragment())
                }
            }
            R.id.menu_mylibrary -> {
                if (user?.id?.startsWith("guest") == true) {
                    guestDialog(this)
                } else {
                    openMyFragment(ResourcesFragment())
                }
            }
            R.id.menu_enterprises -> {
                openEnterpriseFragment()
            }
            R.id.menu_home -> {
                openCallFragment(BellDashboardFragment())
            }
        }
        item.isChecked = true
        return true
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.menu_bell_dashboard, menu)
        bindGoOnlineMenu(menu)
        return super.onCreateOptionsMenu(menu)
    }

    override fun onResume() {
        super.onResume()
        checkNotificationPermissionStatus()
    }

    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        setIntent(intent)
        handleNotificationIntent(intent)

        if (intent?.action == "REFRESH_NOTIFICATION_BADGE") {
            val userId = user?.id
            if (userId != null) {
                lifecycleScope.launch {
                    delay(100)
                    try {
                        mRealm.refresh()
                        val unreadCount = dashboardViewModel.getUnreadNotificationsSize(userId)
                        onNotificationCountUpdated(unreadCount)
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
        }
    }

    override fun onNotificationPermissionGranted() {
        super.onNotificationPermissionGranted()
        if (notificationsShownThisSession) {
            checkAndCreateNewNotifications()
        }
    }

    override fun onNotificationPermissionChanged(isEnabled: Boolean) {
        super.onNotificationPermissionChanged(isEnabled)
        if (!isEnabled) {
            showNotificationDisabledReminder()
        }
    }

    private fun showNotificationDisabledReminder() {
        val snackbar = Snackbar.make(
            binding.root,
            "Notifications are disabled. You might miss important updates.",
            Snackbar.LENGTH_LONG
        )
        snackbar.setAction("Enable") {
            ensureNotificationPermission(true)
        }
        snackbar.show()
    }

    companion object {
        const val MESSAGE_PROGRESS = "message_progress"
        @JvmStatic
        var isFromNotificationAction = false
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/MyActivityFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.res.ResourcesCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import com.github.mikephil.charting.components.Description
import com.github.mikephil.charting.data.BarData
import com.github.mikephil.charting.data.BarDataSet
import com.github.mikephil.charting.data.BarEntry
import com.github.mikephil.charting.formatter.ValueFormatter
import dagger.hilt.android.AndroidEntryPoint
import java.text.DateFormatSymbols
import java.util.Calendar
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentMyActivityBinding
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler

@AndroidEntryPoint
class MyActivityFragment : Fragment() {
    private var _binding: FragmentMyActivityBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    @Inject
    lateinit var userRepository: UserRepository
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMyActivityBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val userModel = userProfileDbHandler.userModel
        val daynightTextColor = ResourcesCompat.getColor(resources, R.color.daynight_textColor, null)

        val endMillis = Calendar.getInstance().timeInMillis
        val startMillis = Calendar.getInstance().apply { add(Calendar.YEAR, -1) }.timeInMillis

        val userId = userModel?.id ?: return

        viewLifecycleOwner.lifecycleScope.launch {
            val monthlyCounts = userRepository.getMonthlyLoginCounts(userId, startMillis, endMillis)
            renderChart(monthlyCounts, daynightTextColor)
        }
    }

    private fun renderChart(monthlyCounts: Map<Int, Int>, textColor: Int) {
        val entries = monthlyCounts.entries
            .sortedBy { it.key }
            .map { (month, count) -> BarEntry(month.toFloat(), count.toFloat()) }

        val label = getString(R.string.chart_label)
        val dataSet = BarDataSet(entries, label)
        val barData = BarData(dataSet)

        val description = Description().apply {
            text = getString(R.string.chart_description)
            setTextColor(textColor)
        }

        binding.chart.apply {
            data = barData
            this.description = description
            xAxis.valueFormatter = object : ValueFormatter() {
                override fun getFormattedValue(value: Float): String {
                    return getMonth(value.toInt())
                }
            }
            xAxis.textColor = textColor
            axisLeft.textColor = textColor
            axisRight.textColor = textColor
            legend.textColor = textColor
            this.description.setPosition(850f, 830f)
            this.data.setValueTextColor(textColor)
            invalidate()
        }
    }

    fun getMonth(month: Int): String {
        return DateFormatSymbols().months[month]
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.res.ResourcesCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import com.github.mikephil.charting.components.Description
import com.github.mikephil.charting.data.BarData
import com.github.mikephil.charting.data.BarDataSet
import com.github.mikephil.charting.data.BarEntry
import com.github.mikephil.charting.formatter.ValueFormatter
import dagger.hilt.android.AndroidEntryPoint
import java.text.DateFormatSymbols
import java.util.Calendar
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentMyActivityBinding
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler

@AndroidEntryPoint
class MyActivityFragment : Fragment() {
    private var _binding: FragmentMyActivityBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var userProfileDbHandler: UserProfileDbHandler
    @Inject
    lateinit var userRepository: UserRepository
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMyActivityBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val userModel = userProfileDbHandler.userModel
        val daynightTextColor = ResourcesCompat.getColor(resources, R.color.daynight_textColor, null)

        val endMillis = Calendar.getInstance().timeInMillis
        val startMillis = Calendar.getInstance().apply { add(Calendar.YEAR, -1) }.timeInMillis

        val userId = userModel?.id ?: return

        viewLifecycleOwner.lifecycleScope.launch {
            val monthlyCounts = userRepository.getMonthlyLoginCounts(userId, startMillis, endMillis)
            renderChart(monthlyCounts, daynightTextColor)
        }
    }

    private fun renderChart(monthlyCounts: Map<Int, Int>, textColor: Int) {
        val entries = monthlyCounts.entries
            .sortedBy { it.key }
            .map { (month, count) -> BarEntry(month.toFloat(), count.toFloat()) }

        val label = getString(R.string.chart_label)
        val dataSet = BarDataSet(entries, label)
        val barData = BarData(dataSet)

        val description = Description().apply {
            text = getString(R.string.chart_description)
            setTextColor(textColor)
        }

        binding.chart.apply {
            data = barData
            this.description = description
            xAxis.valueFormatter = object : ValueFormatter() {
                override fun getFormattedValue(value: Float): String {
                    return getMonth(value.toInt())
                }
            }
            xAxis.textColor = textColor
            axisLeft.textColor = textColor
            axisRight.textColor = textColor
            legend.textColor = textColor
            this.description.setPosition(850f, 830f)
            this.data.setValueTextColor(textColor)
            invalidate()
        }
    }

    fun getMonth(month: Int): String {
        return DateFormatSymbols().months[month]
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/BaseDashboardFragmentPlugin.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import android.os.Bundle
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.widget.TextView
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import io.realm.RealmObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.databinding.ItemMyLifeBinding
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyLife
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.ui.calendar.CalendarFragment
import org.ole.planet.myplanet.ui.courses.TakeCourseFragment
import org.ole.planet.myplanet.ui.myhealth.MyHealthFragment
import org.ole.planet.myplanet.ui.mymeetup.MyMeetupDetailFragment
import org.ole.planet.myplanet.ui.mypersonals.MyPersonalsFragment
import org.ole.planet.myplanet.ui.references.ReferenceFragment
import org.ole.planet.myplanet.ui.submission.MySubmissionFragment
import org.ole.planet.myplanet.ui.team.TeamDetailFragment
import org.ole.planet.myplanet.ui.userprofile.AchievementFragment
import org.ole.planet.myplanet.utilities.DialogUtils.guestDialog
import org.ole.planet.myplanet.utilities.Utilities

open class BaseDashboardFragmentPlugin : BaseContainerFragment() {
    fun handleClick(id: String?, title: String?, f: Fragment, v: TextView) {
        v.text = title
        v.setOnClickListener {
            if (homeItemClickListener != null) {
                if (f is TeamDetailFragment) {
                    val teamObject = mRealm.where(RealmMyTeam::class.java)?.equalTo("_id", id)?.findFirst()
                    val optimizedFragment = TeamDetailFragment.newInstance(
                        teamId = id ?: "",
                        teamName = title ?: "",
                        teamType = teamObject?.type ?: "",
                        isMyTeam = true
                    )
                    prefData.setTeamName(title)
                    homeItemClickListener?.openCallFragment(optimizedFragment)
                } else {
                    val b = Bundle()
                    b.putString("id", id)
                    f.arguments = b
                    prefData.setTeamName(title)
                    homeItemClickListener?.openCallFragment(f)
                }
            }
        }
    }

    private fun handleClickMyLife(title: String, v: View) {
        v.setOnClickListener {
            homeItemClickListener?.let { listener ->
                when (title) {
                    "mySubmissions" -> openIfLoggedIn { listener.openCallFragment(MySubmissionFragment()) }
                    "References" -> listener.openCallFragment(ReferenceFragment())
                    "Calendar" -> listener.openCallFragment(CalendarFragment())
                    "mySurveys" -> openIfLoggedIn { listener.openCallFragment(MySubmissionFragment.newInstance("survey")) }
                    "myAchievements" -> openIfLoggedIn { listener.openCallFragment(AchievementFragment()) }
                    "myPersonals" -> openIfLoggedIn { listener.openCallFragment(MyPersonalsFragment()) }
                    "myHealth" -> openIfLoggedIn { listener.openCallFragment(MyHealthFragment()) }
                    else -> Utilities.toast(activity, getString(R.string.feature_not_available))
                }
            }
        }
    }

    private inline fun openIfLoggedIn(action: () -> Unit) {
        if (model?.id?.startsWith("guest") == false) {
            action()
        } else {
            guestDialog(requireContext())
        }
    }

    fun setTextViewProperties(textViewArray: Array<TextView?>, itemCnt: Int, obj: RealmObject?) {
        textViewArray[itemCnt] = TextView(context)
        textViewArray[itemCnt]?.setPadding(20, 10, 20, 10)
        textViewArray[itemCnt]?.textAlignment = View.TEXT_ALIGNMENT_CENTER
        textViewArray[itemCnt]?.gravity = Gravity.CENTER_VERTICAL or Gravity.CENTER_HORIZONTAL
        when (obj) {
            is RealmMyLibrary -> {
                textViewArray[itemCnt]?.text = obj.title
            }
            is RealmMyCourse -> {
                textViewArray[itemCnt]?.let {
                    handleClick(obj.courseId, obj.courseTitle, TakeCourseFragment(), it)
                }
            }
            is RealmMeetup -> {
                textViewArray[itemCnt]?.let {
                    handleClick(obj.meetupId, obj.title, MyMeetupDetailFragment(), it)
                }
            }
        }
    }

    fun setTextColor(textView: TextView, itemCnt: Int) {
        textView.setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
        setBackgroundColor(textView, itemCnt)
    }

    fun getLayout(itemCnt: Int, obj: RealmObject): View {
        val itemMyLifeBinding = ItemMyLifeBinding.inflate(LayoutInflater.from(activity))
        val v = itemMyLifeBinding.root
        setBackgroundColor(v, itemCnt)

        val title = (obj as RealmMyLife).title
        val user = profileDbHandler.userModel
        itemMyLifeBinding.img.setImageResource(resources.getIdentifier(obj.imageId, "drawable", requireActivity().packageName))
        itemMyLifeBinding.tvName.text = title

        if (title == getString(R.string.my_survey)) {
            itemMyLifeBinding.tvCount.visibility = View.VISIBLE
            val noOfSurvey = RealmSubmission.getNoOfSurveySubmissionByUser(user?.id, mRealm)
            itemMyLifeBinding.tvCount.text = noOfSurvey.toString()
        } else {
            itemMyLifeBinding.tvCount.visibility = View.GONE
        }

        if (title != null) {
            handleClickMyLife(title, v)
        }
        return v
    }

    fun getMyLifeListBase(userId: String?): List<RealmMyLife> {
        val myLifeList: MutableList<RealmMyLife> = ArrayList()
        myLifeList.add(RealmMyLife("ic_myhealth", userId, getString(R.string.myhealth)))
        myLifeList.add(RealmMyLife("my_achievement", userId, getString(R.string.achievements)))
        myLifeList.add(RealmMyLife("ic_submissions", userId, getString(R.string.submission)))
        myLifeList.add(RealmMyLife("ic_my_survey", userId, getString(R.string.my_survey)))
        myLifeList.add(RealmMyLife("ic_references", userId, getString(R.string.references)))
        myLifeList.add(RealmMyLife("ic_calendar", userId, getString(R.string.calendar)))
        myLifeList.add(RealmMyLife("ic_mypersonals", userId, getString(R.string.mypersonals)))
        return myLifeList
    }

    fun setBackgroundColor(v: View, count: Int) {
        if (count % 2 == 0) {
            v.setBackgroundResource(R.drawable.light_rect)
        } else {
            v.setBackgroundResource(R.color.dashboard_item_alternative)
        }
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard


import android.os.Bundle
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.widget.TextView
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import io.realm.RealmObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseContainerFragment
import org.ole.planet.myplanet.databinding.ItemMyLifeBinding
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyLife
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.ui.calendar.CalendarFragment
import org.ole.planet.myplanet.ui.courses.TakeCourseFragment
import org.ole.planet.myplanet.ui.myhealth.MyHealthFragment
import org.ole.planet.myplanet.ui.mymeetup.MyMeetupDetailFragment
import org.ole.planet.myplanet.ui.mypersonals.MyPersonalsFragment
import org.ole.planet.myplanet.ui.references.ReferenceFragment
import org.ole.planet.myplanet.ui.submission.MySubmissionFragment
import org.ole.planet.myplanet.ui.team.TeamDetailFragment
import org.ole.planet.myplanet.ui.userprofile.AchievementFragment
import org.ole.planet.myplanet.utilities.DialogUtils.guestDialog
import org.ole.planet.myplanet.utilities.Utilities

open class BaseDashboardFragmentPlugin : BaseContainerFragment() {
    fun handleClick(id: String?, title: String?, f: Fragment, v: TextView) {
        v.text = title
        v.setOnClickListener {
            if (homeItemClickListener != null) {
                if (f is TeamDetailFragment) {
                    val teamObject = mRealm.where(RealmMyTeam::class.java)?.equalTo("_id", id)?.findFirst()
                    val optimizedFragment = TeamDetailFragment.newInstance(
                        teamId = id ?: "",
                        teamName = title ?: "",
                        teamType = teamObject?.type ?: "",
                        isMyTeam = true
                    )
                    prefData.setTeamName(title)
                    homeItemClickListener?.openCallFragment(optimizedFragment)
                } else {
                    val b = Bundle()
                    b.putString("id", id)
                    f.arguments = b
                    prefData.setTeamName(title)
                    homeItemClickListener?.openCallFragment(f)
                }
            }
        }
    }

    private fun handleClickMyLife(title: String, v: View) {
        v.setOnClickListener {
            homeItemClickListener?.let { listener ->
                when (title) {
                    "mySubmissions" -> openIfLoggedIn { listener.openCallFragment(MySubmissionFragment()) }
                    "References" -> listener.openCallFragment(ReferenceFragment())
                    "Calendar" -> listener.openCallFragment(CalendarFragment())
                    "mySurveys" -> openIfLoggedIn { listener.openCallFragment(MySubmissionFragment.newInstance("survey")) }
                    "myAchievements" -> openIfLoggedIn { listener.openCallFragment(AchievementFragment()) }
                    "myPersonals" -> openIfLoggedIn { listener.openCallFragment(MyPersonalsFragment()) }
                    "myHealth" -> openIfLoggedIn { listener.openCallFragment(MyHealthFragment()) }
                    else -> Utilities.toast(activity, getString(R.string.feature_not_available))
                }
            }
        }
    }

    private inline fun openIfLoggedIn(action: () -> Unit) {
        if (model?.id?.startsWith("guest") == false) {
            action()
        } else {
            guestDialog(requireContext())
        }
    }

    fun setTextViewProperties(textViewArray: Array<TextView?>, itemCnt: Int, obj: RealmObject?) {
        textViewArray[itemCnt] = TextView(context)
        textViewArray[itemCnt]?.setPadding(20, 10, 20, 10)
        textViewArray[itemCnt]?.textAlignment = View.TEXT_ALIGNMENT_CENTER
        textViewArray[itemCnt]?.gravity = Gravity.CENTER_VERTICAL or Gravity.CENTER_HORIZONTAL
        when (obj) {
            is RealmMyLibrary -> {
                textViewArray[itemCnt]?.text = obj.title
            }
            is RealmMyCourse -> {
                textViewArray[itemCnt]?.let {
                    handleClick(obj.courseId, obj.courseTitle, TakeCourseFragment(), it)
                }
            }
            is RealmMeetup -> {
                textViewArray[itemCnt]?.let {
                    handleClick(obj.meetupId, obj.title, MyMeetupDetailFragment(), it)
                }
            }
        }
    }

    fun setTextColor(textView: TextView, itemCnt: Int) {
        textView.setTextColor(ContextCompat.getColor(requireContext(), R.color.daynight_textColor))
        setBackgroundColor(textView, itemCnt)
    }

    fun getLayout(itemCnt: Int, obj: RealmObject): View {
        val itemMyLifeBinding = ItemMyLifeBinding.inflate(LayoutInflater.from(activity))
        val v = itemMyLifeBinding.root
        setBackgroundColor(v, itemCnt)

        val title = (obj as RealmMyLife).title
        val user = profileDbHandler.userModel
        itemMyLifeBinding.img.setImageResource(resources.getIdentifier(obj.imageId, "drawable", requireActivity().packageName))
        itemMyLifeBinding.tvName.text = title

        if (title == getString(R.string.my_survey)) {
            itemMyLifeBinding.tvCount.visibility = View.VISIBLE
            val noOfSurvey = RealmSubmission.getNoOfSurveySubmissionByUser(user?.id, mRealm)
            itemMyLifeBinding.tvCount.text = noOfSurvey.toString()
        } else {
            itemMyLifeBinding.tvCount.visibility = View.GONE
        }

        if (title != null) {
            handleClickMyLife(title, v)
        }
        return v
    }

    fun getMyLifeListBase(userId: String?): List<RealmMyLife> {
        val myLifeList: MutableList<RealmMyLife> = ArrayList()
        myLifeList.add(RealmMyLife("ic_myhealth", userId, getString(R.string.myhealth)))
        myLifeList.add(RealmMyLife("my_achievement", userId, getString(R.string.achievements)))
        myLifeList.add(RealmMyLife("ic_submissions", userId, getString(R.string.submission)))
        myLifeList.add(RealmMyLife("ic_my_survey", userId, getString(R.string.my_survey)))
        myLifeList.add(RealmMyLife("ic_references", userId, getString(R.string.references)))
        myLifeList.add(RealmMyLife("ic_calendar", userId, getString(R.string.calendar)))
        myLifeList.add(RealmMyLife("ic_mypersonals", userId, getString(R.string.mypersonals)))
        return myLifeList
    }

    fun setBackgroundColor(v: View, count: Int) {
        if (count % 2 == 0) {
            v.setBackgroundResource(R.drawable.light_rect)
        } else {
            v.setBackgroundResource(R.color.dashboard_item_alternative)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/notification/AdapterNotification.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard.notification

import android.content.Context
import android.text.Html
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import java.util.regex.Pattern
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowNotificationsBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNotification
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.DiffUtils as DiffUtilExtensions

class AdapterNotification(
    private val databaseService: DatabaseService,
    notifications: List<RealmNotification>,
    private val onMarkAsReadClick: (String) -> Unit,
    private val onNotificationClick: (RealmNotification) -> Unit
) : ListAdapter<RealmNotification, AdapterNotification.ViewHolderNotifications>(
    DiffUtilExtensions.itemCallback(
        areItemsTheSame = { oldItem, newItem -> oldItem.id == newItem.id },
        areContentsTheSame = { oldItem, newItem -> oldItem == newItem }
    )
) {

    init {
        submitList(notifications)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderNotifications {
        val rowNotificationsBinding = RowNotificationsBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderNotifications(rowNotificationsBinding)
    }

    override fun onBindViewHolder(holder: ViewHolderNotifications, position: Int) {
        val notification = getItem(position)
        holder.bind(notification)
    }

    fun updateNotifications(newNotifications: List<RealmNotification>) {
        submitList(newNotifications)
    }

    inner class ViewHolderNotifications(private val rowNotificationsBinding: RowNotificationsBinding) :
        RecyclerView.ViewHolder(rowNotificationsBinding.root) {

        fun bind(notification: RealmNotification) {
            val context = rowNotificationsBinding.root.context
            val currentNotification = formatNotificationMessage(notification, context)
            rowNotificationsBinding.title.text = Html.fromHtml(currentNotification, Html.FROM_HTML_MODE_LEGACY)
            if (notification.isRead) {
                rowNotificationsBinding.btnMarkAsRead.visibility = View.GONE
                rowNotificationsBinding.root.alpha = 0.5f
            } else {
                rowNotificationsBinding.btnMarkAsRead.visibility = View.VISIBLE
                rowNotificationsBinding.root.alpha = 1.0f
                rowNotificationsBinding.btnMarkAsRead.setOnClickListener {
                    onMarkAsReadClick(notification.id)
                }
            }

            rowNotificationsBinding.root.setOnClickListener {
                onNotificationClick(notification)
            }
        }

        private fun formatNotificationMessage(notification: RealmNotification, context: Context): String {
            return when (notification.type.lowercase()) {
                "survey" -> context.getString(R.string.pending_survey_notification) + " ${notification.message}"
                "task" -> {
                    val datePattern = Pattern.compile("\\b(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\\s\\d{1,2},\\s\\w+\\s\\d{4}\\b")
                    val matcher = datePattern.matcher(notification.message)
                    if (matcher.find()) {
                        val taskTitle = notification.message.substring(0, matcher.start()).trim()
                        val dateValue = notification.message.substring(matcher.start()).trim()
                        formatTaskNotification(context, taskTitle, dateValue)
                    } else {
                        notification.message
                    }
                }
                "resource" -> {
                    notification.message.toIntOrNull()?.let { count ->
                        context.getString(R.string.resource_notification, count)
                    } ?: notification.message
                }
                "storage" -> {
                    val storageValue = notification.message.replace("%", "").toIntOrNull()
                    storageValue?.let {
                        when {
                            it <= 10 -> context.getString(R.string.storage_running_low) + " ${it}%"
                            it <= 40 -> context.getString(R.string.storage_running_low) + " ${it}%"
                            else -> context.getString(R.string.storage_available) + " ${it}%"
                        }
                    } ?: notification.message
                }
                "join_request" -> {
                    databaseService.withRealm { realm ->
                        val joinRequest = realm.where(RealmMyTeam::class.java)
                            .equalTo("_id", notification.relatedId)
                            .equalTo("docType", "request")
                            .findFirst()
                        val team = joinRequest?.teamId?.let { tid ->
                            realm.where(RealmMyTeam::class.java)
                                .equalTo("_id", tid)
                                .findFirst()
                        }
                        val requester = joinRequest?.userId?.let { uid ->
                            realm.where(RealmUserModel::class.java)
                                .equalTo("id", uid)
                                .findFirst()
                        }
                        val requesterName = requester?.name ?: "Unknown User"
                        val teamName = team?.name ?: "Unknown Team"
                        "<b>${context.getString(R.string.join_request_prefix)}</b> " +
                            context.getString(R.string.user_requested_to_join_team, requesterName, teamName)
                    }
                }
                else -> notification.message
            }
        }

        private fun formatTaskNotification(context: Context, taskTitle: String, dateValue: String): String {
            return databaseService.withRealm { realm ->
                val taskObj = realm.where(RealmTeamTask::class.java)
                    .equalTo("title", taskTitle)
                    .findFirst()
                val team = realm.where(RealmMyTeam::class.java)
                    .equalTo("_id", taskObj?.teamId)
                    .findFirst()
                if (team?.name != null) {
                    "<b>${team.name}</b>: ${context.getString(R.string.task_notification, taskTitle, dateValue)}"
                } else {
                    context.getString(R.string.task_notification, taskTitle, dateValue)
                }
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard.notification


import android.content.Context
import android.text.Html
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import java.util.regex.Pattern
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowNotificationsBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNotification
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.utilities.DiffUtils as DiffUtilExtensions

class AdapterNotification(
    private val databaseService: DatabaseService,
    notifications: List<RealmNotification>,
    private val onMarkAsReadClick: (String) -> Unit,
    private val onNotificationClick: (RealmNotification) -> Unit
) : ListAdapter<RealmNotification, AdapterNotification.ViewHolderNotifications>(
    DiffUtilExtensions.itemCallback(
        areItemsTheSame = { oldItem, newItem -> oldItem.id == newItem.id },
        areContentsTheSame = { oldItem, newItem -> oldItem == newItem }
    )
) {

    init {
        submitList(notifications)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderNotifications {
        val rowNotificationsBinding = RowNotificationsBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderNotifications(rowNotificationsBinding)
    }

    override fun onBindViewHolder(holder: ViewHolderNotifications, position: Int) {
        val notification = getItem(position)
        holder.bind(notification)
    }

    fun updateNotifications(newNotifications: List<RealmNotification>) {
        submitList(newNotifications)
    }

    inner class ViewHolderNotifications(private val rowNotificationsBinding: RowNotificationsBinding) :
        RecyclerView.ViewHolder(rowNotificationsBinding.root) {

        fun bind(notification: RealmNotification) {
            val context = rowNotificationsBinding.root.context
            val currentNotification = formatNotificationMessage(notification, context)
            rowNotificationsBinding.title.text = Html.fromHtml(currentNotification, Html.FROM_HTML_MODE_LEGACY)
            if (notification.isRead) {
                rowNotificationsBinding.btnMarkAsRead.visibility = View.GONE
                rowNotificationsBinding.root.alpha = 0.5f
            } else {
                rowNotificationsBinding.btnMarkAsRead.visibility = View.VISIBLE
                rowNotificationsBinding.root.alpha = 1.0f
                rowNotificationsBinding.btnMarkAsRead.setOnClickListener {
                    onMarkAsReadClick(notification.id)
                }
            }

            rowNotificationsBinding.root.setOnClickListener {
                onNotificationClick(notification)
            }
        }

        private fun formatNotificationMessage(notification: RealmNotification, context: Context): String {
            return when (notification.type.lowercase()) {
                "survey" -> context.getString(R.string.pending_survey_notification) + " ${notification.message}"
                "task" -> {
                    val datePattern = Pattern.compile("\\b(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\\s\\d{1,2},\\s\\w+\\s\\d{4}\\b")
                    val matcher = datePattern.matcher(notification.message)
                    if (matcher.find()) {
                        val taskTitle = notification.message.substring(0, matcher.start()).trim()
                        val dateValue = notification.message.substring(matcher.start()).trim()
                        formatTaskNotification(context, taskTitle, dateValue)
                    } else {
                        notification.message
                    }
                }
                "resource" -> {
                    notification.message.toIntOrNull()?.let { count ->
                        context.getString(R.string.resource_notification, count)
                    } ?: notification.message
                }
                "storage" -> {
                    val storageValue = notification.message.replace("%", "").toIntOrNull()
                    storageValue?.let {
                        when {
                            it <= 10 -> context.getString(R.string.storage_running_low) + " ${it}%"
                            it <= 40 -> context.getString(R.string.storage_running_low) + " ${it}%"
                            else -> context.getString(R.string.storage_available) + " ${it}%"
                        }
                    } ?: notification.message
                }
                "join_request" -> {
                    databaseService.withRealm { realm ->
                        val joinRequest = realm.where(RealmMyTeam::class.java)
                            .equalTo("_id", notification.relatedId)
                            .equalTo("docType", "request")
                            .findFirst()
                        val team = joinRequest?.teamId?.let { tid ->
                            realm.where(RealmMyTeam::class.java)
                                .equalTo("_id", tid)
                                .findFirst()
                        }
                        val requester = joinRequest?.userId?.let { uid ->
                            realm.where(RealmUserModel::class.java)
                                .equalTo("id", uid)
                                .findFirst()
                        }
                        val requesterName = requester?.name ?: "Unknown User"
                        val teamName = team?.name ?: "Unknown Team"
                        "<b>${context.getString(R.string.join_request_prefix)}</b> " +
                            context.getString(R.string.user_requested_to_join_team, requesterName, teamName)
                    }
                }
                else -> notification.message
            }
        }

        private fun formatTaskNotification(context: Context, taskTitle: String, dateValue: String): String {
            return databaseService.withRealm { realm ->
                val taskObj = realm.where(RealmTeamTask::class.java)
                    .equalTo("title", taskTitle)
                    .findFirst()
                val team = realm.where(RealmMyTeam::class.java)
                    .equalTo("_id", taskObj?.teamId)
                    .findFirst()
                if (team?.name != null) {
                    "<b>${team.name}</b>: ${context.getString(R.string.task_notification, taskTitle, dateValue)}"
                } else {
                    context.getString(R.string.task_notification, taskTitle, dateValue)
                }
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/notification/NotificationsFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard.notification

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.provider.Settings.ACTION_INTERNAL_STORAGE_SETTINGS
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ArrayAdapter
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import java.util.ArrayList
import java.util.Date
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.R.array.status_options
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.FragmentNotificationsBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNotification
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.repository.NotificationRepository
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.resources.ResourcesFragment
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission
import org.ole.planet.myplanet.ui.team.TeamDetailFragment
import org.ole.planet.myplanet.ui.team.TeamPageConfig.JoinRequestsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.TasksPage
import org.ole.planet.myplanet.utilities.NotificationUtils

@AndroidEntryPoint
class NotificationsFragment : Fragment() {
    private var _binding: FragmentNotificationsBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var notificationRepository: NotificationRepository
    private lateinit var adapter: AdapterNotification
    private lateinit var userId: String
    private var notificationUpdateListener: NotificationListener? = null
    private lateinit var dashboardActivity: DashboardActivity
    private var unreadCountCache: Int = 0

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is DashboardActivity) {
            dashboardActivity = context
        }
    }

    fun setNotificationUpdateListener(listener: NotificationListener) {
        this.notificationUpdateListener = listener
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentNotificationsBinding.inflate(inflater, container, false)
        userId = arguments?.getString("userId") ?: ""
        adapter = AdapterNotification(
            databaseService,
            emptyList(),
            onMarkAsReadClick = { notificationId ->
                markAsReadById(notificationId)
            },
            onNotificationClick = { notification ->
                handleNotificationClick(notification)
            }
        )
        binding.rvNotifications.adapter = adapter
        binding.rvNotifications.layoutManager = LinearLayoutManager(requireContext())
        val options = resources.getStringArray(status_options)
        val optionsList: MutableList<String?> = ArrayList(listOf(*options))
        val spinnerAdapter = ArrayAdapter(requireContext(), R.layout.spinner_item, optionsList)
        spinnerAdapter.setDropDownViewResource(R.layout.spinner_item)
        binding.status.adapter = spinnerAdapter
        binding.status.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>, view: View?, position: Int, id: Long) {
                val selectedOption = parent.getItemAtPosition(position).toString().lowercase()
                loadAndDisplayNotifications(selectedOption)
            }

            override fun onNothingSelected(parent: AdapterView<*>) {}
        }
        loadAndDisplayNotifications("all")
        refreshUnreadCountCache()
        binding.btnMarkAllAsRead.setOnClickListener {
            markAllAsRead()
        }
        return binding.root
    }

    private fun handleNotificationClick(notification: RealmNotification) {
        viewLifecycleOwner.lifecycleScope.launch {
            val result = withContext(Dispatchers.IO) {
                when (notification.type) {
                    "survey" -> {
                        databaseService.withRealm { realm ->
                            realm.where(RealmStepExam::class.java)
                                .equalTo("name", notification.relatedId)
                                .findFirst()?.id
                        }
                    }
                    "task" -> {
                        databaseService.withRealm { realm ->
                            val taskId = notification.relatedId
                            val task = realm.where(RealmTeamTask::class.java)
                                .equalTo("id", taskId)
                                .findFirst()
                            val linkJson = JSONObject(task?.link ?: "{}")
                            val teamId = linkJson.optString("teams")
                            if (teamId.isNotEmpty()) {
                                val teamObject = realm.where(RealmMyTeam::class.java)
                                    .equalTo("_id", teamId)
                                    .findFirst()
                                Triple(teamId, teamObject?.name, teamObject?.type)
                            } else {
                                null
                            }
                        }
                    }
                    "join_request" -> {
                        val joinRequestId = notification.relatedId
                        if (joinRequestId?.isNotEmpty() == true) {
                            val actualJoinRequestId = if (joinRequestId.startsWith("join_request_")) {
                                joinRequestId.removePrefix("join_request_")
                            } else {
                                joinRequestId
                            }
                            databaseService.withRealm { realm ->
                                realm.where(RealmMyTeam::class.java)
                                    .equalTo("_id", actualJoinRequestId)
                                    .equalTo("docType", "request")
                                    .findFirst()?.teamId
                            }
                        } else {
                            null
                        }
                    }
                    else -> null
                }
            }

            when (notification.type) {
                "storage" -> {
                    val intent = Intent(ACTION_INTERNAL_STORAGE_SETTINGS)
                    startActivity(intent)
                }
                "survey" -> {
                    val examId = result as? String
                    if (examId != null && activity is OnHomeItemClickListener) {
                        AdapterMySubmission.openSurvey(
                            activity as OnHomeItemClickListener,
                            examId,
                            false,
                            false,
                            "",
                        )
                    }
                }
                "task" -> {
                    val teamDetails = result as? Triple<String, String?, String?>
                    if (teamDetails != null && activity is OnHomeItemClickListener) {
                        val (teamId, teamName, teamType) = teamDetails
                        val f = TeamDetailFragment.newInstance(
                            teamId = teamId,
                            teamName = teamName ?: "",
                            teamType = teamType ?: "",
                            isMyTeam = true,
                            navigateToPage = TasksPage,
                        )
                        (activity as OnHomeItemClickListener).openCallFragment(f)
                    }
                }
                "join_request" -> {
                    val teamId = result as? String
                    if (teamId?.isNotEmpty() == true && activity is OnHomeItemClickListener) {
                        val f = TeamDetailFragment()
                        val b = Bundle()
                        b.putString("id", teamId)
                        b.putBoolean("isMyTeam", true)
                        b.putString("navigateToPage", JoinRequestsPage.id)
                        f.arguments = b
                        (activity as OnHomeItemClickListener).openCallFragment(f)
                    }
                }
                "resource" -> {
                    dashboardActivity.openMyFragment(ResourcesFragment())
                }
            }

            if (!notification.isRead) {
                markAsReadById(notification.id)
            }
        }
    }

    private fun loadAndDisplayNotifications(filter: String) {
        viewLifecycleOwner.lifecycleScope.launch {
            val notifications = withContext(Dispatchers.IO) {
                notificationRepository.getNotifications(userId, filter)
            }
            adapter.updateNotifications(notifications)
            binding.emptyData.visibility = if (notifications.isEmpty()) View.VISIBLE else View.GONE
        }
    }

    private fun markAsReadById(notificationId: String) {
        markNotificationsAsRead(setOf(notificationId), isMarkAll = false) {
            notificationRepository.markNotificationsAsRead(setOf(notificationId))
        }
    }

    private fun markAllAsRead() {
        val notificationIds = adapter.currentList.map { it.id }.toSet()
        markNotificationsAsRead(notificationIds, isMarkAll = true) {
            notificationRepository.markAllUnreadAsRead(userId)
        }
    }

    private fun updateMarkAllAsReadButtonVisibility() {
        _binding?.let { binding ->
            binding.btnMarkAllAsRead.visibility = if (unreadCountCache > 0) View.VISIBLE else View.GONE
        }
    }

    private fun updateUnreadCount() {
        notificationUpdateListener?.onNotificationCountUpdated(unreadCountCache)
    }

    fun refreshNotificationsList() {
        if (::adapter.isInitialized && _binding != null) {
            val selectedFilter = binding.status.selectedItem.toString().lowercase()
            loadAndDisplayNotifications(selectedFilter)
            refreshUnreadCountCache()
        }
    }

    private fun refreshUnreadCountCache() {
        viewLifecycleOwner.lifecycleScope.launch(Dispatchers.IO) {
            val count = notificationRepository.getUnreadCount(userId)
            withContext(Dispatchers.Main) {
                unreadCountCache = count
                updateMarkAllAsReadButtonVisibility()
                updateUnreadCount()
            }
        }
    }

    private fun markNotificationsAsRead(
        notificationIdsForUi: Set<String>,
        isMarkAll: Boolean,
        backgroundAction: suspend () -> Set<String>,
    ) {
        viewLifecycleOwner.lifecycleScope.launch {
            val binding = _binding ?: return@launch
            val selectedFilter = binding.status.selectedItem.toString().lowercase()
            val previousList = adapter.currentList.toList()
            val previousUnreadCount = unreadCountCache
            val appContext = requireContext().applicationContext

            val updatedList = if (notificationIdsForUi.isNotEmpty()) {
                getUpdatedListAfterMarkingRead(previousList, notificationIdsForUi, selectedFilter)
            } else {
                previousList
            }

            if (notificationIdsForUi.isNotEmpty()) {
                adapter.submitList(updatedList)
                binding.emptyData.visibility = if (updatedList.isEmpty()) View.VISIBLE else View.GONE
            }

            val unreadMarkedCount = if (isMarkAll) {
                previousUnreadCount
            } else {
                previousList.count { notificationIdsForUi.contains(it.id) && !it.isRead }
            }

            unreadCountCache = if (isMarkAll) {
                0
            } else {
                (previousUnreadCount - unreadMarkedCount).coerceAtLeast(0)
            }
            updateMarkAllAsReadButtonVisibility()
            updateUnreadCount()

            try {
                withContext(Dispatchers.IO) {
                    val idsToClear = backgroundAction()
                    val notificationManager = NotificationUtils.getInstance(appContext)
                    idsToClear.forEach { notificationManager.clearNotification(it) }
                }
            } catch (e: Exception) {
                unreadCountCache = previousUnreadCount
                val bindingOrNull = _binding

                if (notificationIdsForUi.isNotEmpty()) {
                    adapter.submitList(previousList)
                    bindingOrNull?.emptyData?.visibility =
                        if (previousList.isEmpty()) View.VISIBLE else View.GONE
                }

                updateMarkAllAsReadButtonVisibility()
                updateUnreadCount()

                bindingOrNull?.let { currentBinding ->
                    Snackbar.make(
                        currentBinding.root,
                        getString(R.string.failed_to_mark_as_read),
                        Snackbar.LENGTH_LONG,
                    ).show()
                }
            }
        }
    }

    private fun getUpdatedListAfterMarkingRead(
        currentList: List<RealmNotification>,
        notificationIds: Set<String>,
        selectedFilter: String,
    ): List<RealmNotification> {
        return if (selectedFilter == "unread") {
            currentList.filterNot { notificationIds.contains(it.id) }
        } else {
            currentList.map { notification ->
                if (notificationIds.contains(notification.id) && !notification.isRead) {
                    notification.asReadCopy()
                } else {
                    notification
                }
            }.sortedWith(compareBy<RealmNotification> { it.isRead }.thenByDescending { it.createdAt })
        }
    }

    private fun RealmNotification.asReadCopy(): RealmNotification {
        return RealmNotification().also { copy ->
            copy.id = id
            copy.userId = userId
            copy.message = message
            copy.isRead = true
            copy.createdAt = Date()
            copy.type = type
            copy.relatedId = relatedId
            copy.title = title
        }
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard.notification


import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.provider.Settings.ACTION_INTERNAL_STORAGE_SETTINGS
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ArrayAdapter
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.android.material.snackbar.Snackbar
import dagger.hilt.android.AndroidEntryPoint
import java.util.ArrayList
import java.util.Date
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.R.array.status_options
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.FragmentNotificationsBinding
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNotification
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.repository.NotificationRepository
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.resources.ResourcesFragment
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission
import org.ole.planet.myplanet.ui.team.TeamDetailFragment
import org.ole.planet.myplanet.ui.team.TeamPageConfig.JoinRequestsPage
import org.ole.planet.myplanet.ui.team.TeamPageConfig.TasksPage
import org.ole.planet.myplanet.utilities.NotificationUtils

@AndroidEntryPoint
class NotificationsFragment : Fragment() {
    private var _binding: FragmentNotificationsBinding? = null
    private val binding get() = _binding!!
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var notificationRepository: NotificationRepository
    private lateinit var adapter: AdapterNotification
    private lateinit var userId: String
    private var notificationUpdateListener: NotificationListener? = null
    private lateinit var dashboardActivity: DashboardActivity
    private var unreadCountCache: Int = 0

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is DashboardActivity) {
            dashboardActivity = context
        }
    }

    fun setNotificationUpdateListener(listener: NotificationListener) {
        this.notificationUpdateListener = listener
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentNotificationsBinding.inflate(inflater, container, false)
        userId = arguments?.getString("userId") ?: ""
        adapter = AdapterNotification(
            databaseService,
            emptyList(),
            onMarkAsReadClick = { notificationId ->
                markAsReadById(notificationId)
            },
            onNotificationClick = { notification ->
                handleNotificationClick(notification)
            }
        )
        binding.rvNotifications.adapter = adapter
        binding.rvNotifications.layoutManager = LinearLayoutManager(requireContext())
        val options = resources.getStringArray(status_options)
        val optionsList: MutableList<String?> = ArrayList(listOf(*options))
        val spinnerAdapter = ArrayAdapter(requireContext(), R.layout.spinner_item, optionsList)
        spinnerAdapter.setDropDownViewResource(R.layout.spinner_item)
        binding.status.adapter = spinnerAdapter
        binding.status.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>, view: View?, position: Int, id: Long) {
                val selectedOption = parent.getItemAtPosition(position).toString().lowercase()
                loadAndDisplayNotifications(selectedOption)
            }

            override fun onNothingSelected(parent: AdapterView<*>) {}
        }
        loadAndDisplayNotifications("all")
        refreshUnreadCountCache()
        binding.btnMarkAllAsRead.setOnClickListener {
            markAllAsRead()
        }
        return binding.root
    }

    private fun handleNotificationClick(notification: RealmNotification) {
        viewLifecycleOwner.lifecycleScope.launch {
            val result = withContext(Dispatchers.IO) {
                when (notification.type) {
                    "survey" -> {
                        databaseService.withRealm { realm ->
                            realm.where(RealmStepExam::class.java)
                                .equalTo("name", notification.relatedId)
                                .findFirst()?.id
                        }
                    }
                    "task" -> {
                        databaseService.withRealm { realm ->
                            val taskId = notification.relatedId
                            val task = realm.where(RealmTeamTask::class.java)
                                .equalTo("id", taskId)
                                .findFirst()
                            val linkJson = JSONObject(task?.link ?: "{}")
                            val teamId = linkJson.optString("teams")
                            if (teamId.isNotEmpty()) {
                                val teamObject = realm.where(RealmMyTeam::class.java)
                                    .equalTo("_id", teamId)
                                    .findFirst()
                                Triple(teamId, teamObject?.name, teamObject?.type)
                            } else {
                                null
                            }
                        }
                    }
                    "join_request" -> {
                        val joinRequestId = notification.relatedId
                        if (joinRequestId?.isNotEmpty() == true) {
                            val actualJoinRequestId = if (joinRequestId.startsWith("join_request_")) {
                                joinRequestId.removePrefix("join_request_")
                            } else {
                                joinRequestId
                            }
                            databaseService.withRealm { realm ->
                                realm.where(RealmMyTeam::class.java)
                                    .equalTo("_id", actualJoinRequestId)
                                    .equalTo("docType", "request")
                                    .findFirst()?.teamId
                            }
                        } else {
                            null
                        }
                    }
                    else -> null
                }
            }

            when (notification.type) {
                "storage" -> {
                    val intent = Intent(ACTION_INTERNAL_STORAGE_SETTINGS)
                    startActivity(intent)
                }
                "survey" -> {
                    val examId = result as? String
                    if (examId != null && activity is OnHomeItemClickListener) {
                        AdapterMySubmission.openSurvey(
                            activity as OnHomeItemClickListener,
                            examId,
                            false,
                            false,
                            "",
                        )
                    }
                }
                "task" -> {
                    val teamDetails = result as? Triple<String, String?, String?>
                    if (teamDetails != null && activity is OnHomeItemClickListener) {
                        val (teamId, teamName, teamType) = teamDetails
                        val f = TeamDetailFragment.newInstance(
                            teamId = teamId,
                            teamName = teamName ?: "",
                            teamType = teamType ?: "",
                            isMyTeam = true,
                            navigateToPage = TasksPage,
                        )
                        (activity as OnHomeItemClickListener).openCallFragment(f)
                    }
                }
                "join_request" -> {
                    val teamId = result as? String
                    if (teamId?.isNotEmpty() == true && activity is OnHomeItemClickListener) {
                        val f = TeamDetailFragment()
                        val b = Bundle()
                        b.putString("id", teamId)
                        b.putBoolean("isMyTeam", true)
                        b.putString("navigateToPage", JoinRequestsPage.id)
                        f.arguments = b
                        (activity as OnHomeItemClickListener).openCallFragment(f)
                    }
                }
                "resource" -> {
                    dashboardActivity.openMyFragment(ResourcesFragment())
                }
            }

            if (!notification.isRead) {
                markAsReadById(notification.id)
            }
        }
    }

    private fun loadAndDisplayNotifications(filter: String) {
        viewLifecycleOwner.lifecycleScope.launch {
            val notifications = withContext(Dispatchers.IO) {
                notificationRepository.getNotifications(userId, filter)
            }
            adapter.updateNotifications(notifications)
            binding.emptyData.visibility = if (notifications.isEmpty()) View.VISIBLE else View.GONE
        }
    }

    private fun markAsReadById(notificationId: String) {
        markNotificationsAsRead(setOf(notificationId), isMarkAll = false) {
            notificationRepository.markNotificationsAsRead(setOf(notificationId))
        }
    }

    private fun markAllAsRead() {
        val notificationIds = adapter.currentList.map { it.id }.toSet()
        markNotificationsAsRead(notificationIds, isMarkAll = true) {
            notificationRepository.markAllUnreadAsRead(userId)
        }
    }

    private fun updateMarkAllAsReadButtonVisibility() {
        _binding?.let { binding ->
            binding.btnMarkAllAsRead.visibility = if (unreadCountCache > 0) View.VISIBLE else View.GONE
        }
    }

    private fun updateUnreadCount() {
        notificationUpdateListener?.onNotificationCountUpdated(unreadCountCache)
    }

    fun refreshNotificationsList() {
        if (::adapter.isInitialized && _binding != null) {
            val selectedFilter = binding.status.selectedItem.toString().lowercase()
            loadAndDisplayNotifications(selectedFilter)
            refreshUnreadCountCache()
        }
    }

    private fun refreshUnreadCountCache() {
        viewLifecycleOwner.lifecycleScope.launch(Dispatchers.IO) {
            val count = notificationRepository.getUnreadCount(userId)
            withContext(Dispatchers.Main) {
                unreadCountCache = count
                updateMarkAllAsReadButtonVisibility()
                updateUnreadCount()
            }
        }
    }

    private fun markNotificationsAsRead(
        notificationIdsForUi: Set<String>,
        isMarkAll: Boolean,
        backgroundAction: suspend () -> Set<String>,
    ) {
        viewLifecycleOwner.lifecycleScope.launch {
            val binding = _binding ?: return@launch
            val selectedFilter = binding.status.selectedItem.toString().lowercase()
            val previousList = adapter.currentList.toList()
            val previousUnreadCount = unreadCountCache
            val appContext = requireContext().applicationContext

            val updatedList = if (notificationIdsForUi.isNotEmpty()) {
                getUpdatedListAfterMarkingRead(previousList, notificationIdsForUi, selectedFilter)
            } else {
                previousList
            }

            if (notificationIdsForUi.isNotEmpty()) {
                adapter.submitList(updatedList)
                binding.emptyData.visibility = if (updatedList.isEmpty()) View.VISIBLE else View.GONE
            }

            val unreadMarkedCount = if (isMarkAll) {
                previousUnreadCount
            } else {
                previousList.count { notificationIdsForUi.contains(it.id) && !it.isRead }
            }

            unreadCountCache = if (isMarkAll) {
                0
            } else {
                (previousUnreadCount - unreadMarkedCount).coerceAtLeast(0)
            }
            updateMarkAllAsReadButtonVisibility()
            updateUnreadCount()

            try {
                withContext(Dispatchers.IO) {
                    val idsToClear = backgroundAction()
                    val notificationManager = NotificationUtils.getInstance(appContext)
                    idsToClear.forEach { notificationManager.clearNotification(it) }
                }
            } catch (e: Exception) {
                unreadCountCache = previousUnreadCount
                val bindingOrNull = _binding

                if (notificationIdsForUi.isNotEmpty()) {
                    adapter.submitList(previousList)
                    bindingOrNull?.emptyData?.visibility =
                        if (previousList.isEmpty()) View.VISIBLE else View.GONE
                }

                updateMarkAllAsReadButtonVisibility()
                updateUnreadCount()

                bindingOrNull?.let { currentBinding ->
                    Snackbar.make(
                        currentBinding.root,
                        getString(R.string.failed_to_mark_as_read),
                        Snackbar.LENGTH_LONG,
                    ).show()
                }
            }
        }
    }

    private fun getUpdatedListAfterMarkingRead(
        currentList: List<RealmNotification>,
        notificationIds: Set<String>,
        selectedFilter: String,
    ): List<RealmNotification> {
        return if (selectedFilter == "unread") {
            currentList.filterNot { notificationIds.contains(it.id) }
        } else {
            currentList.map { notification ->
                if (notificationIds.contains(notification.id) && !notification.isRead) {
                    notification.asReadCopy()
                } else {
                    notification
                }
            }.sortedWith(compareBy<RealmNotification> { it.isRead }.thenByDescending { it.createdAt })
        }
    }

    private fun RealmNotification.asReadCopy(): RealmNotification {
        return RealmNotification().also { copy ->
            copy.id = id
            copy.userId = userId
            copy.message = message
            copy.isRead = true
            copy.createdAt = Date()
            copy.type = type
            copy.relatedId = relatedId
            copy.title = title
        }
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/DashboardViewModel.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import androidx.lifecycle.ViewModel
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.repository.CourseRepository
import org.ole.planet.myplanet.repository.LibraryRepository
import org.ole.planet.myplanet.repository.NotificationRepository
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.UserRepository

data class DashboardUiState(
    val unreadNotifications: Int = 0,
)

@HiltViewModel
class DashboardViewModel @Inject constructor(
    private val userRepository: UserRepository,
    private val libraryRepository: LibraryRepository,
    private val courseRepository: CourseRepository,
    private val submissionRepository: SubmissionRepository,
    private val notificationRepository: NotificationRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(DashboardUiState())
    val uiState: StateFlow<DashboardUiState> = _uiState.asStateFlow()
    fun setUnreadNotifications(count: Int) {
        _uiState.value = _uiState.value.copy(unreadNotifications = count)
    }
    fun calculateIndividualProgress(voiceCount: Int, hasUnfinishedSurvey: Boolean): Int {
        val earnedDollarsVoice = minOf(voiceCount, 5) * 2
        val earnedDollarsSurvey = if (!hasUnfinishedSurvey) 1 else 0
        val total = earnedDollarsVoice + earnedDollarsSurvey
        return total.coerceAtMost(500)
    }

    fun calculateCommunityProgress(allVoiceCount: Int, hasUnfinishedSurvey: Boolean): Int {
        val earnedDollarsVoice = minOf(allVoiceCount, 5) * 2
        val earnedDollarsSurvey = if (!hasUnfinishedSurvey) 1 else 0
        val total = earnedDollarsVoice + earnedDollarsSurvey
        return total.coerceAtMost(11)
    }

    suspend fun updateResourceNotification(userId: String?) {
        val resourceCount = libraryRepository.countLibrariesNeedingUpdate(userId)
        notificationRepository.updateResourceNotification(userId, resourceCount)
    }

    suspend fun createNotificationIfMissing(
        type: String,
        message: String,
        relatedId: String?,
        userId: String?,
    ) {
        notificationRepository.createNotificationIfMissing(type, message, relatedId, userId)
    }

    suspend fun getPendingSurveys(userId: String?): List<RealmSubmission> {
        return submissionRepository.getPendingSurveys(userId)
    }

    suspend fun getSurveyTitlesFromSubmissions(submissions: List<RealmSubmission>): List<String> {
        return submissionRepository.getSurveyTitlesFromSubmissions(submissions)
    }

    suspend fun getUnreadNotificationsSize(userId: String?): Int {
        return notificationRepository.getUnreadCount(userId)
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard


import androidx.lifecycle.ViewModel
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.repository.CourseRepository
import org.ole.planet.myplanet.repository.LibraryRepository
import org.ole.planet.myplanet.repository.NotificationRepository
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.UserRepository

data class DashboardUiState(
    val unreadNotifications: Int = 0,
)

@HiltViewModel
class DashboardViewModel @Inject constructor(
    private val userRepository: UserRepository,
    private val libraryRepository: LibraryRepository,
    private val courseRepository: CourseRepository,
    private val submissionRepository: SubmissionRepository,
    private val notificationRepository: NotificationRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(DashboardUiState())
    val uiState: StateFlow<DashboardUiState> = _uiState.asStateFlow()
    fun setUnreadNotifications(count: Int) {
        _uiState.value = _uiState.value.copy(unreadNotifications = count)
    }
    fun calculateIndividualProgress(voiceCount: Int, hasUnfinishedSurvey: Boolean): Int {
        val earnedDollarsVoice = minOf(voiceCount, 5) * 2
        val earnedDollarsSurvey = if (!hasUnfinishedSurvey) 1 else 0
        val total = earnedDollarsVoice + earnedDollarsSurvey
        return total.coerceAtMost(500)
    }

    fun calculateCommunityProgress(allVoiceCount: Int, hasUnfinishedSurvey: Boolean): Int {
        val earnedDollarsVoice = minOf(allVoiceCount, 5) * 2
        val earnedDollarsSurvey = if (!hasUnfinishedSurvey) 1 else 0
        val total = earnedDollarsVoice + earnedDollarsSurvey
        return total.coerceAtMost(11)
    }

    suspend fun updateResourceNotification(userId: String?) {
        val resourceCount = libraryRepository.countLibrariesNeedingUpdate(userId)
        notificationRepository.updateResourceNotification(userId, resourceCount)
    }

    suspend fun createNotificationIfMissing(
        type: String,
        message: String,
        relatedId: String?,
        userId: String?,
    ) {
        notificationRepository.createNotificationIfMissing(type, message, relatedId, userId)
    }

    suspend fun getPendingSurveys(userId: String?): List<RealmSubmission> {
        return submissionRepository.getPendingSurveys(userId)
    }

    suspend fun getSurveyTitlesFromSubmissions(submissions: List<RealmSubmission>): List<String> {
        return submissionRepository.getSurveyTitlesFromSubmissions(submissions)
    }

    suspend fun getUnreadNotificationsSize(userId: String?): Int {
        return notificationRepository.getUnreadCount(userId)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/AboutFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import android.os.Bundle
import android.text.Html
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.text.HtmlCompat
import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentAboutBinding

class AboutFragment : Fragment() {
    private var _binding: FragmentAboutBinding? = null
    private val binding get() = _binding!!
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentAboutBinding.inflate(inflater, container, false)
        val versionString = getString(R.string.version, resources.getText(R.string.app_version))
        val aboutText = getString(R.string.about)

        val newAboutText: String = aboutText.replace("<h3>MyPlanet</h3>", "<h3>MyPlanet</h3>\n<h4>$versionString</h4>")
        binding.tvDisclaimer.text = Html.fromHtml(newAboutText, HtmlCompat.FROM_HTML_MODE_LEGACY)
        return binding.root
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard


import android.os.Bundle
import android.text.Html
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.text.HtmlCompat
import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentAboutBinding

class AboutFragment : Fragment() {
    private var _binding: FragmentAboutBinding? = null
    private val binding get() = _binding!!
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentAboutBinding.inflate(inflater, container, false)
        val versionString = getString(R.string.version, resources.getText(R.string.app_version))
        val aboutText = getString(R.string.about)

        val newAboutText: String = aboutText.replace("<h3>MyPlanet</h3>", "<h3>MyPlanet</h3>\n<h4>$versionString</h4>")
        binding.tvDisclaimer.text = Html.fromHtml(newAboutText, HtmlCompat.FROM_HTML_MODE_LEGACY)
        return binding.root
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/BaseDashboardFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import android.app.DatePickerDialog
import android.content.Intent
import android.graphics.Typeface
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.widget.AdapterView
import android.widget.DatePicker
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import com.bumptech.glide.Glide
import com.google.android.flexbox.FlexDirection
import com.google.android.flexbox.FlexboxLayout
import io.realm.Case
import io.realm.RealmChangeListener
import io.realm.RealmObject
import io.realm.RealmResults
import io.realm.Sort
import java.util.Calendar
import java.util.UUID
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.NotificationCallback
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.databinding.AlertHealthListBinding
import org.ole.planet.myplanet.databinding.ItemLibraryHomeBinding
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyLife
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmOfflineActivity
import org.ole.planet.myplanet.model.RealmTeamNotification
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.TransactionSyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler.Companion.KEY_LOGIN
import org.ole.planet.myplanet.ui.exam.UserInformationFragment
import org.ole.planet.myplanet.ui.myhealth.UserListArrayAdapter
import org.ole.planet.myplanet.ui.team.TeamDetailFragment
import org.ole.planet.myplanet.ui.userprofile.BecomeMemberActivity
import org.ole.planet.myplanet.ui.userprofile.UserProfileFragment
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.Utilities

open class BaseDashboardFragment : BaseDashboardFragmentPlugin(), NotificationCallback,
    SyncListener {
    private var fullName: String? = null
    private var params = LinearLayout.LayoutParams(250, 100)
    private var di: DialogUtils.CustomProgressDialog? = null
    private lateinit var myCoursesResults: RealmResults<RealmMyCourse>
    private val myCoursesChangeListener = RealmChangeListener<RealmResults<RealmMyCourse>> { _ ->
        updateMyCoursesUI()
    }
    private lateinit var myTeamsResults: RealmResults<RealmMyTeam>
    private val myTeamsChangeListener = RealmChangeListener<RealmResults<RealmMyTeam>> { _ ->
        updateMyTeamsUI()
    }
    private lateinit var offlineActivitiesResults: RealmResults<RealmOfflineActivity>
    fun onLoaded(v: View) {
        model = profileDbHandler.userModel
        fullName = profileDbHandler.userModel?.getFullName()
        if (fullName?.trim().isNullOrBlank()) {
            fullName = profileDbHandler.userModel?.name
            v.findViewById<LinearLayout>(R.id.ll_prompt).visibility = View.VISIBLE
            v.findViewById<LinearLayout>(R.id.ll_prompt).setOnClickListener {
                if (!childFragmentManager.isStateSaved) {
                    UserInformationFragment.getInstance("", "", false).show(childFragmentManager, "")
                }
            }
        } else {
            v.findViewById<LinearLayout>(R.id.ll_prompt).visibility = View.GONE
        }
        v.findViewById<ImageView>(R.id.ic_close).setOnClickListener {
            v.findViewById<LinearLayout>(R.id.ll_prompt).visibility = View.GONE
        }
        val imageView = v.findViewById<ImageView>(R.id.imageView)
        if (!TextUtils.isEmpty(model?.userImage)) {
            Glide.with(requireActivity())
                .load(model?.userImage)
                .placeholder(R.drawable.profile)
                .error(R.drawable.profile)
                .into(imageView)
        } else {
            imageView.setImageResource(R.drawable.profile)
        }

        if (mRealm.isInTransaction) {
            mRealm.commitTransaction()
        }

        offlineActivitiesResults = mRealm.where(RealmOfflineActivity::class.java)
            .equalTo("userName", profileDbHandler.userModel?.name)
            .equalTo("type", KEY_LOGIN)
            .findAllAsync()
        v.findViewById<TextView>(R.id.txtRole).text = getString(R.string.user_role, model?.getRoleAsString())
        val offlineVisits = profileDbHandler.offlineVisits
        v.findViewById<TextView>(R.id.txtFullName).text = getString(R.string.user_name, fullName, offlineVisits)
    }

    override fun forceDownloadNewsImages() {
        Utilities.toast(activity, getString(R.string.please_select_starting_date))
        val now = Calendar.getInstance()
        val dpd = DatePickerDialog(requireActivity(), { _: DatePicker?, i: Int, i1: Int, i2: Int ->
            now[Calendar.YEAR] = i
            now[Calendar.MONTH] = i1
            now[Calendar.DAY_OF_MONTH] = i2
            val imageList = mRealm.where(RealmMyLibrary::class.java).equalTo("isPrivate", true)
                .greaterThan("createdDate", now.timeInMillis).equalTo("mediaType", "image")
                .findAll()
            val urls = ArrayList<String>()
            getUrlsAndStartDownload(imageList, urls) },
            now[Calendar.YEAR], now[Calendar.MONTH], now[Calendar.DAY_OF_MONTH]
        )
        dpd.setTitle(getString(R.string.read_offline_news_from))
        dpd.show()
    }

    override fun downloadDictionary() {
        val list = ArrayList<String>()
        list.add(Constants.DICTIONARY_URL)
        if (!FileUtils.checkFileExist(requireContext(), Constants.DICTIONARY_URL)) {
            Utilities.toast(activity, getString(R.string.downloading_started_please_check_notification))
            DownloadUtils.openDownloadService(activity, list, false)
        } else {
            Utilities.toast(activity, getString(R.string.file_already_exists))
        }
    }

    private suspend fun myLibraryDiv(view: View) {
        val dbMylibrary = databaseService.withRealmAsync { realm ->
            val results = RealmMyLibrary.getMyLibraryByUserId(realm, settings)
            realm.copyFromRealm(results)
        }

        view.findViewById<FlexboxLayout>(R.id.flexboxLayout).flexDirection = FlexDirection.ROW
        if (dbMylibrary.isEmpty()) {
            view.findViewById<TextView>(R.id.count_library).visibility = View.GONE
        } else {
            view.findViewById<TextView>(R.id.count_library).text = getString(R.string.number_placeholder, dbMylibrary.size)
        }
        for ((itemCnt, items) in dbMylibrary.withIndex()) {
            val itemLibraryHomeBinding = ItemLibraryHomeBinding.inflate(LayoutInflater.from(activity))
            val v = itemLibraryHomeBinding.root
            setTextColor(itemLibraryHomeBinding.title, itemCnt)
            val colorResId = if (itemCnt % 2 == 0) R.color.card_bg else R.color.dashboard_item_alternative
            val color = context?.let { ContextCompat.getColor(it, colorResId) }
            if (color != null) {
                v.setBackgroundColor(color)
            }

            itemLibraryHomeBinding.title.text = items.title
            itemLibraryHomeBinding.detail.setOnClickListener {
                if (homeItemClickListener != null) {
                    homeItemClickListener?.openLibraryDetailFragment(items)
                }
            }

            myLibraryItemClickAction(itemLibraryHomeBinding.title, items)
            view.findViewById<FlexboxLayout>(R.id.flexboxLayout).addView(v, params)
        }
    }

    private fun initializeFlexBoxView(v: View, id: Int, c: Class<out RealmObject>) {
        val flexboxLayout: FlexboxLayout = v.findViewById(id)
        flexboxLayout.flexDirection = FlexDirection.ROW
        setUpMyList(c, flexboxLayout, v)
    }

    private fun setUpMyList(c: Class<out RealmObject>, flexboxLayout: FlexboxLayout, view: View) {
        val dbMycourses: List<RealmObject>
        val userId = settings?.getString("userId", "--")
        setUpMyLife(userId)
        dbMycourses = when (c) {
            RealmMyCourse::class.java -> {
                RealmMyCourse.getMyByUserId(mRealm, settings).filter { !it.courseTitle.isNullOrBlank() }
            }
            RealmMyTeam::class.java -> {
                val i = myTeamInit(flexboxLayout)
                setCountText(i, RealmMyTeam::class.java, view)
                return
            }
            RealmMyLife::class.java -> {
                myLifeListInit(flexboxLayout)
                return
            }
            else -> {
                userId?.let {
                    mRealm.where(c).contains("userId", it, Case.INSENSITIVE).findAll()
                } ?: listOf()
            }
        }
        setCountText(dbMycourses.size, c, view)
        val myCoursesTextViewArray = arrayOfNulls<TextView>(dbMycourses.size)
        for ((itemCnt, items) in dbMycourses.withIndex()) {
            val course = items as RealmMyCourse
            setTextViewProperties(myCoursesTextViewArray, itemCnt, items)
            myCoursesTextViewArray[itemCnt]?.let { setTextColor(it, itemCnt) }
            flexboxLayout.addView(myCoursesTextViewArray[itemCnt], params)
        }
    }

    private fun myTeamInit(flexboxLayout: FlexboxLayout): Int {
        val dbMyTeam = RealmMyTeam.getMyTeamsByUserId(mRealm, settings)
        val userId = profileDbHandler.userModel?.id
        for ((count, ob) in dbMyTeam.withIndex()) {
            val v = LayoutInflater.from(activity).inflate(R.layout.item_home_my_team, flexboxLayout, false)
            val name = v.findViewById<TextView>(R.id.tv_name)
            setBackgroundColor(v, count)
            if ((ob as RealmMyTeam).teamType == "sync") {
                name.setTypeface(null, Typeface.BOLD)
            }
            handleClick(ob._id, ob.name, TeamDetailFragment(), name)
            showNotificationIcons(ob, v, userId)
            name.text = ob.name
            flexboxLayout.addView(v, params)
        }
        return dbMyTeam.size
    }

    private fun showNotificationIcons(ob: RealmObject, v: View, userId: String?) {
        val current = Calendar.getInstance().timeInMillis
        val tomorrow = Calendar.getInstance()
        tomorrow.add(Calendar.DAY_OF_YEAR, 1)
        val imgTask = v.findViewById<ImageView>(R.id.img_task)
        val imgChat = v.findViewById<ImageView>(R.id.img_chat)
        val notification: RealmTeamNotification? = mRealm.where(RealmTeamNotification::class.java)
            .equalTo("parentId", (ob as RealmMyTeam)._id).equalTo("type", "chat").findFirst()
        val chatCount: Long = mRealm.where(RealmNews::class.java).equalTo("viewableBy", "teams")
            .equalTo("viewableId", ob._id).count()
        if (notification != null) {
            imgChat.visibility = if (notification.lastCount < chatCount) View.VISIBLE else View.GONE
        }
        val tasks = mRealm.where(RealmTeamTask::class.java).equalTo("assignee", userId)
            .between("deadline", current, tomorrow.timeInMillis).findAll()
        imgTask.visibility = if (tasks.isNotEmpty()) View.VISIBLE else View.GONE
    }

    private fun myLifeListInit(flexboxLayout: FlexboxLayout) {
        val dbMylife: MutableList<RealmMyLife> = ArrayList()
        val rawMylife: List<RealmMyLife> = RealmMyLife.getMyLifeByUserId(mRealm, settings)
        for (item in rawMylife) if (item.isVisible) dbMylife.add(item)
        for ((itemCnt, items) in dbMylife.withIndex()) {
            flexboxLayout.addView(getLayout(itemCnt, items), params)
        }
    }

    private fun setUpMyLife(userId: String?) {
        databaseService.withRealm { realm ->
            val realmObjects = RealmMyLife.getMyLifeByUserId(realm, settings)
            if (realmObjects.isEmpty()) {
                if (!realm.isInTransaction) {
                    realm.beginTransaction()
                }
                val myLifeListBase = getMyLifeListBase(userId)
                var ml: RealmMyLife
                var weight = 1
                for (item in myLifeListBase) {
                    ml = realm.createObject(RealmMyLife::class.java, UUID.randomUUID().toString())
                    ml.title = item.title
                    ml.imageId = item.imageId
                    ml.weight = weight
                    ml.userId = item.userId
                    ml.isVisible = true
                    weight++
                }
                realm.commitTransaction()
            }
        }
    }

    private fun myLibraryItemClickAction(textView: TextView, items: RealmMyLibrary?) {
        textView.setOnClickListener {
            items?.let {
                openResource(it)
            }
        }
    }

    override fun onDestroy() {
        if (::myCoursesResults.isInitialized) {
            myCoursesResults.removeChangeListener(myCoursesChangeListener)
        }
        if (::myTeamsResults.isInitialized) {
            myTeamsResults.removeChangeListener(myTeamsChangeListener)
        }
        if (isRealmInitialized()) {
            mRealm.removeAllChangeListeners()
            if (mRealm.isInTransaction) {
                mRealm.cancelTransaction()
            }
            mRealm.close()
        }
        super.onDestroy()
    }

    private fun setCountText(countText: Int, c: Class<*>, v: View) {
        when (c) {
            RealmMyCourse::class.java -> {
                updateCountText(countText, v.findViewById(R.id.count_course))
            }
            RealmMyTeam::class.java -> {
                updateCountText(countText, v.findViewById(R.id.count_team))
            }
        }
    }

    private fun updateCountText(countText: Int, tv: TextView) {
        tv.text = getString(R.string.number_placeholder, countText)
        hideCountIfZero(tv, countText)
    }

    private fun hideCountIfZero(v: View, count: Int) {
        v.visibility = if (count == 0) View.GONE else View.VISIBLE
    }

    fun initView(view: View) {
        view.findViewById<View>(R.id.imageView).setOnClickListener {
            homeItemClickListener?.openCallFragment(UserProfileFragment())
        }
        view.findViewById<View>(R.id.txtFullName).setOnClickListener {
            homeItemClickListener?.openCallFragment(UserProfileFragment())
        }
        viewLifecycleOwner.lifecycleScope.launch {
            myLibraryDiv(view)
        }
        initializeFlexBoxView(view, R.id.flexboxLayoutCourse, RealmMyCourse::class.java)
        initializeFlexBoxView(view, R.id.flexboxLayoutTeams, RealmMyTeam::class.java)
        initializeFlexBoxView(view, R.id.flexboxLayoutMyLife, RealmMyLife::class.java)

        if (mRealm.isInTransaction) {
            mRealm.commitTransaction()
        }
        myCoursesResults = RealmMyCourse.getMyByUserId(mRealm, settings)
        myTeamsResults = RealmMyTeam.getMyTeamsByUserId(mRealm, settings)

        myCoursesResults.addChangeListener(myCoursesChangeListener)
        myTeamsResults.addChangeListener(myTeamsChangeListener)
    }

    private fun updateMyCoursesUI() {
        val flexboxLayout: FlexboxLayout = view?.findViewById(R.id.flexboxLayoutCourse) ?: return
        flexboxLayout.removeAllViews()
        setUpMyList(RealmMyCourse::class.java, flexboxLayout, requireView())
    }

    private fun updateMyTeamsUI() {
        val flexboxLayout: FlexboxLayout = view?.findViewById(R.id.flexboxLayoutTeams) ?: return
        flexboxLayout.removeAllViews()
        setUpMyList(RealmMyTeam::class.java, flexboxLayout, requireView())
    }

    override fun showResourceDownloadDialog() {
        viewLifecycleOwner.lifecycleScope.launch {
            showDownloadDialog(getLibraryList(mRealm))
        }
    }

    override fun showUserResourceDialog() {
        var dialog: AlertDialog? = null
        val userModelList = mRealm.where(RealmUserModel::class.java).sort("joinDate", Sort.DESCENDING).findAll()
        val adapter = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, userModelList)
        val alertHealthListBinding = AlertHealthListBinding.inflate(LayoutInflater.from(activity))
        alertHealthListBinding.etSearch.visibility = View.GONE
        alertHealthListBinding.spnSort.visibility = View.GONE

        alertHealthListBinding.btnAddMember.setOnClickListener {
            startActivity(Intent(requireContext(), BecomeMemberActivity::class.java))
        }

        alertHealthListBinding.list.adapter = adapter
        alertHealthListBinding.list.onItemClickListener = AdapterView.OnItemClickListener { _, _, i, _ ->
            val selected = alertHealthListBinding.list.adapter.getItem(i) as RealmUserModel
            showDownloadDialog(getLibraryList(mRealm, selected._id))
            dialog?.dismiss()
        }

        dialog = AlertDialog.Builder(requireActivity())
            .setTitle(getString(R.string.select_member))
            .setView(alertHealthListBinding.root)
            .setCancelable(false)
            .setNegativeButton(R.string.dismiss, null)
            .create()

        dialog.show()
    }

    override fun syncKeyId() {
        if (model?.getRoleAsString()?.contains("health") == true) {
            settings?.let { TransactionSyncManager.syncAllHealthData(mRealm, it, this) }
        } else {
            settings?.let { TransactionSyncManager.syncKeyIv(mRealm, it, this) }
        }
    }

    override fun onSyncStarted() {
        di?.show()
    }

    override fun onSyncComplete() {
        di?.dismiss()
    }

    override fun onSyncFailed(msg: String?) {
        di?.dismiss()
    }

}
=======
package org.ole.planet.myplanet.ui.dashboard


import android.app.DatePickerDialog
import android.content.Intent
import android.graphics.Typeface
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.widget.AdapterView
import android.widget.DatePicker
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import com.bumptech.glide.Glide
import com.google.android.flexbox.FlexDirection
import com.google.android.flexbox.FlexboxLayout
import io.realm.Case
import io.realm.RealmChangeListener
import io.realm.RealmObject
import io.realm.RealmResults
import io.realm.Sort
import java.util.Calendar
import java.util.UUID
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.NotificationCallback
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.databinding.AlertHealthListBinding
import org.ole.planet.myplanet.databinding.ItemLibraryHomeBinding
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyLife
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmOfflineActivity
import org.ole.planet.myplanet.model.RealmTeamNotification
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.TransactionSyncManager
import org.ole.planet.myplanet.service.UserProfileDbHandler.Companion.KEY_LOGIN
import org.ole.planet.myplanet.ui.exam.UserInformationFragment
import org.ole.planet.myplanet.ui.myhealth.UserListArrayAdapter
import org.ole.planet.myplanet.ui.team.TeamDetailFragment
import org.ole.planet.myplanet.ui.userprofile.BecomeMemberActivity
import org.ole.planet.myplanet.ui.userprofile.UserProfileFragment
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.Utilities

open class BaseDashboardFragment : BaseDashboardFragmentPlugin(), NotificationCallback,
    SyncListener {
    private var fullName: String? = null
    private var params = LinearLayout.LayoutParams(250, 100)
    private var di: DialogUtils.CustomProgressDialog? = null
    private lateinit var myCoursesResults: RealmResults<RealmMyCourse>
    private val myCoursesChangeListener = RealmChangeListener<RealmResults<RealmMyCourse>> { _ ->
        updateMyCoursesUI()
    }
    private lateinit var myTeamsResults: RealmResults<RealmMyTeam>
    private val myTeamsChangeListener = RealmChangeListener<RealmResults<RealmMyTeam>> { _ ->
        updateMyTeamsUI()
    }
    private lateinit var offlineActivitiesResults: RealmResults<RealmOfflineActivity>
    fun onLoaded(v: View) {
        model = profileDbHandler.userModel
        fullName = profileDbHandler.userModel?.getFullName()
        if (fullName?.trim().isNullOrBlank()) {
            fullName = profileDbHandler.userModel?.name
            v.findViewById<LinearLayout>(R.id.ll_prompt).visibility = View.VISIBLE
            v.findViewById<LinearLayout>(R.id.ll_prompt).setOnClickListener {
                if (!childFragmentManager.isStateSaved) {
                    UserInformationFragment.getInstance("", "", false).show(childFragmentManager, "")
                }
            }
        } else {
            v.findViewById<LinearLayout>(R.id.ll_prompt).visibility = View.GONE
        }
        v.findViewById<ImageView>(R.id.ic_close).setOnClickListener {
            v.findViewById<LinearLayout>(R.id.ll_prompt).visibility = View.GONE
        }
        val imageView = v.findViewById<ImageView>(R.id.imageView)
        if (!TextUtils.isEmpty(model?.userImage)) {
            Glide.with(requireActivity())
                .load(model?.userImage)
                .placeholder(R.drawable.profile)
                .error(R.drawable.profile)
                .into(imageView)
        } else {
            imageView.setImageResource(R.drawable.profile)
        }

        if (mRealm.isInTransaction) {
            mRealm.commitTransaction()
        }

        offlineActivitiesResults = mRealm.where(RealmOfflineActivity::class.java)
            .equalTo("userName", profileDbHandler.userModel?.name)
            .equalTo("type", KEY_LOGIN)
            .findAllAsync()
        v.findViewById<TextView>(R.id.txtRole).text = getString(R.string.user_role, model?.getRoleAsString())
        val offlineVisits = profileDbHandler.offlineVisits
        v.findViewById<TextView>(R.id.txtFullName).text = getString(R.string.user_name, fullName, offlineVisits)
    }

    override fun forceDownloadNewsImages() {
        Utilities.toast(activity, getString(R.string.please_select_starting_date))
        val now = Calendar.getInstance()
        val dpd = DatePickerDialog(requireActivity(), { _: DatePicker?, i: Int, i1: Int, i2: Int ->
            now[Calendar.YEAR] = i
            now[Calendar.MONTH] = i1
            now[Calendar.DAY_OF_MONTH] = i2
            val imageList = mRealm.where(RealmMyLibrary::class.java).equalTo("isPrivate", true)
                .greaterThan("createdDate", now.timeInMillis).equalTo("mediaType", "image")
                .findAll()
            val urls = ArrayList<String>()
            getUrlsAndStartDownload(imageList, urls) },
            now[Calendar.YEAR], now[Calendar.MONTH], now[Calendar.DAY_OF_MONTH]
        )
        dpd.setTitle(getString(R.string.read_offline_news_from))
        dpd.show()
    }

    override fun downloadDictionary() {
        val list = ArrayList<String>()
        list.add(Constants.DICTIONARY_URL)
        if (!FileUtils.checkFileExist(requireContext(), Constants.DICTIONARY_URL)) {
            Utilities.toast(activity, getString(R.string.downloading_started_please_check_notification))
            DownloadUtils.openDownloadService(activity, list, false)
        } else {
            Utilities.toast(activity, getString(R.string.file_already_exists))
        }
    }

    private suspend fun myLibraryDiv(view: View) {
        val dbMylibrary = databaseService.withRealmAsync { realm ->
            val results = RealmMyLibrary.getMyLibraryByUserId(realm, settings)
            realm.copyFromRealm(results)
        }

        view.findViewById<FlexboxLayout>(R.id.flexboxLayout).flexDirection = FlexDirection.ROW
        if (dbMylibrary.isEmpty()) {
            view.findViewById<TextView>(R.id.count_library).visibility = View.GONE
        } else {
            view.findViewById<TextView>(R.id.count_library).text = getString(R.string.number_placeholder, dbMylibrary.size)
        }
        for ((itemCnt, items) in dbMylibrary.withIndex()) {
            val itemLibraryHomeBinding = ItemLibraryHomeBinding.inflate(LayoutInflater.from(activity))
            val v = itemLibraryHomeBinding.root
            setTextColor(itemLibraryHomeBinding.title, itemCnt)
            val colorResId = if (itemCnt % 2 == 0) R.color.card_bg else R.color.dashboard_item_alternative
            val color = context?.let { ContextCompat.getColor(it, colorResId) }
            if (color != null) {
                v.setBackgroundColor(color)
            }

            itemLibraryHomeBinding.title.text = items.title
            itemLibraryHomeBinding.detail.setOnClickListener {
                if (homeItemClickListener != null) {
                    homeItemClickListener?.openLibraryDetailFragment(items)
                }
            }

            myLibraryItemClickAction(itemLibraryHomeBinding.title, items)
            view.findViewById<FlexboxLayout>(R.id.flexboxLayout).addView(v, params)
        }
    }

    private fun initializeFlexBoxView(v: View, id: Int, c: Class<out RealmObject>) {
        val flexboxLayout: FlexboxLayout = v.findViewById(id)
        flexboxLayout.flexDirection = FlexDirection.ROW
        setUpMyList(c, flexboxLayout, v)
    }

    private fun setUpMyList(c: Class<out RealmObject>, flexboxLayout: FlexboxLayout, view: View) {
        val dbMycourses: List<RealmObject>
        val userId = settings?.getString("userId", "--")
        setUpMyLife(userId)
        dbMycourses = when (c) {
            RealmMyCourse::class.java -> {
                RealmMyCourse.getMyByUserId(mRealm, settings).filter { !it.courseTitle.isNullOrBlank() }
            }
            RealmMyTeam::class.java -> {
                val i = myTeamInit(flexboxLayout)
                setCountText(i, RealmMyTeam::class.java, view)
                return
            }
            RealmMyLife::class.java -> {
                myLifeListInit(flexboxLayout)
                return
            }
            else -> {
                userId?.let {
                    mRealm.where(c).contains("userId", it, Case.INSENSITIVE).findAll()
                } ?: listOf()
            }
        }
        setCountText(dbMycourses.size, c, view)
        val myCoursesTextViewArray = arrayOfNulls<TextView>(dbMycourses.size)
        for ((itemCnt, items) in dbMycourses.withIndex()) {
            val course = items as RealmMyCourse
            setTextViewProperties(myCoursesTextViewArray, itemCnt, items)
            myCoursesTextViewArray[itemCnt]?.let { setTextColor(it, itemCnt) }
            flexboxLayout.addView(myCoursesTextViewArray[itemCnt], params)
        }
    }

    private fun myTeamInit(flexboxLayout: FlexboxLayout): Int {
        val dbMyTeam = RealmMyTeam.getMyTeamsByUserId(mRealm, settings)
        val userId = profileDbHandler.userModel?.id
        for ((count, ob) in dbMyTeam.withIndex()) {
            val v = LayoutInflater.from(activity).inflate(R.layout.item_home_my_team, flexboxLayout, false)
            val name = v.findViewById<TextView>(R.id.tv_name)
            setBackgroundColor(v, count)
            if ((ob as RealmMyTeam).teamType == "sync") {
                name.setTypeface(null, Typeface.BOLD)
            }
            handleClick(ob._id, ob.name, TeamDetailFragment(), name)
            showNotificationIcons(ob, v, userId)
            name.text = ob.name
            flexboxLayout.addView(v, params)
        }
        return dbMyTeam.size
    }

    private fun showNotificationIcons(ob: RealmObject, v: View, userId: String?) {
        val current = Calendar.getInstance().timeInMillis
        val tomorrow = Calendar.getInstance()
        tomorrow.add(Calendar.DAY_OF_YEAR, 1)
        val imgTask = v.findViewById<ImageView>(R.id.img_task)
        val imgChat = v.findViewById<ImageView>(R.id.img_chat)
        val notification: RealmTeamNotification? = mRealm.where(RealmTeamNotification::class.java)
            .equalTo("parentId", (ob as RealmMyTeam)._id).equalTo("type", "chat").findFirst()
        val chatCount: Long = mRealm.where(RealmNews::class.java).equalTo("viewableBy", "teams")
            .equalTo("viewableId", ob._id).count()
        if (notification != null) {
            imgChat.visibility = if (notification.lastCount < chatCount) View.VISIBLE else View.GONE
        }
        val tasks = mRealm.where(RealmTeamTask::class.java).equalTo("assignee", userId)
            .between("deadline", current, tomorrow.timeInMillis).findAll()
        imgTask.visibility = if (tasks.isNotEmpty()) View.VISIBLE else View.GONE
    }

    private fun myLifeListInit(flexboxLayout: FlexboxLayout) {
        val dbMylife: MutableList<RealmMyLife> = ArrayList()
        val rawMylife: List<RealmMyLife> = RealmMyLife.getMyLifeByUserId(mRealm, settings)
        for (item in rawMylife) if (item.isVisible) dbMylife.add(item)
        for ((itemCnt, items) in dbMylife.withIndex()) {
            flexboxLayout.addView(getLayout(itemCnt, items), params)
        }
    }

    private fun setUpMyLife(userId: String?) {
        databaseService.withRealm { realm ->
            val realmObjects = RealmMyLife.getMyLifeByUserId(realm, settings)
            if (realmObjects.isEmpty()) {
                if (!realm.isInTransaction) {
                    realm.beginTransaction()
                }
                val myLifeListBase = getMyLifeListBase(userId)
                var ml: RealmMyLife
                var weight = 1
                for (item in myLifeListBase) {
                    ml = realm.createObject(RealmMyLife::class.java, UUID.randomUUID().toString())
                    ml.title = item.title
                    ml.imageId = item.imageId
                    ml.weight = weight
                    ml.userId = item.userId
                    ml.isVisible = true
                    weight++
                }
                realm.commitTransaction()
            }
        }
    }

    private fun myLibraryItemClickAction(textView: TextView, items: RealmMyLibrary?) {
        textView.setOnClickListener {
            items?.let {
                openResource(it)
            }
        }
    }

    override fun onDestroy() {
        if (::myCoursesResults.isInitialized) {
            myCoursesResults.removeChangeListener(myCoursesChangeListener)
        }
        if (::myTeamsResults.isInitialized) {
            myTeamsResults.removeChangeListener(myTeamsChangeListener)
        }
        if (isRealmInitialized()) {
            mRealm.removeAllChangeListeners()
            if (mRealm.isInTransaction) {
                mRealm.cancelTransaction()
            }
            mRealm.close()
        }
        super.onDestroy()
    }

    private fun setCountText(countText: Int, c: Class<*>, v: View) {
        when (c) {
            RealmMyCourse::class.java -> {
                updateCountText(countText, v.findViewById(R.id.count_course))
            }
            RealmMyTeam::class.java -> {
                updateCountText(countText, v.findViewById(R.id.count_team))
            }
        }
    }

    private fun updateCountText(countText: Int, tv: TextView) {
        tv.text = getString(R.string.number_placeholder, countText)
        hideCountIfZero(tv, countText)
    }

    private fun hideCountIfZero(v: View, count: Int) {
        v.visibility = if (count == 0) View.GONE else View.VISIBLE
    }

    fun initView(view: View) {
        view.findViewById<View>(R.id.imageView).setOnClickListener {
            homeItemClickListener?.openCallFragment(UserProfileFragment())
        }
        view.findViewById<View>(R.id.txtFullName).setOnClickListener {
            homeItemClickListener?.openCallFragment(UserProfileFragment())
        }
        viewLifecycleOwner.lifecycleScope.launch {
            myLibraryDiv(view)
        }
        initializeFlexBoxView(view, R.id.flexboxLayoutCourse, RealmMyCourse::class.java)
        initializeFlexBoxView(view, R.id.flexboxLayoutTeams, RealmMyTeam::class.java)
        initializeFlexBoxView(view, R.id.flexboxLayoutMyLife, RealmMyLife::class.java)

        if (mRealm.isInTransaction) {
            mRealm.commitTransaction()
        }
        myCoursesResults = RealmMyCourse.getMyByUserId(mRealm, settings)
        myTeamsResults = RealmMyTeam.getMyTeamsByUserId(mRealm, settings)

        myCoursesResults.addChangeListener(myCoursesChangeListener)
        myTeamsResults.addChangeListener(myTeamsChangeListener)
    }

    private fun updateMyCoursesUI() {
        val flexboxLayout: FlexboxLayout = view?.findViewById(R.id.flexboxLayoutCourse) ?: return
        flexboxLayout.removeAllViews()
        setUpMyList(RealmMyCourse::class.java, flexboxLayout, requireView())
    }

    private fun updateMyTeamsUI() {
        val flexboxLayout: FlexboxLayout = view?.findViewById(R.id.flexboxLayoutTeams) ?: return
        flexboxLayout.removeAllViews()
        setUpMyList(RealmMyTeam::class.java, flexboxLayout, requireView())
    }

    override fun showResourceDownloadDialog() {
        viewLifecycleOwner.lifecycleScope.launch {
            showDownloadDialog(getLibraryList(mRealm))
        }
    }

    override fun showUserResourceDialog() {
        var dialog: AlertDialog? = null
        val userModelList = mRealm.where(RealmUserModel::class.java).sort("joinDate", Sort.DESCENDING).findAll()
        val adapter = UserListArrayAdapter(requireActivity(), android.R.layout.simple_list_item_1, userModelList)
        val alertHealthListBinding = AlertHealthListBinding.inflate(LayoutInflater.from(activity))
        alertHealthListBinding.etSearch.visibility = View.GONE
        alertHealthListBinding.spnSort.visibility = View.GONE

        alertHealthListBinding.btnAddMember.setOnClickListener {
            startActivity(Intent(requireContext(), BecomeMemberActivity::class.java))
        }

        alertHealthListBinding.list.adapter = adapter
        alertHealthListBinding.list.onItemClickListener = AdapterView.OnItemClickListener { _, _, i, _ ->
            val selected = alertHealthListBinding.list.adapter.getItem(i) as RealmUserModel
            showDownloadDialog(getLibraryList(mRealm, selected._id))
            dialog?.dismiss()
        }

        dialog = AlertDialog.Builder(requireActivity())
            .setTitle(getString(R.string.select_member))
            .setView(alertHealthListBinding.root)
            .setCancelable(false)
            .setNegativeButton(R.string.dismiss, null)
            .create()

        dialog.show()
    }

    override fun syncKeyId() {
        if (model?.getRoleAsString()?.contains("health") == true) {
            settings?.let { TransactionSyncManager.syncAllHealthData(mRealm, it, this) }
        } else {
            settings?.let { TransactionSyncManager.syncKeyIv(mRealm, it, this) }
        }
    }

    override fun onSyncStarted() {
        di?.show()
    }

    override fun onSyncComplete() {
        di?.dismiss()
    }

    override fun onSyncFailed(msg: String?) {
        di?.dismiss()
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/BellDashboardViewModel.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import io.realm.Realm
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.utilities.NetworkUtils.isNetworkConnectedFlow

class BellDashboardViewModel : ViewModel() {
    private val _networkStatus = MutableStateFlow<NetworkStatus>(NetworkStatus.Disconnected)
    val networkStatus: StateFlow<NetworkStatus> = _networkStatus.asStateFlow()

    private val _completedCourses = MutableStateFlow<List<CourseCompletion>>(emptyList())
    val completedCourses: StateFlow<List<CourseCompletion>> = _completedCourses.asStateFlow()

    init {
        viewModelScope.launch {
            isNetworkConnectedFlow.collect { isConnected ->
                if (isConnected) {
                    updateNetworkStatus(NetworkStatus.Connecting)
                } else {
                    updateNetworkStatus(NetworkStatus.Disconnected)
                }
            }
        }
    }

    fun loadCompletedCourses(userId: String?) {
        viewModelScope.launch(Dispatchers.IO) {
            var realm: Realm? = null
            try {
                realm = Realm.getDefaultInstance()
                val myCourses = RealmMyCourse.getMyCourseByUserId(userId, realm.where(RealmMyCourse::class.java).findAll())
                val courseProgress = RealmCourseProgress.getCourseProgress(realm, userId)

                val completed = myCourses.filter { course ->
                    val progress = courseProgress[course.id]
                    progress?.let {
                        it.asJsonObject["current"].asInt == it.asJsonObject["max"].asInt
                    } == true
                }.map {
                    CourseCompletion(it.courseId, it.courseTitle)
                }
                _completedCourses.value = completed
            } finally {
                realm?.close()
            }
        }
    }

    private fun updateNetworkStatus(status: NetworkStatus) {
        _networkStatus.value = status
    }

    suspend fun checkServerConnection(serverUrl: String): Boolean {
        val reachable = withContext(Dispatchers.IO) {
            isServerReachable(serverUrl)
        }
        updateNetworkStatus(if (reachable) NetworkStatus.Connected else NetworkStatus.Disconnected)
        return reachable
    }
}

data class CourseCompletion(val courseId: String?, val courseTitle: String?)

sealed class NetworkStatus {
    object Disconnected : NetworkStatus()
    object Connecting : NetworkStatus()
    object Connected : NetworkStatus()
}
=======
package org.ole.planet.myplanet.ui.dashboard


import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import io.realm.Realm
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.utilities.NetworkUtils.isNetworkConnectedFlow

class BellDashboardViewModel : ViewModel() {
    private val _networkStatus = MutableStateFlow<NetworkStatus>(NetworkStatus.Disconnected)
    val networkStatus: StateFlow<NetworkStatus> = _networkStatus.asStateFlow()

    private val _completedCourses = MutableStateFlow<List<CourseCompletion>>(emptyList())
    val completedCourses: StateFlow<List<CourseCompletion>> = _completedCourses.asStateFlow()

    init {
        viewModelScope.launch {
            isNetworkConnectedFlow.collect { isConnected ->
                if (isConnected) {
                    updateNetworkStatus(NetworkStatus.Connecting)
                } else {
                    updateNetworkStatus(NetworkStatus.Disconnected)
                }
            }
        }
    }

    fun loadCompletedCourses(userId: String?) {
        viewModelScope.launch(Dispatchers.IO) {
            var realm: Realm? = null
            try {
                realm = Realm.getDefaultInstance()
                val myCourses = RealmMyCourse.getMyCourseByUserId(userId, realm.where(RealmMyCourse::class.java).findAll())
                val courseProgress = RealmCourseProgress.getCourseProgress(realm, userId)

                val completed = myCourses.filter { course ->
                    val progress = courseProgress[course.id]
                    progress?.let {
                        it.asJsonObject["current"].asInt == it.asJsonObject["max"].asInt
                    } == true
                }.map {
                    CourseCompletion(it.courseId, it.courseTitle)
                }
                _completedCourses.value = completed
            } finally {
                realm?.close()
            }
        }
    }

    private fun updateNetworkStatus(status: NetworkStatus) {
        _networkStatus.value = status
    }

    suspend fun checkServerConnection(serverUrl: String): Boolean {
        val reachable = withContext(Dispatchers.IO) {
            isServerReachable(serverUrl)
        }
        updateNetworkStatus(if (reachable) NetworkStatus.Connected else NetworkStatus.Disconnected)
        return reachable
    }
}

data class CourseCompletion(val courseId: String?, val courseTitle: String?)

sealed class NetworkStatus {
    object Disconnected : NetworkStatus()
    object Connecting : NetworkStatus()
    object Connected : NetworkStatus()
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/BellDashboardFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.NumberPicker
import android.widget.RadioGroup
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import java.util.concurrent.TimeUnit
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentHomeBellBinding
import org.ole.planet.myplanet.model.RealmCertification
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.courses.CoursesFragment
import org.ole.planet.myplanet.ui.courses.TakeCourseFragment
import org.ole.planet.myplanet.ui.mylife.LifeFragment
import org.ole.planet.myplanet.ui.resources.ResourcesFragment
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission
import org.ole.planet.myplanet.ui.submission.MySubmissionFragment
import org.ole.planet.myplanet.ui.team.TeamFragment
import org.ole.planet.myplanet.utilities.DialogUtils.guestDialog
import org.ole.planet.myplanet.utilities.ServerUrlMapper

class BellDashboardFragment : BaseDashboardFragment() {
    private var _binding: FragmentHomeBellBinding? = null
    private val binding get() = _binding!!
    private var networkStatusJob: Job? = null
    private val viewModel: BellDashboardViewModel by viewModels()
    var user: RealmUserModel? = null
    private var surveyReminderJob: Job? = null
    private var surveyListDialog: AlertDialog? = null

    companion object {
        private const val PREF_SURVEY_REMINDERS = "survey_reminders"
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentHomeBellBinding.inflate(inflater, container, false)
        val view = binding.root
        declareElements()
        onLoaded(view)
        user = profileDbHandler?.userModel
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        initView(view)
        binding.cardProfileBell.txtCommunityName.text = model?.planetCode
        setupNetworkStatusMonitoring()
        (activity as DashboardActivity?)?.supportActionBar?.hide()
        observeCompletedCourses()
        if((user?.id?.startsWith("guest") != true) && !DashboardActivity.isFromNotificationAction) {
            checkPendingSurveys()
        }
        if (model?.id?.startsWith("guest") == false && TextUtils.isEmpty(model?.key)) {
            syncKeyId()
        }
    }

    private fun setupNetworkStatusMonitoring() {
        networkStatusJob?.cancel()
        networkStatusJob = viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.networkStatus.collect { status ->
                    updateNetworkIndicator(status)
                }
            }
        }
    }

    private fun setNetworkIndicatorColor(colorRes: Int) {
        if (isAdded && view?.isAttachedToWindow == true) {
            val color = ContextCompat.getColor(requireContext(), colorRes)
            binding.cardProfileBell.imageView.borderColor = color
        }
    }

    private suspend fun isServerReachable(mapping: ServerUrlMapper.UrlMapping): Boolean {
        val primaryAvailable = viewModel.checkServerConnection(mapping.primaryUrl)

        if (primaryAvailable) {
            return true
        }

        mapping.alternativeUrl?.let {
            val alternativeAvailable = viewModel.checkServerConnection(it)
            return alternativeAvailable
        }

        return false
    }

    private suspend fun handleConnectingState() {
        setNetworkIndicatorColor(R.color.md_yellow_600)
        val updateUrl = settings.getString("serverURL", "") ?: return
        val mapping = ServerUrlMapper().processUrl(updateUrl)
        try {
            val reachable = isServerReachable(mapping)
            setNetworkIndicatorColor(if (reachable) R.color.green else R.color.md_yellow_600)
        } catch (e: Exception) {
            e.printStackTrace()
            setNetworkIndicatorColor(R.color.md_yellow_600)
        }
    }

    private suspend fun updateNetworkIndicator(status: NetworkStatus) {
        if (!isAdded) return
        context ?: return

        when (status) {
            is NetworkStatus.Disconnected -> setNetworkIndicatorColor(R.color.md_red_700)
            is NetworkStatus.Connecting -> handleConnectingState()
            is NetworkStatus.Connected -> setNetworkIndicatorColor(R.color.green)
        }
    }

    private fun checkPendingSurveys() {
        viewLifecycleOwner.lifecycleScope.launch {
            if (checkScheduledReminders()) {
                return@launch
            }
            val pendingSurveys = submissionRepository.getUniquePendingSurveys(user?.id)

            if (pendingSurveys.isNotEmpty()) {
                val surveyIds = pendingSurveys.joinToString(",") { it.id.toString() }
                val preferences = requireActivity().getSharedPreferences(PREF_SURVEY_REMINDERS, 0)
                if (preferences.contains("reminder_time_$surveyIds")) {
                    return@launch
                }
                val title = getString(
                    R.string.surveys_to_complete,
                    pendingSurveys.size,
                    if (pendingSurveys.size > 1) "surveys" else "survey"
                )
                val surveyTitles = submissionRepository.getSurveyTitlesFromSubmissions(pendingSurveys)
                showSurveyListDialog(pendingSurveys, title, surveyTitles)
            } else {
                checkScheduledReminders()
            }
        }
    }

    private fun showRemindLaterDialog(pendingSurveys: List<RealmSubmission>,previousDialog: AlertDialog) {
        val dialogView = LayoutInflater.from(requireActivity()).inflate(R.layout.dialog_remind_later, null)
        val radioGroup: RadioGroup = dialogView.findViewById(R.id.radioGroupRemindOptions)
        val numberPicker: NumberPicker = dialogView.findViewById(R.id.numberPickerTime)
        val unitTextView: TextView = dialogView.findViewById(R.id.textViewTimeUnit)

        numberPicker.minValue = 1
        numberPicker.maxValue = 60
        numberPicker.wrapSelectorWheel = false

        radioGroup.check(R.id.radioButtonMinutes)
        unitTextView.text = getString(R.string.minutes)

        radioGroup.setOnCheckedChangeListener { _, checkedId ->
            when (checkedId) {
                R.id.radioButtonMinutes -> {
                    numberPicker.maxValue = 60
                    unitTextView.text = getString(R.string.minutes)
                }
                R.id.radioButtonHours -> {
                    numberPicker.maxValue = 24
                    unitTextView.text = getString(R.string.hours)
                }
                R.id.radioButtonDays -> {
                    numberPicker.maxValue = 30
                    unitTextView.text = getString(R.string.days)
                }
            }
        }

        AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
            .setTitle(getString(R.string.remind_me_later))
            .setView(dialogView)
            .setPositiveButton(getString(R.string.set_reminder)) { dialog, _ ->
                val value = numberPicker.value
                val timeUnit = when (radioGroup.checkedRadioButtonId) {
                    R.id.radioButtonMinutes -> TimeUnit.MINUTES
                    R.id.radioButtonHours -> TimeUnit.HOURS
                    R.id.radioButtonDays -> TimeUnit.DAYS
                    else -> TimeUnit.MINUTES
                }

                scheduleReminder(pendingSurveys, value, timeUnit)
                previousDialog.dismiss()
                dialog.dismiss()
            }
            .setNegativeButton(getString(R.string.cancel), null)
            .show()
            .window?.setBackgroundDrawableResource(R.color.card_bg)
    }

    private fun scheduleReminder(pendingSurveys: List<RealmSubmission>, value: Int, timeUnit: TimeUnit) {
        val currentTime = System.currentTimeMillis()
        val reminderTime = currentTime + timeUnit.toMillis(value.toLong())

        val surveyIds = pendingSurveys.joinToString(",") { it.id.toString() }
        val preferences = requireActivity().getSharedPreferences(PREF_SURVEY_REMINDERS, 0)
        preferences.edit()
            .putLong("reminder_time_$surveyIds", reminderTime)
            .putString("reminder_surveys_$surveyIds", surveyIds)
            .apply()

        val unitString = when (timeUnit) {
            TimeUnit.MINUTES -> resources.getQuantityString(R.plurals.minutes, value, value)
            TimeUnit.HOURS -> resources.getQuantityString(R.plurals.hours, value, value)
            TimeUnit.DAYS -> resources.getQuantityString(R.plurals.days, value, value)
            else -> "$value ${timeUnit.name.lowercase()}"
        }

        startReminderCheck()
    }

    private fun startReminderCheck() {
        surveyReminderJob?.cancel()
        surveyReminderJob = lifecycleScope.launch {
            while (isActive) {
                checkScheduledReminders()
                delay(60000)
            }
        }
    }

    private suspend fun checkScheduledReminders(): Boolean {
        val preferences = requireActivity().getSharedPreferences(PREF_SURVEY_REMINDERS, 0)
        val currentTime = System.currentTimeMillis()

        val remindersToShow = mutableListOf<String>()
        val remindersToRemove = mutableListOf<String>()

        for (entry in preferences.all) {
            if (entry.key.startsWith("reminder_time_")) {
                val surveyIds = entry.key.removePrefix("reminder_time_")
                val reminderTime = preferences.getLong(entry.key, 0)

                if (reminderTime <= currentTime) {
                    remindersToShow.add(surveyIds)
                    remindersToRemove.add(surveyIds)
                }
            }
        }

        for (surveyIds in remindersToShow) {
            val surveyIdList = surveyIds.split(",").filter { it.isNotBlank() }
            if (surveyIdList.isEmpty()) {
                continue
            }
            val submissions = submissionRepository.getSubmissionsByIds(surveyIdList)
            val submissionsById = submissions.associateBy { it.id }
            val pendingSurveys = surveyIdList.mapNotNull { submissionsById[it] }

            if (pendingSurveys.isNotEmpty()) {
                showPendingSurveysReminder(pendingSurveys)
            }
        }

        val editor = preferences.edit()
        for (surveyIds in remindersToRemove) {
            editor.remove("reminder_time_$surveyIds")
            editor.remove("reminder_surveys_$surveyIds")
        }
        editor.apply()

        return remindersToShow.isNotEmpty()

    }

    private fun showPendingSurveysReminder(pendingSurveys: List<RealmSubmission>) {
        if (pendingSurveys.isEmpty()) return

        viewLifecycleOwner.lifecycleScope.launch {
            val title = getString(
                R.string.reminder_surveys_to_complete,
                pendingSurveys.size,
                if (pendingSurveys.size > 1) "surveys" else "survey"
            )
            val surveyTitles = submissionRepository.getSurveyTitlesFromSubmissions(pendingSurveys)
            showSurveyListDialog(pendingSurveys, title, surveyTitles, dismissOnNeutral = true)
        }
    }

    private fun showSurveyListDialog(
        pendingSurveys: List<RealmSubmission>,
        title: String,
        surveyTitles: List<String>,
        dismissOnNeutral: Boolean = false
    ) {
        val dialogView = LayoutInflater.from(requireActivity()).inflate(R.layout.dialog_survey_list, null)
        val recyclerView: RecyclerView = dialogView.findViewById(R.id.recyclerViewSurveys)
        recyclerView.layoutManager = LinearLayoutManager(requireActivity())

        surveyListDialog?.dismiss()
        surveyListDialog = AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
            .setTitle(title)
            .setView(dialogView)
            .setPositiveButton(getString(R.string.ok)) { dialog, _ ->
                homeItemClickListener?.openCallFragment(MySubmissionFragment.newInstance("survey"))
                dialog.dismiss()
            }
            .setNeutralButton(getString(R.string.remind_later)) { _, _ -> }
            .setNegativeButton(getString(R.string.cancel)) { dialog, _ -> dialog.dismiss() }
            .create()

        val adapter = SurveyAdapter({ position ->
            val selectedSurvey = pendingSurveys[position].id
            AdapterMySubmission.openSurvey(homeItemClickListener, selectedSurvey, true, false, "")
        }, surveyListDialog!!)
        recyclerView.adapter = adapter
        adapter.submitList(surveyTitles)
        surveyListDialog?.show()
        surveyListDialog?.window?.setBackgroundDrawableResource(R.color.card_bg)

        surveyListDialog?.getButton(AlertDialog.BUTTON_NEUTRAL)?.setOnClickListener {
            showRemindLaterDialog(pendingSurveys, surveyListDialog!!)
            if (dismissOnNeutral) surveyListDialog?.dismiss()
        }
    }

    private fun observeCompletedCourses() {
        binding.cardProfileBell.progressBarBadges?.visibility = View.VISIBLE
        viewModel.loadCompletedCourses(user?.id)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.completedCourses.collectLatest { courses ->
                    if (courses.isNotEmpty()) {
                        showBadges(courses)
                        binding.cardProfileBell.progressBarBadges?.visibility = View.GONE
                    }
                }
            }
        }

        viewLifecycleOwner.lifecycleScope.launch {
            delay(2000)
            if (binding.cardProfileBell.progressBarBadges?.visibility == View.VISIBLE) {
                binding.cardProfileBell.progressBarBadges?.visibility = View.GONE
            }
        }
    }


    private fun showBadges(completedCourses: List<CourseCompletion>) {
        binding.cardProfileBell.llBadges.removeAllViews()
        completedCourses.forEachIndexed { index, course ->
            val rootView = requireActivity().findViewById<ViewGroup>(android.R.id.content)
            val star = LayoutInflater.from(activity).inflate(R.layout.image_start, rootView, false) as ImageView
            setColor(course.courseId, star)
            binding.cardProfileBell.llBadges.addView(star)
            star.contentDescription = "${getString(R.string.completed_course)} ${course.courseTitle}"
            star.setOnClickListener {
                openCourse(course, index)
            }
        }
    }

    private fun openCourse(course: CourseCompletion, position: Int) {
        if (homeItemClickListener != null) {
            val f: Fragment = TakeCourseFragment()
            val b = Bundle()
            b.putString("id", course.courseId)
            b.putInt("position", position)
            f.arguments = b
            homeItemClickListener?.openCallFragment(f)
        }
    }

    private fun setColor(courseId: String?, star: ImageView) {
        if (RealmCertification.isCourseCertified(mRealm, courseId)) {
            star.setColorFilter(ContextCompat.getColor(requireContext(), R.color.colorPrimary))
        } else {
            star.setColorFilter(ContextCompat.getColor(requireContext(), R.color.md_blue_grey_300))
        }
    }

    private fun declareElements() {
        binding.homeCardTeams.llHomeTeam.setOnClickListener {
            val fragment = TeamFragment().apply {
                arguments = Bundle().apply {
                    putBoolean("fromDashboard", true)
                }
            }
            homeItemClickListener?.openMyFragment(fragment)
        }
        binding.homeCardLibrary.myLibraryImageButton.setOnClickListener {
            if (user?.id?.startsWith("guest") == true) {
                guestDialog(requireContext())
            } else {
                homeItemClickListener?.openMyFragment(ResourcesFragment())
            }
        }
        binding.homeCardCourses.myCoursesImageButton.setOnClickListener {
            if (user?.id?.startsWith("guest") == true) {
                guestDialog(requireContext())
            } else {
                homeItemClickListener?.openMyFragment(CoursesFragment())
            }
        }
        binding.fabMyActivity.setOnClickListener { openHelperFragment(MyActivityFragment()) }
        binding.homeCardMyLife.myLifeImageButton.setOnClickListener { homeItemClickListener?.openCallFragment(LifeFragment()) }
    }

    private fun openHelperFragment(f: Fragment) {
        val b = Bundle()
        b.putBoolean("isMyCourseLib", true)
        f.arguments = b
        homeItemClickListener?.openCallFragment(f)
    }

    override fun onPause() {
        surveyListDialog?.dismiss()
        surveyListDialog = null
        super.onPause()
    }

    override fun onDestroyView() {
        surveyListDialog?.dismiss()
        surveyListDialog = null
        networkStatusJob?.cancel()
       surveyReminderJob?.cancel()
        super.onDestroyView()
        _binding = null
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard


import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.NumberPicker
import android.widget.RadioGroup
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import java.util.concurrent.TimeUnit
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.FragmentHomeBellBinding
import org.ole.planet.myplanet.model.RealmCertification
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.courses.CoursesFragment
import org.ole.planet.myplanet.ui.courses.TakeCourseFragment
import org.ole.planet.myplanet.ui.mylife.LifeFragment
import org.ole.planet.myplanet.ui.resources.ResourcesFragment
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission
import org.ole.planet.myplanet.ui.submission.MySubmissionFragment
import org.ole.planet.myplanet.ui.team.TeamFragment
import org.ole.planet.myplanet.utilities.DialogUtils.guestDialog
import org.ole.planet.myplanet.utilities.ServerUrlMapper

class BellDashboardFragment : BaseDashboardFragment() {
    private var _binding: FragmentHomeBellBinding? = null
    private val binding get() = _binding!!
    private var networkStatusJob: Job? = null
    private val viewModel: BellDashboardViewModel by viewModels()
    var user: RealmUserModel? = null
    private var surveyReminderJob: Job? = null
    private var surveyListDialog: AlertDialog? = null

    companion object {
        private const val PREF_SURVEY_REMINDERS = "survey_reminders"
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentHomeBellBinding.inflate(inflater, container, false)
        val view = binding.root
        declareElements()
        onLoaded(view)
        user = profileDbHandler?.userModel
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        initView(view)
        binding.cardProfileBell.txtCommunityName.text = model?.planetCode
        setupNetworkStatusMonitoring()
        (activity as DashboardActivity?)?.supportActionBar?.hide()
        observeCompletedCourses()
        if((user?.id?.startsWith("guest") != true) && !DashboardActivity.isFromNotificationAction) {
            checkPendingSurveys()
        }
        if (model?.id?.startsWith("guest") == false && TextUtils.isEmpty(model?.key)) {
            syncKeyId()
        }
    }

    private fun setupNetworkStatusMonitoring() {
        networkStatusJob?.cancel()
        networkStatusJob = viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.networkStatus.collect { status ->
                    updateNetworkIndicator(status)
                }
            }
        }
    }

    private fun setNetworkIndicatorColor(colorRes: Int) {
        if (isAdded && view?.isAttachedToWindow == true) {
            val color = ContextCompat.getColor(requireContext(), colorRes)
            binding.cardProfileBell.imageView.borderColor = color
        }
    }

    private suspend fun isServerReachable(mapping: ServerUrlMapper.UrlMapping): Boolean {
        val primaryAvailable = viewModel.checkServerConnection(mapping.primaryUrl)

        if (primaryAvailable) {
            return true
        }

        mapping.alternativeUrl?.let {
            val alternativeAvailable = viewModel.checkServerConnection(it)
            return alternativeAvailable
        }

        return false
    }

    private suspend fun handleConnectingState() {
        setNetworkIndicatorColor(R.color.md_yellow_600)
        val updateUrl = settings.getString("serverURL", "") ?: return
        val mapping = ServerUrlMapper().processUrl(updateUrl)
        try {
            val reachable = isServerReachable(mapping)
            setNetworkIndicatorColor(if (reachable) R.color.green else R.color.md_yellow_600)
        } catch (e: Exception) {
            e.printStackTrace()
            setNetworkIndicatorColor(R.color.md_yellow_600)
        }
    }

    private suspend fun updateNetworkIndicator(status: NetworkStatus) {
        if (!isAdded) return
        context ?: return

        when (status) {
            is NetworkStatus.Disconnected -> setNetworkIndicatorColor(R.color.md_red_700)
            is NetworkStatus.Connecting -> handleConnectingState()
            is NetworkStatus.Connected -> setNetworkIndicatorColor(R.color.green)
        }
    }

    private fun checkPendingSurveys() {
        viewLifecycleOwner.lifecycleScope.launch {
            if (checkScheduledReminders()) {
                return@launch
            }
            val pendingSurveys = submissionRepository.getUniquePendingSurveys(user?.id)

            if (pendingSurveys.isNotEmpty()) {
                val surveyIds = pendingSurveys.joinToString(",") { it.id.toString() }
                val preferences = requireActivity().getSharedPreferences(PREF_SURVEY_REMINDERS, 0)
                if (preferences.contains("reminder_time_$surveyIds")) {
                    return@launch
                }
                val title = getString(
                    R.string.surveys_to_complete,
                    pendingSurveys.size,
                    if (pendingSurveys.size > 1) "surveys" else "survey"
                )
                val surveyTitles = submissionRepository.getSurveyTitlesFromSubmissions(pendingSurveys)
                showSurveyListDialog(pendingSurveys, title, surveyTitles)
            } else {
                checkScheduledReminders()
            }
        }
    }

    private fun showRemindLaterDialog(pendingSurveys: List<RealmSubmission>,previousDialog: AlertDialog) {
        val dialogView = LayoutInflater.from(requireActivity()).inflate(R.layout.dialog_remind_later, null)
        val radioGroup: RadioGroup = dialogView.findViewById(R.id.radioGroupRemindOptions)
        val numberPicker: NumberPicker = dialogView.findViewById(R.id.numberPickerTime)
        val unitTextView: TextView = dialogView.findViewById(R.id.textViewTimeUnit)

        numberPicker.minValue = 1
        numberPicker.maxValue = 60
        numberPicker.wrapSelectorWheel = false

        radioGroup.check(R.id.radioButtonMinutes)
        unitTextView.text = getString(R.string.minutes)

        radioGroup.setOnCheckedChangeListener { _, checkedId ->
            when (checkedId) {
                R.id.radioButtonMinutes -> {
                    numberPicker.maxValue = 60
                    unitTextView.text = getString(R.string.minutes)
                }
                R.id.radioButtonHours -> {
                    numberPicker.maxValue = 24
                    unitTextView.text = getString(R.string.hours)
                }
                R.id.radioButtonDays -> {
                    numberPicker.maxValue = 30
                    unitTextView.text = getString(R.string.days)
                }
            }
        }

        AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
            .setTitle(getString(R.string.remind_me_later))
            .setView(dialogView)
            .setPositiveButton(getString(R.string.set_reminder)) { dialog, _ ->
                val value = numberPicker.value
                val timeUnit = when (radioGroup.checkedRadioButtonId) {
                    R.id.radioButtonMinutes -> TimeUnit.MINUTES
                    R.id.radioButtonHours -> TimeUnit.HOURS
                    R.id.radioButtonDays -> TimeUnit.DAYS
                    else -> TimeUnit.MINUTES
                }

                scheduleReminder(pendingSurveys, value, timeUnit)
                previousDialog.dismiss()
                dialog.dismiss()
            }
            .setNegativeButton(getString(R.string.cancel), null)
            .show()
            .window?.setBackgroundDrawableResource(R.color.card_bg)
    }

    private fun scheduleReminder(pendingSurveys: List<RealmSubmission>, value: Int, timeUnit: TimeUnit) {
        val currentTime = System.currentTimeMillis()
        val reminderTime = currentTime + timeUnit.toMillis(value.toLong())

        val surveyIds = pendingSurveys.joinToString(",") { it.id.toString() }
        val preferences = requireActivity().getSharedPreferences(PREF_SURVEY_REMINDERS, 0)
        preferences.edit()
            .putLong("reminder_time_$surveyIds", reminderTime)
            .putString("reminder_surveys_$surveyIds", surveyIds)
            .apply()

        val unitString = when (timeUnit) {
            TimeUnit.MINUTES -> resources.getQuantityString(R.plurals.minutes, value, value)
            TimeUnit.HOURS -> resources.getQuantityString(R.plurals.hours, value, value)
            TimeUnit.DAYS -> resources.getQuantityString(R.plurals.days, value, value)
            else -> "$value ${timeUnit.name.lowercase()}"
        }

        startReminderCheck()
    }

    private fun startReminderCheck() {
        surveyReminderJob?.cancel()
        surveyReminderJob = lifecycleScope.launch {
            while (isActive) {
                checkScheduledReminders()
                delay(60000)
            }
        }
    }

    private suspend fun checkScheduledReminders(): Boolean {
        val preferences = requireActivity().getSharedPreferences(PREF_SURVEY_REMINDERS, 0)
        val currentTime = System.currentTimeMillis()

        val remindersToShow = mutableListOf<String>()
        val remindersToRemove = mutableListOf<String>()

        for (entry in preferences.all) {
            if (entry.key.startsWith("reminder_time_")) {
                val surveyIds = entry.key.removePrefix("reminder_time_")
                val reminderTime = preferences.getLong(entry.key, 0)

                if (reminderTime <= currentTime) {
                    remindersToShow.add(surveyIds)
                    remindersToRemove.add(surveyIds)
                }
            }
        }

        for (surveyIds in remindersToShow) {
            val surveyIdList = surveyIds.split(",").filter { it.isNotBlank() }
            if (surveyIdList.isEmpty()) {
                continue
            }
            val submissions = submissionRepository.getSubmissionsByIds(surveyIdList)
            val submissionsById = submissions.associateBy { it.id }
            val pendingSurveys = surveyIdList.mapNotNull { submissionsById[it] }

            if (pendingSurveys.isNotEmpty()) {
                showPendingSurveysReminder(pendingSurveys)
            }
        }

        val editor = preferences.edit()
        for (surveyIds in remindersToRemove) {
            editor.remove("reminder_time_$surveyIds")
            editor.remove("reminder_surveys_$surveyIds")
        }
        editor.apply()

        return remindersToShow.isNotEmpty()

    }

    private fun showPendingSurveysReminder(pendingSurveys: List<RealmSubmission>) {
        if (pendingSurveys.isEmpty()) return

        viewLifecycleOwner.lifecycleScope.launch {
            val title = getString(
                R.string.reminder_surveys_to_complete,
                pendingSurveys.size,
                if (pendingSurveys.size > 1) "surveys" else "survey"
            )
            val surveyTitles = submissionRepository.getSurveyTitlesFromSubmissions(pendingSurveys)
            showSurveyListDialog(pendingSurveys, title, surveyTitles, dismissOnNeutral = true)
        }
    }

    private fun showSurveyListDialog(
        pendingSurveys: List<RealmSubmission>,
        title: String,
        surveyTitles: List<String>,
        dismissOnNeutral: Boolean = false
    ) {
        val dialogView = LayoutInflater.from(requireActivity()).inflate(R.layout.dialog_survey_list, null)
        val recyclerView: RecyclerView = dialogView.findViewById(R.id.recyclerViewSurveys)
        recyclerView.layoutManager = LinearLayoutManager(requireActivity())

        surveyListDialog?.dismiss()
        surveyListDialog = AlertDialog.Builder(requireActivity(), R.style.AlertDialogTheme)
            .setTitle(title)
            .setView(dialogView)
            .setPositiveButton(getString(R.string.ok)) { dialog, _ ->
                homeItemClickListener?.openCallFragment(MySubmissionFragment.newInstance("survey"))
                dialog.dismiss()
            }
            .setNeutralButton(getString(R.string.remind_later)) { _, _ -> }
            .setNegativeButton(getString(R.string.cancel)) { dialog, _ -> dialog.dismiss() }
            .create()

        val adapter = SurveyAdapter({ position ->
            val selectedSurvey = pendingSurveys[position].id
            AdapterMySubmission.openSurvey(homeItemClickListener, selectedSurvey, true, false, "")
        }, surveyListDialog!!)
        recyclerView.adapter = adapter
        adapter.submitList(surveyTitles)
        surveyListDialog?.show()
        surveyListDialog?.window?.setBackgroundDrawableResource(R.color.card_bg)

        surveyListDialog?.getButton(AlertDialog.BUTTON_NEUTRAL)?.setOnClickListener {
            showRemindLaterDialog(pendingSurveys, surveyListDialog!!)
            if (dismissOnNeutral) surveyListDialog?.dismiss()
        }
    }

    private fun observeCompletedCourses() {
        binding.cardProfileBell.progressBarBadges?.visibility = View.VISIBLE
        viewModel.loadCompletedCourses(user?.id)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.completedCourses.collectLatest { courses ->
                    if (courses.isNotEmpty()) {
                        showBadges(courses)
                        binding.cardProfileBell.progressBarBadges?.visibility = View.GONE
                    }
                }
            }
        }

        viewLifecycleOwner.lifecycleScope.launch {
            delay(2000)
            if (binding.cardProfileBell.progressBarBadges?.visibility == View.VISIBLE) {
                binding.cardProfileBell.progressBarBadges?.visibility = View.GONE
            }
        }
    }


    private fun showBadges(completedCourses: List<CourseCompletion>) {
        binding.cardProfileBell.llBadges.removeAllViews()
        completedCourses.forEachIndexed { index, course ->
            val rootView = requireActivity().findViewById<ViewGroup>(android.R.id.content)
            val star = LayoutInflater.from(activity).inflate(R.layout.image_start, rootView, false) as ImageView
            setColor(course.courseId, star)
            binding.cardProfileBell.llBadges.addView(star)
            star.contentDescription = "${getString(R.string.completed_course)} ${course.courseTitle}"
            star.setOnClickListener {
                openCourse(course, index)
            }
        }
    }

    private fun openCourse(course: CourseCompletion, position: Int) {
        if (homeItemClickListener != null) {
            val f: Fragment = TakeCourseFragment()
            val b = Bundle()
            b.putString("id", course.courseId)
            b.putInt("position", position)
            f.arguments = b
            homeItemClickListener?.openCallFragment(f)
        }
    }

    private fun setColor(courseId: String?, star: ImageView) {
        if (RealmCertification.isCourseCertified(mRealm, courseId)) {
            star.setColorFilter(ContextCompat.getColor(requireContext(), R.color.colorPrimary))
        } else {
            star.setColorFilter(ContextCompat.getColor(requireContext(), R.color.md_blue_grey_300))
        }
    }

    private fun declareElements() {
        binding.homeCardTeams.llHomeTeam.setOnClickListener {
            val fragment = TeamFragment().apply {
                arguments = Bundle().apply {
                    putBoolean("fromDashboard", true)
                }
            }
            homeItemClickListener?.openMyFragment(fragment)
        }
        binding.homeCardLibrary.myLibraryImageButton.setOnClickListener {
            if (user?.id?.startsWith("guest") == true) {
                guestDialog(requireContext())
            } else {
                homeItemClickListener?.openMyFragment(ResourcesFragment())
            }
        }
        binding.homeCardCourses.myCoursesImageButton.setOnClickListener {
            if (user?.id?.startsWith("guest") == true) {
                guestDialog(requireContext())
            } else {
                homeItemClickListener?.openMyFragment(CoursesFragment())
            }
        }
        binding.fabMyActivity.setOnClickListener { openHelperFragment(MyActivityFragment()) }
        binding.homeCardMyLife.myLifeImageButton.setOnClickListener { homeItemClickListener?.openCallFragment(LifeFragment()) }
    }

    private fun openHelperFragment(f: Fragment) {
        val b = Bundle()
        b.putBoolean("isMyCourseLib", true)
        f.arguments = b
        homeItemClickListener?.openCallFragment(f)
    }

    override fun onPause() {
        surveyListDialog?.dismiss()
        surveyListDialog = null
        super.onPause()
    }

    override fun onDestroyView() {
        surveyListDialog?.dismiss()
        surveyListDialog = null
        networkStatusJob?.cancel()
       surveyReminderJob?.cancel()
        super.onDestroyView()
        _binding = null
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/dashboard/InactiveDashboardFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.dashboard

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.databinding.FragmentInActiveDashboardBinding
import org.ole.planet.myplanet.ui.feedback.FeedbackFragment

class InactiveDashboardFragment : Fragment() {
    private var _binding: FragmentInActiveDashboardBinding? = null
    private val binding get() = _binding!!
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentInActiveDashboardBinding.inflate(inflater, container, false)
        binding.btnFeedback.setOnClickListener {
            FeedbackFragment().show(childFragmentManager, "")
        }
        return binding.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
=======
package org.ole.planet.myplanet.ui.dashboard


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.databinding.FragmentInActiveDashboardBinding
import org.ole.planet.myplanet.ui.feedback.FeedbackFragment

class InactiveDashboardFragment : Fragment() {
    private var _binding: FragmentInActiveDashboardBinding? = null
    private val binding get() = _binding!!
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentInActiveDashboardBinding.inflate(inflater, container, false)
        binding.btnFeedback.setOnClickListener {
            FeedbackFragment().show(childFragmentManager, "")
        }
        return binding.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/enterprises/AdapterReports.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.enterprises

import android.app.DatePickerDialog
import android.content.Context
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import com.google.gson.JsonObject
import java.util.Calendar
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.DialogAddReportBinding
import org.ole.planet.myplanet.databinding.ReportListItemBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.TimeUtils

class AdapterReports(
    private val context: Context,
    private val teamRepository: TeamRepository,
    private val scope: CoroutineScope,
) : ListAdapter<RealmMyTeam, AdapterReports.ViewHolderReports>(diffCallback) {
    private var startTimeStamp: String? = null
    private var endTimeStamp: String? = null
    lateinit var prefData: SharedPrefManager
    private var nonTeamMember = false

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderReports {
        val binding = ReportListItemBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        prefData = SharedPrefManager(context)
        return ViewHolderReports(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderReports, position: Int) {
        val binding = holder.binding
        if (nonTeamMember) {
            binding.edit.visibility = View.GONE
            binding.delete.visibility = View.GONE
        } else {
            binding.edit.visibility = View.VISIBLE
            binding.delete.visibility = View.VISIBLE
        }
        val report = getItem(position)
        binding.tvReportTitle.text = context.getString(R.string.team_financial_report, prefData.getTeamName())
        report?.let {
            with(binding) {
                val totalIncome = report.sales + report.otherIncome
                val totalExpenses = report.wages + report.otherExpenses
                val profitLoss = totalIncome - totalExpenses

                date.text = context.getString(R.string.string_range, TimeUtils.formatDate(it.startDate, " MMM dd, yyyy"), TimeUtils.formatDate(it.endDate, "MMM dd, yyyy"))
                beginningBalanceValue.text = context.getString(R.string.number_placeholder, it.beginningBalance)
                salesValue.text = context.getString(R.string.number_placeholder, it.sales)
                otherValue.text = context.getString(R.string.number_placeholder, it.otherIncome)
                totalIncomeValue.text = context.getString(R.string.number_placeholder, totalIncome)
                personnelValue.text = context.getString(R.string.number_placeholder, it.wages)
                nonPersonnelValue.text = context.getString(R.string.number_placeholder, it.otherExpenses)
                totalExpensesValue.text = context.getString(R.string.number_placeholder, totalExpenses)
                profitLossValue.text = context.getString(R.string.number_placeholder, profitLoss)
                endingBalanceValue.text = context.getString(R.string.number_placeholder, profitLoss + it.beginningBalance)
                tvReportDetails.text = context.getString(R.string.message_placeholder, it.description)
                createUpdate.text = context.getString(R.string.report_date_details, TimeUtils.formatDate(it.createdDate, "MMM dd, yyyy"), TimeUtils.formatDate(it.updatedDate, "MMM dd, yyyy"))
            }
        }

        binding.edit.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition == RecyclerView.NO_POSITION) return@setOnClickListener
            val currentReport = getItem(adapterPosition) ?: return@setOnClickListener
            val dialogAddReportBinding = DialogAddReportBinding.inflate(LayoutInflater.from(context))
            val v: View = dialogAddReportBinding.root
            val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
            builder.setTitle("Edit Report")
                .setView(v)
                .setPositiveButton("submit", null)
                .setNegativeButton("cancel", null)
            val dialog = builder.create()
            dialog.show()
            val submit = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            val cancel = dialog.getButton(AlertDialog.BUTTON_NEGATIVE)

            val calendar = Calendar.getInstance()
            calendar.set(Calendar.DAY_OF_MONTH, 1)

            startTimeStamp = currentReport.startDate.toString()
            endTimeStamp = currentReport.endDate.toString()

            dialogAddReportBinding.startDate.text = context.getString(R.string.message_placeholder, TimeUtils.formatDate(currentReport.startDate, " MMM dd, yyyy"))
            dialogAddReportBinding.endDate.text = context.getString(R.string.message_placeholder, TimeUtils.formatDate(currentReport.endDate, " MMM dd, yyyy"))
            dialogAddReportBinding.summary.setText(context.getString(R.string.message_placeholder, currentReport.description))
            dialogAddReportBinding.beginningBalance.setText(context.getString(R.string.number_placeholder, currentReport.beginningBalance))
            dialogAddReportBinding.sales.setText(context.getString(R.string.number_placeholder, currentReport.sales))
            dialogAddReportBinding.otherIncome.setText(context.getString(R.string.number_placeholder, currentReport.otherIncome))
            dialogAddReportBinding.personnel.setText(context.getString(R.string.number_placeholder, currentReport.wages))
            dialogAddReportBinding.nonPersonnel.setText(context.getString(R.string.number_placeholder, currentReport.otherExpenses))

            dialogAddReportBinding.ltStartDate.setOnClickListener {
                val year = calendar.get(Calendar.YEAR)
                val month = calendar.get(Calendar.MONTH)
                val day = calendar.get(Calendar.DAY_OF_MONTH)

                val dpd = DatePickerDialog(context, { _, selectedYear, selectedMonth, selectedDay ->
                    dialogAddReportBinding.startDate.text = context.getString(R.string.formatted_date, selectedDay, selectedMonth + 1, selectedYear)
                    calendar.set(Calendar.YEAR, selectedYear)
                    calendar.set(Calendar.MONTH, selectedMonth)
                    calendar.set(Calendar.DAY_OF_MONTH, selectedDay)

                    startTimeStamp = context.getString(R.string.number_placeholder, calendar.timeInMillis)
                }, year, month, day)

                dpd.show()
            }

            dialogAddReportBinding.ltEndDate.setOnClickListener {
                val year = calendar.get(Calendar.YEAR)
                val month = calendar.get(Calendar.MONTH)
                val day = calendar.get(Calendar.DAY_OF_MONTH)

                val dpd = DatePickerDialog(context, { _, selectedYear, selectedMonth, selectedDay ->
                    dialogAddReportBinding.endDate.text = context.getString(R.string.formatted_date, selectedDay, selectedMonth + 1, selectedYear)
                    calendar.set(Calendar.YEAR, selectedYear)
                    calendar.set(Calendar.MONTH, selectedMonth)
                    calendar.set(Calendar.DAY_OF_MONTH, selectedDay)

                    endTimeStamp = "${calendar.timeInMillis}"
                }, year, month, day)

                dpd.show()
            }

            submit.setOnClickListener {
                if (dialogAddReportBinding.startDate.text == "Start Date"){
                    dialogAddReportBinding.startDate.error = "start date is required"
                } else if (dialogAddReportBinding.endDate.text == "End Date"){
                    dialogAddReportBinding.endDate.error = "start date is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.summary.text}")) {
                    dialogAddReportBinding.summary.error = "summary is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.beginningBalance.text}")) {
                    dialogAddReportBinding.beginningBalance.error = "beginning balance is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.sales.text}")) {
                    dialogAddReportBinding.sales.error = "sales is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.otherIncome.text}")) {
                    dialogAddReportBinding.otherIncome.error = "other income is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.personnel.text}")) {
                    dialogAddReportBinding.personnel.error = "personnel is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.nonPersonnel.text}")) {
                    dialogAddReportBinding.nonPersonnel.error = "non-personnel is required"
                } else {
                    val reportId = currentReport._id
                    if (reportId.isNullOrBlank()) {
                        Snackbar.make(
                            binding.root,
                            "Failed to update report. Please try again.",
                            Snackbar.LENGTH_LONG,
                        ).show()
                        return@setOnClickListener
                    }
                    val doc = JsonObject().apply {
                        addProperty("description", dialogAddReportBinding.summary.text.toString())
                        addProperty(
                            "beginningBalance",
                            dialogAddReportBinding.beginningBalance.text.toString().toIntOrNull()
                                ?: currentReport.beginningBalance,
                        )
                        addProperty(
                            "sales",
                            dialogAddReportBinding.sales.text.toString().toIntOrNull()
                                ?: currentReport.sales,
                        )
                        addProperty(
                            "otherIncome",
                            dialogAddReportBinding.otherIncome.text.toString().toIntOrNull()
                                ?: currentReport.otherIncome,
                        )
                        addProperty(
                            "wages",
                            dialogAddReportBinding.personnel.text.toString().toIntOrNull()
                                ?: currentReport.wages,
                        )
                        addProperty(
                            "otherExpenses",
                            dialogAddReportBinding.nonPersonnel.text.toString().toIntOrNull()
                                ?: currentReport.otherExpenses,
                        )
                        addProperty("startDate", startTimeStamp?.toLongOrNull() ?: currentReport.startDate)
                        addProperty("endDate", endTimeStamp?.toLongOrNull() ?: currentReport.endDate)
                        addProperty("updatedDate", System.currentTimeMillis())
                        addProperty("updated", true)
                    }
                    scope.launch {
                        try {
                            withContext(Dispatchers.IO) {
                                teamRepository.updateReport(reportId, doc)
                            }
                            dialog.dismiss()
                        } catch (e: Exception) {
                            Snackbar.make(
                                binding.root,
                                "Failed to update report. Please try again.",
                                Snackbar.LENGTH_LONG
                            ).show()
                        }
                    }
                }
            }

            cancel.setOnClickListener { dialog.dismiss() }
        }

        binding.delete.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition == RecyclerView.NO_POSITION) return@setOnClickListener
            val reportToDelete = getItem(adapterPosition)
            reportToDelete?._id?.let { reportId ->
                val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
                builder.setTitle(context.getString(R.string.delete_report))
                    .setMessage(R.string.delete_record)
                    .setPositiveButton(R.string.ok) { _, _ ->
                        scope.launch {
                            try {
                                withContext(Dispatchers.IO) {
                                    teamRepository.archiveReport(reportId)
                                }
                            } catch (e: Exception) {
                                binding.root.let { view ->
                                    Snackbar.make(view, context.getString(R.string.failed_to_delete_report), Snackbar.LENGTH_LONG).show()
                                }
                            }
                        }
                    }
                    .setNegativeButton("Cancel", null)
                    .show()
            }

        }

    }

    fun setNonTeamMember(nonTeamMember: Boolean) {
        this.nonTeamMember = nonTeamMember
    }

    class ViewHolderReports(val binding: ReportListItemBinding) : RecyclerView.ViewHolder(binding.root)

    companion object {
        val diffCallback = DiffUtils.itemCallback<RealmMyTeam>(
            areItemsTheSame = { oldItem, newItem -> oldItem._id == newItem._id },
            areContentsTheSame = { oldItem, newItem -> oldItem == newItem }
        )
    }
}
=======
package org.ole.planet.myplanet.ui.enterprises


import android.app.DatePickerDialog
import android.content.Context
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AlertDialog
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import com.google.gson.JsonObject
import java.util.Calendar
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.DialogAddReportBinding
import org.ole.planet.myplanet.databinding.ReportListItemBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.utilities.DiffUtils
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.TimeUtils

class AdapterReports(
    private val context: Context,
    private val teamRepository: TeamRepository,
    private val scope: CoroutineScope,
) : ListAdapter<RealmMyTeam, AdapterReports.ViewHolderReports>(diffCallback) {
    private var startTimeStamp: String? = null
    private var endTimeStamp: String? = null
    lateinit var prefData: SharedPrefManager
    private var nonTeamMember = false

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderReports {
        val binding = ReportListItemBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        prefData = SharedPrefManager(context)
        return ViewHolderReports(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderReports, position: Int) {
        val binding = holder.binding
        if (nonTeamMember) {
            binding.edit.visibility = View.GONE
            binding.delete.visibility = View.GONE
        } else {
            binding.edit.visibility = View.VISIBLE
            binding.delete.visibility = View.VISIBLE
        }
        val report = getItem(position)
        binding.tvReportTitle.text = context.getString(R.string.team_financial_report, prefData.getTeamName())
        report?.let {
            with(binding) {
                val totalIncome = report.sales + report.otherIncome
                val totalExpenses = report.wages + report.otherExpenses
                val profitLoss = totalIncome - totalExpenses

                date.text = context.getString(R.string.string_range, TimeUtils.formatDate(it.startDate, " MMM dd, yyyy"), TimeUtils.formatDate(it.endDate, "MMM dd, yyyy"))
                beginningBalanceValue.text = context.getString(R.string.number_placeholder, it.beginningBalance)
                salesValue.text = context.getString(R.string.number_placeholder, it.sales)
                otherValue.text = context.getString(R.string.number_placeholder, it.otherIncome)
                totalIncomeValue.text = context.getString(R.string.number_placeholder, totalIncome)
                personnelValue.text = context.getString(R.string.number_placeholder, it.wages)
                nonPersonnelValue.text = context.getString(R.string.number_placeholder, it.otherExpenses)
                totalExpensesValue.text = context.getString(R.string.number_placeholder, totalExpenses)
                profitLossValue.text = context.getString(R.string.number_placeholder, profitLoss)
                endingBalanceValue.text = context.getString(R.string.number_placeholder, profitLoss + it.beginningBalance)
                tvReportDetails.text = context.getString(R.string.message_placeholder, it.description)
                createUpdate.text = context.getString(R.string.report_date_details, TimeUtils.formatDate(it.createdDate, "MMM dd, yyyy"), TimeUtils.formatDate(it.updatedDate, "MMM dd, yyyy"))
            }
        }

        binding.edit.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition == RecyclerView.NO_POSITION) return@setOnClickListener
            val currentReport = getItem(adapterPosition) ?: return@setOnClickListener
            val dialogAddReportBinding = DialogAddReportBinding.inflate(LayoutInflater.from(context))
            val v: View = dialogAddReportBinding.root
            val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
            builder.setTitle("Edit Report")
                .setView(v)
                .setPositiveButton("submit", null)
                .setNegativeButton("cancel", null)
            val dialog = builder.create()
            dialog.show()
            val submit = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            val cancel = dialog.getButton(AlertDialog.BUTTON_NEGATIVE)

            val calendar = Calendar.getInstance()
            calendar.set(Calendar.DAY_OF_MONTH, 1)

            startTimeStamp = currentReport.startDate.toString()
            endTimeStamp = currentReport.endDate.toString()

            dialogAddReportBinding.startDate.text = context.getString(R.string.message_placeholder, TimeUtils.formatDate(currentReport.startDate, " MMM dd, yyyy"))
            dialogAddReportBinding.endDate.text = context.getString(R.string.message_placeholder, TimeUtils.formatDate(currentReport.endDate, " MMM dd, yyyy"))
            dialogAddReportBinding.summary.setText(context.getString(R.string.message_placeholder, currentReport.description))
            dialogAddReportBinding.beginningBalance.setText(context.getString(R.string.number_placeholder, currentReport.beginningBalance))
            dialogAddReportBinding.sales.setText(context.getString(R.string.number_placeholder, currentReport.sales))
            dialogAddReportBinding.otherIncome.setText(context.getString(R.string.number_placeholder, currentReport.otherIncome))
            dialogAddReportBinding.personnel.setText(context.getString(R.string.number_placeholder, currentReport.wages))
            dialogAddReportBinding.nonPersonnel.setText(context.getString(R.string.number_placeholder, currentReport.otherExpenses))

            dialogAddReportBinding.ltStartDate.setOnClickListener {
                val year = calendar.get(Calendar.YEAR)
                val month = calendar.get(Calendar.MONTH)
                val day = calendar.get(Calendar.DAY_OF_MONTH)

                val dpd = DatePickerDialog(context, { _, selectedYear, selectedMonth, selectedDay ->
                    dialogAddReportBinding.startDate.text = context.getString(R.string.formatted_date, selectedDay, selectedMonth + 1, selectedYear)
                    calendar.set(Calendar.YEAR, selectedYear)
                    calendar.set(Calendar.MONTH, selectedMonth)
                    calendar.set(Calendar.DAY_OF_MONTH, selectedDay)

                    startTimeStamp = context.getString(R.string.number_placeholder, calendar.timeInMillis)
                }, year, month, day)

                dpd.show()
            }

            dialogAddReportBinding.ltEndDate.setOnClickListener {
                val year = calendar.get(Calendar.YEAR)
                val month = calendar.get(Calendar.MONTH)
                val day = calendar.get(Calendar.DAY_OF_MONTH)

                val dpd = DatePickerDialog(context, { _, selectedYear, selectedMonth, selectedDay ->
                    dialogAddReportBinding.endDate.text = context.getString(R.string.formatted_date, selectedDay, selectedMonth + 1, selectedYear)
                    calendar.set(Calendar.YEAR, selectedYear)
                    calendar.set(Calendar.MONTH, selectedMonth)
                    calendar.set(Calendar.DAY_OF_MONTH, selectedDay)

                    endTimeStamp = "${calendar.timeInMillis}"
                }, year, month, day)

                dpd.show()
            }

            submit.setOnClickListener {
                if (dialogAddReportBinding.startDate.text == "Start Date"){
                    dialogAddReportBinding.startDate.error = "start date is required"
                } else if (dialogAddReportBinding.endDate.text == "End Date"){
                    dialogAddReportBinding.endDate.error = "start date is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.summary.text}")) {
                    dialogAddReportBinding.summary.error = "summary is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.beginningBalance.text}")) {
                    dialogAddReportBinding.beginningBalance.error = "beginning balance is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.sales.text}")) {
                    dialogAddReportBinding.sales.error = "sales is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.otherIncome.text}")) {
                    dialogAddReportBinding.otherIncome.error = "other income is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.personnel.text}")) {
                    dialogAddReportBinding.personnel.error = "personnel is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.nonPersonnel.text}")) {
                    dialogAddReportBinding.nonPersonnel.error = "non-personnel is required"
                } else {
                    val reportId = currentReport._id
                    if (reportId.isNullOrBlank()) {
                        Snackbar.make(
                            binding.root,
                            "Failed to update report. Please try again.",
                            Snackbar.LENGTH_LONG,
                        ).show()
                        return@setOnClickListener
                    }
                    val doc = JsonObject().apply {
                        addProperty("description", dialogAddReportBinding.summary.text.toString())
                        addProperty(
                            "beginningBalance",
                            dialogAddReportBinding.beginningBalance.text.toString().toIntOrNull()
                                ?: currentReport.beginningBalance,
                        )
                        addProperty(
                            "sales",
                            dialogAddReportBinding.sales.text.toString().toIntOrNull()
                                ?: currentReport.sales,
                        )
                        addProperty(
                            "otherIncome",
                            dialogAddReportBinding.otherIncome.text.toString().toIntOrNull()
                                ?: currentReport.otherIncome,
                        )
                        addProperty(
                            "wages",
                            dialogAddReportBinding.personnel.text.toString().toIntOrNull()
                                ?: currentReport.wages,
                        )
                        addProperty(
                            "otherExpenses",
                            dialogAddReportBinding.nonPersonnel.text.toString().toIntOrNull()
                                ?: currentReport.otherExpenses,
                        )
                        addProperty("startDate", startTimeStamp?.toLongOrNull() ?: currentReport.startDate)
                        addProperty("endDate", endTimeStamp?.toLongOrNull() ?: currentReport.endDate)
                        addProperty("updatedDate", System.currentTimeMillis())
                        addProperty("updated", true)
                    }
                    scope.launch {
                        try {
                            withContext(Dispatchers.IO) {
                                teamRepository.updateReport(reportId, doc)
                            }
                            dialog.dismiss()
                        } catch (e: Exception) {
                            Snackbar.make(
                                binding.root,
                                "Failed to update report. Please try again.",
                                Snackbar.LENGTH_LONG
                            ).show()
                        }
                    }
                }
            }

            cancel.setOnClickListener { dialog.dismiss() }
        }

        binding.delete.setOnClickListener {
            val adapterPosition = holder.bindingAdapterPosition
            if (adapterPosition == RecyclerView.NO_POSITION) return@setOnClickListener
            val reportToDelete = getItem(adapterPosition)
            reportToDelete?._id?.let { reportId ->
                val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
                builder.setTitle(context.getString(R.string.delete_report))
                    .setMessage(R.string.delete_record)
                    .setPositiveButton(R.string.ok) { _, _ ->
                        scope.launch {
                            try {
                                withContext(Dispatchers.IO) {
                                    teamRepository.archiveReport(reportId)
                                }
                            } catch (e: Exception) {
                                binding.root.let { view ->
                                    Snackbar.make(view, context.getString(R.string.failed_to_delete_report), Snackbar.LENGTH_LONG).show()
                                }
                            }
                        }
                    }
                    .setNegativeButton("Cancel", null)
                    .show()
            }

        }

    }

    fun setNonTeamMember(nonTeamMember: Boolean) {
        this.nonTeamMember = nonTeamMember
    }

    class ViewHolderReports(val binding: ReportListItemBinding) : RecyclerView.ViewHolder(binding.root)

    companion object {
        val diffCallback = DiffUtils.itemCallback<RealmMyTeam>(
            areItemsTheSame = { oldItem, newItem -> oldItem._id == newItem._id },
            areContentsTheSame = { oldItem, newItem -> oldItem == newItem }
        )
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/enterprises/AdapterFinance.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.enterprises

import android.content.Context
import android.graphics.Color
import android.graphics.drawable.Drawable
import android.graphics.drawable.GradientDrawable
import android.graphics.drawable.LayerDrawable
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.ViewGroup
import android.widget.LinearLayout
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import java.util.Locale
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowFinanceBinding
import org.ole.planet.myplanet.ui.enterprises.AdapterFinance.ViewHolderFinance
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate

data class TransactionData(
    val id: String,
    val date: Long,
    val description: String?,
    val type: String?,
    val amount: Int,
    val balance: Int
)

class AdapterFinance(
    private val context: Context,
) : ListAdapter<TransactionData, ViewHolderFinance>(TransactionDataDiffCallback()) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderFinance {
        val binding = RowFinanceBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderFinance(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderFinance, position: Int) {
        val item = getItem(position)
        val binding = holder.binding
        binding.date.text = formatDate(item.date, "MMM dd, yyyy")
        binding.note.text = item.description
        binding.debit.setTextColor(Color.BLACK)
        binding.credit.setTextColor(Color.BLACK)
        if (TextUtils.equals(item.type?.lowercase(Locale.getDefault()), "debit")) {
            binding.debit.text = context.getString(R.string.number_placeholder, item.amount)
            binding.credit.text = context.getString(R.string.message_placeholder, " -")
        } else {
            binding.credit.text = context.getString(R.string.number_placeholder, item.amount)
            binding.debit.text = context.getString(R.string.message_placeholder, " -")
        }
        binding.balance.text = item.balance.toString()
        updateBackgroundColor(binding.llayout, position)
    }

    private fun updateBackgroundColor(layout: LinearLayout, position: Int) {
        if (position % 2 < 1) {
            val border = GradientDrawable()
            border.setColor(-0x1) //white background
            border.setStroke(1, ContextCompat.getColor(context, R.color.black_overlay))
            border.gradientType = GradientDrawable.LINEAR_GRADIENT
            val layers = arrayOf<Drawable>(border)
            val layerDrawable = LayerDrawable(layers)
            layerDrawable.setLayerInset(0, -10, 0, -10, 0)
            layout.background = layerDrawable
        }
    }

    class ViewHolderFinance(val binding: RowFinanceBinding) : RecyclerView.ViewHolder(
        binding.root
    )

    private class TransactionDataDiffCallback : DiffUtil.ItemCallback<TransactionData>() {
        override fun areItemsTheSame(oldItem: TransactionData, newItem: TransactionData): Boolean {
            return oldItem.id == newItem.id
        }

        override fun areContentsTheSame(oldItem: TransactionData, newItem: TransactionData): Boolean {
            return oldItem == newItem
        }
    }
}
=======
package org.ole.planet.myplanet.ui.enterprises


import android.content.Context
import android.graphics.Color
import android.graphics.drawable.Drawable
import android.graphics.drawable.GradientDrawable
import android.graphics.drawable.LayerDrawable
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.ViewGroup
import android.widget.LinearLayout
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import java.util.Locale
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.RowFinanceBinding
import org.ole.planet.myplanet.ui.enterprises.AdapterFinance.ViewHolderFinance
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate

data class TransactionData(
    val id: String,
    val date: Long,
    val description: String?,
    val type: String?,
    val amount: Int,
    val balance: Int
)

class AdapterFinance(
    private val context: Context,
) : ListAdapter<TransactionData, ViewHolderFinance>(TransactionDataDiffCallback()) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolderFinance {
        val binding = RowFinanceBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return ViewHolderFinance(binding)
    }

    override fun onBindViewHolder(holder: ViewHolderFinance, position: Int) {
        val item = getItem(position)
        val binding = holder.binding
        binding.date.text = formatDate(item.date, "MMM dd, yyyy")
        binding.note.text = item.description
        binding.debit.setTextColor(Color.BLACK)
        binding.credit.setTextColor(Color.BLACK)
        if (TextUtils.equals(item.type?.lowercase(Locale.getDefault()), "debit")) {
            binding.debit.text = context.getString(R.string.number_placeholder, item.amount)
            binding.credit.text = context.getString(R.string.message_placeholder, " -")
        } else {
            binding.credit.text = context.getString(R.string.number_placeholder, item.amount)
            binding.debit.text = context.getString(R.string.message_placeholder, " -")
        }
        binding.balance.text = item.balance.toString()
        updateBackgroundColor(binding.llayout, position)
    }

    private fun updateBackgroundColor(layout: LinearLayout, position: Int) {
        if (position % 2 < 1) {
            val border = GradientDrawable()
            border.setColor(-0x1) //white background
            border.setStroke(1, ContextCompat.getColor(context, R.color.black_overlay))
            border.gradientType = GradientDrawable.LINEAR_GRADIENT
            val layers = arrayOf<Drawable>(border)
            val layerDrawable = LayerDrawable(layers)
            layerDrawable.setLayerInset(0, -10, 0, -10, 0)
            layout.background = layerDrawable
        }
    }

    class ViewHolderFinance(val binding: RowFinanceBinding) : RecyclerView.ViewHolder(
        binding.root
    )

    private class TransactionDataDiffCallback : DiffUtil.ItemCallback<TransactionData>() {
        override fun areItemsTheSame(oldItem: TransactionData, newItem: TransactionData): Boolean {
            return oldItem.id == newItem.id
        }

        override fun areContentsTheSame(oldItem: TransactionData, newItem: TransactionData): Boolean {
            return oldItem == newItem
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/enterprises/ReportsFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.enterprises

import android.app.Activity
import android.app.DatePickerDialog
import android.content.Intent
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.core.view.isVisible
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.gson.JsonObject
import io.realm.RealmResults
import io.realm.Sort
import java.io.IOException
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale
import java.util.UUID
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment
import org.ole.planet.myplanet.databinding.DialogAddReportBinding
import org.ole.planet.myplanet.databinding.FragmentReportsBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.Utilities

class ReportsFragment : BaseTeamFragment() {
    private var _binding: FragmentReportsBinding? = null
    private val binding get() = _binding!!
    var list: RealmResults<RealmMyTeam>? = null
    private lateinit var adapterReports: AdapterReports
    private var startTimeStamp: String? = null
    private var endTimeStamp: String? = null
    lateinit var teamType: String
    private lateinit var createFileLauncher: ActivityResultLauncher<Intent>

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentReportsBinding.inflate(inflater, container, false)
        prefData = SharedPrefManager(requireContext())
        binding.addReports.isVisible = false
        binding.addReports.setOnClickListener{
            val dialogAddReportBinding = DialogAddReportBinding.inflate(LayoutInflater.from(requireContext()))
            val v: View = dialogAddReportBinding.root
            val builder = AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
            builder.setTitle(R.string.add_report)
                .setView(v)
                .setPositiveButton("submit", null)
                .setNegativeButton("cancel", null)
            val dialog = builder.create()
            dialog.show()
            val submit = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            val cancel = dialog.getButton(AlertDialog.BUTTON_NEGATIVE)

            val calendar = Calendar.getInstance()
            calendar.set(Calendar.DAY_OF_MONTH, 1)
            val firstDayOfMonth = "${calendar.get(Calendar.DAY_OF_MONTH)}/${calendar.get(Calendar.MONTH) + 1}/${calendar.get(Calendar.YEAR)}"
            startTimeStamp = "${calendar.timeInMillis}"

            calendar.set(Calendar.DAY_OF_MONTH, calendar.getActualMaximum(Calendar.DAY_OF_MONTH))
            val lastDayOfMonth = "${calendar.get(Calendar.DAY_OF_MONTH)}/${calendar.get(Calendar.MONTH) + 1}/${calendar.get(Calendar.YEAR)}"
            endTimeStamp = "${calendar.timeInMillis}"

            dialogAddReportBinding.startDate.text = firstDayOfMonth
            dialogAddReportBinding.endDate.text = lastDayOfMonth

            dialogAddReportBinding.ltStartDate.setOnClickListener {
                val year = calendar.get(Calendar.YEAR)
                val month = calendar.get(Calendar.MONTH)
                val day = calendar.get(Calendar.DAY_OF_MONTH)

                val dpd = DatePickerDialog(requireContext(), { _, selectedYear, selectedMonth, selectedDay ->
                    dialogAddReportBinding.startDate.text = getString(R.string.formatted_date, selectedDay, selectedMonth + 1, selectedYear)
                    calendar.set(Calendar.YEAR, selectedYear)
                    calendar.set(Calendar.MONTH, selectedMonth)
                    calendar.set(Calendar.DAY_OF_MONTH, selectedDay)

                    startTimeStamp = "${calendar.timeInMillis}"
                }, year, month, day)

                dpd.show()
            }

            dialogAddReportBinding.ltEndDate.setOnClickListener {
                val year = calendar.get(Calendar.YEAR)
                val month = calendar.get(Calendar.MONTH)
                val day = calendar.get(Calendar.DAY_OF_MONTH)

                val dpd = DatePickerDialog(requireContext(), { _, selectedYear, selectedMonth, selectedDay ->
                    dialogAddReportBinding.endDate.text = getString(R.string.formatted_date, selectedDay, selectedMonth + 1, selectedYear)
                    calendar.set(Calendar.YEAR, selectedYear)
                    calendar.set(Calendar.MONTH, selectedMonth)
                    calendar.set(Calendar.DAY_OF_MONTH, selectedDay)

                    endTimeStamp = "${calendar.timeInMillis}"
                }, year, month, day)

                dpd.show()
            }

            submit.setOnClickListener {
                if (dialogAddReportBinding.startDate.text == "Start Date"){
                    dialogAddReportBinding.startDate.error = "start date is required"
                } else if (dialogAddReportBinding.endDate.text == "End Date"){
                    dialogAddReportBinding.endDate.error = "start date is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.summary.text}")) {
                    dialogAddReportBinding.summary.error = "summary is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.beginningBalance.text}")) {
                    dialogAddReportBinding.beginningBalance.error = "beginning balance is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.sales.text}")) {
                    dialogAddReportBinding.sales.error = "sales is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.otherIncome.text}")) {
                    dialogAddReportBinding.otherIncome.error = "other income is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.personnel.text}")) {
                    dialogAddReportBinding.personnel.error = "personnel is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.nonPersonnel.text}")) {
                    dialogAddReportBinding.nonPersonnel.error = "non-personnel is required"
                } else {
                    val doc = JsonObject().apply {
                        addProperty("_id", UUID.randomUUID().toString())
                        addProperty("createdDate", System.currentTimeMillis())
                        addProperty("description", "${dialogAddReportBinding.summary.text}")
                        addProperty("beginningBalance", dialogAddReportBinding.beginningBalance.text.toString().toIntOrNull() ?: 0)
                        addProperty("sales", dialogAddReportBinding.sales.text.toString().toIntOrNull() ?: 0)
                        addProperty("otherIncome", dialogAddReportBinding.otherIncome.text.toString().toIntOrNull() ?: 0)
                        addProperty("wages", dialogAddReportBinding.personnel.text.toString().toIntOrNull() ?: 0)
                        addProperty("otherExpenses", dialogAddReportBinding.nonPersonnel.text.toString().toIntOrNull() ?: 0)
                        addProperty("startDate", startTimeStamp?.toLongOrNull() ?: 0L)
                        addProperty("endDate", endTimeStamp?.toLongOrNull() ?: 0L)
                        addProperty("updatedDate", System.currentTimeMillis())
                        addProperty("teamId", teamId)
                        addProperty("teamType", team?.teamType)
                        addProperty("teamPlanetCode", team?.teamPlanetCode)
                        addProperty("docType", "report")
                        addProperty("updated", true)
                    }
                    viewLifecycleOwner.lifecycleScope.launch {
                        teamRepository.addReport(doc)
                    }
                    dialog.dismiss()
                }
            }

            cancel.setOnClickListener { dialog.dismiss() }
        }

        binding.exportCSV.setOnClickListener {
            val currentDate = Date()
            val dateFormat = SimpleDateFormat("EEE_MMM_dd_yyyy", Locale.US)
            val formattedDate = dateFormat.format(currentDate)
            val teamName = prefData.getTeamName()?.replace(" ", "_")

            val intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply {
                addCategory(Intent.CATEGORY_OPENABLE)
                type = "text/csv"
                putExtra(Intent.EXTRA_TITLE, "Report_of_${teamName}_Financial_Report_Summary_on_${formattedDate}")
            }
            createFileLauncher.launch(intent)
        }

        list = mRealm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("docType", "report")
            .notEqualTo("status", "archived")
            .sort("createdDate", Sort.DESCENDING)
            .findAllAsync()

        list?.addChangeListener { results ->
            updatedReportsList(results)
        }

        createFileLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == Activity.RESULT_OK) {
                val uri = result.data?.data
                if (uri != null) {
                    try {
                        val reports = mRealm.where(RealmMyTeam::class.java)
                            .equalTo("teamId", teamId)
                            .equalTo("docType", "report")
                            .notEqualTo("status", "archived")
                            .sort("createdDate", Sort.DESCENDING)
                            .findAll()
                        val csvBuilder = StringBuilder()
                        csvBuilder.append("${prefData.getTeamName()} Financial Report Summary\n\n")
                        csvBuilder.append("Start Date, End Date, Created Date, Updated Date, Beginning Balance, Sales, Other Income, Wages, Other Expenses, Profit/Loss, Ending Balance\n")
                        for (report in reports) {
                            val dateFormat = SimpleDateFormat("EEE MMM dd yyyy HH:mm:ss 'GMT'Z (z)", Locale.US)
                            val totalIncome = report.sales + report.otherIncome
                            val totalExpenses = report.wages + report.otherExpenses
                            val profitLoss = totalIncome - totalExpenses
                            val endingBalance = profitLoss + report.beginningBalance
                            csvBuilder.append("${dateFormat.format(report.startDate)}, ${dateFormat.format(report.endDate)}, ${dateFormat.format(report.createdDate)}, ${dateFormat.format(report.updatedDate)}, ${report.beginningBalance}, ${report.sales}, ${report.otherIncome}, ${report.wages}, ${report.otherExpenses}, $profitLoss, $endingBalance\n")
                        }

                        requireContext().contentResolver.openOutputStream(uri)?.use { outputStream ->
                            outputStream.write("$csvBuilder".toByteArray())
                        }
                        Utilities.toast(requireContext(), getString(R.string.csv_file_saved_successfully))
                    } catch (e: IOException) {
                        e.printStackTrace()
                        Utilities.toast(requireContext(), getString(R.string.failed_to_save_csv_file))
                    }
                } else {
                    Utilities.toast(requireContext(), getString(R.string.export_cancelled))
                }
            }
        }
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        adapterReports = AdapterReports(requireContext(), teamRepository, viewLifecycleOwner.lifecycleScope)
        binding.rvReports.adapter = adapterReports
        binding.rvReports.layoutManager = LinearLayoutManager(activity)

        list = mRealm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("docType", "report")
            .notEqualTo("status", "archived")
            .sort("createdDate", Sort.DESCENDING)
            .findAll()
        updatedReportsList(list as RealmResults<RealmMyTeam>)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                isMemberFlow.collectLatest { isMember ->
                    binding.addReports.isVisible = isMember
                    adapterReports.setNonTeamMember(!isMember)
                }
            }
        }
    }

    override fun onNewsItemClick(news: RealmNews?) {}

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    fun updatedReportsList(results: RealmResults<RealmMyTeam>) {
        if (_binding == null) return

        val immutableResults = results.let { mRealm.copyFromRealm(it) }
        adapterReports.submitList(immutableResults)

        if (results.isEmpty()) {
            binding.exportCSV.visibility = View.GONE
            BaseRecyclerFragment.showNoData(binding.tvMessage, results.count(), "reports")
        } else {
            binding.exportCSV.visibility = View.VISIBLE
        }
    }

    override fun onDestroyView() {
        list?.removeAllChangeListeners()
        list = null
        if (isRealmInitialized()) {
            mRealm.close()
        }
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.ui.enterprises


import android.app.Activity
import android.app.DatePickerDialog
import android.content.Intent
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.core.view.isVisible
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.LinearLayoutManager
import com.google.gson.JsonObject
import io.realm.RealmResults
import io.realm.Sort
import java.io.IOException
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale
import java.util.UUID
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseRecyclerFragment
import org.ole.planet.myplanet.databinding.DialogAddReportBinding
import org.ole.planet.myplanet.databinding.FragmentReportsBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.Utilities

class ReportsFragment : BaseTeamFragment() {
    private var _binding: FragmentReportsBinding? = null
    private val binding get() = _binding!!
    var list: RealmResults<RealmMyTeam>? = null
    private lateinit var adapterReports: AdapterReports
    private var startTimeStamp: String? = null
    private var endTimeStamp: String? = null
    lateinit var teamType: String
    private lateinit var createFileLauncher: ActivityResultLauncher<Intent>

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentReportsBinding.inflate(inflater, container, false)
        prefData = SharedPrefManager(requireContext())
        binding.addReports.isVisible = false
        binding.addReports.setOnClickListener{
            val dialogAddReportBinding = DialogAddReportBinding.inflate(LayoutInflater.from(requireContext()))
            val v: View = dialogAddReportBinding.root
            val builder = AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
            builder.setTitle(R.string.add_report)
                .setView(v)
                .setPositiveButton("submit", null)
                .setNegativeButton("cancel", null)
            val dialog = builder.create()
            dialog.show()
            val submit = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            val cancel = dialog.getButton(AlertDialog.BUTTON_NEGATIVE)

            val calendar = Calendar.getInstance()
            calendar.set(Calendar.DAY_OF_MONTH, 1)
            val firstDayOfMonth = "${calendar.get(Calendar.DAY_OF_MONTH)}/${calendar.get(Calendar.MONTH) + 1}/${calendar.get(Calendar.YEAR)}"
            startTimeStamp = "${calendar.timeInMillis}"

            calendar.set(Calendar.DAY_OF_MONTH, calendar.getActualMaximum(Calendar.DAY_OF_MONTH))
            val lastDayOfMonth = "${calendar.get(Calendar.DAY_OF_MONTH)}/${calendar.get(Calendar.MONTH) + 1}/${calendar.get(Calendar.YEAR)}"
            endTimeStamp = "${calendar.timeInMillis}"

            dialogAddReportBinding.startDate.text = firstDayOfMonth
            dialogAddReportBinding.endDate.text = lastDayOfMonth

            dialogAddReportBinding.ltStartDate.setOnClickListener {
                val year = calendar.get(Calendar.YEAR)
                val month = calendar.get(Calendar.MONTH)
                val day = calendar.get(Calendar.DAY_OF_MONTH)

                val dpd = DatePickerDialog(requireContext(), { _, selectedYear, selectedMonth, selectedDay ->
                    dialogAddReportBinding.startDate.text = getString(R.string.formatted_date, selectedDay, selectedMonth + 1, selectedYear)
                    calendar.set(Calendar.YEAR, selectedYear)
                    calendar.set(Calendar.MONTH, selectedMonth)
                    calendar.set(Calendar.DAY_OF_MONTH, selectedDay)

                    startTimeStamp = "${calendar.timeInMillis}"
                }, year, month, day)

                dpd.show()
            }

            dialogAddReportBinding.ltEndDate.setOnClickListener {
                val year = calendar.get(Calendar.YEAR)
                val month = calendar.get(Calendar.MONTH)
                val day = calendar.get(Calendar.DAY_OF_MONTH)

                val dpd = DatePickerDialog(requireContext(), { _, selectedYear, selectedMonth, selectedDay ->
                    dialogAddReportBinding.endDate.text = getString(R.string.formatted_date, selectedDay, selectedMonth + 1, selectedYear)
                    calendar.set(Calendar.YEAR, selectedYear)
                    calendar.set(Calendar.MONTH, selectedMonth)
                    calendar.set(Calendar.DAY_OF_MONTH, selectedDay)

                    endTimeStamp = "${calendar.timeInMillis}"
                }, year, month, day)

                dpd.show()
            }

            submit.setOnClickListener {
                if (dialogAddReportBinding.startDate.text == "Start Date"){
                    dialogAddReportBinding.startDate.error = "start date is required"
                } else if (dialogAddReportBinding.endDate.text == "End Date"){
                    dialogAddReportBinding.endDate.error = "start date is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.summary.text}")) {
                    dialogAddReportBinding.summary.error = "summary is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.beginningBalance.text}")) {
                    dialogAddReportBinding.beginningBalance.error = "beginning balance is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.sales.text}")) {
                    dialogAddReportBinding.sales.error = "sales is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.otherIncome.text}")) {
                    dialogAddReportBinding.otherIncome.error = "other income is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.personnel.text}")) {
                    dialogAddReportBinding.personnel.error = "personnel is required"
                } else if (TextUtils.isEmpty("${dialogAddReportBinding.nonPersonnel.text}")) {
                    dialogAddReportBinding.nonPersonnel.error = "non-personnel is required"
                } else {
                    val doc = JsonObject().apply {
                        addProperty("_id", UUID.randomUUID().toString())
                        addProperty("createdDate", System.currentTimeMillis())
                        addProperty("description", "${dialogAddReportBinding.summary.text}")
                        addProperty("beginningBalance", dialogAddReportBinding.beginningBalance.text.toString().toIntOrNull() ?: 0)
                        addProperty("sales", dialogAddReportBinding.sales.text.toString().toIntOrNull() ?: 0)
                        addProperty("otherIncome", dialogAddReportBinding.otherIncome.text.toString().toIntOrNull() ?: 0)
                        addProperty("wages", dialogAddReportBinding.personnel.text.toString().toIntOrNull() ?: 0)
                        addProperty("otherExpenses", dialogAddReportBinding.nonPersonnel.text.toString().toIntOrNull() ?: 0)
                        addProperty("startDate", startTimeStamp?.toLongOrNull() ?: 0L)
                        addProperty("endDate", endTimeStamp?.toLongOrNull() ?: 0L)
                        addProperty("updatedDate", System.currentTimeMillis())
                        addProperty("teamId", teamId)
                        addProperty("teamType", team?.teamType)
                        addProperty("teamPlanetCode", team?.teamPlanetCode)
                        addProperty("docType", "report")
                        addProperty("updated", true)
                    }
                    viewLifecycleOwner.lifecycleScope.launch {
                        teamRepository.addReport(doc)
                    }
                    dialog.dismiss()
                }
            }

            cancel.setOnClickListener { dialog.dismiss() }
        }

        binding.exportCSV.setOnClickListener {
            val currentDate = Date()
            val dateFormat = SimpleDateFormat("EEE_MMM_dd_yyyy", Locale.US)
            val formattedDate = dateFormat.format(currentDate)
            val teamName = prefData.getTeamName()?.replace(" ", "_")

            val intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply {
                addCategory(Intent.CATEGORY_OPENABLE)
                type = "text/csv"
                putExtra(Intent.EXTRA_TITLE, "Report_of_${teamName}_Financial_Report_Summary_on_${formattedDate}")
            }
            createFileLauncher.launch(intent)
        }

        list = mRealm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("docType", "report")
            .notEqualTo("status", "archived")
            .sort("createdDate", Sort.DESCENDING)
            .findAllAsync()

        list?.addChangeListener { results ->
            updatedReportsList(results)
        }

        createFileLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == Activity.RESULT_OK) {
                val uri = result.data?.data
                if (uri != null) {
                    try {
                        val reports = mRealm.where(RealmMyTeam::class.java)
                            .equalTo("teamId", teamId)
                            .equalTo("docType", "report")
                            .notEqualTo("status", "archived")
                            .sort("createdDate", Sort.DESCENDING)
                            .findAll()
                        val csvBuilder = StringBuilder()
                        csvBuilder.append("${prefData.getTeamName()} Financial Report Summary\n\n")
                        csvBuilder.append("Start Date, End Date, Created Date, Updated Date, Beginning Balance, Sales, Other Income, Wages, Other Expenses, Profit/Loss, Ending Balance\n")
                        for (report in reports) {
                            val dateFormat = SimpleDateFormat("EEE MMM dd yyyy HH:mm:ss 'GMT'Z (z)", Locale.US)
                            val totalIncome = report.sales + report.otherIncome
                            val totalExpenses = report.wages + report.otherExpenses
                            val profitLoss = totalIncome - totalExpenses
                            val endingBalance = profitLoss + report.beginningBalance
                            csvBuilder.append("${dateFormat.format(report.startDate)}, ${dateFormat.format(report.endDate)}, ${dateFormat.format(report.createdDate)}, ${dateFormat.format(report.updatedDate)}, ${report.beginningBalance}, ${report.sales}, ${report.otherIncome}, ${report.wages}, ${report.otherExpenses}, $profitLoss, $endingBalance\n")
                        }

                        requireContext().contentResolver.openOutputStream(uri)?.use { outputStream ->
                            outputStream.write("$csvBuilder".toByteArray())
                        }
                        Utilities.toast(requireContext(), getString(R.string.csv_file_saved_successfully))
                    } catch (e: IOException) {
                        e.printStackTrace()
                        Utilities.toast(requireContext(), getString(R.string.failed_to_save_csv_file))
                    }
                } else {
                    Utilities.toast(requireContext(), getString(R.string.export_cancelled))
                }
            }
        }
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        adapterReports = AdapterReports(requireContext(), teamRepository, viewLifecycleOwner.lifecycleScope)
        binding.rvReports.adapter = adapterReports
        binding.rvReports.layoutManager = LinearLayoutManager(activity)

        list = mRealm.where(RealmMyTeam::class.java)
            .equalTo("teamId", teamId)
            .equalTo("docType", "report")
            .notEqualTo("status", "archived")
            .sort("createdDate", Sort.DESCENDING)
            .findAll()
        updatedReportsList(list as RealmResults<RealmMyTeam>)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                isMemberFlow.collectLatest { isMember ->
                    binding.addReports.isVisible = isMember
                    adapterReports.setNonTeamMember(!isMember)
                }
            }
        }
    }

    override fun onNewsItemClick(news: RealmNews?) {}

    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    fun updatedReportsList(results: RealmResults<RealmMyTeam>) {
        if (_binding == null) return

        val immutableResults = results.let { mRealm.copyFromRealm(it) }
        adapterReports.submitList(immutableResults)

        if (results.isEmpty()) {
            binding.exportCSV.visibility = View.GONE
            BaseRecyclerFragment.showNoData(binding.tvMessage, results.count(), "reports")
        } else {
            binding.exportCSV.visibility = View.VISIBLE
        }
    }

    override fun onDestroyView() {
        list?.removeAllChangeListeners()
        list = null
        if (isRealmInitialized()) {
            mRealm.close()
        }
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/ui/enterprises/FinanceFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.ui.enterprises

import android.content.DialogInterface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.DatePicker
import androidx.appcompat.app.AlertDialog
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AddTransactionBinding
import org.ole.planet.myplanet.databinding.FragmentFinanceBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.utilities.TimeUtils.formatDateTZ
import org.ole.planet.myplanet.utilities.Utilities

class FinanceFragment : BaseTeamFragment() {
    private var _binding: FragmentFinanceBinding? = null
    private val binding get() = _binding!!
    private lateinit var addTransactionBinding: AddTransactionBinding
    private lateinit var adapterFinance: AdapterFinance
    var date: Calendar? = null
    private var transactions: List<RealmMyTeam> = emptyList()
    private var isAsc = false
    private var transactionsJob: Job? = null
    private var currentStartDate: Long? = null
    private var currentEndDate: Long? = null

    var listener =
        android.app.DatePickerDialog.OnDateSetListener { _: DatePicker?, year: Int, monthOfYear: Int, dayOfMonth: Int ->
            date = Calendar.getInstance()
            date?.set(Calendar.YEAR, year)
            date?.set(Calendar.MONTH, monthOfYear)
            date?.set(Calendar.DAY_OF_MONTH, dayOfMonth)
            if (date != null) {
                addTransactionBinding.tvSelectDate.text = date?.timeInMillis?.let { formatDateTZ(it) }
            }
        }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentFinanceBinding.inflate(inflater, container, false)
        date = Calendar.getInstance()
        updateToDateState(false)
        binding.tvFromDateCalendar.setOnClickListener {
            showDatePickerDialog(isFromDate = true)
        }

        binding.tvFromDateCalendarIcon.setOnClickListener {
            showDatePickerDialog(isFromDate = true)
        }

        binding.etToDate.setOnClickListener {
            if (binding.tvFromDateCalendar.text.toString().isNotEmpty()) {
                showDatePickerDialog(isFromDate = false)
            }
        }

        binding.tvToDateCalendarIcon.setOnClickListener {
            if (binding.tvFromDateCalendar.text.toString().isNotEmpty()) {
                showDatePickerDialog(isFromDate = false)
            }
        }


        binding.llDate.setOnClickListener {
            binding.imgDate.rotation += 180
            val newSort = !isAsc
            isAsc = newSort
            observeTransactions(sortAscending = newSort)
        }
        binding.btnReset.setOnClickListener {
            binding.tvFromDateCalendar.setText("")
            binding.etToDate.setText("")
            updateToDateState(false)
            currentStartDate = null
            currentEndDate = null
            isAsc = false
            binding.imgDate.rotation = 0f
            observeTransactions(sortAscending = isAsc, startDate = null, endDate = null)
        }
        return binding.root
    }

    private fun showDatePickerDialog(isFromDate: Boolean) {
        val now = Calendar.getInstance().apply {
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
        }
        val datePickerDialog = android.app.DatePickerDialog(
            requireContext(),
            { _, year, monthOfYear, dayOfMonth ->
                val selectedDate = Calendar.getInstance().apply {
                    set(year, monthOfYear, dayOfMonth)
                }
                val formattedDate = selectedDate.formatToString("yyyy-MM-dd")

                if (isFromDate) {
                    binding.tvFromDateCalendar.setText(formattedDate)
                    val toDateText = binding.etToDate.text.toString()
                    if (toDateText.isNotEmpty()) {
                        val fromDateMillis = selectedDate.timeInMillis
                        val toDateMillis = parseDate(toDateText)?.timeInMillis
                        if (toDateMillis != null && toDateMillis < fromDateMillis) {
                            binding.etToDate.setText("")
                        }
                    }
                    updateToDateState(true)
                } else {
                    binding.etToDate.setText(formattedDate)
                }

                filterIfBothDatesSelected()
            },
            now[Calendar.YEAR],
            now[Calendar.MONTH],
            now[Calendar.DAY_OF_MONTH]
        )

        if (!isFromDate) {
            val fromDateText = binding.tvFromDateCalendar.text.toString()
            if (fromDateText.isNotEmpty()) {
                val fromDate = parseDate(fromDateText)
                if (fromDate != null) {
                    datePickerDialog.datePicker.minDate = fromDate.timeInMillis
                }
            }
        }
        datePickerDialog.show()
    }


    private fun Calendar.formatToString(pattern: String): String {
        val dateFormat = SimpleDateFormat(pattern, Locale.getDefault())
        return dateFormat.format(this.time)
    }

    private fun updateToDateState(enabled: Boolean) {
        binding.etToDate.isEnabled = enabled
        binding.tvToDateCalendarIcon.isEnabled = enabled
        binding.etToDate.alpha = if (enabled) 1.0f else 0.5f
        binding.tvToDateCalendarIcon.alpha = if (enabled) 1.0f else 0.5f
    }

    private fun parseDate(dateString: String): Calendar? {
        return try {
            val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
            val date = dateFormat.parse(dateString)
            if (date != null) {
                Calendar.getInstance().apply {
                    time = date
                }
            } else {
                null
            }
        } catch (e: ParseException) {
            null
        }
    }


    private fun filterIfBothDatesSelected() {
        val fromDate = binding.tvFromDateCalendar.text.toString()
        val toDate = binding.etToDate.text.toString()
        if (fromDate.isNotEmpty() && toDate.isNotEmpty()) {
            filterDataByDateRange(fromDate, toDate)
        }
    }


    private fun filterDataByDateRange(fromDate: String, toDate: String) {
        try {
            val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())

            val start = dateFormat.parse(fromDate)?.time ?: throw IllegalArgumentException("Invalid fromDate format")
            val end = dateFormat.parse(toDate)?.time ?: throw IllegalArgumentException("Invalid toDate format")
            currentStartDate = start
            currentEndDate = end
            observeTransactions()

        } catch (e: ParseException) {
            e.printStackTrace()
        } catch (e: IllegalArgumentException) {
            e.printStackTrace()
        }
    }


    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        if (user?.isManager() == true || user?.isLeader() == true) {
            binding.addTransaction.visibility = View.VISIBLE
        } else {
            binding.addTransaction.visibility = View.GONE
        }
        binding.addTransaction.setOnClickListener { addTransaction() }
        adapterFinance = AdapterFinance(requireActivity())
        binding.rvFinance.layoutManager = LinearLayoutManager(activity)
        binding.rvFinance.adapter = adapterFinance
        observeTransactions()
    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun calculateTotal(list: List<RealmMyTeam>) {
        var debit = 0
        var credit = 0
        for (team in list) {
            if ("credit".equals(team.type?.lowercase(Locale.getDefault()), ignoreCase = true)) {
                credit += team.amount
            } else {
                debit += team.amount
            }
        }
        val total = credit - debit
        binding.tvDebit.text = getString(R.string.number_placeholder, debit)
        binding.tvCredit.text = getString(R.string.number_placeholder, credit)
        binding.tvBalance.text = getString(R.string.number_placeholder, total)
        if (total >= 0) binding.balanceCaution.visibility = View.GONE
    }

    private fun addTransaction() {
        AlertDialog.Builder(requireActivity()).setView(setUpAlertUi()).setTitle(R.string.add_transaction)
            .setPositiveButton("Submit") { _: DialogInterface?, _: Int ->
                val type = addTransactionBinding.spnType.selectedItem.toString()
                val note = "${addTransactionBinding.tlNote.editText?.text}".trim { it <= ' ' }
                val amount = "${addTransactionBinding.tlAmount.editText?.text}".trim { it <= ' ' }
                if (note.isEmpty()) {
                    Utilities.toast(activity, getString(R.string.note_is_required))
                } else if (amount.isEmpty()) {
                    Utilities.toast(activity, getString(R.string.amount_is_required))
                } else if (date == null) {
                    Utilities.toast(activity, getString(R.string.date_is_required))
                } else {
                    val amountValue = amount.toIntOrNull()
                    if (amountValue == null) {
                        Utilities.toast(activity, getString(R.string.amount_is_required))
                        return@setPositiveButton
                    }
                    viewLifecycleOwner.lifecycleScope.launch {
                        val result = teamRepository.createTransaction(
                            teamId = teamId,
                            type = type,
                            note = note,
                            amount = amountValue,
                            date = date!!.timeInMillis,
                            parentCode = user?.parentCode,
                            planetCode = user?.planetCode,
                        )
                        if (result.isSuccess) {
                            Utilities.toast(activity, getString(R.string.transaction_added))
                        } else {
                            val errorMessage = result.exceptionOrNull()?.localizedMessage
                                ?: getString(R.string.no_data_available_please_check_and_try_again)
                            Utilities.toast(activity, errorMessage)
                        }
                    }
                }
            }.setNegativeButton("Cancel", null).show()
    }

    private fun setUpAlertUi(): View {
        addTransactionBinding = AddTransactionBinding.inflate(LayoutInflater.from(activity))
        addTransactionBinding.tvSelectDate.setOnClickListener {
            android.app.DatePickerDialog(requireActivity(), listener, date!![Calendar.YEAR], date!![Calendar.MONTH], date!![Calendar.DAY_OF_MONTH]).show()
        }
        return addTransactionBinding.root
    }

    private fun mapTransactionsToPresentationModel(transactions: List<RealmMyTeam>): List<TransactionData> {
        val transactionDataList = mutableListOf<TransactionData>()
        var balance = 0
        for (team in transactions.filter { it._id != null }) {
            balance += if ("debit".equals(team.type, ignoreCase = true)) {
                -team.amount
            } else {
                team.amount
            }
            transactionDataList.add(
                TransactionData(
                    id = team._id!!,
                    date = team.date,
                    description = team.description,
                    type = team.type,
                    amount = team.amount,
                    balance = balance
                )
            )
        }
        return transactionDataList
    }

    private fun updatedFinanceList(results: List<RealmMyTeam>) {
        if (view == null) return

        val transactionData = mapTransactionsToPresentationModel(results)
        adapterFinance.submitList(transactionData)
        calculateTotal(results)

        if (results.isNotEmpty()) {
            binding.dataLayout.visibility = View.VISIBLE
            binding.tvNodata.visibility = View.GONE
            binding.rvFinance.visibility = View.VISIBLE
        } else if (binding.tvFromDateCalendar.text.isNullOrEmpty() && binding.etToDate.text.isNullOrEmpty()) {
            binding.dataLayout.visibility = View.GONE
            binding.tvNodata.visibility = View.VISIBLE
            binding.rvFinance.visibility = View.GONE
        } else {
            binding.dataLayout.visibility = View.VISIBLE
            binding.tvNodata.visibility = View.VISIBLE
            binding.rvFinance.visibility = View.GONE
        }
    }

    override fun onDestroyView() {
        transactionsJob?.cancel()
        transactionsJob = null
        transactions = emptyList()
        _binding = null
        super.onDestroyView()
    }

    private fun observeTransactions(
        sortAscending: Boolean = isAsc,
        startDate: Long? = currentStartDate,
        endDate: Long? = currentEndDate,
    ) {
        transactionsJob?.cancel()
        transactionsJob = viewLifecycleOwner.lifecycleScope.launch {
            teamRepository.getTeamTransactions(
                teamId = teamId,
                startDate = startDate,
                endDate = endDate,
                sortAscending = sortAscending,
            ).collectLatest { results ->
                transactions = results
                updatedFinanceList(results)
                showNoData(binding.tvNodata, transactions.size, "finances")
            }
        }
    }
}
=======
package org.ole.planet.myplanet.ui.enterprises


import android.content.DialogInterface
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.DatePicker
import androidx.appcompat.app.AlertDialog
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.AddTransactionBinding
import org.ole.planet.myplanet.databinding.FragmentFinanceBinding
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.ui.team.BaseTeamFragment
import org.ole.planet.myplanet.utilities.TimeUtils.formatDateTZ
import org.ole.planet.myplanet.utilities.Utilities

class FinanceFragment : BaseTeamFragment() {
    private var _binding: FragmentFinanceBinding? = null
    private val binding get() = _binding!!
    private lateinit var addTransactionBinding: AddTransactionBinding
    private lateinit var adapterFinance: AdapterFinance
    var date: Calendar? = null
    private var transactions: List<RealmMyTeam> = emptyList()
    private var isAsc = false
    private var transactionsJob: Job? = null
    private var currentStartDate: Long? = null
    private var currentEndDate: Long? = null

    var listener =
        android.app.DatePickerDialog.OnDateSetListener { _: DatePicker?, year: Int, monthOfYear: Int, dayOfMonth: Int ->
            date = Calendar.getInstance()
            date?.set(Calendar.YEAR, year)
            date?.set(Calendar.MONTH, monthOfYear)
            date?.set(Calendar.DAY_OF_MONTH, dayOfMonth)
            if (date != null) {
                addTransactionBinding.tvSelectDate.text = date?.timeInMillis?.let { formatDateTZ(it) }
            }
        }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentFinanceBinding.inflate(inflater, container, false)
        date = Calendar.getInstance()
        updateToDateState(false)
        binding.tvFromDateCalendar.setOnClickListener {
            showDatePickerDialog(isFromDate = true)
        }

        binding.tvFromDateCalendarIcon.setOnClickListener {
            showDatePickerDialog(isFromDate = true)
        }

        binding.etToDate.setOnClickListener {
            if (binding.tvFromDateCalendar.text.toString().isNotEmpty()) {
                showDatePickerDialog(isFromDate = false)
            }
        }

        binding.tvToDateCalendarIcon.setOnClickListener {
            if (binding.tvFromDateCalendar.text.toString().isNotEmpty()) {
                showDatePickerDialog(isFromDate = false)
            }
        }


        binding.llDate.setOnClickListener {
            binding.imgDate.rotation += 180
            val newSort = !isAsc
            isAsc = newSort
            observeTransactions(sortAscending = newSort)
        }
        binding.btnReset.setOnClickListener {
            binding.tvFromDateCalendar.setText("")
            binding.etToDate.setText("")
            updateToDateState(false)
            currentStartDate = null
            currentEndDate = null
            isAsc = false
            binding.imgDate.rotation = 0f
            observeTransactions(sortAscending = isAsc, startDate = null, endDate = null)
        }
        return binding.root
    }

    private fun showDatePickerDialog(isFromDate: Boolean) {
        val now = Calendar.getInstance().apply {
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
        }
        val datePickerDialog = android.app.DatePickerDialog(
            requireContext(),
            { _, year, monthOfYear, dayOfMonth ->
                val selectedDate = Calendar.getInstance().apply {
                    set(year, monthOfYear, dayOfMonth)
                }
                val formattedDate = selectedDate.formatToString("yyyy-MM-dd")

                if (isFromDate) {
                    binding.tvFromDateCalendar.setText(formattedDate)
                    val toDateText = binding.etToDate.text.toString()
                    if (toDateText.isNotEmpty()) {
                        val fromDateMillis = selectedDate.timeInMillis
                        val toDateMillis = parseDate(toDateText)?.timeInMillis
                        if (toDateMillis != null && toDateMillis < fromDateMillis) {
                            binding.etToDate.setText("")
                        }
                    }
                    updateToDateState(true)
                } else {
                    binding.etToDate.setText(formattedDate)
                }

                filterIfBothDatesSelected()
            },
            now[Calendar.YEAR],
            now[Calendar.MONTH],
            now[Calendar.DAY_OF_MONTH]
        )

        if (!isFromDate) {
            val fromDateText = binding.tvFromDateCalendar.text.toString()
            if (fromDateText.isNotEmpty()) {
                val fromDate = parseDate(fromDateText)
                if (fromDate != null) {
                    datePickerDialog.datePicker.minDate = fromDate.timeInMillis
                }
            }
        }
        datePickerDialog.show()
    }


    private fun Calendar.formatToString(pattern: String): String {
        val dateFormat = SimpleDateFormat(pattern, Locale.getDefault())
        return dateFormat.format(this.time)
    }

    private fun updateToDateState(enabled: Boolean) {
        binding.etToDate.isEnabled = enabled
        binding.tvToDateCalendarIcon.isEnabled = enabled
        binding.etToDate.alpha = if (enabled) 1.0f else 0.5f
        binding.tvToDateCalendarIcon.alpha = if (enabled) 1.0f else 0.5f
    }

    private fun parseDate(dateString: String): Calendar? {
        return try {
            val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
            val date = dateFormat.parse(dateString)
            if (date != null) {
                Calendar.getInstance().apply {
                    time = date
                }
            } else {
                null
            }
        } catch (e: ParseException) {
            null
        }
    }


    private fun filterIfBothDatesSelected() {
        val fromDate = binding.tvFromDateCalendar.text.toString()
        val toDate = binding.etToDate.text.toString()
        if (fromDate.isNotEmpty() && toDate.isNotEmpty()) {
            filterDataByDateRange(fromDate, toDate)
        }
    }


    private fun filterDataByDateRange(fromDate: String, toDate: String) {
        try {
            val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())

            val start = dateFormat.parse(fromDate)?.time ?: throw IllegalArgumentException("Invalid fromDate format")
            val end = dateFormat.parse(toDate)?.time ?: throw IllegalArgumentException("Invalid toDate format")
            currentStartDate = start
            currentEndDate = end
            observeTransactions()

        } catch (e: ParseException) {
            e.printStackTrace()
        } catch (e: IllegalArgumentException) {
            e.printStackTrace()
        }
    }


    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        if (user?.isManager() == true || user?.isLeader() == true) {
            binding.addTransaction.visibility = View.VISIBLE
        } else {
            binding.addTransaction.visibility = View.GONE
        }
        binding.addTransaction.setOnClickListener { addTransaction() }
        adapterFinance = AdapterFinance(requireActivity())
        binding.rvFinance.layoutManager = LinearLayoutManager(activity)
        binding.rvFinance.adapter = adapterFinance
        observeTransactions()
    }

    override fun onNewsItemClick(news: RealmNews?) {}
    override fun clearImages() {
        imageList.clear()
        llImage?.removeAllViews()
    }

    private fun calculateTotal(list: List<RealmMyTeam>) {
        var debit = 0
        var credit = 0
        for (team in list) {
            if ("credit".equals(team.type?.lowercase(Locale.getDefault()), ignoreCase = true)) {
                credit += team.amount
            } else {
                debit += team.amount
            }
        }
        val total = credit - debit
        binding.tvDebit.text = getString(R.string.number_placeholder, debit)
        binding.tvCredit.text = getString(R.string.number_placeholder, credit)
        binding.tvBalance.text = getString(R.string.number_placeholder, total)
        if (total >= 0) binding.balanceCaution.visibility = View.GONE
    }

    private fun addTransaction() {
        AlertDialog.Builder(requireActivity()).setView(setUpAlertUi()).setTitle(R.string.add_transaction)
            .setPositiveButton("Submit") { _: DialogInterface?, _: Int ->
                val type = addTransactionBinding.spnType.selectedItem.toString()
                val note = "${addTransactionBinding.tlNote.editText?.text}".trim { it <= ' ' }
                val amount = "${addTransactionBinding.tlAmount.editText?.text}".trim { it <= ' ' }
                if (note.isEmpty()) {
                    Utilities.toast(activity, getString(R.string.note_is_required))
                } else if (amount.isEmpty()) {
                    Utilities.toast(activity, getString(R.string.amount_is_required))
                } else if (date == null) {
                    Utilities.toast(activity, getString(R.string.date_is_required))
                } else {
                    val amountValue = amount.toIntOrNull()
                    if (amountValue == null) {
                        Utilities.toast(activity, getString(R.string.amount_is_required))
                        return@setPositiveButton
                    }
                    viewLifecycleOwner.lifecycleScope.launch {
                        val result = teamRepository.createTransaction(
                            teamId = teamId,
                            type = type,
                            note = note,
                            amount = amountValue,
                            date = date!!.timeInMillis,
                            parentCode = user?.parentCode,
                            planetCode = user?.planetCode,
                        )
                        if (result.isSuccess) {
                            Utilities.toast(activity, getString(R.string.transaction_added))
                        } else {
                            val errorMessage = result.exceptionOrNull()?.localizedMessage
                                ?: getString(R.string.no_data_available_please_check_and_try_again)
                            Utilities.toast(activity, errorMessage)
                        }
                    }
                }
            }.setNegativeButton("Cancel", null).show()
    }

    private fun setUpAlertUi(): View {
        addTransactionBinding = AddTransactionBinding.inflate(LayoutInflater.from(activity))
        addTransactionBinding.tvSelectDate.setOnClickListener {
            android.app.DatePickerDialog(requireActivity(), listener, date!![Calendar.YEAR], date!![Calendar.MONTH], date!![Calendar.DAY_OF_MONTH]).show()
        }
        return addTransactionBinding.root
    }

    private fun mapTransactionsToPresentationModel(transactions: List<RealmMyTeam>): List<TransactionData> {
        val transactionDataList = mutableListOf<TransactionData>()
        var balance = 0
        for (team in transactions.filter { it._id != null }) {
            balance += if ("debit".equals(team.type, ignoreCase = true)) {
                -team.amount
            } else {
                team.amount
            }
            transactionDataList.add(
                TransactionData(
                    id = team._id!!,
                    date = team.date,
                    description = team.description,
                    type = team.type,
                    amount = team.amount,
                    balance = balance
                )
            )
        }
        return transactionDataList
    }

    private fun updatedFinanceList(results: List<RealmMyTeam>) {
        if (view == null) return

        val transactionData = mapTransactionsToPresentationModel(results)
        adapterFinance.submitList(transactionData)
        calculateTotal(results)

        if (results.isNotEmpty()) {
            binding.dataLayout.visibility = View.VISIBLE
            binding.tvNodata.visibility = View.GONE
            binding.rvFinance.visibility = View.VISIBLE
        } else if (binding.tvFromDateCalendar.text.isNullOrEmpty() && binding.etToDate.text.isNullOrEmpty()) {
            binding.dataLayout.visibility = View.GONE
            binding.tvNodata.visibility = View.VISIBLE
            binding.rvFinance.visibility = View.GONE
        } else {
            binding.dataLayout.visibility = View.VISIBLE
            binding.tvNodata.visibility = View.VISIBLE
            binding.rvFinance.visibility = View.GONE
        }
    }

    override fun onDestroyView() {
        transactionsJob?.cancel()
        transactionsJob = null
        transactions = emptyList()
        _binding = null
        super.onDestroyView()
    }

    private fun observeTransactions(
        sortAscending: Boolean = isAsc,
        startDate: Long? = currentStartDate,
        endDate: Long? = currentEndDate,
    ) {
        transactionsJob?.cancel()
        transactionsJob = viewLifecycleOwner.lifecycleScope.launch {
            teamRepository.getTeamTransactions(
                teamId = teamId,
                startDate = startDate,
                endDate = endDate,
                sortAscending = sortAscending,
            ).collectLatest { results ->
                transactions = results
                updatedFinanceList(results)
                showNoData(binding.tvNodata, transactions.size, "finances")
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/di/ApiClientEntryPoint.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.di

import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import org.ole.planet.myplanet.datamanager.ApiClient

@EntryPoint
@InstallIn(SingletonComponent::class)
interface ApiClientEntryPoint {
    fun apiClient(): ApiClient
}
=======
package org.ole.planet.myplanet.di


import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import org.ole.planet.myplanet.datamanager.ApiClient

@EntryPoint
@InstallIn(SingletonComponent::class)
interface ApiClientEntryPoint {
    fun apiClient(): ApiClient
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/di/ServiceEntryPoint.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.di

import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import kotlinx.coroutines.CoroutineScope

@EntryPoint
@InstallIn(SingletonComponent::class)
interface ServiceEntryPoint {
    @ApplicationScope
    fun applicationScope(): CoroutineScope
}
=======
package org.ole.planet.myplanet.di


import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import kotlinx.coroutines.CoroutineScope

@EntryPoint
@InstallIn(SingletonComponent::class)
interface ServiceEntryPoint {
    @ApplicationScope
    fun applicationScope(): CoroutineScope
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/di/ApiInterfaceEntryPoint.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.di

import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import org.ole.planet.myplanet.datamanager.ApiInterface

@EntryPoint
@InstallIn(SingletonComponent::class)
interface ApiInterfaceEntryPoint {
    fun apiInterface(): ApiInterface
}
=======
package org.ole.planet.myplanet.di


import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import org.ole.planet.myplanet.datamanager.ApiInterface

@EntryPoint
@InstallIn(SingletonComponent::class)
interface ApiInterfaceEntryPoint {
    fun apiInterface(): ApiInterface
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/di/RepositoryModule.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.di

import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton
import org.ole.planet.myplanet.repository.ChatRepository
import org.ole.planet.myplanet.repository.ChatRepositoryImpl
import org.ole.planet.myplanet.repository.CourseRepository
import org.ole.planet.myplanet.repository.CourseRepositoryImpl
import org.ole.planet.myplanet.repository.FeedbackRepository
import org.ole.planet.myplanet.repository.FeedbackRepositoryImpl
import org.ole.planet.myplanet.repository.LibraryRepository
import org.ole.planet.myplanet.repository.LibraryRepositoryImpl
import org.ole.planet.myplanet.repository.MeetupRepository
import org.ole.planet.myplanet.repository.MeetupRepositoryImpl
import org.ole.planet.myplanet.repository.MyPersonalRepository
import org.ole.planet.myplanet.repository.MyPersonalRepositoryImpl
import org.ole.planet.myplanet.repository.NewsRepository
import org.ole.planet.myplanet.repository.NewsRepositoryImpl
import org.ole.planet.myplanet.repository.NotificationRepository
import org.ole.planet.myplanet.repository.NotificationRepositoryImpl
import org.ole.planet.myplanet.repository.RatingRepository
import org.ole.planet.myplanet.repository.RatingRepositoryImpl
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.SubmissionRepositoryImpl
import org.ole.planet.myplanet.repository.SurveyRepository
import org.ole.planet.myplanet.repository.SurveyRepositoryImpl
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.repository.TagRepositoryImpl
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.repository.TeamRepositoryImpl
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.repository.UserRepositoryImpl

@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {

    @Binds
    @Singleton
    abstract fun bindChatRepository(impl: ChatRepositoryImpl): ChatRepository

    @Binds
    @Singleton
    abstract fun bindCourseRepository(impl: CourseRepositoryImpl): CourseRepository

    @Binds
    @Singleton
    abstract fun bindFeedbackRepository(impl: FeedbackRepositoryImpl): FeedbackRepository

    @Binds
    @Singleton
    abstract fun bindLibraryRepository(impl: LibraryRepositoryImpl): LibraryRepository

    @Binds
    @Singleton
    abstract fun bindMeetupRepository(impl: MeetupRepositoryImpl): MeetupRepository

    @Binds
    @Singleton
    abstract fun bindMyPersonalRepository(impl: MyPersonalRepositoryImpl): MyPersonalRepository

    @Binds
    @Singleton
    abstract fun bindNewsRepository(impl: NewsRepositoryImpl): NewsRepository

    @Binds
    @Singleton
    abstract fun bindNotificationRepository(impl: NotificationRepositoryImpl): NotificationRepository

    @Binds
    @Singleton
    abstract fun bindRatingRepository(impl: RatingRepositoryImpl): RatingRepository

    @Binds
    @Singleton
    abstract fun bindSubmissionRepository(impl: SubmissionRepositoryImpl): SubmissionRepository

    @Binds
    @Singleton
    abstract fun bindSurveyRepository(impl: SurveyRepositoryImpl): SurveyRepository

    @Binds
    @Singleton
    abstract fun bindTagRepository(impl: TagRepositoryImpl): TagRepository

    @Binds
    @Singleton
    abstract fun bindTeamRepository(impl: TeamRepositoryImpl): TeamRepository

    @Binds
    @Singleton
    abstract fun bindUserRepository(impl: UserRepositoryImpl): UserRepository
}
=======
package org.ole.planet.myplanet.di


import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton
import org.ole.planet.myplanet.repository.ChatRepository
import org.ole.planet.myplanet.repository.ChatRepositoryImpl
import org.ole.planet.myplanet.repository.CourseRepository
import org.ole.planet.myplanet.repository.CourseRepositoryImpl
import org.ole.planet.myplanet.repository.FeedbackRepository
import org.ole.planet.myplanet.repository.FeedbackRepositoryImpl
import org.ole.planet.myplanet.repository.LibraryRepository
import org.ole.planet.myplanet.repository.LibraryRepositoryImpl
import org.ole.planet.myplanet.repository.MeetupRepository
import org.ole.planet.myplanet.repository.MeetupRepositoryImpl
import org.ole.planet.myplanet.repository.MyPersonalRepository
import org.ole.planet.myplanet.repository.MyPersonalRepositoryImpl
import org.ole.planet.myplanet.repository.NewsRepository
import org.ole.planet.myplanet.repository.NewsRepositoryImpl
import org.ole.planet.myplanet.repository.NotificationRepository
import org.ole.planet.myplanet.repository.NotificationRepositoryImpl
import org.ole.planet.myplanet.repository.RatingRepository
import org.ole.planet.myplanet.repository.RatingRepositoryImpl
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.SubmissionRepositoryImpl
import org.ole.planet.myplanet.repository.SurveyRepository
import org.ole.planet.myplanet.repository.SurveyRepositoryImpl
import org.ole.planet.myplanet.repository.TagRepository
import org.ole.planet.myplanet.repository.TagRepositoryImpl
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.repository.TeamRepositoryImpl
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.repository.UserRepositoryImpl

@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {

    @Binds
    @Singleton
    abstract fun bindChatRepository(impl: ChatRepositoryImpl): ChatRepository

    @Binds
    @Singleton
    abstract fun bindCourseRepository(impl: CourseRepositoryImpl): CourseRepository

    @Binds
    @Singleton
    abstract fun bindFeedbackRepository(impl: FeedbackRepositoryImpl): FeedbackRepository

    @Binds
    @Singleton
    abstract fun bindLibraryRepository(impl: LibraryRepositoryImpl): LibraryRepository

    @Binds
    @Singleton
    abstract fun bindMeetupRepository(impl: MeetupRepositoryImpl): MeetupRepository

    @Binds
    @Singleton
    abstract fun bindMyPersonalRepository(impl: MyPersonalRepositoryImpl): MyPersonalRepository

    @Binds
    @Singleton
    abstract fun bindNewsRepository(impl: NewsRepositoryImpl): NewsRepository

    @Binds
    @Singleton
    abstract fun bindNotificationRepository(impl: NotificationRepositoryImpl): NotificationRepository

    @Binds
    @Singleton
    abstract fun bindRatingRepository(impl: RatingRepositoryImpl): RatingRepository

    @Binds
    @Singleton
    abstract fun bindSubmissionRepository(impl: SubmissionRepositoryImpl): SubmissionRepository

    @Binds
    @Singleton
    abstract fun bindSurveyRepository(impl: SurveyRepositoryImpl): SurveyRepository

    @Binds
    @Singleton
    abstract fun bindTagRepository(impl: TagRepositoryImpl): TagRepository

    @Binds
    @Singleton
    abstract fun bindTeamRepository(impl: TeamRepositoryImpl): TeamRepository

    @Binds
    @Singleton
    abstract fun bindUserRepository(impl: UserRepositoryImpl): UserRepository
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/di/SharedPreferencesModule.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.di

import android.content.Context
import android.content.SharedPreferences
import androidx.preference.PreferenceManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class AppPreferences

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class DefaultPreferences

@Module
@InstallIn(SingletonComponent::class)
object SharedPreferencesModule {

    @Provides
    @Singleton
    @AppPreferences
    fun provideAppSharedPreferences(@ApplicationContext context: Context): SharedPreferences {
        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    }

    @Provides
    @Singleton
    @DefaultPreferences
    fun provideDefaultSharedPreferences(@ApplicationContext context: Context): SharedPreferences {
        return PreferenceManager.getDefaultSharedPreferences(context)
    }
}
=======
package org.ole.planet.myplanet.di


import android.content.Context
import android.content.SharedPreferences
import androidx.preference.PreferenceManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class AppPreferences

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class DefaultPreferences

@Module
@InstallIn(SingletonComponent::class)
object SharedPreferencesModule {

    @Provides
    @Singleton
    @AppPreferences
    fun provideAppSharedPreferences(@ApplicationContext context: Context): SharedPreferences {
        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    }

    @Provides
    @Singleton
    @DefaultPreferences
    fun provideDefaultSharedPreferences(@ApplicationContext context: Context): SharedPreferences {
        return PreferenceManager.getDefaultSharedPreferences(context)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/di/WorkerDependenciesEntryPoint.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.di

import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UserProfileDbHandler

@EntryPoint
@InstallIn(SingletonComponent::class)
interface WorkerDependenciesEntryPoint {
    fun databaseService(): DatabaseService
    fun userProfileDbHandler(): UserProfileDbHandler
    fun uploadManager(): UploadManager
    fun teamRepository(): TeamRepository
    fun submissionRepository(): SubmissionRepository
}
=======
package org.ole.planet.myplanet.di


import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.TeamRepository
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UserProfileDbHandler

@EntryPoint
@InstallIn(SingletonComponent::class)
interface WorkerDependenciesEntryPoint {
    fun databaseService(): DatabaseService
    fun userProfileDbHandler(): UserProfileDbHandler
    fun uploadManager(): UploadManager
    fun teamRepository(): TeamRepository
    fun submissionRepository(): SubmissionRepository
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/di/AutoSyncEntryPoint.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.di

import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UploadToShelfService

@EntryPoint
@InstallIn(SingletonComponent::class)
interface AutoSyncEntryPoint {
    fun syncManager(): SyncManager
    fun uploadManager(): UploadManager
    fun uploadToShelfService(): UploadToShelfService
}
=======
package org.ole.planet.myplanet.di


import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UploadToShelfService

@EntryPoint
@InstallIn(SingletonComponent::class)
interface AutoSyncEntryPoint {
    fun syncManager(): SyncManager
    fun uploadManager(): UploadManager
    fun uploadToShelfService(): UploadToShelfService
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/di/ApplicationScopeEntryPoint.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.di

import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import kotlinx.coroutines.CoroutineScope

@EntryPoint
@InstallIn(SingletonComponent::class)
interface ApplicationScopeEntryPoint {
    @ApplicationScope
    fun applicationScope(): CoroutineScope
}
=======
package org.ole.planet.myplanet.di


import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import kotlinx.coroutines.CoroutineScope

@EntryPoint
@InstallIn(SingletonComponent::class)
interface ApplicationScopeEntryPoint {
    @ApplicationScope
    fun applicationScope(): CoroutineScope
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/di/DatabaseModule.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.di

import android.content.Context
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton
import org.ole.planet.myplanet.datamanager.DatabaseService

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Provides
    @Singleton
    fun provideDatabaseService(@ApplicationContext context: Context): DatabaseService {
        return DatabaseService(context)
    }

    // Realm initialization is handled in DatabaseService
}
=======
package org.ole.planet.myplanet.di


import android.content.Context
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton
import org.ole.planet.myplanet.datamanager.DatabaseService

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Provides
    @Singleton
    fun provideDatabaseService(@ApplicationContext context: Context): DatabaseService {
        return DatabaseService(context)
    }

    // Realm initialization is handled in DatabaseService
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/di/NetworkModule.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.di

import com.google.gson.Gson
import com.google.gson.GsonBuilder
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import java.lang.reflect.Modifier
import java.util.concurrent.TimeUnit
import javax.inject.Qualifier
import javax.inject.Singleton
import okhttp3.OkHttpClient
import org.ole.planet.myplanet.datamanager.ApiClient
import org.ole.planet.myplanet.datamanager.ApiInterface
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class StandardHttpClient

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class StandardRetrofit

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    @Provides
    @Singleton
    fun provideGson(): Gson {
        return GsonBuilder()
            .excludeFieldsWithModifiers(Modifier.FINAL, Modifier.TRANSIENT, Modifier.STATIC)
            .serializeNulls()
            .create()
    }

    private fun buildOkHttpClient(connect: Long, read: Long, write: Long): OkHttpClient {
        return OkHttpClient.Builder()
            .connectTimeout(connect, TimeUnit.SECONDS)
            .readTimeout(read, TimeUnit.SECONDS)
            .writeTimeout(write, TimeUnit.SECONDS)
            .build()
    }

    @Provides
    @Singleton
    @StandardHttpClient
    fun provideStandardOkHttpClient(): OkHttpClient {
        return buildOkHttpClient(10, 10, 10)
    }

    @Provides
    @Singleton
    @StandardRetrofit
    fun provideStandardRetrofit(
        @StandardHttpClient okHttpClient: OkHttpClient,
        gson: Gson
    ): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://vi.media.mit.edu/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create(gson))
            .build()
    }

    @Provides
    @Singleton
    fun provideApiInterface(@StandardRetrofit retrofit: Retrofit): ApiInterface {
        return retrofit.create(ApiInterface::class.java)
    }

    @Provides
    @Singleton
    fun provideApiClient(
        @StandardRetrofit retrofit: Retrofit,
    ): ApiClient {
        ApiClient.client = retrofit
        return ApiClient
    }
}
=======
package org.ole.planet.myplanet.di


import com.google.gson.Gson
import com.google.gson.GsonBuilder
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import java.lang.reflect.Modifier
import java.util.concurrent.TimeUnit
import javax.inject.Qualifier
import javax.inject.Singleton
import okhttp3.OkHttpClient
import org.ole.planet.myplanet.datamanager.ApiClient
import org.ole.planet.myplanet.datamanager.ApiInterface
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class StandardHttpClient

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class StandardRetrofit

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    @Provides
    @Singleton
    fun provideGson(): Gson {
        return GsonBuilder()
            .excludeFieldsWithModifiers(Modifier.FINAL, Modifier.TRANSIENT, Modifier.STATIC)
            .serializeNulls()
            .create()
    }

    private fun buildOkHttpClient(connect: Long, read: Long, write: Long): OkHttpClient {
        return OkHttpClient.Builder()
            .connectTimeout(connect, TimeUnit.SECONDS)
            .readTimeout(read, TimeUnit.SECONDS)
            .writeTimeout(write, TimeUnit.SECONDS)
            .build()
    }

    @Provides
    @Singleton
    @StandardHttpClient
    fun provideStandardOkHttpClient(): OkHttpClient {
        return buildOkHttpClient(10, 10, 10)
    }

    @Provides
    @Singleton
    @StandardRetrofit
    fun provideStandardRetrofit(
        @StandardHttpClient okHttpClient: OkHttpClient,
        gson: Gson
    ): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://vi.media.mit.edu/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create(gson))
            .build()
    }

    @Provides
    @Singleton
    fun provideApiInterface(@StandardRetrofit retrofit: Retrofit): ApiInterface {
        return retrofit.create(ApiInterface::class.java)
    }

    @Provides
    @Singleton
    fun provideApiClient(
        @StandardRetrofit retrofit: Retrofit,
    ): ApiClient {
        ApiClient.client = retrofit
        return ApiClient
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/di/ServiceModule.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.di

import android.content.Context
import android.content.SharedPreferences
import com.google.gson.Gson
import dagger.Lazy
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.service.ImprovedSyncManager
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UploadToShelfService

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class ApplicationScope

@Module
@InstallIn(SingletonComponent::class)
object ServiceModule {

    @Provides
    @Singleton
    @ApplicationScope
    fun provideApplicationScope(): CoroutineScope {
        return CoroutineScope(SupervisorJob() + Dispatchers.IO)
    }

    @Provides
    @Singleton
    fun provideSyncManager(
        @ApplicationContext context: Context,
        databaseService: DatabaseService,
        @AppPreferences preferences: SharedPreferences,
        apiInterface: ApiInterface,
        improvedSyncManager: Lazy<ImprovedSyncManager>,
        @ApplicationScope scope: CoroutineScope
    ): SyncManager {
        return SyncManager(context, databaseService, preferences, apiInterface, improvedSyncManager, scope)
    }

    @Provides
    @Singleton
    fun provideUploadManager(
        @ApplicationContext context: Context,
        databaseService: DatabaseService,
        @AppPreferences preferences: SharedPreferences,
        gson: Gson
    ): UploadManager {
        return UploadManager(context, databaseService, preferences, gson)
    }

    @Provides
    @Singleton
    fun provideUploadToShelfService(
        @ApplicationContext context: Context,
        databaseService: DatabaseService,
        @AppPreferences preferences: SharedPreferences
    ): UploadToShelfService {
        return UploadToShelfService(context, databaseService, preferences)
    }
}
=======
package org.ole.planet.myplanet.di


import android.content.Context
import android.content.SharedPreferences
import com.google.gson.Gson
import dagger.Lazy
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Qualifier
import javax.inject.Singleton
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.service.ImprovedSyncManager
import org.ole.planet.myplanet.service.SyncManager
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UploadToShelfService

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class ApplicationScope

@Module
@InstallIn(SingletonComponent::class)
object ServiceModule {

    @Provides
    @Singleton
    @ApplicationScope
    fun provideApplicationScope(): CoroutineScope {
        return CoroutineScope(SupervisorJob() + Dispatchers.IO)
    }

    @Provides
    @Singleton
    fun provideSyncManager(
        @ApplicationContext context: Context,
        databaseService: DatabaseService,
        @AppPreferences preferences: SharedPreferences,
        apiInterface: ApiInterface,
        improvedSyncManager: Lazy<ImprovedSyncManager>,
        @ApplicationScope scope: CoroutineScope
    ): SyncManager {
        return SyncManager(context, databaseService, preferences, apiInterface, improvedSyncManager, scope)
    }

    @Provides
    @Singleton
    fun provideUploadManager(
        @ApplicationContext context: Context,
        databaseService: DatabaseService,
        @AppPreferences preferences: SharedPreferences,
        gson: Gson
    ): UploadManager {
        return UploadManager(context, databaseService, preferences, gson)
    }

    @Provides
    @Singleton
    fun provideUploadToShelfService(
        @ApplicationContext context: Context,
        databaseService: DatabaseService,
        @AppPreferences preferences: SharedPreferences
    ): UploadToShelfService {
        return UploadToShelfService(context, databaseService, preferences)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmAnswer.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmAnswer : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var value: String? = null
    var valueChoices: RealmList<String>? = null
    var mistakes = 0
    var isPassed = false
    var grade = 0
    var examId: String? = null
    var questionId: String? = null
    var submissionId: String? = null
    val valueChoicesArray: JsonArray
        get() {
            val array = JsonArray()
            if (valueChoices == null) {
                return array
            }
            for (choice in valueChoices ?: emptyList()) {
                array.add(Gson().fromJson(choice, JsonObject::class.java))
            }
            return array
        }

    companion object {
        @JvmStatic
        fun serializeRealmAnswer(answers: RealmList<RealmAnswer>): JsonArray {
            val array = JsonArray()
            for (ans in answers) {
                array.add(createObject(ans))
            }
            return array
        }

        private fun createObject(ans: RealmAnswer): JsonObject {
            val `object` = JsonObject()
            if (!TextUtils.isEmpty(ans.value)) {
                `object`.addProperty("value", ans.value)
            } else {
                `object`.add("value", ans.valueChoicesArray)
            }
            `object`.addProperty("mistakes", ans.mistakes)
            `object`.addProperty("passed", ans.isPassed)

            if (!TextUtils.isEmpty(ans.questionId)) {
                `object`.addProperty("questionId", ans.questionId)
            }
            return `object`
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmAnswer : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var value: String? = null
    var valueChoices: RealmList<String>? = null
    var mistakes = 0
    var isPassed = false
    var grade = 0
    var examId: String? = null
    var questionId: String? = null
    var submissionId: String? = null
    val valueChoicesArray: JsonArray
        get() {
            val array = JsonArray()
            if (valueChoices == null) {
                return array
            }
            for (choice in valueChoices ?: emptyList()) {
                array.add(Gson().fromJson(choice, JsonObject::class.java))
            }
            return array
        }

    companion object {
        @JvmStatic
        fun serializeRealmAnswer(answers: RealmList<RealmAnswer>): JsonArray {
            val array = JsonArray()
            for (ans in answers) {
                array.add(createObject(ans))
            }
            return array
        }

        private fun createObject(ans: RealmAnswer): JsonObject {
            val `object` = JsonObject()
            if (!TextUtils.isEmpty(ans.value)) {
                `object`.addProperty("value", ans.value)
            } else {
                `object`.add("value", ans.valueChoicesArray)
            }
            `object`.addProperty("mistakes", ans.mistakes)
            `object`.addProperty("passed", ans.isPassed)

            if (!TextUtils.isEmpty(ans.questionId)) {
                `object`.addProperty("questionId", ans.questionId)
            }
            return `object`
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmCommunity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmCommunity : RealmObject() {
    @PrimaryKey
    var id: String = ""
    var weight: Int = 10
    var registrationRequest: String = ""
    var localDomain: String = ""
    var name: String = ""
    var parentDomain: String = ""

    override fun toString(): String {
        return name
    }
}
=======
package org.ole.planet.myplanet.model


import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmCommunity : RealmObject() {
    @PrimaryKey
    var id: String = ""
    var weight: Int = 10
    var registrationRequest: String = ""
    var localDomain: String = ""
    var name: String = ""
    var parentDomain: String = ""

    override fun toString(): String {
        return name
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmTeamNotification.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmTeamNotification : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var type: String? = null
    var parentId: String? = null
    var lastCount = 0
}
=======
package org.ole.planet.myplanet.model


import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmTeamNotification : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var type: String? = null
    var parentId: String? = null
    var lastCount = 0
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmCourseStep.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmCourseStep : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var courseId: String? = null
    var stepTitle: String? = null
    var description: String? = null
    var noOfResources: Int? = null
}
=======
package org.ole.planet.myplanet.model


import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmCourseStep : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var courseId: String? = null
    var stepTitle: String? = null
    var description: String? = null
    var noOfResources: Int? = null
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmFeedback.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import com.google.gson.stream.JsonReader
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.io.StringReader
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmFeedback : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var title: String? = null
    var source: String? = null
    var status: String? = null
    var priority: String? = null
    var owner: String? = null
    var openTime: Long = 0
    var type: String? = null
    var url: String? = null
    var isUploaded = false
    var _rev: String? = null
    var messages: String? = null
        private set
    var item: String? = null
    var parentCode: String? = null
    var state: String? = null
    fun setMessages(messages: JsonArray?) {
        this.messages = Gson().toJson(messages)
    }

    val messageList: List<FeedbackReply>?
        get() {
            if (TextUtils.isEmpty(messages)) return null
            val feedbackReplies: MutableList<FeedbackReply> = ArrayList()

            val stringReader = StringReader(messages)
            val jsonReader = JsonReader(stringReader)

            val e = JsonParser.parseReader(jsonReader)
            val ar = e.asJsonArray
            if (ar.size() > 0) {
                for (i in 1 until ar.size()) {
                    val ob = ar[i].asJsonObject
                    feedbackReplies.add(
                        FeedbackReply(
                            ob["message"].asString,
                            ob["user"].asString,
                            ob["time"].asString
                        )
                    )
                }
            }
            return feedbackReplies
        }

    val message: String
        get() {
            if (TextUtils.isEmpty(messages)) return ""

            val stringReader = StringReader(messages)
            val jsonReader = JsonReader(stringReader)

            val e = JsonParser.parseReader(jsonReader)
            val ar = e.asJsonArray
            if (ar.size() > 0) {
                val ob = ar[0].asJsonObject
                return ob["message"].asString
            }
            return ""
        }

    fun setMessages(messages: String?) {
        this.messages = messages
    }

    companion object {
        @JvmStatic
        fun serializeFeedback(feedback: RealmFeedback): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("title", feedback.title)
            `object`.addProperty("source", feedback.source)
            `object`.addProperty("status", feedback.status)
            `object`.addProperty("priority", feedback.priority)
            `object`.addProperty("owner", feedback.owner)
            `object`.addProperty("openTime", feedback.openTime)
            `object`.addProperty("type", feedback.type)
            `object`.addProperty("url", feedback.url)
            `object`.addProperty("parentCode", feedback.parentCode)
            `object`.addProperty("state", feedback.state)
            `object`.addProperty("item", feedback.item)
            if (feedback._id != null) `object`.addProperty("_id", feedback._id)
            if (feedback._rev != null) `object`.addProperty("_rev", feedback._rev)

            try {
                `object`.add("messages", JsonParser.parseString(feedback.messages))
            } catch (err: Exception) {
                err.printStackTrace()
            }
            return `object`
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var feedback = mRealm.where(RealmFeedback::class.java)
                .equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (feedback == null) {
                feedback = mRealm.createObject(RealmFeedback::class.java, JsonUtils.getString("_id", act))
            }
            feedback?._id = JsonUtils.getString("_id", act)
            feedback?.title = JsonUtils.getString("title", act)
            feedback?.source = JsonUtils.getString("source", act)
            feedback?.status = JsonUtils.getString("status", act)
            feedback?.priority = JsonUtils.getString("priority", act)
            feedback?.owner = JsonUtils.getString("owner", act)
            feedback?.openTime = JsonUtils.getLong("openTime", act)
            feedback?.type = JsonUtils.getString("type", act)
            feedback?.url = JsonUtils.getString("url", act)
            feedback?.parentCode = JsonUtils.getString("parentCode", act)
            feedback?.setMessages(Gson().toJson(JsonUtils.getJsonArray("messages", act)))
            feedback?.isUploaded = true
            feedback?.item = JsonUtils.getString("item", act)
            feedback?.state = JsonUtils.getString("state", act)
            feedback?._rev = JsonUtils.getString("_rev", act)
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import com.google.gson.stream.JsonReader
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.io.StringReader
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmFeedback : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var title: String? = null
    var source: String? = null
    var status: String? = null
    var priority: String? = null
    var owner: String? = null
    var openTime: Long = 0
    var type: String? = null
    var url: String? = null
    var isUploaded = false
    var _rev: String? = null
    var messages: String? = null
        private set
    var item: String? = null
    var parentCode: String? = null
    var state: String? = null
    fun setMessages(messages: JsonArray?) {
        this.messages = Gson().toJson(messages)
    }

    val messageList: List<FeedbackReply>?
        get() {
            if (TextUtils.isEmpty(messages)) return null
            val feedbackReplies: MutableList<FeedbackReply> = ArrayList()

            val stringReader = StringReader(messages)
            val jsonReader = JsonReader(stringReader)

            val e = JsonParser.parseReader(jsonReader)
            val ar = e.asJsonArray
            if (ar.size() > 0) {
                for (i in 1 until ar.size()) {
                    val ob = ar[i].asJsonObject
                    feedbackReplies.add(
                        FeedbackReply(
                            ob["message"].asString,
                            ob["user"].asString,
                            ob["time"].asString
                        )
                    )
                }
            }
            return feedbackReplies
        }

    val message: String
        get() {
            if (TextUtils.isEmpty(messages)) return ""

            val stringReader = StringReader(messages)
            val jsonReader = JsonReader(stringReader)

            val e = JsonParser.parseReader(jsonReader)
            val ar = e.asJsonArray
            if (ar.size() > 0) {
                val ob = ar[0].asJsonObject
                return ob["message"].asString
            }
            return ""
        }

    fun setMessages(messages: String?) {
        this.messages = messages
    }

    companion object {
        @JvmStatic
        fun serializeFeedback(feedback: RealmFeedback): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("title", feedback.title)
            `object`.addProperty("source", feedback.source)
            `object`.addProperty("status", feedback.status)
            `object`.addProperty("priority", feedback.priority)
            `object`.addProperty("owner", feedback.owner)
            `object`.addProperty("openTime", feedback.openTime)
            `object`.addProperty("type", feedback.type)
            `object`.addProperty("url", feedback.url)
            `object`.addProperty("parentCode", feedback.parentCode)
            `object`.addProperty("state", feedback.state)
            `object`.addProperty("item", feedback.item)
            if (feedback._id != null) `object`.addProperty("_id", feedback._id)
            if (feedback._rev != null) `object`.addProperty("_rev", feedback._rev)

            try {
                `object`.add("messages", JsonParser.parseString(feedback.messages))
            } catch (err: Exception) {
                err.printStackTrace()
            }
            return `object`
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var feedback = mRealm.where(RealmFeedback::class.java)
                .equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (feedback == null) {
                feedback = mRealm.createObject(RealmFeedback::class.java, JsonUtils.getString("_id", act))
            }
            feedback?._id = JsonUtils.getString("_id", act)
            feedback?.title = JsonUtils.getString("title", act)
            feedback?.source = JsonUtils.getString("source", act)
            feedback?.status = JsonUtils.getString("status", act)
            feedback?.priority = JsonUtils.getString("priority", act)
            feedback?.owner = JsonUtils.getString("owner", act)
            feedback?.openTime = JsonUtils.getLong("openTime", act)
            feedback?.type = JsonUtils.getString("type", act)
            feedback?.url = JsonUtils.getString("url", act)
            feedback?.parentCode = JsonUtils.getString("parentCode", act)
            feedback?.setMessages(Gson().toJson(JsonUtils.getJsonArray("messages", act)))
            feedback?.isUploaded = true
            feedback?.item = JsonUtils.getString("item", act)
            feedback?.state = JsonUtils.getString("state", act)
            feedback?._rev = JsonUtils.getString("_rev", act)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmCourseActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmCourseActivity : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var createdOn: String? = null
    var _rev: String? = null
    var time: Long = 0
    var title: String? = null
    var courseId: String? = null
    var parentCode: String? = null
    var type: String? = null
    var user: String? = null

    companion object {
        @JvmStatic
        suspend fun createActivity(realm: Realm, userModel: RealmUserModel?, course: RealmMyCourse?) {
            try {
                if (!realm.isInTransaction) {
                    realm.executeTransaction { realmInstance ->
                        val activity = realmInstance.createObject(RealmCourseActivity::class.java, UUID.randomUUID().toString())
                        activity.type = "visit"
                        activity.title = course?.courseTitle
                        activity.courseId = course?.courseId
                        activity.time = Date().time
                        activity.parentCode = userModel?.parentCode
                        activity.createdOn = userModel?.planetCode
                        activity.user = userModel?.name
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        @JvmStatic
        fun serializeSerialize(realmCourseActivities: RealmCourseActivity): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", realmCourseActivities.user)
            ob.addProperty("courseId", realmCourseActivities.courseId)
            ob.addProperty("type", realmCourseActivities.type)
            ob.addProperty("title", realmCourseActivities.title)
            ob.addProperty("time", realmCourseActivities.time)
            ob.addProperty("createdOn", realmCourseActivities.createdOn)
            ob.addProperty("parentCode", realmCourseActivities.parentCode)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            return ob
        }
    }
}
=======
package org.ole.planet.myplanet.model


import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmCourseActivity : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var createdOn: String? = null
    var _rev: String? = null
    var time: Long = 0
    var title: String? = null
    var courseId: String? = null
    var parentCode: String? = null
    var type: String? = null
    var user: String? = null

    companion object {
        @JvmStatic
        suspend fun createActivity(realm: Realm, userModel: RealmUserModel?, course: RealmMyCourse?) {
            try {
                if (!realm.isInTransaction) {
                    realm.executeTransaction { realmInstance ->
                        val activity = realmInstance.createObject(RealmCourseActivity::class.java, UUID.randomUUID().toString())
                        activity.type = "visit"
                        activity.title = course?.courseTitle
                        activity.courseId = course?.courseId
                        activity.time = Date().time
                        activity.parentCode = userModel?.parentCode
                        activity.createdOn = userModel?.planetCode
                        activity.user = userModel?.name
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        @JvmStatic
        fun serializeSerialize(realmCourseActivities: RealmCourseActivity): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", realmCourseActivities.user)
            ob.addProperty("courseId", realmCourseActivities.courseId)
            ob.addProperty("type", realmCourseActivities.type)
            ob.addProperty("title", realmCourseActivities.title)
            ob.addProperty("time", realmCourseActivities.time)
            ob.addProperty("createdOn", realmCourseActivities.createdOn)
            ob.addProperty("parentCode", realmCourseActivities.parentCode)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            return ob
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmMyTeam.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.SharedPreferences
import com.google.gson.Gson
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.RealmResults
import io.realm.annotations.PrimaryKey
import java.util.Date
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.utilities.AndroidDecrypter
import org.ole.planet.myplanet.utilities.DownloadUtils.extractLinks
import org.ole.planet.myplanet.utilities.DownloadUtils.openDownloadService
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.UrlUtils.getUrl

open class RealmMyTeam : RealmObject() {
    @PrimaryKey
    var _id: String? = null
    var _rev: String? = null
    var courses: RealmList<String>? = null
    var teamId: String? = null
    var name: String? = null
    var userId: String? = null
    var description: String? = null
    var requests: String? = null
    var sourcePlanet: String? = null
    var limit = 0
    var createdDate: Long = 0
    var resourceId: String? = null
    var status: String? = null
    var teamType: String? = null
    var teamPlanetCode: String? = null
    var userPlanetCode: String? = null
    var parentCode: String? = null
    var docType: String? = null
    var title: String? = null
    var route: String? = null
    var services: String? = null
    var createdBy: String? = null
    var rules: String? = null
    var isLeader = false
    var type: String? = null
    var amount = 0
    var date: Long = 0
    var isPublic = false
    var updated = false
    var beginningBalance = 0
    var sales = 0
    var otherIncome = 0
    var wages = 0
    var otherExpenses = 0
    var startDate: Long = 0
    var endDate: Long = 0
    var updatedDate: Long = 0

    companion object {
        private val concatenatedLinks = ArrayList<String>()

        @JvmStatic
        fun populateTeamFields(doc: JsonObject, team: RealmMyTeam, includeCourses: Boolean = false) {
            team.userId = JsonUtils.getString("userId", doc)
            team.teamId = JsonUtils.getString("teamId", doc)
            team._rev = JsonUtils.getString("_rev", doc)
            team.name = JsonUtils.getString("name", doc)
            team.sourcePlanet = JsonUtils.getString("sourcePlanet", doc)
            team.title = JsonUtils.getString("title", doc)
            team.description = JsonUtils.getString("description", doc)
            team.limit = JsonUtils.getInt("limit", doc)
            team.status = JsonUtils.getString("status", doc)
            team.teamPlanetCode = JsonUtils.getString("teamPlanetCode", doc)
            team.createdDate = JsonUtils.getLong("createdDate", doc)
            team.resourceId = JsonUtils.getString("resourceId", doc)
            team.teamType = JsonUtils.getString("teamType", doc)
            team.route = JsonUtils.getString("route", doc)
            team.type = JsonUtils.getString("type", doc)
            team.services = JsonUtils.getString("services", doc)
            team.rules = JsonUtils.getString("rules", doc)
            team.parentCode = JsonUtils.getString("parentCode", doc)
            team.createdBy = JsonUtils.getString("createdBy", doc)
            team.userPlanetCode = JsonUtils.getString("userPlanetCode", doc)
            team.isLeader = JsonUtils.getBoolean("isLeader", doc)
            team.amount = JsonUtils.getInt("amount", doc)
            team.date = JsonUtils.getLong("date", doc)
            team.docType = JsonUtils.getString("docType", doc)
            team.isPublic = JsonUtils.getBoolean("public", doc)
            team.beginningBalance = JsonUtils.getInt("beginningBalance", doc)
            team.sales = JsonUtils.getInt("sales", doc)
            team.otherIncome = JsonUtils.getInt("otherIncome", doc)
            team.wages = JsonUtils.getInt("wages", doc)
            team.otherExpenses = JsonUtils.getInt("otherExpenses", doc)
            team.startDate = JsonUtils.getLong("startDate", doc)
            team.endDate = JsonUtils.getLong("endDate", doc)
            team.updatedDate = JsonUtils.getLong("updatedDate", doc)
            team.updated = JsonUtils.getBoolean("updated", doc)

            if (includeCourses) {
                val coursesArray = JsonUtils.getJsonArray("courses", doc)
                team.courses = RealmList()
                for (e in coursesArray) {
                    val id = e.asJsonObject["_id"].asString
                    if (!team.courses!!.contains(id)) {
                        team.courses!!.add(id)
                    }
                }
            }
        }

        private fun processDescription(description: String?) {
            val links = extractLinks(description ?: "")
            val baseUrl = getUrl()
            for (link in links) {
                val concatenatedLink = "$baseUrl/$link"
                concatenatedLinks.add(concatenatedLink)
            }
            openDownloadService(context, concatenatedLinks, true)
        }

        @JvmStatic
        fun populateReportFields(doc: JsonObject, team: RealmMyTeam) {
            team.description = JsonUtils.getString("description", doc)
            team.beginningBalance = JsonUtils.getInt("beginningBalance", doc)
            team.sales = JsonUtils.getInt("sales", doc)
            team.otherIncome = JsonUtils.getInt("otherIncome", doc)
            team.wages = JsonUtils.getInt("wages", doc)
            team.otherExpenses = JsonUtils.getInt("otherExpenses", doc)
            team.startDate = JsonUtils.getLong("startDate", doc)
            team.endDate = JsonUtils.getLong("endDate", doc)
            team.updatedDate = JsonUtils.getLong("updatedDate", doc)
            team.updated = JsonUtils.getBoolean("updated", doc)
        }

        @JvmStatic
        fun insertMyTeams(doc: JsonObject, mRealm: Realm) {
            val status = JsonUtils.getString("status", doc)
            if (status == "archived") {
                return
            }

            val teamId = JsonUtils.getString("_id", doc)
            var myTeams = mRealm.where(RealmMyTeam::class.java).equalTo("_id", teamId).findFirst()
            if (myTeams == null) {
                myTeams = mRealm.createObject(RealmMyTeam::class.java, teamId)
            }
            myTeams?.let {
                populateTeamFields(doc, it, true)
                processDescription(it.description)
            }
        }

        @JvmStatic
        fun getResourceIds(teamId: String?, realm: Realm): MutableList<String> {
            val teams = realm.where(RealmMyTeam::class.java).equalTo("teamId", teamId).findAll()
            val ids = mutableListOf<String>()
            for (team in teams) {
                if (!team.resourceId.isNullOrBlank()) {
                    ids.add(team.resourceId!!)
                }
            }
            return ids
        }

        @JvmStatic
        fun getResourceIdsByUser(userId: String?, realm: Realm): MutableList<String> {
            val list = realm.where(RealmMyTeam::class.java)
                .equalTo("userId", userId)
                .equalTo("docType", "membership")
                .findAll()
            val teamIds = mutableListOf<String>()
            for (team in list) {
                if (!team.teamId.isNullOrBlank()) {
                    teamIds.add(team.teamId!!)
                }
            }
            val l2 = realm.where(RealmMyTeam::class.java)
                .`in`("teamId", teamIds.toTypedArray())
                .equalTo("docType", "resourceLink")
                .findAll()
            val ids = mutableListOf<String>()
            for (team in l2) {
                if (!team.resourceId.isNullOrBlank()) {
                    ids.add(team.resourceId!!)
                }
            }
            return ids
        }

        @JvmStatic
        fun getTeamCreator(teamId: String?, realm: Realm?): String {
            val teams = realm?.where(RealmMyTeam::class.java)?.equalTo("teamId", teamId)?.findFirst()
            return teams?.userId ?: ""
        }

        @JvmStatic
        fun insert(mRealm: Realm, doc: JsonObject) {
            insertMyTeams(doc, mRealm)
        }

        @JvmStatic
        suspend fun requestToJoin(teamId: String?, userId: String?, userPlanetCode: String?, teamType: String?) {
            withContext(Dispatchers.IO) {
                Realm.getDefaultInstance().use { realm ->
                    realm.executeTransaction {
                        val team = it.createObject(RealmMyTeam::class.java, AndroidDecrypter.generateIv())
                        team.docType = "request"
                        team.createdDate = Date().time
                        team.teamType = teamType
                        team.userId = userId
                        team.teamId = teamId
                        team.updated = true
                        team.teamPlanetCode = userPlanetCode
                        team.userPlanetCode = userPlanetCode
                    }
                }
            }
        }

        @JvmStatic
        fun getRequestedMember(teamId: String, realm: Realm): MutableList<RealmUserModel> {
            return getUsers(teamId, realm, "request")
        }

        @JvmStatic
        fun getJoinedMember(teamId: String, realm: Realm): MutableList<RealmUserModel> {
            return getUsers(teamId, realm, "membership")
        }

        @JvmStatic
        fun getJoinedMemberCount(teamId: String, realm: Realm): Int {
            return getUsers(teamId, realm, "membership").size
        }

        @JvmStatic
        fun isTeamLeader(teamId: String?, userId: String?, realm: Realm): Boolean {
            val team = realm.where(RealmMyTeam::class.java)
                .equalTo("teamId", teamId)
                .equalTo("docType", "membership")
                .equalTo("userId", userId)
                .equalTo("isLeader", true)
                .findFirst()
            return team != null
        }

        @JvmStatic
        fun getUsers(teamId: String?, mRealm: Realm, docType: String): MutableList<RealmUserModel> {
            var query = mRealm.where(RealmMyTeam::class.java).equalTo("teamId", teamId)
            if (docType.isNotEmpty()) {
                query = query.equalTo("docType", docType)
            }
            val myTeam = query.findAll()
            val list = mutableListOf<RealmUserModel>()
            for (team in myTeam) {
                val model = mRealm.where(RealmUserModel::class.java)
                    .equalTo("id", team.userId)
                    .findFirst()
                if (model != null && !list.contains(model)) list.add(model)
            }
            return list
        }

        @JvmStatic
        fun serialize(team: RealmMyTeam): JsonObject {
            val gson = Gson()
            val `object` = JsonObject()

            JsonUtils.addString(`object`, "_id", team._id)
            JsonUtils.addString(`object`, "_rev", team._rev)
            `object`.addProperty("name", team.name)
            `object`.addProperty("userId", team.userId)
            if (team.docType != "report" && team.docType != "request") {
                `object`.addProperty("limit", team.limit)
                `object`.addProperty("amount", team.amount)
                `object`.addProperty("date", team.date)
                `object`.addProperty("public", team.isPublic)
                `object`.addProperty("isLeader", team.isLeader)
            }
            if (team.docType != "request") {
                `object`.addProperty("createdDate", team.createdDate)
                `object`.addProperty("description", team.description)
                `object`.addProperty("beginningBalance", team.beginningBalance)
                `object`.addProperty("sales", team.sales)
                `object`.addProperty("otherIncome", team.otherIncome)
                `object`.addProperty("wages", team.wages)
                `object`.addProperty("otherExpenses", team.otherExpenses)
                `object`.addProperty("startDate", team.startDate)
                `object`.addProperty("endDate", team.endDate)
                `object`.addProperty("updatedDate", team.updatedDate)
            }
            JsonUtils.addString(`object`, "teamId", team.teamId)
            `object`.addProperty("teamType", team.teamType)
            `object`.addProperty("teamPlanetCode", team.teamPlanetCode)
            `object`.addProperty("docType", team.docType)
            `object`.addProperty("status", team.status)
            `object`.addProperty("userPlanetCode", team.userPlanetCode)
            `object`.addProperty("parentCode", team.parentCode)
            `object`.addProperty("type", team.type)
            `object`.addProperty("route", team.route)
            `object`.addProperty("sourcePlanet", team.sourcePlanet)
            `object`.addProperty("services", team.services)
            `object`.addProperty("createdBy", team.createdBy)
            `object`.addProperty("resourceId", team.resourceId)
            `object`.addProperty("rules", team.rules)

            if (team.teamType == "debit" || team.teamType == "credit") {
                `object`.addProperty("type", team.teamType)
            }

            return JsonParser.parseString(gson.toJson(`object`)).asJsonObject
        }

        fun getMyTeamsByUserId(mRealm: Realm, settings: SharedPreferences?): RealmResults<RealmMyTeam> {
            val userId = settings?.getString("userId", "--") ?: "--"
            val list = mRealm.where(RealmMyTeam::class.java)
                .equalTo("userId", userId)
                .equalTo("docType", "membership")
                .findAll()

            val teamIds = list.map { it.teamId }.toTypedArray()
            return mRealm.where(RealmMyTeam::class.java)
                .`in`("_id", teamIds)
                .notEqualTo("status", "archived")
                .findAll()
        }
    }

    fun requested(userId: String?, mRealm: Realm): Boolean {
        val m = mRealm.where(RealmMyTeam::class.java)
            .equalTo("docType", "request")
            .equalTo("teamId", _id)
            .equalTo("userId", userId)
            .findAll()

        return m.isNotEmpty()
    }

    fun isMyTeam(userID: String?, mRealm: Realm): Boolean {
        return mRealm.where(RealmMyTeam::class.java)
            .equalTo("userId", userID)
            .equalTo("teamId", _id)
            .equalTo("docType", "membership")
            .count() > 0
    }

    fun leave(user: RealmUserModel?, mRealm: Realm) {
        val teams = mRealm.where(RealmMyTeam::class.java)
            .equalTo("userId", user?.id)
            .equalTo("teamId", this._id)
            .equalTo("docType", "membership")
            .findAll()

        for (team in teams) {
            if (team != null) {
                removeTeam(team, mRealm)
            }
        }
    }

    private fun removeTeam(team: RealmMyTeam, mRealm: Realm) {
        if (!mRealm.isInTransaction) mRealm.beginTransaction()
        team.deleteFromRealm()
        mRealm.commitTransaction()
    }
}
=======
package org.ole.planet.myplanet.model


import android.content.SharedPreferences
import com.google.gson.Gson
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.RealmResults
import io.realm.annotations.PrimaryKey
import java.util.Date
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.utilities.AndroidDecrypter
import org.ole.planet.myplanet.utilities.DownloadUtils.extractLinks
import org.ole.planet.myplanet.utilities.DownloadUtils.openDownloadService
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.UrlUtils.getUrl

open class RealmMyTeam : RealmObject() {
    @PrimaryKey
    var _id: String? = null
    var _rev: String? = null
    var courses: RealmList<String>? = null
    var teamId: String? = null
    var name: String? = null
    var userId: String? = null
    var description: String? = null
    var requests: String? = null
    var sourcePlanet: String? = null
    var limit = 0
    var createdDate: Long = 0
    var resourceId: String? = null
    var status: String? = null
    var teamType: String? = null
    var teamPlanetCode: String? = null
    var userPlanetCode: String? = null
    var parentCode: String? = null
    var docType: String? = null
    var title: String? = null
    var route: String? = null
    var services: String? = null
    var createdBy: String? = null
    var rules: String? = null
    var isLeader = false
    var type: String? = null
    var amount = 0
    var date: Long = 0
    var isPublic = false
    var updated = false
    var beginningBalance = 0
    var sales = 0
    var otherIncome = 0
    var wages = 0
    var otherExpenses = 0
    var startDate: Long = 0
    var endDate: Long = 0
    var updatedDate: Long = 0

    companion object {
        private val concatenatedLinks = ArrayList<String>()

        @JvmStatic
        fun populateTeamFields(doc: JsonObject, team: RealmMyTeam, includeCourses: Boolean = false) {
            team.userId = JsonUtils.getString("userId", doc)
            team.teamId = JsonUtils.getString("teamId", doc)
            team._rev = JsonUtils.getString("_rev", doc)
            team.name = JsonUtils.getString("name", doc)
            team.sourcePlanet = JsonUtils.getString("sourcePlanet", doc)
            team.title = JsonUtils.getString("title", doc)
            team.description = JsonUtils.getString("description", doc)
            team.limit = JsonUtils.getInt("limit", doc)
            team.status = JsonUtils.getString("status", doc)
            team.teamPlanetCode = JsonUtils.getString("teamPlanetCode", doc)
            team.createdDate = JsonUtils.getLong("createdDate", doc)
            team.resourceId = JsonUtils.getString("resourceId", doc)
            team.teamType = JsonUtils.getString("teamType", doc)
            team.route = JsonUtils.getString("route", doc)
            team.type = JsonUtils.getString("type", doc)
            team.services = JsonUtils.getString("services", doc)
            team.rules = JsonUtils.getString("rules", doc)
            team.parentCode = JsonUtils.getString("parentCode", doc)
            team.createdBy = JsonUtils.getString("createdBy", doc)
            team.userPlanetCode = JsonUtils.getString("userPlanetCode", doc)
            team.isLeader = JsonUtils.getBoolean("isLeader", doc)
            team.amount = JsonUtils.getInt("amount", doc)
            team.date = JsonUtils.getLong("date", doc)
            team.docType = JsonUtils.getString("docType", doc)
            team.isPublic = JsonUtils.getBoolean("public", doc)
            team.beginningBalance = JsonUtils.getInt("beginningBalance", doc)
            team.sales = JsonUtils.getInt("sales", doc)
            team.otherIncome = JsonUtils.getInt("otherIncome", doc)
            team.wages = JsonUtils.getInt("wages", doc)
            team.otherExpenses = JsonUtils.getInt("otherExpenses", doc)
            team.startDate = JsonUtils.getLong("startDate", doc)
            team.endDate = JsonUtils.getLong("endDate", doc)
            team.updatedDate = JsonUtils.getLong("updatedDate", doc)
            team.updated = JsonUtils.getBoolean("updated", doc)

            if (includeCourses) {
                val coursesArray = JsonUtils.getJsonArray("courses", doc)
                team.courses = RealmList()
                for (e in coursesArray) {
                    val id = e.asJsonObject["_id"].asString
                    if (!team.courses!!.contains(id)) {
                        team.courses!!.add(id)
                    }
                }
            }
        }

        private fun processDescription(description: String?) {
            val links = extractLinks(description ?: "")
            val baseUrl = getUrl()
            for (link in links) {
                val concatenatedLink = "$baseUrl/$link"
                concatenatedLinks.add(concatenatedLink)
            }
            openDownloadService(context, concatenatedLinks, true)
        }

        @JvmStatic
        fun populateReportFields(doc: JsonObject, team: RealmMyTeam) {
            team.description = JsonUtils.getString("description", doc)
            team.beginningBalance = JsonUtils.getInt("beginningBalance", doc)
            team.sales = JsonUtils.getInt("sales", doc)
            team.otherIncome = JsonUtils.getInt("otherIncome", doc)
            team.wages = JsonUtils.getInt("wages", doc)
            team.otherExpenses = JsonUtils.getInt("otherExpenses", doc)
            team.startDate = JsonUtils.getLong("startDate", doc)
            team.endDate = JsonUtils.getLong("endDate", doc)
            team.updatedDate = JsonUtils.getLong("updatedDate", doc)
            team.updated = JsonUtils.getBoolean("updated", doc)
        }

        @JvmStatic
        fun insertMyTeams(doc: JsonObject, mRealm: Realm) {
            val status = JsonUtils.getString("status", doc)
            if (status == "archived") {
                return
            }

            val teamId = JsonUtils.getString("_id", doc)
            var myTeams = mRealm.where(RealmMyTeam::class.java).equalTo("_id", teamId).findFirst()
            if (myTeams == null) {
                myTeams = mRealm.createObject(RealmMyTeam::class.java, teamId)
            }
            myTeams?.let {
                populateTeamFields(doc, it, true)
                processDescription(it.description)
            }
        }

        @JvmStatic
        fun getResourceIds(teamId: String?, realm: Realm): MutableList<String> {
            val teams = realm.where(RealmMyTeam::class.java).equalTo("teamId", teamId).findAll()
            val ids = mutableListOf<String>()
            for (team in teams) {
                if (!team.resourceId.isNullOrBlank()) {
                    ids.add(team.resourceId!!)
                }
            }
            return ids
        }

        @JvmStatic
        fun getResourceIdsByUser(userId: String?, realm: Realm): MutableList<String> {
            val list = realm.where(RealmMyTeam::class.java)
                .equalTo("userId", userId)
                .equalTo("docType", "membership")
                .findAll()
            val teamIds = mutableListOf<String>()
            for (team in list) {
                if (!team.teamId.isNullOrBlank()) {
                    teamIds.add(team.teamId!!)
                }
            }
            val l2 = realm.where(RealmMyTeam::class.java)
                .`in`("teamId", teamIds.toTypedArray())
                .equalTo("docType", "resourceLink")
                .findAll()
            val ids = mutableListOf<String>()
            for (team in l2) {
                if (!team.resourceId.isNullOrBlank()) {
                    ids.add(team.resourceId!!)
                }
            }
            return ids
        }

        @JvmStatic
        fun getTeamCreator(teamId: String?, realm: Realm?): String {
            val teams = realm?.where(RealmMyTeam::class.java)?.equalTo("teamId", teamId)?.findFirst()
            return teams?.userId ?: ""
        }

        @JvmStatic
        fun insert(mRealm: Realm, doc: JsonObject) {
            insertMyTeams(doc, mRealm)
        }

        @JvmStatic
        suspend fun requestToJoin(teamId: String?, userId: String?, userPlanetCode: String?, teamType: String?) {
            withContext(Dispatchers.IO) {
                Realm.getDefaultInstance().use { realm ->
                    realm.executeTransaction {
                        val team = it.createObject(RealmMyTeam::class.java, AndroidDecrypter.generateIv())
                        team.docType = "request"
                        team.createdDate = Date().time
                        team.teamType = teamType
                        team.userId = userId
                        team.teamId = teamId
                        team.updated = true
                        team.teamPlanetCode = userPlanetCode
                        team.userPlanetCode = userPlanetCode
                    }
                }
            }
        }

        @JvmStatic
        fun getRequestedMember(teamId: String, realm: Realm): MutableList<RealmUserModel> {
            return getUsers(teamId, realm, "request")
        }

        @JvmStatic
        fun getJoinedMember(teamId: String, realm: Realm): MutableList<RealmUserModel> {
            return getUsers(teamId, realm, "membership")
        }

        @JvmStatic
        fun getJoinedMemberCount(teamId: String, realm: Realm): Int {
            return getUsers(teamId, realm, "membership").size
        }

        @JvmStatic
        fun isTeamLeader(teamId: String?, userId: String?, realm: Realm): Boolean {
            val team = realm.where(RealmMyTeam::class.java)
                .equalTo("teamId", teamId)
                .equalTo("docType", "membership")
                .equalTo("userId", userId)
                .equalTo("isLeader", true)
                .findFirst()
            return team != null
        }

        @JvmStatic
        fun getUsers(teamId: String?, mRealm: Realm, docType: String): MutableList<RealmUserModel> {
            var query = mRealm.where(RealmMyTeam::class.java).equalTo("teamId", teamId)
            if (docType.isNotEmpty()) {
                query = query.equalTo("docType", docType)
            }
            val myTeam = query.findAll()
            val list = mutableListOf<RealmUserModel>()
            for (team in myTeam) {
                val model = mRealm.where(RealmUserModel::class.java)
                    .equalTo("id", team.userId)
                    .findFirst()
                if (model != null && !list.contains(model)) list.add(model)
            }
            return list
        }

        @JvmStatic
        fun serialize(team: RealmMyTeam): JsonObject {
            val gson = Gson()
            val `object` = JsonObject()

            JsonUtils.addString(`object`, "_id", team._id)
            JsonUtils.addString(`object`, "_rev", team._rev)
            `object`.addProperty("name", team.name)
            `object`.addProperty("userId", team.userId)
            if (team.docType != "report" && team.docType != "request") {
                `object`.addProperty("limit", team.limit)
                `object`.addProperty("amount", team.amount)
                `object`.addProperty("date", team.date)
                `object`.addProperty("public", team.isPublic)
                `object`.addProperty("isLeader", team.isLeader)
            }
            if (team.docType != "request") {
                `object`.addProperty("createdDate", team.createdDate)
                `object`.addProperty("description", team.description)
                `object`.addProperty("beginningBalance", team.beginningBalance)
                `object`.addProperty("sales", team.sales)
                `object`.addProperty("otherIncome", team.otherIncome)
                `object`.addProperty("wages", team.wages)
                `object`.addProperty("otherExpenses", team.otherExpenses)
                `object`.addProperty("startDate", team.startDate)
                `object`.addProperty("endDate", team.endDate)
                `object`.addProperty("updatedDate", team.updatedDate)
            }
            JsonUtils.addString(`object`, "teamId", team.teamId)
            `object`.addProperty("teamType", team.teamType)
            `object`.addProperty("teamPlanetCode", team.teamPlanetCode)
            `object`.addProperty("docType", team.docType)
            `object`.addProperty("status", team.status)
            `object`.addProperty("userPlanetCode", team.userPlanetCode)
            `object`.addProperty("parentCode", team.parentCode)
            `object`.addProperty("type", team.type)
            `object`.addProperty("route", team.route)
            `object`.addProperty("sourcePlanet", team.sourcePlanet)
            `object`.addProperty("services", team.services)
            `object`.addProperty("createdBy", team.createdBy)
            `object`.addProperty("resourceId", team.resourceId)
            `object`.addProperty("rules", team.rules)

            if (team.teamType == "debit" || team.teamType == "credit") {
                `object`.addProperty("type", team.teamType)
            }

            return JsonParser.parseString(gson.toJson(`object`)).asJsonObject
        }

        fun getMyTeamsByUserId(mRealm: Realm, settings: SharedPreferences?): RealmResults<RealmMyTeam> {
            val userId = settings?.getString("userId", "--") ?: "--"
            val list = mRealm.where(RealmMyTeam::class.java)
                .equalTo("userId", userId)
                .equalTo("docType", "membership")
                .findAll()

            val teamIds = list.map { it.teamId }.toTypedArray()
            return mRealm.where(RealmMyTeam::class.java)
                .`in`("_id", teamIds)
                .notEqualTo("status", "archived")
                .findAll()
        }
    }

    fun requested(userId: String?, mRealm: Realm): Boolean {
        val m = mRealm.where(RealmMyTeam::class.java)
            .equalTo("docType", "request")
            .equalTo("teamId", _id)
            .equalTo("userId", userId)
            .findAll()

        return m.isNotEmpty()
    }

    fun isMyTeam(userID: String?, mRealm: Realm): Boolean {
        return mRealm.where(RealmMyTeam::class.java)
            .equalTo("userId", userID)
            .equalTo("teamId", _id)
            .equalTo("docType", "membership")
            .count() > 0
    }

    fun leave(user: RealmUserModel?, mRealm: Realm) {
        val teams = mRealm.where(RealmMyTeam::class.java)
            .equalTo("userId", user?.id)
            .equalTo("teamId", this._id)
            .equalTo("docType", "membership")
            .findAll()

        for (team in teams) {
            if (team != null) {
                removeTeam(team, mRealm)
            }
        }
    }

    private fun removeTeam(team: RealmMyTeam, mRealm: Realm) {
        if (!mRealm.isInTransaction) mRealm.beginTransaction()
        team.deleteFromRealm()
        mRealm.commitTransaction()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmMyCourse.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.Context.MODE_PRIVATE
import android.content.SharedPreferences
import android.text.TextUtils
import android.util.Base64
import androidx.core.content.edit
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.RealmResults
import io.realm.annotations.PrimaryKey
import io.realm.kotlin.where
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.createStepResource
import org.ole.planet.myplanet.model.RealmStepExam.Companion.insertCourseStepsExams
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DownloadUtils.extractLinks
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.UrlUtils

open class RealmMyCourse : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var userId: RealmList<String>? = null
        private set
    var courseId: String? = null
    var courseRev: String? = null
    var languageOfInstruction: String? = null
    var courseTitle: String? = null
    var memberLimit: Int? = null
    var description: String? = null
    var method: String? = null
    var gradeLevel: String? = null
    var subjectLevel: String? = null
    var createdDate: Long = 0
    private var numberOfSteps: Int? = null
    var courseSteps: RealmList<RealmCourseStep>? = null
    @Transient
    var isMyCourse: Boolean = false
    fun setUserId(userId: String?) {
        if (this.userId == null) {
            this.userId = RealmList()
        }
        if (!this.userId?.contains(userId)!! && !TextUtils.isEmpty(userId)) {
            this.userId?.add(userId)
        }
    }

    fun removeUserId(userId: String?) {
        this.userId?.remove(userId)
    }

    fun getNumberOfSteps(): Int {
        return numberOfSteps ?: 0
    }

    fun setNumberOfSteps(numberOfSteps: Int?) {
        this.numberOfSteps = numberOfSteps
    }

    override fun toString(): String {
        return courseTitle ?: ""
    }

    companion object {
        private val gson = Gson()
        private val concatenatedLinks = ArrayList<String>()

        @JvmStatic
        fun insertMyCourses(userId: String?, myCoursesDoc: JsonObject?, mRealm: Realm) {
            context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
            val id = JsonUtils.getString("_id", myCoursesDoc)
            var myMyCoursesDB = mRealm.where(RealmMyCourse::class.java).equalTo("id", id).findFirst()
            if (myMyCoursesDB == null) {
                myMyCoursesDB = mRealm.createObject(RealmMyCourse::class.java, id)
            }
            myMyCoursesDB?.setUserId(userId)
            myMyCoursesDB?.courseId = JsonUtils.getString("_id", myCoursesDoc)
            myMyCoursesDB?.courseRev = JsonUtils.getString("_rev", myCoursesDoc)
            myMyCoursesDB?.languageOfInstruction = JsonUtils.getString("languageOfInstruction", myCoursesDoc)
            myMyCoursesDB?.courseTitle = JsonUtils.getString("courseTitle", myCoursesDoc)
            myMyCoursesDB?.memberLimit = JsonUtils.getInt("memberLimit", myCoursesDoc)
            myMyCoursesDB?.description = JsonUtils.getString("description", myCoursesDoc)
            val description = JsonUtils.getString("description", myCoursesDoc)
            val links = extractLinks(description)
            val baseUrl = UrlUtils.getUrl()
            for (link in links) {
                val concatenatedLink = "$baseUrl/$link"
                concatenatedLinks.add(concatenatedLink)
            }
            myMyCoursesDB?.method = JsonUtils.getString("method", myCoursesDoc)
            myMyCoursesDB?.gradeLevel = JsonUtils.getString("gradeLevel", myCoursesDoc)
            myMyCoursesDB?.subjectLevel = JsonUtils.getString("subjectLevel", myCoursesDoc)
            myMyCoursesDB?.createdDate = JsonUtils.getLong("createdDate", myCoursesDoc)
            myMyCoursesDB?.setNumberOfSteps(JsonUtils.getJsonArray("steps", myCoursesDoc).size())
            val courseStepsJsonArray = JsonUtils.getJsonArray("steps", myCoursesDoc)
            val courseStepsList = mutableListOf<RealmCourseStep>()

            for (i in 0 until courseStepsJsonArray.size()) {
                val stepId = Base64.encodeToString(courseStepsJsonArray[i].toString().toByteArray(), Base64.NO_WRAP)
                val stepJson = courseStepsJsonArray[i].asJsonObject
                val step = RealmCourseStep()
                step.id = stepId
                step.stepTitle = JsonUtils.getString("stepTitle", stepJson)
                step.description = JsonUtils.getString("description", stepJson)
                val stepDescription = JsonUtils.getString("description", stepJson)
                val stepLinks = extractLinks(stepDescription)
                for (stepLink in stepLinks) {
                    val concatenatedLink = "$baseUrl/$stepLink"
                    concatenatedLinks.add(concatenatedLink)
                }
                insertCourseStepsAttachments(myMyCoursesDB?.courseId, stepId, JsonUtils.getJsonArray("resources", stepJson), mRealm)
                insertExam(stepJson, mRealm, stepId, i + 1, myMyCoursesDB?.courseId)
                insertSurvey(stepJson, mRealm, stepId, i + 1, myMyCoursesDB?.courseId, myMyCoursesDB?.createdDate)
                step.noOfResources = JsonUtils.getJsonArray("resources", stepJson).size()
                step.courseId = myMyCoursesDB?.courseId
                courseStepsList.add(step)
            }
            myMyCoursesDB?.courseSteps = RealmList()
            myMyCoursesDB?.courseSteps?.addAll(courseStepsList)
        }

        @JvmStatic
        fun saveConcatenatedLinksToPrefs() {
            val settings: SharedPreferences = context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
            val existingJsonLinks = settings.getString("concatenated_links", null)
            val existingConcatenatedLinks = if (existingJsonLinks != null) {
                gson.fromJson(existingJsonLinks, Array<String>::class.java).toMutableList()
            } else {
                mutableListOf()
            }
            val linksToProcess: List<String>
            synchronized(concatenatedLinks) {
                linksToProcess = concatenatedLinks.toList()
            }
            for (link in linksToProcess) {
                if (!existingConcatenatedLinks.contains(link)) {
                    existingConcatenatedLinks.add(link)
                }
            }
            val jsonConcatenatedLinks = gson.toJson(existingConcatenatedLinks)
            settings.edit { putString("concatenated_links", jsonConcatenatedLinks) }
        }

        fun getCourseSteps(mRealm: Realm, courseId: String?): List<RealmCourseStep> {
            val myCourse = mRealm.where<RealmMyCourse>().equalTo("id", courseId).findFirst()
            val courseSteps = myCourse?.courseSteps ?: emptyList()
            return courseSteps
        }

        fun getCourseStepIds(mRealm: Realm, courseId: String?): Array<String?> {
            val course = mRealm.where<RealmMyCourse>().equalTo("courseId", courseId).findFirst()
            val stepIds = course?.courseSteps?.map { it.id }?.toTypedArray() ?: emptyArray()
            return stepIds
        }

        private fun insertExam(stepContainer: JsonObject, mRealm: Realm, stepId: String, i: Int, myCoursesID: String?) {
            if (stepContainer.has("exam")) {
                val `object` = stepContainer.getAsJsonObject("exam")
                `object`.addProperty("stepNumber", i)
                insertCourseStepsExams(myCoursesID, stepId, `object`, mRealm)
            }
        }

        private fun insertSurvey(stepContainer: JsonObject, mRealm: Realm, stepId: String, i: Int, myCoursesID: String?, createdDate: Long?) {
            if (stepContainer.has("survey")) {
                val `object` = stepContainer.getAsJsonObject("survey")
                `object`.addProperty("stepNumber", i)
                `object`.addProperty("createdDate", createdDate)
                insertCourseStepsExams(myCoursesID, stepId, `object`, mRealm)
            }
        }

        private fun insertCourseStepsAttachments(myCoursesID: String?, stepId: String?, resources: JsonArray, mRealm: Realm?) {
            resources.forEach { resource ->
                if (mRealm != null) {
                    createStepResource(mRealm, resource.asJsonObject, myCoursesID, stepId)
                }
            }
        }

        @JvmStatic
        fun getMyByUserId(mRealm: Realm, settings: SharedPreferences?): RealmResults<RealmMyCourse> {
            val userId = settings?.getString("userId", "--")
            return mRealm.where(RealmMyCourse::class.java)
                .equalTo("userId", userId)
                .findAll()
        }

        @JvmStatic
        fun getMyCourseByUserId(userId: String?, libs: List<RealmMyCourse>?): List<RealmMyCourse> {
            val libraries: MutableList<RealmMyCourse> = ArrayList()
            for (item in libs ?: emptyList()) {
                if (item.userId?.contains(userId) == true) {
                    libraries.add(item)
                }
            }
            return libraries
        }

        @JvmStatic
        fun getAllCourses(userId: String?, libs: List<RealmMyCourse>): List<RealmMyCourse> {
            val libraries: MutableList<RealmMyCourse> = ArrayList()
            for (item in libs) {
                item.isMyCourse = item.userId?.contains(userId)!!
                libraries.add(item)
            }
            return libraries
        }

        @JvmStatic
        fun getOurCourse(userId: String?, libs: List<RealmMyCourse>): List<RealmMyCourse> {
            val libraries: MutableList<RealmMyCourse> = ArrayList()
            for (item in libs) {
                if (!item.userId?.contains(userId)!!) {
                    libraries.add(item)
                }
            }
            return libraries
        }

        @JvmStatic
        fun isMyCourse(userId: String?, courseId: String?, realm: Realm): Boolean {
            return getMyCourseByUserId(userId, realm.where(RealmMyCourse::class.java).equalTo("courseId", courseId).findAll()).isNotEmpty()
        }

        @JvmStatic
        fun getCourseByCourseId(courseId: String, mRealm: Realm): RealmMyCourse? {
            return mRealm.where(RealmMyCourse::class.java).equalTo("courseId", courseId).findFirst()
        }

        @JvmStatic
        fun insert(mRealm: Realm, myCoursesDoc: JsonObject?) {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }
            insertMyCourses("", myCoursesDoc, mRealm)
            mRealm.commitTransaction()
        }

        @JvmStatic
        fun getMyCourse(mRealm: Realm, id: String?): RealmMyCourse? {
            return mRealm.where(RealmMyCourse::class.java).equalTo("courseId", id).findFirst()
        }

        @JvmStatic
        fun createMyCourse(course: RealmMyCourse?, mRealm: Realm, id: String?) {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }
            course?.setUserId(id)
            mRealm.commitTransaction()
        }

        @JvmStatic
        fun getMyCourseIds(realm: Realm?, userId: String?): JsonArray {
            val myCourses = getMyCourseByUserId(userId, realm?.where(RealmMyCourse::class.java)?.findAll())
            val ids = JsonArray()
            for (lib in myCourses) {
                ids.add(lib.courseId)
            }
            return ids
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.content.Context.MODE_PRIVATE
import android.content.SharedPreferences
import android.text.TextUtils
import android.util.Base64
import androidx.core.content.edit
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.RealmResults
import io.realm.annotations.PrimaryKey
import io.realm.kotlin.where
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.createStepResource
import org.ole.planet.myplanet.model.RealmStepExam.Companion.insertCourseStepsExams
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DownloadUtils.extractLinks
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.UrlUtils

open class RealmMyCourse : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var userId: RealmList<String>? = null
        private set
    var courseId: String? = null
    var courseRev: String? = null
    var languageOfInstruction: String? = null
    var courseTitle: String? = null
    var memberLimit: Int? = null
    var description: String? = null
    var method: String? = null
    var gradeLevel: String? = null
    var subjectLevel: String? = null
    var createdDate: Long = 0
    private var numberOfSteps: Int? = null
    var courseSteps: RealmList<RealmCourseStep>? = null
    @Transient
    var isMyCourse: Boolean = false
    fun setUserId(userId: String?) {
        if (this.userId == null) {
            this.userId = RealmList()
        }
        if (!this.userId?.contains(userId)!! && !TextUtils.isEmpty(userId)) {
            this.userId?.add(userId)
        }
    }

    fun removeUserId(userId: String?) {
        this.userId?.remove(userId)
    }

    fun getNumberOfSteps(): Int {
        return numberOfSteps ?: 0
    }

    fun setNumberOfSteps(numberOfSteps: Int?) {
        this.numberOfSteps = numberOfSteps
    }

    override fun toString(): String {
        return courseTitle ?: ""
    }

    companion object {
        private val gson = Gson()
        private val concatenatedLinks = ArrayList<String>()

        @JvmStatic
        fun insertMyCourses(userId: String?, myCoursesDoc: JsonObject?, mRealm: Realm) {
            context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
            val id = JsonUtils.getString("_id", myCoursesDoc)
            var myMyCoursesDB = mRealm.where(RealmMyCourse::class.java).equalTo("id", id).findFirst()
            if (myMyCoursesDB == null) {
                myMyCoursesDB = mRealm.createObject(RealmMyCourse::class.java, id)
            }
            myMyCoursesDB?.setUserId(userId)
            myMyCoursesDB?.courseId = JsonUtils.getString("_id", myCoursesDoc)
            myMyCoursesDB?.courseRev = JsonUtils.getString("_rev", myCoursesDoc)
            myMyCoursesDB?.languageOfInstruction = JsonUtils.getString("languageOfInstruction", myCoursesDoc)
            myMyCoursesDB?.courseTitle = JsonUtils.getString("courseTitle", myCoursesDoc)
            myMyCoursesDB?.memberLimit = JsonUtils.getInt("memberLimit", myCoursesDoc)
            myMyCoursesDB?.description = JsonUtils.getString("description", myCoursesDoc)
            val description = JsonUtils.getString("description", myCoursesDoc)
            val links = extractLinks(description)
            val baseUrl = UrlUtils.getUrl()
            for (link in links) {
                val concatenatedLink = "$baseUrl/$link"
                concatenatedLinks.add(concatenatedLink)
            }
            myMyCoursesDB?.method = JsonUtils.getString("method", myCoursesDoc)
            myMyCoursesDB?.gradeLevel = JsonUtils.getString("gradeLevel", myCoursesDoc)
            myMyCoursesDB?.subjectLevel = JsonUtils.getString("subjectLevel", myCoursesDoc)
            myMyCoursesDB?.createdDate = JsonUtils.getLong("createdDate", myCoursesDoc)
            myMyCoursesDB?.setNumberOfSteps(JsonUtils.getJsonArray("steps", myCoursesDoc).size())
            val courseStepsJsonArray = JsonUtils.getJsonArray("steps", myCoursesDoc)
            val courseStepsList = mutableListOf<RealmCourseStep>()

            for (i in 0 until courseStepsJsonArray.size()) {
                val stepId = Base64.encodeToString(courseStepsJsonArray[i].toString().toByteArray(), Base64.NO_WRAP)
                val stepJson = courseStepsJsonArray[i].asJsonObject
                val step = RealmCourseStep()
                step.id = stepId
                step.stepTitle = JsonUtils.getString("stepTitle", stepJson)
                step.description = JsonUtils.getString("description", stepJson)
                val stepDescription = JsonUtils.getString("description", stepJson)
                val stepLinks = extractLinks(stepDescription)
                for (stepLink in stepLinks) {
                    val concatenatedLink = "$baseUrl/$stepLink"
                    concatenatedLinks.add(concatenatedLink)
                }
                insertCourseStepsAttachments(myMyCoursesDB?.courseId, stepId, JsonUtils.getJsonArray("resources", stepJson), mRealm)
                insertExam(stepJson, mRealm, stepId, i + 1, myMyCoursesDB?.courseId)
                insertSurvey(stepJson, mRealm, stepId, i + 1, myMyCoursesDB?.courseId, myMyCoursesDB?.createdDate)
                step.noOfResources = JsonUtils.getJsonArray("resources", stepJson).size()
                step.courseId = myMyCoursesDB?.courseId
                courseStepsList.add(step)
            }
            myMyCoursesDB?.courseSteps = RealmList()
            myMyCoursesDB?.courseSteps?.addAll(courseStepsList)
        }

        @JvmStatic
        fun saveConcatenatedLinksToPrefs() {
            val settings: SharedPreferences = context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
            val existingJsonLinks = settings.getString("concatenated_links", null)
            val existingConcatenatedLinks = if (existingJsonLinks != null) {
                gson.fromJson(existingJsonLinks, Array<String>::class.java).toMutableList()
            } else {
                mutableListOf()
            }
            val linksToProcess: List<String>
            synchronized(concatenatedLinks) {
                linksToProcess = concatenatedLinks.toList()
            }
            for (link in linksToProcess) {
                if (!existingConcatenatedLinks.contains(link)) {
                    existingConcatenatedLinks.add(link)
                }
            }
            val jsonConcatenatedLinks = gson.toJson(existingConcatenatedLinks)
            settings.edit { putString("concatenated_links", jsonConcatenatedLinks) }
        }

        fun getCourseSteps(mRealm: Realm, courseId: String?): List<RealmCourseStep> {
            val myCourse = mRealm.where<RealmMyCourse>().equalTo("id", courseId).findFirst()
            val courseSteps = myCourse?.courseSteps ?: emptyList()
            return courseSteps
        }

        fun getCourseStepIds(mRealm: Realm, courseId: String?): Array<String?> {
            val course = mRealm.where<RealmMyCourse>().equalTo("courseId", courseId).findFirst()
            val stepIds = course?.courseSteps?.map { it.id }?.toTypedArray() ?: emptyArray()
            return stepIds
        }

        private fun insertExam(stepContainer: JsonObject, mRealm: Realm, stepId: String, i: Int, myCoursesID: String?) {
            if (stepContainer.has("exam")) {
                val `object` = stepContainer.getAsJsonObject("exam")
                `object`.addProperty("stepNumber", i)
                insertCourseStepsExams(myCoursesID, stepId, `object`, mRealm)
            }
        }

        private fun insertSurvey(stepContainer: JsonObject, mRealm: Realm, stepId: String, i: Int, myCoursesID: String?, createdDate: Long?) {
            if (stepContainer.has("survey")) {
                val `object` = stepContainer.getAsJsonObject("survey")
                `object`.addProperty("stepNumber", i)
                `object`.addProperty("createdDate", createdDate)
                insertCourseStepsExams(myCoursesID, stepId, `object`, mRealm)
            }
        }

        private fun insertCourseStepsAttachments(myCoursesID: String?, stepId: String?, resources: JsonArray, mRealm: Realm?) {
            resources.forEach { resource ->
                if (mRealm != null) {
                    createStepResource(mRealm, resource.asJsonObject, myCoursesID, stepId)
                }
            }
        }

        @JvmStatic
        fun getMyByUserId(mRealm: Realm, settings: SharedPreferences?): RealmResults<RealmMyCourse> {
            val userId = settings?.getString("userId", "--")
            return mRealm.where(RealmMyCourse::class.java)
                .equalTo("userId", userId)
                .findAll()
        }

        @JvmStatic
        fun getMyCourseByUserId(userId: String?, libs: List<RealmMyCourse>?): List<RealmMyCourse> {
            val libraries: MutableList<RealmMyCourse> = ArrayList()
            for (item in libs ?: emptyList()) {
                if (item.userId?.contains(userId) == true) {
                    libraries.add(item)
                }
            }
            return libraries
        }

        @JvmStatic
        fun getAllCourses(userId: String?, libs: List<RealmMyCourse>): List<RealmMyCourse> {
            val libraries: MutableList<RealmMyCourse> = ArrayList()
            for (item in libs) {
                item.isMyCourse = item.userId?.contains(userId)!!
                libraries.add(item)
            }
            return libraries
        }

        @JvmStatic
        fun getOurCourse(userId: String?, libs: List<RealmMyCourse>): List<RealmMyCourse> {
            val libraries: MutableList<RealmMyCourse> = ArrayList()
            for (item in libs) {
                if (!item.userId?.contains(userId)!!) {
                    libraries.add(item)
                }
            }
            return libraries
        }

        @JvmStatic
        fun isMyCourse(userId: String?, courseId: String?, realm: Realm): Boolean {
            return getMyCourseByUserId(userId, realm.where(RealmMyCourse::class.java).equalTo("courseId", courseId).findAll()).isNotEmpty()
        }

        @JvmStatic
        fun getCourseByCourseId(courseId: String, mRealm: Realm): RealmMyCourse? {
            return mRealm.where(RealmMyCourse::class.java).equalTo("courseId", courseId).findFirst()
        }

        @JvmStatic
        fun insert(mRealm: Realm, myCoursesDoc: JsonObject?) {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }
            insertMyCourses("", myCoursesDoc, mRealm)
            mRealm.commitTransaction()
        }

        @JvmStatic
        fun getMyCourse(mRealm: Realm, id: String?): RealmMyCourse? {
            return mRealm.where(RealmMyCourse::class.java).equalTo("courseId", id).findFirst()
        }

        @JvmStatic
        fun createMyCourse(course: RealmMyCourse?, mRealm: Realm, id: String?) {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }
            course?.setUserId(id)
            mRealm.commitTransaction()
        }

        @JvmStatic
        fun getMyCourseIds(realm: Realm?, userId: String?): JsonArray {
            val myCourses = getMyCourseByUserId(userId, realm?.where(RealmMyCourse::class.java)?.findAll())
            val ids = JsonArray()
            for (lib in myCourses) {
                ids.add(lib.courseId)
            }
            return ids
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmRating.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmRating : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var createdOn: String? = null
    var _rev: String? = null
    var time: Long = 0
    var title: String? = null
    var userId: String? = null
    var isUpdated = false
    var rate = 0
    var _id: String? = null
    var item: String? = null
    var comment: String? = null
    var parentCode: String? = null
    var planetCode: String? = null
    var type: String? = null
    var user: String? = null

    companion object {
        @JvmStatic
        fun getRatings(mRealm: Realm, type: String?, userId: String?): HashMap<String?, JsonObject> {
            val ratings = mRealm.where(RealmRating::class.java).equalTo("type", type).findAll()
            val aggregated = aggregateRatings(ratings, userId)
            val map = HashMap<String?, JsonObject>()
            for ((item, aggregation) in aggregated) {
                map[item] = aggregation.toJson()
            }
            return map
        }

        @JvmStatic
        fun getRatingsById(mRealm: Realm, type: String?, id: String?, userid: String?): JsonObject? {
            val ratings = mRealm.where(RealmRating::class.java)
                .equalTo("type", type)
                .equalTo("item", id)
                .findAll()
            val aggregated = aggregateRatings(ratings, userid)[id]
            return aggregated?.toJson()
        }

        private fun aggregateRatings(
            ratings: Iterable<RealmRating>,
            userId: String?
        ): Map<String?, RatingAggregation> {
            val aggregationMap = LinkedHashMap<String?, RatingAggregation>()
            for (rating in ratings) {
                val item = rating.item
                val aggregation = aggregationMap.getOrPut(item) { RatingAggregation() }
                aggregation.totalRating += rating.rate
                aggregation.totalCount += 1
                if (userId != null && userId == rating.userId) {
                    aggregation.ratingByUser = rating.rate
                }
            }
            return aggregationMap
        }

        private data class RatingAggregation(
            var totalRating: Int = 0,
            var totalCount: Int = 0,
            var ratingByUser: Int? = null
        ) {
            fun toJson(): JsonObject {
                val `object` = JsonObject()
                if (ratingByUser != null) {
                    `object`.addProperty("ratingByUser", ratingByUser)
                }
                if (totalCount > 0) {
                    `object`.addProperty("averageRating", totalRating.toFloat() / totalCount)
                    `object`.addProperty("total", totalCount)
                }
                return `object`
            }
        }

        @JvmStatic
        fun serializeRating(realmRating: RealmRating): JsonObject {
            val ob = JsonObject()
            if (realmRating._id != null) ob.addProperty("_id", realmRating._id)
            if (realmRating._rev != null) ob.addProperty("_rev", realmRating._rev)
            ob.add("user", Gson().fromJson(realmRating.user, JsonObject::class.java))
            ob.addProperty("item", realmRating.item)
            ob.addProperty("type", realmRating.type)
            ob.addProperty("title", realmRating.title)
            ob.addProperty("time", realmRating.time)
            ob.addProperty("comment", realmRating.comment)
            ob.addProperty("rate", realmRating.rate)
            ob.addProperty("createdOn", realmRating.createdOn)
            ob.addProperty("parentCode", realmRating.parentCode)
            ob.addProperty("planetCode", realmRating.planetCode)
            ob.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            return ob
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject) {
            var rating = mRealm.where(RealmRating::class.java).equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (rating == null) {
                rating = mRealm.createObject(RealmRating::class.java, JsonUtils.getString("_id", act))
            }
            if (rating != null) {
                rating._rev = JsonUtils.getString("_rev", act)
                rating._id = JsonUtils.getString("_id", act)
                rating.time = JsonUtils.getLong("time", act)
                rating.title = JsonUtils.getString("title", act)
                rating.type = JsonUtils.getString("type", act)
                rating.item = JsonUtils.getString("item", act)
                rating.rate = JsonUtils.getInt("rate", act)
                rating.isUpdated = false
                rating.comment = JsonUtils.getString("comment", act)
                rating.user = Gson().toJson(JsonUtils.getJsonObject("user", act))
                rating.userId = JsonUtils.getString("_id", JsonUtils.getJsonObject("user", act))
                rating.parentCode = JsonUtils.getString("parentCode", act)
                rating.parentCode = JsonUtils.getString("planetCode", act)
                rating.createdOn = JsonUtils.getString("createdOn", act)
            }
        }
    }
}
=======
package org.ole.planet.myplanet.model


import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmRating : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var createdOn: String? = null
    var _rev: String? = null
    var time: Long = 0
    var title: String? = null
    var userId: String? = null
    var isUpdated = false
    var rate = 0
    var _id: String? = null
    var item: String? = null
    var comment: String? = null
    var parentCode: String? = null
    var planetCode: String? = null
    var type: String? = null
    var user: String? = null

    companion object {
        @JvmStatic
        fun getRatings(mRealm: Realm, type: String?, userId: String?): HashMap<String?, JsonObject> {
            val ratings = mRealm.where(RealmRating::class.java).equalTo("type", type).findAll()
            val aggregated = aggregateRatings(ratings, userId)
            val map = HashMap<String?, JsonObject>()
            for ((item, aggregation) in aggregated) {
                map[item] = aggregation.toJson()
            }
            return map
        }

        @JvmStatic
        fun getRatingsById(mRealm: Realm, type: String?, id: String?, userid: String?): JsonObject? {
            val ratings = mRealm.where(RealmRating::class.java)
                .equalTo("type", type)
                .equalTo("item", id)
                .findAll()
            val aggregated = aggregateRatings(ratings, userid)[id]
            return aggregated?.toJson()
        }

        private fun aggregateRatings(
            ratings: Iterable<RealmRating>,
            userId: String?
        ): Map<String?, RatingAggregation> {
            val aggregationMap = LinkedHashMap<String?, RatingAggregation>()
            for (rating in ratings) {
                val item = rating.item
                val aggregation = aggregationMap.getOrPut(item) { RatingAggregation() }
                aggregation.totalRating += rating.rate
                aggregation.totalCount += 1
                if (userId != null && userId == rating.userId) {
                    aggregation.ratingByUser = rating.rate
                }
            }
            return aggregationMap
        }

        private data class RatingAggregation(
            var totalRating: Int = 0,
            var totalCount: Int = 0,
            var ratingByUser: Int? = null
        ) {
            fun toJson(): JsonObject {
                val `object` = JsonObject()
                if (ratingByUser != null) {
                    `object`.addProperty("ratingByUser", ratingByUser)
                }
                if (totalCount > 0) {
                    `object`.addProperty("averageRating", totalRating.toFloat() / totalCount)
                    `object`.addProperty("total", totalCount)
                }
                return `object`
            }
        }

        @JvmStatic
        fun serializeRating(realmRating: RealmRating): JsonObject {
            val ob = JsonObject()
            if (realmRating._id != null) ob.addProperty("_id", realmRating._id)
            if (realmRating._rev != null) ob.addProperty("_rev", realmRating._rev)
            ob.add("user", Gson().fromJson(realmRating.user, JsonObject::class.java))
            ob.addProperty("item", realmRating.item)
            ob.addProperty("type", realmRating.type)
            ob.addProperty("title", realmRating.title)
            ob.addProperty("time", realmRating.time)
            ob.addProperty("comment", realmRating.comment)
            ob.addProperty("rate", realmRating.rate)
            ob.addProperty("createdOn", realmRating.createdOn)
            ob.addProperty("parentCode", realmRating.parentCode)
            ob.addProperty("planetCode", realmRating.planetCode)
            ob.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            return ob
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject) {
            var rating = mRealm.where(RealmRating::class.java).equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (rating == null) {
                rating = mRealm.createObject(RealmRating::class.java, JsonUtils.getString("_id", act))
            }
            if (rating != null) {
                rating._rev = JsonUtils.getString("_rev", act)
                rating._id = JsonUtils.getString("_id", act)
                rating.time = JsonUtils.getLong("time", act)
                rating.title = JsonUtils.getString("title", act)
                rating.type = JsonUtils.getString("type", act)
                rating.item = JsonUtils.getString("item", act)
                rating.rate = JsonUtils.getInt("rate", act)
                rating.isUpdated = false
                rating.comment = JsonUtils.getString("comment", act)
                rating.user = Gson().toJson(JsonUtils.getJsonObject("user", act))
                rating.userId = JsonUtils.getString("_id", JsonUtils.getJsonObject("user", act))
                rating.parentCode = JsonUtils.getString("parentCode", act)
                rating.parentCode = JsonUtils.getString("planetCode", act)
                rating.createdOn = JsonUtils.getString("createdOn", act)
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmCourseProgress.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getCourseSteps
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getMyCourseByUserId
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.isMyCourse
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmCourseProgress : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var createdOn: String? = null
    var createdDate: Long = 0
    var updatedDate: Long = 0
    var _rev: String? = null
    var stepNum = 0
    var passed = false
    var userId: String? = null
    var courseId: String? = null
    var parentCode: String? = null

    companion object {
        @JvmStatic
        fun serializeProgress(progress: RealmCourseProgress): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("userId", progress.userId)
            `object`.addProperty("parentCode", progress.parentCode)
            `object`.addProperty("courseId", progress.courseId)
            `object`.addProperty("passed", progress.passed)
            `object`.addProperty("stepNum", progress.stepNum)
            `object`.addProperty("createdOn", progress.createdOn)
            `object`.addProperty("createdDate", progress.createdDate)
            `object`.addProperty("updatedDate", progress.updatedDate)
            return `object`
        }

        @JvmStatic
        fun getCourseProgress(mRealm: Realm, userId: String?): HashMap<String?, JsonObject> {
            val r = getMyCourseByUserId(userId, mRealm.where(RealmMyCourse::class.java).findAll())
            val map = HashMap<String?, JsonObject>()
            for (course in r) {
                val `object` = JsonObject()
                val steps = getCourseSteps(mRealm, course.courseId)
                `object`.addProperty("max", steps.size)
                `object`.addProperty("current", getCurrentProgress(steps, mRealm, userId, course.courseId))
                if (isMyCourse(userId, course.courseId, mRealm)) map[course.courseId] = `object`
            }
            return map
        }

        @JvmStatic
        fun getCurrentProgress(steps: List<RealmCourseStep?>?, mRealm: Realm, userId: String?, courseId: String?): Int {
            var i = 0
            while (i < (steps?.size ?: 0)) {
                mRealm.where(RealmCourseProgress::class.java).equalTo("stepNum", i + 1).equalTo("userId", userId).equalTo("courseId", courseId)
                    .findFirst()
                    ?: break
                i++
            }
            return i
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var courseProgress = mRealm.where(RealmCourseProgress::class.java).equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (courseProgress == null) {
                courseProgress = mRealm.createObject(RealmCourseProgress::class.java, JsonUtils.getString("_id", act))
            }
            courseProgress?._rev = JsonUtils.getString("_rev", act)
            courseProgress?._id = JsonUtils.getString("_id", act)
            courseProgress?.passed = JsonUtils.getBoolean("passed", act)
            courseProgress?.stepNum = JsonUtils.getInt("stepNum", act)
            courseProgress?.userId = JsonUtils.getString("userId", act)
            courseProgress?.parentCode = JsonUtils.getString("parentCode", act)
            courseProgress?.courseId = JsonUtils.getString("courseId", act)
            courseProgress?.createdOn = JsonUtils.getString("createdOn", act)
            courseProgress?.createdDate = JsonUtils.getLong("createdDate", act)
            courseProgress?.updatedDate = JsonUtils.getLong("updatedDate", act)
        }
    }
}
=======
package org.ole.planet.myplanet.model


import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getCourseSteps
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getMyCourseByUserId
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.isMyCourse
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmCourseProgress : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var createdOn: String? = null
    var createdDate: Long = 0
    var updatedDate: Long = 0
    var _rev: String? = null
    var stepNum = 0
    var passed = false
    var userId: String? = null
    var courseId: String? = null
    var parentCode: String? = null

    companion object {
        @JvmStatic
        fun serializeProgress(progress: RealmCourseProgress): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("userId", progress.userId)
            `object`.addProperty("parentCode", progress.parentCode)
            `object`.addProperty("courseId", progress.courseId)
            `object`.addProperty("passed", progress.passed)
            `object`.addProperty("stepNum", progress.stepNum)
            `object`.addProperty("createdOn", progress.createdOn)
            `object`.addProperty("createdDate", progress.createdDate)
            `object`.addProperty("updatedDate", progress.updatedDate)
            return `object`
        }

        @JvmStatic
        fun getCourseProgress(mRealm: Realm, userId: String?): HashMap<String?, JsonObject> {
            val r = getMyCourseByUserId(userId, mRealm.where(RealmMyCourse::class.java).findAll())
            val map = HashMap<String?, JsonObject>()
            for (course in r) {
                val `object` = JsonObject()
                val steps = getCourseSteps(mRealm, course.courseId)
                `object`.addProperty("max", steps.size)
                `object`.addProperty("current", getCurrentProgress(steps, mRealm, userId, course.courseId))
                if (isMyCourse(userId, course.courseId, mRealm)) map[course.courseId] = `object`
            }
            return map
        }

        @JvmStatic
        fun getCurrentProgress(steps: List<RealmCourseStep?>?, mRealm: Realm, userId: String?, courseId: String?): Int {
            var i = 0
            while (i < (steps?.size ?: 0)) {
                mRealm.where(RealmCourseProgress::class.java).equalTo("stepNum", i + 1).equalTo("userId", userId).equalTo("courseId", courseId)
                    .findFirst()
                    ?: break
                i++
            }
            return i
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var courseProgress = mRealm.where(RealmCourseProgress::class.java).equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (courseProgress == null) {
                courseProgress = mRealm.createObject(RealmCourseProgress::class.java, JsonUtils.getString("_id", act))
            }
            courseProgress?._rev = JsonUtils.getString("_rev", act)
            courseProgress?._id = JsonUtils.getString("_id", act)
            courseProgress?.passed = JsonUtils.getBoolean("passed", act)
            courseProgress?.stepNum = JsonUtils.getInt("stepNum", act)
            courseProgress?.userId = JsonUtils.getString("userId", act)
            courseProgress?.parentCode = JsonUtils.getString("parentCode", act)
            courseProgress?.courseId = JsonUtils.getString("courseId", act)
            courseProgress?.createdOn = JsonUtils.getString("createdOn", act)
            courseProgress?.createdDate = JsonUtils.getLong("createdDate", act)
            courseProgress?.updatedDate = JsonUtils.getLong("updatedDate", act)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/Conversation.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import io.realm.RealmObject

open class Conversation : RealmObject() {
    var query: String? = null
    var response: String? = null
}
=======
package org.ole.planet.myplanet.model


import io.realm.RealmObject

open class Conversation : RealmObject() {
    var query: String? = null
    var response: String? = null
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmTag.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmTag : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var name: String? = null
    var linkId: String? = null
    var tagId: String? = null
    var attachedTo: RealmList<String>? = null
    var docType: String? = null
    var db: String? = null
    var isAttached = false
    private fun setAttachedTo(attachedTo: JsonArray) {
        this.attachedTo = RealmList()
        for (i in 0 until attachedTo.size()) {
            this.attachedTo?.add(JsonUtils.getString(attachedTo, i))
        }
        isAttached = (this.attachedTo?.size ?: 0) > 0
    }

    override fun toString(): String {
        return name.orEmpty()
    }

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject) {
            var tag = mRealm.where(RealmTag::class.java).equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (tag == null) {
                tag = mRealm.createObject(RealmTag::class.java, JsonUtils.getString("_id", act))
            }
            if (tag != null) {
                tag._rev = JsonUtils.getString("_rev", act)
                tag._id = JsonUtils.getString("_id", act)
                tag.name = JsonUtils.getString("name", act)
                tag.db = JsonUtils.getString("db", act)
                tag.docType = JsonUtils.getString("docType", act)
                tag.tagId = JsonUtils.getString("tagId", act)
                tag.linkId = JsonUtils.getString("linkId", act)
                val el = act["attachedTo"]
                if (el != null && el.isJsonArray) {
                    tag.setAttachedTo(JsonUtils.getJsonArray("attachedTo", act))
                } else {
                    tag.attachedTo?.add(JsonUtils.getString("attachedTo", act))
                }
                tag.isAttached = (tag.attachedTo?.size ?: 0) > 0
            }
        }

        @JvmStatic
        fun getTagsArray(list: List<RealmTag>): JsonArray {
            val array = JsonArray()
            for (t in list) {
                array.add(t._id)
            }
            return array
        }
    }
}
=======
package org.ole.planet.myplanet.model


import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmTag : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var name: String? = null
    var linkId: String? = null
    var tagId: String? = null
    var attachedTo: RealmList<String>? = null
    var docType: String? = null
    var db: String? = null
    var isAttached = false
    private fun setAttachedTo(attachedTo: JsonArray) {
        this.attachedTo = RealmList()
        for (i in 0 until attachedTo.size()) {
            this.attachedTo?.add(JsonUtils.getString(attachedTo, i))
        }
        isAttached = (this.attachedTo?.size ?: 0) > 0
    }

    override fun toString(): String {
        return name.orEmpty()
    }

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject) {
            var tag = mRealm.where(RealmTag::class.java).equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (tag == null) {
                tag = mRealm.createObject(RealmTag::class.java, JsonUtils.getString("_id", act))
            }
            if (tag != null) {
                tag._rev = JsonUtils.getString("_rev", act)
                tag._id = JsonUtils.getString("_id", act)
                tag.name = JsonUtils.getString("name", act)
                tag.db = JsonUtils.getString("db", act)
                tag.docType = JsonUtils.getString("docType", act)
                tag.tagId = JsonUtils.getString("tagId", act)
                tag.linkId = JsonUtils.getString("linkId", act)
                val el = act["attachedTo"]
                if (el != null && el.isJsonArray) {
                    tag.setAttachedTo(JsonUtils.getJsonArray("attachedTo", act))
                } else {
                    tag.attachedTo?.add(JsonUtils.getString("attachedTo", act))
                }
                tag.isAttached = (tag.attachedTo?.size ?: 0) > 0
            }
        }

        @JvmStatic
        fun getTagsArray(list: List<RealmTag>): JsonArray {
            val array = JsonArray()
            for (t in list) {
                array.add(t._id)
            }
            return array
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/Download.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.os.Parcel
import android.os.Parcelable

class Download() : Parcelable {
    var fileName: String? = null
    var progress: Int = 0
    var currentFileSize: Int = 0
    var totalFileSize: Int = 0
    var completeAll: Boolean = false
    var failed: Boolean = false
    var message: String? = null
    var fileUrl: String? = null

    constructor(parcel: Parcel) : this() {
        fileName = parcel.readString()
        progress = parcel.readInt()
        currentFileSize = parcel.readInt()
        totalFileSize = parcel.readInt()
        completeAll = parcel.readByte() != 0.toByte()
        failed = parcel.readByte() != 0.toByte()
        message = parcel.readString()
        fileUrl = parcel.readString()
    }

    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeString(fileName)
        parcel.writeInt(progress)
        parcel.writeInt(currentFileSize)
        parcel.writeInt(totalFileSize)
        parcel.writeByte(if (completeAll) 1 else 0)
        parcel.writeByte(if (failed) 1 else 0)
        parcel.writeString(message)
        parcel.writeString(fileUrl)
    }

    override fun describeContents(): Int {
        return 0
    }

    companion object CREATOR : Parcelable.Creator<Download> {
        override fun createFromParcel(parcel: Parcel): Download {
            return Download(parcel)
        }

        override fun newArray(size: Int): Array<Download?> {
            return arrayOfNulls(size)
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.os.Parcel
import android.os.Parcelable

class Download() : Parcelable {
    var fileName: String? = null
    var progress: Int = 0
    var currentFileSize: Int = 0
    var totalFileSize: Int = 0
    var completeAll: Boolean = false
    var failed: Boolean = false
    var message: String? = null
    var fileUrl: String? = null

    constructor(parcel: Parcel) : this() {
        fileName = parcel.readString()
        progress = parcel.readInt()
        currentFileSize = parcel.readInt()
        totalFileSize = parcel.readInt()
        completeAll = parcel.readByte() != 0.toByte()
        failed = parcel.readByte() != 0.toByte()
        message = parcel.readString()
        fileUrl = parcel.readString()
    }

    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeString(fileName)
        parcel.writeInt(progress)
        parcel.writeInt(currentFileSize)
        parcel.writeInt(totalFileSize)
        parcel.writeByte(if (completeAll) 1 else 0)
        parcel.writeByte(if (failed) 1 else 0)
        parcel.writeString(message)
        parcel.writeString(fileUrl)
    }

    override fun describeContents(): Int {
        return 0
    }

    companion object CREATOR : Parcelable.Creator<Download> {
        override fun createFromParcel(parcel: Parcel): Download {
            return Download(parcel)
        }

        override fun newArray(size: Int): Array<Download?> {
            return arrayOfNulls(size)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmApkLog.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.Context
import com.google.gson.JsonObject
import io.realm.RealmObject
import io.realm.annotations.Ignore
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmApkLog : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var userId: String? = null
    var type: String? = null
    var _rev: String? = null
    var error: String? = null
    var page: String? = null
    var parentCode: String? = null
    var version: String? = null
    var createdOn: String? = null
    var time: String? = null

    fun setError(e: Throwable) {
        error += "--------- Stack trace ---------\n\n"
        appendReport(e)
        error += "--------- Cause ---------\n\n"
        val cause = e.cause
        appendReport(cause)
    }

    private fun appendReport(cause: Throwable?) {
        if (cause != null) {
            error += """
                $cause


                """.trimIndent()
            val arr = cause.stackTrace
            for (i in arr.indices) {
                error += """    ${arr[i]}
"""
            }
        }
        error += "-------------------------------\n\n"
    }

    companion object {
        @Ignore
        const val ERROR_TYPE_CRASH = "crash"

        @JvmStatic
        fun serialize(log: RealmApkLog, context: Context): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("type", log.type)
            `object`.addProperty("error", log.error)
            `object`.addProperty("page", log.page)
            `object`.addProperty("time", log.time)
            `object`.addProperty("userId", log.userId)
            `object`.addProperty("version", log.version)
            `object`.addProperty("createdOn", log.createdOn)
            `object`.addProperty("androidId", log.createdOn)
            `object`.addProperty("createdOn", log.createdOn)
            `object`.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            `object`.addProperty("deviceName", NetworkUtils.getDeviceName())
            `object`.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            `object`.addProperty("parentCode", log.parentCode)
            return `object`
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.content.Context
import com.google.gson.JsonObject
import io.realm.RealmObject
import io.realm.annotations.Ignore
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmApkLog : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var userId: String? = null
    var type: String? = null
    var _rev: String? = null
    var error: String? = null
    var page: String? = null
    var parentCode: String? = null
    var version: String? = null
    var createdOn: String? = null
    var time: String? = null

    fun setError(e: Throwable) {
        error += "--------- Stack trace ---------\n\n"
        appendReport(e)
        error += "--------- Cause ---------\n\n"
        val cause = e.cause
        appendReport(cause)
    }

    private fun appendReport(cause: Throwable?) {
        if (cause != null) {
            error += """
                $cause


                """.trimIndent()
            val arr = cause.stackTrace
            for (i in arr.indices) {
                error += """    ${arr[i]}
"""
            }
        }
        error += "-------------------------------\n\n"
    }

    companion object {
        @Ignore
        const val ERROR_TYPE_CRASH = "crash"

        @JvmStatic
        fun serialize(log: RealmApkLog, context: Context): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("type", log.type)
            `object`.addProperty("error", log.error)
            `object`.addProperty("page", log.page)
            `object`.addProperty("time", log.time)
            `object`.addProperty("userId", log.userId)
            `object`.addProperty("version", log.version)
            `object`.addProperty("createdOn", log.createdOn)
            `object`.addProperty("androidId", log.createdOn)
            `object`.addProperty("createdOn", log.createdOn)
            `object`.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            `object`.addProperty("deviceName", NetworkUtils.getDeviceName())
            `object`.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            `object`.addProperty("parentCode", log.parentCode)
            return `object`
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmNewsLog.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.JsonObject
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmNewsLog : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var type: String? = null
    var time: Long? = null
    var userId: String? = null
    var androidId: String? = null

    companion object {
        @JvmStatic
        fun serialize(log: RealmNewsLog): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", log.userId)
            ob.addProperty("type", log.type)
            ob.addProperty("time", log.time)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            ob.addProperty(
                "customDeviceName", NetworkUtils.getCustomDeviceName(MainApplication.context)
            )
            return ob
        }
    }
}
=======
package org.ole.planet.myplanet.model


import com.google.gson.JsonObject
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmNewsLog : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var type: String? = null
    var time: Long? = null
    var userId: String? = null
    var androidId: String? = null

    companion object {
        @JvmStatic
        fun serialize(log: RealmNewsLog): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", log.userId)
            ob.addProperty("type", log.type)
            ob.addProperty("time", log.time)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            ob.addProperty(
                "customDeviceName", NetworkUtils.getCustomDeviceName(MainApplication.context)
            )
            return ob
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmExamQuestion.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.RealmResults
import io.realm.annotations.PrimaryKey
import java.util.Locale
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmExamQuestion : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var header: String? = null
    var body: String? = null
    var type: String? = null
    var examId: String? = null
    private var correctChoice: RealmList<String>? = null
    var marks: String? = null
    var choices: String? = null
    var hasOtherOption: Boolean = false
    private fun setCorrectChoiceArray(array: JsonArray, question: RealmExamQuestion?) {
        for (i in 0 until array.size()) {
            question?.correctChoice?.add(JsonUtils.getString(array, i).lowercase(Locale.getDefault()))
        }
    }

    fun getCorrectChoice(): RealmList<String>? {
        return correctChoice
    }

    val correctChoiceArray: JsonArray
        get() {
            val array = JsonArray()
            for (s in correctChoice ?: emptyList()){
                array.add(s)
            }
            return array
        }

    companion object {
        @JvmStatic
        fun insertExamQuestions(questions: JsonArray, examId: String?, mRealm: Realm) {
            if (questions.size() == 0) return
            for (i in 0 until questions.size()) {
                val question = questions[i].asJsonObject
                val questionId = if (question.has("id")) {
                    JsonUtils.getString("id", question)
                } else {
                    "$examId-${i}"
                }

                var myQuestion = mRealm.where(RealmExamQuestion::class.java)
                    .equalTo("id", questionId)
                    .findFirst()

                if (myQuestion == null) {
                    myQuestion = mRealm.createObject(RealmExamQuestion::class.java, questionId)
                }

                myQuestion.apply {
                    this.examId = examId
                    body = JsonUtils.getString("body", question)
                    type = JsonUtils.getString("type", question)
                    header = JsonUtils.getString("title", question)
                    marks = JsonUtils.getString("marks", question)
                    choices = if (question.has("choices")) {
                        Gson().toJson(JsonUtils.getJsonArray("choices", question))
                    } else {
                        "[]"
                    }

                    hasOtherOption = JsonUtils.getBoolean("hasOtherOption", question)
                    val isMultipleChoice = type?.startsWith("select") == true && question.has("choices")
                    if (isMultipleChoice) {
                        insertCorrectChoice(question["choices"].asJsonArray, question, this)
                    }
                }
            }
        }

        private fun insertCorrectChoice(array: JsonArray, question: JsonObject, myQuestion: RealmExamQuestion?) {
            for (a in 0 until array.size()) {
                val res = array[a].asJsonObject
                if (question["correctChoice"].isJsonArray) {
                    myQuestion?.correctChoice = RealmList()
                    myQuestion?.setCorrectChoiceArray(JsonUtils.getJsonArray("correctChoice", question), myQuestion)
                } else if (JsonUtils.getString("correctChoice", question) == JsonUtils.getString("id", res)) {
                    myQuestion?.correctChoice = RealmList()
                    myQuestion?.correctChoice?.add(JsonUtils.getString("res", res))
                }
            }
        }

        @JvmStatic
        fun serializeQuestions(question: RealmResults<RealmExamQuestion>): JsonArray {
            val array = JsonArray()
            for (que in question) {
                val `object` = JsonObject()
                `object`.addProperty("header", que.header)
                `object`.addProperty("body", que.body)
                `object`.addProperty("type", que.type)
                `object`.addProperty("marks", que.marks)
                `object`.add("choices", JsonUtils.getStringAsJsonArray(que.choices))
                `object`.add("correctChoice", que.correctChoiceArray)
                `object`.addProperty("hasOtherOption", que.hasOtherOption)
                array.add(`object`)
            }
            return array
        }
    }
}
=======
package org.ole.planet.myplanet.model


import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.RealmResults
import io.realm.annotations.PrimaryKey
import java.util.Locale
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmExamQuestion : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var header: String? = null
    var body: String? = null
    var type: String? = null
    var examId: String? = null
    private var correctChoice: RealmList<String>? = null
    var marks: String? = null
    var choices: String? = null
    var hasOtherOption: Boolean = false
    private fun setCorrectChoiceArray(array: JsonArray, question: RealmExamQuestion?) {
        for (i in 0 until array.size()) {
            question?.correctChoice?.add(JsonUtils.getString(array, i).lowercase(Locale.getDefault()))
        }
    }

    fun getCorrectChoice(): RealmList<String>? {
        return correctChoice
    }

    val correctChoiceArray: JsonArray
        get() {
            val array = JsonArray()
            for (s in correctChoice ?: emptyList()){
                array.add(s)
            }
            return array
        }

    companion object {
        @JvmStatic
        fun insertExamQuestions(questions: JsonArray, examId: String?, mRealm: Realm) {
            if (questions.size() == 0) return
            for (i in 0 until questions.size()) {
                val question = questions[i].asJsonObject
                val questionId = if (question.has("id")) {
                    JsonUtils.getString("id", question)
                } else {
                    "$examId-${i}"
                }

                var myQuestion = mRealm.where(RealmExamQuestion::class.java)
                    .equalTo("id", questionId)
                    .findFirst()

                if (myQuestion == null) {
                    myQuestion = mRealm.createObject(RealmExamQuestion::class.java, questionId)
                }

                myQuestion.apply {
                    this.examId = examId
                    body = JsonUtils.getString("body", question)
                    type = JsonUtils.getString("type", question)
                    header = JsonUtils.getString("title", question)
                    marks = JsonUtils.getString("marks", question)
                    choices = if (question.has("choices")) {
                        Gson().toJson(JsonUtils.getJsonArray("choices", question))
                    } else {
                        "[]"
                    }

                    hasOtherOption = JsonUtils.getBoolean("hasOtherOption", question)
                    val isMultipleChoice = type?.startsWith("select") == true && question.has("choices")
                    if (isMultipleChoice) {
                        insertCorrectChoice(question["choices"].asJsonArray, question, this)
                    }
                }
            }
        }

        private fun insertCorrectChoice(array: JsonArray, question: JsonObject, myQuestion: RealmExamQuestion?) {
            for (a in 0 until array.size()) {
                val res = array[a].asJsonObject
                if (question["correctChoice"].isJsonArray) {
                    myQuestion?.correctChoice = RealmList()
                    myQuestion?.setCorrectChoiceArray(JsonUtils.getJsonArray("correctChoice", question), myQuestion)
                } else if (JsonUtils.getString("correctChoice", question) == JsonUtils.getString("id", res)) {
                    myQuestion?.correctChoice = RealmList()
                    myQuestion?.correctChoice?.add(JsonUtils.getString("res", res))
                }
            }
        }

        @JvmStatic
        fun serializeQuestions(question: RealmResults<RealmExamQuestion>): JsonArray {
            val array = JsonArray()
            for (que in question) {
                val `object` = JsonObject()
                `object`.addProperty("header", que.header)
                `object`.addProperty("body", que.body)
                `object`.addProperty("type", que.type)
                `object`.addProperty("marks", que.marks)
                `object`.add("choices", JsonUtils.getStringAsJsonArray(que.choices))
                `object`.add("correctChoice", que.correctChoiceArray)
                `object`.addProperty("hasOtherOption", que.hasOtherOption)
                array.add(`object`)
            }
            return array
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmSearchActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.VersionUtils

open class RealmSearchActivity(
    @PrimaryKey
    var id: String = "",
    var _id: String = "",
    var _rev: String = "",
    var text: String = "",
    var type: String = "",
    var time: Long = 0,
    var user: String = "",
    var filter: String = "",
    var createdOn: String = "",
    var parentCode: String = ""
) : RealmObject() {
    fun serialize(): JsonObject {
        val obj = JsonObject()
        obj.addProperty("text", text)
        obj.addProperty("type", type)
        obj.addProperty("time", time)
        obj.addProperty("user", user)
        obj.addProperty("androidId", VersionUtils.getAndroidId(MainApplication.context))
        obj.addProperty(
            "customDeviceName", NetworkUtils.getCustomDeviceName(MainApplication.context)
        )
        obj.addProperty("deviceName", NetworkUtils.getDeviceName())
        obj.addProperty("createdOn", createdOn)
        obj.addProperty("parentCode", parentCode)
        obj.add("filter", Gson().fromJson(filter, JsonObject::class.java))
        return obj
    }

    companion object {
        @JvmStatic
        fun insert(log: RealmNewsLog): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", log.userId)
            ob.addProperty("type", log.type)
            ob.addProperty("time", log.time)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            ob.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(MainApplication.context))
            return ob
        }
    }
}
=======
package org.ole.planet.myplanet.model


import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.VersionUtils

open class RealmSearchActivity(
    @PrimaryKey
    var id: String = "",
    var _id: String = "",
    var _rev: String = "",
    var text: String = "",
    var type: String = "",
    var time: Long = 0,
    var user: String = "",
    var filter: String = "",
    var createdOn: String = "",
    var parentCode: String = ""
) : RealmObject() {
    fun serialize(): JsonObject {
        val obj = JsonObject()
        obj.addProperty("text", text)
        obj.addProperty("type", type)
        obj.addProperty("time", time)
        obj.addProperty("user", user)
        obj.addProperty("androidId", VersionUtils.getAndroidId(MainApplication.context))
        obj.addProperty(
            "customDeviceName", NetworkUtils.getCustomDeviceName(MainApplication.context)
        )
        obj.addProperty("deviceName", NetworkUtils.getDeviceName())
        obj.addProperty("createdOn", createdOn)
        obj.addProperty("parentCode", parentCode)
        obj.add("filter", Gson().fromJson(filter, JsonObject::class.java))
        return obj
    }

    companion object {
        @JvmStatic
        fun insert(log: RealmNewsLog): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", log.userId)
            ob.addProperty("type", log.type)
            ob.addProperty("time", log.time)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            ob.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(MainApplication.context))
            return ob
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmRemovedLog.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.UUID

open class RealmRemovedLog : RealmObject() {
    @PrimaryKey
    var id: String? = null
    private var userId: String? = null
    private var type: String? = null
    private var docId: String? = null

    companion object {
        @JvmStatic
        fun onAdd(mRealm: Realm, type: String?, userId: String?, docId: String?) {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            mRealm.where(RealmRemovedLog::class.java)
                .equalTo("type", type)
                .equalTo("userId", userId)
                .equalTo("docId", docId)
                .findAll().deleteAllFromRealm()
            mRealm.commitTransaction()
        }

        @JvmStatic
        fun onRemove(mRealm: Realm, type: String, userId: String?, docId: String?) {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            val log = mRealm.createObject(RealmRemovedLog::class.java, UUID.randomUUID().toString())
            log.docId = docId
            log.userId = userId
            log.type = type
            mRealm.commitTransaction()
        }

        @JvmStatic
        fun removedIds(realm: Realm?, type: String, userId: String?): Array<String> {
            val removedLibs = realm?.where(RealmRemovedLog::class.java)
                ?.equalTo("userId", userId)
                ?.equalTo("type", type)
                ?.findAll()

            if (removedLibs != null) {
                val ids = Array(removedLibs.size) { "" }
                for ((i, removed) in removedLibs.withIndex()) {
                    ids[i] = removed.docId ?: ""
                }
                return ids
            }
            return arrayOf()
        }
    }
}
=======
package org.ole.planet.myplanet.model


import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.UUID

open class RealmRemovedLog : RealmObject() {
    @PrimaryKey
    var id: String? = null
    private var userId: String? = null
    private var type: String? = null
    private var docId: String? = null

    companion object {
        @JvmStatic
        fun onAdd(mRealm: Realm, type: String?, userId: String?, docId: String?) {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            mRealm.where(RealmRemovedLog::class.java)
                .equalTo("type", type)
                .equalTo("userId", userId)
                .equalTo("docId", docId)
                .findAll().deleteAllFromRealm()
            mRealm.commitTransaction()
        }

        @JvmStatic
        fun onRemove(mRealm: Realm, type: String, userId: String?, docId: String?) {
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            val log = mRealm.createObject(RealmRemovedLog::class.java, UUID.randomUUID().toString())
            log.docId = docId
            log.userId = userId
            log.type = type
            mRealm.commitTransaction()
        }

        @JvmStatic
        fun removedIds(realm: Realm?, type: String, userId: String?): Array<String> {
            val removedLibs = realm?.where(RealmRemovedLog::class.java)
                ?.equalTo("userId", userId)
                ?.equalTo("type", type)
                ?.findAll()

            if (removedLibs != null) {
                val ids = Array(removedLibs.size) { "" }
                for ((i, removed) in removedLibs.withIndex()) {
                    ids[i] = removed.docId ?: ""
                }
                return ids
            }
            return arrayOf()
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/MyPlanet.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.app.usage.UsageStats
import android.app.usage.UsageStatsManager
import android.content.Context
import android.content.SharedPreferences
import android.os.Build
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import java.io.Serializable
import java.util.Calendar
import java.util.Date
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.VersionUtils

class MyPlanet : Serializable {
    var planetVersion: String? = null
    var minapkcode = 0
    var latestapkcode = 0
    var apkpath: String? = null
    var appname: String? = null
    var localapkpath: String? = null
    override fun toString(): String {
        return appname!!
    }

    companion object {
        @JvmStatic
        fun getMyPlanetActivities(context: Context, pref: SharedPreferences, model: RealmUserModel): JsonObject {
            val postJSON = JsonObject()
            val preferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            val planet = Gson().fromJson(preferences.getString("versionDetail", ""), MyPlanet::class.java)
            if (planet != null) postJSON.addProperty("planetVersion", planet.planetVersion)
            postJSON.addProperty("_id", VersionUtils.getAndroidId(MainApplication.context) + "@" + NetworkUtils.getUniqueIdentifier())
            postJSON.addProperty("last_synced", pref.getLong("LastSync", 0))
            postJSON.addProperty("parentCode", model.parentCode)
            postJSON.addProperty("createdOn", model.planetCode)
            postJSON.addProperty("type", "usages")
            postJSON.add("usages", getTabletUsages(context))
            return postJSON
        }

        @JvmStatic
        fun getNormalMyPlanetActivities(context: Context, pref: SharedPreferences, model: RealmUserModel): JsonObject {
            val postJSON = JsonObject()
            val preferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            val planet = Gson().fromJson(preferences.getString("versionDetail", ""), MyPlanet::class.java)
            if (planet != null) postJSON.addProperty("planetVersion", planet.planetVersion)
            postJSON.addProperty("last_synced", pref.getLong("LastSync", 0))
            postJSON.addProperty("parentCode", model.parentCode)
            postJSON.addProperty("createdOn", model.planetCode)
            postJSON.addProperty("version", VersionUtils.getVersionCode(context))
            postJSON.addProperty("versionName", VersionUtils.getVersionName(context))
            postJSON.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            postJSON.addProperty("uniqueAndroidId", VersionUtils.getAndroidId(MainApplication.context))
            postJSON.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            postJSON.addProperty("deviceName", NetworkUtils.getDeviceName())
            postJSON.addProperty("time", Date().time)
            postJSON.addProperty("type", "sync")
            return postJSON
        }

        @JvmStatic
        fun getTabletUsages(context: Context): JsonArray {
            val cal = Calendar.getInstance()
            val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            cal.timeInMillis = settings.getLong("lastUsageUploaded", 0)
            val arr = JsonArray()
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) {
                val mUsageStatsManager = MainApplication.context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager
                val queryUsageStats = mUsageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, cal.timeInMillis, System.currentTimeMillis())
                for (s in queryUsageStats) {
                    addStats(s, arr, context)
                }
            }
            return arr
        }

        private fun addStats(s: UsageStats, arr: JsonArray, context: Context) {
            if (s.packageName == MainApplication.context.packageName) {
                val `object` = JsonObject()
                `object`.addProperty("lastTimeUsed", if (s.lastTimeUsed > 0) s.lastTimeUsed else 0)
                `object`.addProperty("firstTimeUsed", if (s.firstTimeStamp > 0) s.lastTimeStamp else 0)
                `object`.addProperty("totalForegroundTime", s.totalTimeInForeground)
                val totalUsed = s.lastTimeUsed - s.firstTimeStamp
                `object`.addProperty("totalUsed", if (totalUsed > 0) totalUsed else 0)
                `object`.addProperty("version", VersionUtils.getVersionCode(context))
                `object`.addProperty("versionName", VersionUtils.getVersionName(context))
                `object`.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
                `object`.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
                `object`.addProperty("deviceName", NetworkUtils.getDeviceName())
                `object`.addProperty("time", Date().time)
                arr.add(`object`)
            }
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.app.usage.UsageStats
import android.app.usage.UsageStatsManager
import android.content.Context
import android.content.SharedPreferences
import android.os.Build
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import java.io.Serializable
import java.util.Calendar
import java.util.Date
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.VersionUtils

class MyPlanet : Serializable {
    var planetVersion: String? = null
    var minapkcode = 0
    var latestapkcode = 0
    var apkpath: String? = null
    var appname: String? = null
    var localapkpath: String? = null
    override fun toString(): String {
        return appname!!
    }

    companion object {
        @JvmStatic
        fun getMyPlanetActivities(context: Context, pref: SharedPreferences, model: RealmUserModel): JsonObject {
            val postJSON = JsonObject()
            val preferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            val planet = Gson().fromJson(preferences.getString("versionDetail", ""), MyPlanet::class.java)
            if (planet != null) postJSON.addProperty("planetVersion", planet.planetVersion)
            postJSON.addProperty("_id", VersionUtils.getAndroidId(MainApplication.context) + "@" + NetworkUtils.getUniqueIdentifier())
            postJSON.addProperty("last_synced", pref.getLong("LastSync", 0))
            postJSON.addProperty("parentCode", model.parentCode)
            postJSON.addProperty("createdOn", model.planetCode)
            postJSON.addProperty("type", "usages")
            postJSON.add("usages", getTabletUsages(context))
            return postJSON
        }

        @JvmStatic
        fun getNormalMyPlanetActivities(context: Context, pref: SharedPreferences, model: RealmUserModel): JsonObject {
            val postJSON = JsonObject()
            val preferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            val planet = Gson().fromJson(preferences.getString("versionDetail", ""), MyPlanet::class.java)
            if (planet != null) postJSON.addProperty("planetVersion", planet.planetVersion)
            postJSON.addProperty("last_synced", pref.getLong("LastSync", 0))
            postJSON.addProperty("parentCode", model.parentCode)
            postJSON.addProperty("createdOn", model.planetCode)
            postJSON.addProperty("version", VersionUtils.getVersionCode(context))
            postJSON.addProperty("versionName", VersionUtils.getVersionName(context))
            postJSON.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            postJSON.addProperty("uniqueAndroidId", VersionUtils.getAndroidId(MainApplication.context))
            postJSON.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            postJSON.addProperty("deviceName", NetworkUtils.getDeviceName())
            postJSON.addProperty("time", Date().time)
            postJSON.addProperty("type", "sync")
            return postJSON
        }

        @JvmStatic
        fun getTabletUsages(context: Context): JsonArray {
            val cal = Calendar.getInstance()
            val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            cal.timeInMillis = settings.getLong("lastUsageUploaded", 0)
            val arr = JsonArray()
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) {
                val mUsageStatsManager = MainApplication.context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager
                val queryUsageStats = mUsageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, cal.timeInMillis, System.currentTimeMillis())
                for (s in queryUsageStats) {
                    addStats(s, arr, context)
                }
            }
            return arr
        }

        private fun addStats(s: UsageStats, arr: JsonArray, context: Context) {
            if (s.packageName == MainApplication.context.packageName) {
                val `object` = JsonObject()
                `object`.addProperty("lastTimeUsed", if (s.lastTimeUsed > 0) s.lastTimeUsed else 0)
                `object`.addProperty("firstTimeUsed", if (s.firstTimeStamp > 0) s.lastTimeStamp else 0)
                `object`.addProperty("totalForegroundTime", s.totalTimeInForeground)
                val totalUsed = s.lastTimeUsed - s.firstTimeStamp
                `object`.addProperty("totalUsed", if (totalUsed > 0) totalUsed else 0)
                `object`.addProperty("version", VersionUtils.getVersionCode(context))
                `object`.addProperty("versionName", VersionUtils.getVersionName(context))
                `object`.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
                `object`.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
                `object`.addProperty("deviceName", NetworkUtils.getDeviceName())
                `object`.addProperty("time", Date().time)
                arr.add(`object`)
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmCertification.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmCertification : RealmObject() {
    @PrimaryKey
    var _id: String? = null
    var _rev: String? = null
    var name: String? = null
    private var courseIds: String? = null

    fun setCourseIds(courseIds: JsonArray?) {
        this.courseIds = Gson().toJson(courseIds)
    }

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, `object`: JsonObject?) {
            val id = JsonUtils.getString("_id", `object`)
            var certification = mRealm.where(RealmCertification::class.java).equalTo("_id", id).findFirst()
            if (certification == null) {
                certification = mRealm.createObject(RealmCertification::class.java, id)
            }
            certification?.name = JsonUtils.getString("name", `object`)
            certification?.setCourseIds(JsonUtils.getJsonArray("courseIds", `object`))
        }

        @JvmStatic
        fun isCourseCertified(realm: Realm, courseId: String?): Boolean {
            if (courseId == null) {
                return false
            }
            val c =
                realm.where(RealmCertification::class.java).contains("courseIds", courseId).count()
            return c > 0
        }
    }
}
=======
package org.ole.planet.myplanet.model


import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmCertification : RealmObject() {
    @PrimaryKey
    var _id: String? = null
    var _rev: String? = null
    var name: String? = null
    private var courseIds: String? = null

    fun setCourseIds(courseIds: JsonArray?) {
        this.courseIds = Gson().toJson(courseIds)
    }

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, `object`: JsonObject?) {
            val id = JsonUtils.getString("_id", `object`)
            var certification = mRealm.where(RealmCertification::class.java).equalTo("_id", id).findFirst()
            if (certification == null) {
                certification = mRealm.createObject(RealmCertification::class.java, id)
            }
            certification?.name = JsonUtils.getString("name", `object`)
            certification?.setCourseIds(JsonUtils.getJsonArray("courseIds", `object`))
        }

        @JvmStatic
        fun isCourseCertified(realm: Realm, courseId: String?): Boolean {
            if (courseId == null) {
                return false
            }
            val c =
                realm.where(RealmCertification::class.java).contains("courseIds", courseId).count()
            return c > 0
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmAchievement.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.text.TextUtils
import android.widget.EditText
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonElement
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmAchievement : RealmObject() {
    var achievements: RealmList<String>? = null
    var references: RealmList<String>? = null
    var purpose: String? = null
    var achievementsHeader: String? = null
    var sendToNation: String? = null
    var _rev: String? = null
    @PrimaryKey
    var _id: String? = null
    var goals: String? = null

    val achievementsArray: JsonArray
        get() {
            val array = JsonArray()
            for (s in achievements ?: emptyList()) {
                val ob = Gson().fromJson(s, JsonElement::class.java)
                array.add(ob)
            }
            return array
        }

    fun getReferencesArray(): JsonArray {
        val array = JsonArray()
        for (s in references ?: emptyList()) {
            val ob = Gson().fromJson(s, JsonElement::class.java)
            array.add(ob)
        }
        return array
    }

    fun setAchievements(ac: JsonArray) {
        achievements = RealmList()
        for (el in ac) {
            val achievement = Gson().toJson(el)
            if (achievements?.contains(achievement) != true) {
                achievements?.add(achievement)
            }
        }
    }

    fun setReferences(of: JsonArray?) {
        references = RealmList()
        if (of == null) return
        for (el in of) {
            val e = Gson().toJson(el)
            if (references?.contains(e) != true) {
                references?.add(e)
            }
        }
    }

    companion object {
        @JvmStatic
        fun serialize(sub: RealmAchievement): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("_id", sub._id)
            if (!TextUtils.isEmpty(sub._rev)) `object`.addProperty("_rev", sub._rev)
            `object`.addProperty("goals", sub.goals)
            `object`.addProperty("purpose", sub.purpose)
            `object`.addProperty("achievementsHeader", sub.achievementsHeader)
            `object`.add("references", sub.getReferencesArray())
            `object`.add("achievements", sub.achievementsArray)
            return `object`
        }

        @JvmStatic
        fun createReference(name: String?, relation: EditText, phone: EditText, email: EditText): JsonObject {
            val ob = JsonObject()
            ob.addProperty("name", name)
            ob.addProperty("phone", phone.text.toString())
            ob.addProperty("relationship", relation.text.toString())
            ob.addProperty("email", email.text.toString())
            return ob
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var achievement = mRealm.where(RealmAchievement::class.java)
                .equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (achievement == null) {
                achievement = mRealm.createObject(RealmAchievement::class.java, JsonUtils.getString("_id", act))
            }
            achievement?._rev = JsonUtils.getString("_rev", act)
            achievement?.purpose = JsonUtils.getString("purpose", act)
            achievement?.goals = JsonUtils.getString("goals", act)
            achievement?.achievementsHeader = JsonUtils.getString("achievementsHeader", act)
            achievement?.setReferences(JsonUtils.getJsonArray("references", act))
            achievement?.setAchievements(JsonUtils.getJsonArray("achievements", act))
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.text.TextUtils
import android.widget.EditText
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonElement
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmAchievement : RealmObject() {
    var achievements: RealmList<String>? = null
    var references: RealmList<String>? = null
    var purpose: String? = null
    var achievementsHeader: String? = null
    var sendToNation: String? = null
    var _rev: String? = null
    @PrimaryKey
    var _id: String? = null
    var goals: String? = null

    val achievementsArray: JsonArray
        get() {
            val array = JsonArray()
            for (s in achievements ?: emptyList()) {
                val ob = Gson().fromJson(s, JsonElement::class.java)
                array.add(ob)
            }
            return array
        }

    fun getReferencesArray(): JsonArray {
        val array = JsonArray()
        for (s in references ?: emptyList()) {
            val ob = Gson().fromJson(s, JsonElement::class.java)
            array.add(ob)
        }
        return array
    }

    fun setAchievements(ac: JsonArray) {
        achievements = RealmList()
        for (el in ac) {
            val achievement = Gson().toJson(el)
            if (achievements?.contains(achievement) != true) {
                achievements?.add(achievement)
            }
        }
    }

    fun setReferences(of: JsonArray?) {
        references = RealmList()
        if (of == null) return
        for (el in of) {
            val e = Gson().toJson(el)
            if (references?.contains(e) != true) {
                references?.add(e)
            }
        }
    }

    companion object {
        @JvmStatic
        fun serialize(sub: RealmAchievement): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("_id", sub._id)
            if (!TextUtils.isEmpty(sub._rev)) `object`.addProperty("_rev", sub._rev)
            `object`.addProperty("goals", sub.goals)
            `object`.addProperty("purpose", sub.purpose)
            `object`.addProperty("achievementsHeader", sub.achievementsHeader)
            `object`.add("references", sub.getReferencesArray())
            `object`.add("achievements", sub.achievementsArray)
            return `object`
        }

        @JvmStatic
        fun createReference(name: String?, relation: EditText, phone: EditText, email: EditText): JsonObject {
            val ob = JsonObject()
            ob.addProperty("name", name)
            ob.addProperty("phone", phone.text.toString())
            ob.addProperty("relationship", relation.text.toString())
            ob.addProperty("email", email.text.toString())
            return ob
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var achievement = mRealm.where(RealmAchievement::class.java)
                .equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (achievement == null) {
                achievement = mRealm.createObject(RealmAchievement::class.java, JsonUtils.getString("_id", act))
            }
            achievement?._rev = JsonUtils.getString("_rev", act)
            achievement?.purpose = JsonUtils.getString("purpose", act)
            achievement?.goals = JsonUtils.getString("goals", act)
            achievement?.achievementsHeader = JsonUtils.getString("achievementsHeader", act)
            achievement?.setReferences(JsonUtils.getJsonArray("references", act))
            achievement?.setAchievements(JsonUtils.getJsonArray("achievements", act))
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmNotification.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import java.util.UUID

open class RealmNotification : RealmObject() {
    @PrimaryKey
    var id: String = UUID.randomUUID().toString()
    var userId: String = ""
    var message: String = ""
    var isRead: Boolean = false
    var createdAt: Date = Date()
    var type: String = ""
    var relatedId: String? = null
    var title: String? = null
}
=======
package org.ole.planet.myplanet.model


import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import java.util.UUID

open class RealmNotification : RealmObject() {
    @PrimaryKey
    var id: String = UUID.randomUUID().toString()
    var userId: String = ""
    var message: String = ""
    var isRead: Boolean = false
    var createdAt: Date = Date()
    var type: String = ""
    var relatedId: String? = null
    var title: String? = null
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmUserModel.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.SharedPreferences
import android.util.Base64
import androidx.core.content.edit
import androidx.core.net.toUri
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.io.File
import java.io.InputStream
import java.util.Locale
import java.util.UUID
import org.apache.commons.lang3.StringUtils
import org.json.JSONException
import org.json.JSONObject
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities
import org.ole.planet.myplanet.utilities.VersionUtils

open class RealmUserModel : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var name: String? = null
    var rolesList: RealmList<String?>? = null
    var userAdmin: Boolean? = null
    var joinDate: Long = 0
    var firstName: String? = null
    var lastName: String? = null
    var middleName: String? = null
    var email: String? = null
    var planetCode: String? = null
    var parentCode: String? = null
    var phoneNumber: String? = null
    var password_scheme: String? = null
    var iterations: String? = null
    var derived_key: String? = null
    var level: String? = null
    var language: String? = null
    var gender: String? = null
    var salt: String? = null
    var dob: String? = null
    var age: String? = null
    var birthPlace: String? = null
    var userImage: String? = null
    var key: String? = null
    var iv: String? = null
    var password: String? = null
    var isUpdated = false
    var isShowTopbar = false
    var isArchived = false

    fun serialize(): JsonObject {
        val jsonObject = JsonObject()
        if (_id?.isNotEmpty() == true) {
            jsonObject.addProperty("_id", _id)
            jsonObject.addProperty("_rev", _rev)
        }
        jsonObject.addProperty("name", name)
        jsonObject.add("roles", getRoles())
        if (_id?.isEmpty() == true) {
            jsonObject.addProperty("password", password)
            jsonObject.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            jsonObject.addProperty("uniqueAndroidId", VersionUtils.getAndroidId(context))
            jsonObject.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
        } else {
            jsonObject.addProperty("derived_key", derived_key)
            jsonObject.addProperty("salt", salt)
            jsonObject.addProperty("password_scheme", password_scheme)
        }
        jsonObject.addProperty("isUserAdmin", userAdmin)
        jsonObject.addProperty("joinDate", joinDate)
        jsonObject.addProperty("firstName", firstName)
        jsonObject.addProperty("lastName", lastName)
        jsonObject.addProperty("middleName", middleName)
        jsonObject.addProperty("email", email)
        jsonObject.addProperty("language", language)
        jsonObject.addProperty("level", level)
        jsonObject.addProperty("type", "user")
        jsonObject.addProperty("gender", gender)
        jsonObject.addProperty("phoneNumber", phoneNumber)
        jsonObject.addProperty("birthDate", dob)
        jsonObject.addProperty("age", age)
        try {
            jsonObject.addProperty("iterations", iterations?.takeIf { it.isNotBlank() }?.toInt() ?: 10)
        } catch (e: NumberFormatException) {
            e.printStackTrace()
            jsonObject.addProperty("iterations", 10)
        }
        jsonObject.addProperty("parentCode", parentCode)
        jsonObject.addProperty("planetCode", planetCode)
        jsonObject.addProperty("birthPlace", birthPlace)
        jsonObject.addProperty("isArchived", isArchived)

        val base64Image = encodeImageToBase64(userImage)

        if (!base64Image.isNullOrEmpty()) {
            val attachmentObject = JsonObject()
            val imageData = JsonObject()
            imageData.addProperty("content_type", "image/jpeg")
            imageData.addProperty("data", base64Image)

            attachmentObject.add("img", imageData)
            jsonObject.add("_attachments", attachmentObject)
        }

        return jsonObject
    }

    fun encodeImageToBase64(imagePath: String?): String? {
        if (imagePath.isNullOrEmpty()) return null
        return try {
            val inputStream: InputStream? = if (imagePath.startsWith("content://")) {
                val uri = imagePath.toUri()
                context.contentResolver.openInputStream(uri)
            } else {
                File(imagePath).inputStream()
            }

            inputStream?.use {
                val bytes = it.readBytes()
                Base64.encodeToString(bytes, Base64.NO_WRAP)
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private fun getRoles(): JsonArray {
        val ar = JsonArray()
        for (s in rolesList ?: emptyList())    {
            ar.add(s)
        }
        return ar
    }

    fun setRoles(roles: RealmList<String?>?) {
        rolesList = roles
    }

    fun getRoleAsString(): String {
        return StringUtils.join(rolesList, ",")
    }

    fun getFullName(): String {
        return "$firstName $lastName"
    }

    fun getFullNameWithMiddleName(): String {
        return "$firstName ${middleName ?: ""} $lastName"
    }

    fun addImageUrl(jsonDoc: JsonObject?) {
        if (jsonDoc?.has("_attachments") == true) {
            val element = JsonParser.parseString(jsonDoc["_attachments"].asJsonObject.toString())
            val obj = element.asJsonObject
            val entries = obj.entrySet()
            for ((key1) in entries) {
                userImage = UrlUtils.getUserImageUrl(id, key1)
                break
            }
        }
    }

    fun isManager(): Boolean {
        val roles = getRoles()
        val isManager = roles.toString().lowercase(Locale.ROOT).contains("manager") || userAdmin ?: false
        return isManager
    }

    fun isLeader(): Boolean {
        val roles = getRoles()
        return roles.toString().lowercase(Locale.ROOT).contains("leader")
    }

    fun isGuest(): Boolean {
        val hasGuestId = _id?.startsWith("guest_") == true
        val hasGuestRole = rolesList?.any { it?.lowercase() == "guest" } == true
        return hasGuestId || (hasGuestRole && rolesList?.any { it?.lowercase() == "learner" } != true)
    }

    override fun toString(): String {
        return "$name"
    }

    companion object {
        @JvmStatic
        fun createGuestUser(username: String?, mRealm: Realm, settings: SharedPreferences): RealmUserModel? {
            val `object` = JsonObject()
            `object`.addProperty("_id", "guest_$username")
            `object`.addProperty("name", username)
            `object`.addProperty("firstName", username)
            val rolesArray = JsonArray()
            rolesArray.add("guest")
            `object`.add("roles", rolesArray)
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            return populateUsersTable(`object`, mRealm, settings)
        }

        @JvmStatic
        fun populateUsersTable(jsonDoc: JsonObject?, mRealm: Realm?, settings: SharedPreferences): RealmUserModel? {
            if (jsonDoc == null || mRealm == null) return null
            try {
                val id = JsonUtils.getString("_id", jsonDoc).takeIf { it.isNotEmpty() } ?: UUID.randomUUID().toString()
                val userName = JsonUtils.getString("name", jsonDoc)
                var user: RealmUserModel? = null

                if (!mRealm.isInTransaction) {
                    mRealm.executeTransaction { realm ->
                        user = realm.where(RealmUserModel::class.java)
                            .equalTo("_id", id)
                            .findFirst()

                        if (user == null && id.startsWith("org.couchdb.user:") && userName.isNotEmpty()) {
                            val guestUser = realm.where(RealmUserModel::class.java)
                                .equalTo("name", userName)
                                .beginsWith("_id", "guest_")
                                .findFirst()

                            if (guestUser != null) {
                                val tempData = JsonObject()
                                tempData.addProperty("_id", id)
                                tempData.addProperty("name", guestUser.name)
                                tempData.addProperty("firstName", guestUser.firstName)
                                tempData.addProperty("lastName", guestUser.lastName)
                                tempData.addProperty("middleName", guestUser.middleName)
                                tempData.addProperty("email", guestUser.email)
                                tempData.addProperty("phoneNumber", guestUser.phoneNumber)
                                tempData.addProperty("level", guestUser.level)
                                tempData.addProperty("language", guestUser.language)
                                tempData.addProperty("gender", guestUser.gender)
                                tempData.addProperty("birthDate", guestUser.dob)
                                tempData.addProperty("planetCode", guestUser.planetCode)
                                tempData.addProperty("parentCode", guestUser.parentCode)
                                tempData.addProperty("userImage", guestUser.userImage)
                                tempData.addProperty("joinDate", guestUser.joinDate)
                                tempData.addProperty("isShowTopbar", guestUser.isShowTopbar)
                                tempData.addProperty("isArchived", guestUser.isArchived)

                                val rolesArray = JsonArray()
                                guestUser.rolesList?.forEach { role ->
                                    rolesArray.add(role)
                                }
                                tempData.add("roles", rolesArray)
                                guestUser.deleteFromRealm()
                                user = realm.createObject(RealmUserModel::class.java, id)
                                user?.let { insertIntoUsers(tempData, it, settings) }
                            }
                        }

                        if (user == null) {
                            user = realm.createObject(RealmUserModel::class.java, id)
                        }
                        user?.let { insertIntoUsers(jsonDoc, it, settings) }
                    }
                } else {
                    user = mRealm.where(RealmUserModel::class.java)
                        .equalTo("_id", id)
                        .findFirst()

                    if (user == null && id.startsWith("org.couchdb.user:") && userName.isNotEmpty()) {
                        val guestUser = mRealm.where(RealmUserModel::class.java)
                            .equalTo("name", userName)
                            .beginsWith("_id", "guest_")
                            .findFirst()

                        if (guestUser != null) {
                            val tempData = JsonObject()
                            tempData.addProperty("_id", id)
                            tempData.addProperty("name", guestUser.name)
                            tempData.addProperty("firstName", guestUser.firstName)
                            tempData.addProperty("lastName", guestUser.lastName)
                            tempData.addProperty("middleName", guestUser.middleName)
                            tempData.addProperty("email", guestUser.email)
                            tempData.addProperty("phoneNumber", guestUser.phoneNumber)
                            tempData.addProperty("level", guestUser.level)
                            tempData.addProperty("language", guestUser.language)
                            tempData.addProperty("gender", guestUser.gender)
                            tempData.addProperty("birthDate", guestUser.dob)
                            tempData.addProperty("planetCode", guestUser.planetCode)
                            tempData.addProperty("parentCode", guestUser.parentCode)
                            tempData.addProperty("userImage", guestUser.userImage)
                            tempData.addProperty("joinDate", guestUser.joinDate)
                            tempData.addProperty("isShowTopbar", guestUser.isShowTopbar)
                            tempData.addProperty("isArchived", guestUser.isArchived)
                            val rolesArray = JsonArray()
                            guestUser.rolesList?.forEach { role ->
                                rolesArray.add(role)
                            }
                            tempData.add("roles", rolesArray)
                            guestUser.deleteFromRealm()
                            user = mRealm.createObject(RealmUserModel::class.java, id)
                            user?.let { insertIntoUsers(tempData, it, settings) }
                        }
                    }

                    if (user == null) {
                        user = mRealm.createObject(RealmUserModel::class.java, id)
                    }
                    user?.let { insertIntoUsers(jsonDoc, it, settings) }
                }
                return user
            } catch (err: Exception) {
                err.printStackTrace()
            }
            return null
        }

        private fun insertIntoUsers(jsonDoc: JsonObject?, user: RealmUserModel, settings: SharedPreferences) {
            if (jsonDoc == null) return

            val planetCodes = JsonUtils.getString("planetCode", jsonDoc)
            val rolesArray = JsonUtils.getJsonArray("roles", jsonDoc)
            val newId = JsonUtils.getString("_id", jsonDoc)

            user.apply {
                _rev = JsonUtils.getString("_rev", jsonDoc)
                _id = newId
                name = JsonUtils.getString("name", jsonDoc)
                setRoles(RealmList<String?>().apply {
                    for (i in 0 until rolesArray.size()) {
                        add(JsonUtils.getString(rolesArray, i))
                    }
                })
                userAdmin = JsonUtils.getBoolean("isUserAdmin", jsonDoc)
                val newJoinDate = JsonUtils.getLong("joinDate", jsonDoc)
                if (newJoinDate != 0L || joinDate == 0L) {
                    joinDate = newJoinDate
                }

                val newFirstName = JsonUtils.getString("firstName", jsonDoc)
                if (newFirstName.isNotEmpty() || firstName.isNullOrEmpty()) {
                    firstName = newFirstName
                }

                val newLastName = JsonUtils.getString("lastName", jsonDoc)
                if (newLastName.isNotEmpty() || lastName.isNullOrEmpty()) {
                    lastName = newLastName
                }

                val newMiddleName = JsonUtils.getString("middleName", jsonDoc)
                if (newMiddleName.isNotEmpty() || middleName.isNullOrEmpty()) {
                    middleName = newMiddleName
                }

                val newEmail = JsonUtils.getString("email", jsonDoc)
                if (newEmail.isNotEmpty() || email.isNullOrEmpty()) {
                    email = newEmail
                }

                val newPhoneNumber = JsonUtils.getString("phoneNumber", jsonDoc)
                if (newPhoneNumber.isNotEmpty() || phoneNumber.isNullOrEmpty()) {
                    phoneNumber = newPhoneNumber
                }

                val newLevel = JsonUtils.getString("level", jsonDoc)
                if (newLevel.isNotEmpty() || level.isNullOrEmpty()) {
                    level = newLevel
                }

                val newLanguage = JsonUtils.getString("language", jsonDoc)
                if (newLanguage.isNotEmpty() || language.isNullOrEmpty()) {
                    language = newLanguage
                }

                val newGender = JsonUtils.getString("gender", jsonDoc)
                if (newGender.isNotEmpty() || gender.isNullOrEmpty()) {
                    gender = newGender
                }

                val newDob = JsonUtils.getString("birthDate", jsonDoc)
                if (newDob.isNotEmpty() || dob.isNullOrEmpty()) {
                    dob = newDob
                }

                val newBirthPlace = JsonUtils.getString("birthPlace", jsonDoc)
                if (newBirthPlace.isNotEmpty() || birthPlace.isNullOrEmpty()) {
                    birthPlace = newBirthPlace
                }

                val newAge = JsonUtils.getString("age", jsonDoc)
                if (newAge.isNotEmpty() || age.isNullOrEmpty()) {
                    age = newAge
                }
                planetCode = planetCodes
                parentCode = JsonUtils.getString("parentCode", jsonDoc)
                if (_id?.isEmpty() == true) {
                    password = JsonUtils.getString("password", jsonDoc)
                }
                password_scheme = JsonUtils.getString("password_scheme", jsonDoc)
                iterations = JsonUtils.getString("iterations", jsonDoc)
                derived_key = JsonUtils.getString("derived_key", jsonDoc)
                salt = JsonUtils.getString("salt", jsonDoc)
                isShowTopbar = true
                isArchived = JsonUtils.getBoolean("isArchived", jsonDoc)
                addImageUrl(jsonDoc)
            }

            if (planetCodes.isNotEmpty()) {
                settings.edit { putString("planetCode", planetCodes) }
            }
        }

        @JvmStatic
        fun isUserExists(realm: Realm, name: String?): Boolean {
            return realm.where(RealmUserModel::class.java)
                .equalTo("name", name)
                .not().beginsWith("_id", "guest").count() > 0
        }

        fun updateUserDetails(realm: Realm, userId: String?, firstName: String?, lastName: String?,
        middleName: String?, email: String?, phoneNumber: String?, level: String?, language: String?,
        gender: String?, dob: String?, onSuccess: () -> Unit) {
            realm.executeTransactionAsync({ mRealm ->
                val user = mRealm.where(RealmUserModel::class.java).equalTo("id", userId).findFirst()
                if (user != null) {
                    user.firstName = firstName
                    user.lastName = lastName
                    user.middleName = middleName
                    user.email = email
                    user.phoneNumber = phoneNumber
                    user.level = level
                    user.language = language
                    user.gender = gender
                    user.dob = dob
                    user.isUpdated = true
                }
            }, {
                onSuccess.invoke()
                Utilities.toast(context, "User details updated successfully")
            }) {
                Utilities.toast(context, "User details update failed")
            }
        }

        @JvmStatic
        fun parseLeadersJson(jsonString: String): List<RealmUserModel> {
            val leadersList = mutableListOf<RealmUserModel>()
            try {
                val jsonObject = JSONObject(jsonString)
                val docsArray = jsonObject.getJSONArray("docs")
                for (i in 0 until docsArray.length()) {
                    val docObject = docsArray.getJSONObject(i)
                    val user = RealmUserModel()
                    user.name = docObject.getString("name")
                    if (!docObject.isNull("firstName")) {
                        user.firstName = docObject.getString("firstName")
                    }
                    if (!docObject.isNull("lastName")) {
                        user.lastName = docObject.getString("lastName")
                    }
                    if (!docObject.isNull("email")) {
                        user.email = docObject.getString("email")
                    }
                    leadersList.add(user)
                }
            } catch (e: JSONException) {
                e.printStackTrace()
            }
            return leadersList
        }

        @JvmStatic
        fun cleanupDuplicateUsers(realm: Realm, onSuccess: () -> Unit) {
            realm.executeTransactionAsync({ mRealm: Realm ->
                val allUsers = mRealm.where(RealmUserModel::class.java).findAll()
                val usersByName = allUsers.groupBy { it.name }

                usersByName.forEach { (_, users) ->
                    if (users.size > 1) {
                        val sortedUsers = users.sortedWith { user1, user2 ->
                            when {
                                user1._id?.startsWith("org.couchdb.user:") == true &&
                                        user2._id?.startsWith("guest_") == true -> -1
                                user1._id?.startsWith("guest_") == true &&
                                        user2._id?.startsWith("org.couchdb.user:") == true -> 1
                                else -> 0
                            }
                        }

                        for (i in 1 until sortedUsers.size) {
                            sortedUsers[i].deleteFromRealm()
                        }
                    }
                }
            }, {
                onSuccess.invoke()
            }) {
            }
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.content.SharedPreferences
import android.util.Base64
import androidx.core.content.edit
import androidx.core.net.toUri
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.io.File
import java.io.InputStream
import java.util.Locale
import java.util.UUID
import org.apache.commons.lang3.StringUtils
import org.json.JSONException
import org.json.JSONObject
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities
import org.ole.planet.myplanet.utilities.VersionUtils

open class RealmUserModel : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var name: String? = null
    var rolesList: RealmList<String?>? = null
    var userAdmin: Boolean? = null
    var joinDate: Long = 0
    var firstName: String? = null
    var lastName: String? = null
    var middleName: String? = null
    var email: String? = null
    var planetCode: String? = null
    var parentCode: String? = null
    var phoneNumber: String? = null
    var password_scheme: String? = null
    var iterations: String? = null
    var derived_key: String? = null
    var level: String? = null
    var language: String? = null
    var gender: String? = null
    var salt: String? = null
    var dob: String? = null
    var age: String? = null
    var birthPlace: String? = null
    var userImage: String? = null
    var key: String? = null
    var iv: String? = null
    var password: String? = null
    var isUpdated = false
    var isShowTopbar = false
    var isArchived = false

    fun serialize(): JsonObject {
        val jsonObject = JsonObject()
        if (_id?.isNotEmpty() == true) {
            jsonObject.addProperty("_id", _id)
            jsonObject.addProperty("_rev", _rev)
        }
        jsonObject.addProperty("name", name)
        jsonObject.add("roles", getRoles())
        if (_id?.isEmpty() == true) {
            jsonObject.addProperty("password", password)
            jsonObject.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            jsonObject.addProperty("uniqueAndroidId", VersionUtils.getAndroidId(context))
            jsonObject.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
        } else {
            jsonObject.addProperty("derived_key", derived_key)
            jsonObject.addProperty("salt", salt)
            jsonObject.addProperty("password_scheme", password_scheme)
        }
        jsonObject.addProperty("isUserAdmin", userAdmin)
        jsonObject.addProperty("joinDate", joinDate)
        jsonObject.addProperty("firstName", firstName)
        jsonObject.addProperty("lastName", lastName)
        jsonObject.addProperty("middleName", middleName)
        jsonObject.addProperty("email", email)
        jsonObject.addProperty("language", language)
        jsonObject.addProperty("level", level)
        jsonObject.addProperty("type", "user")
        jsonObject.addProperty("gender", gender)
        jsonObject.addProperty("phoneNumber", phoneNumber)
        jsonObject.addProperty("birthDate", dob)
        jsonObject.addProperty("age", age)
        try {
            jsonObject.addProperty("iterations", iterations?.takeIf { it.isNotBlank() }?.toInt() ?: 10)
        } catch (e: NumberFormatException) {
            e.printStackTrace()
            jsonObject.addProperty("iterations", 10)
        }
        jsonObject.addProperty("parentCode", parentCode)
        jsonObject.addProperty("planetCode", planetCode)
        jsonObject.addProperty("birthPlace", birthPlace)
        jsonObject.addProperty("isArchived", isArchived)

        val base64Image = encodeImageToBase64(userImage)

        if (!base64Image.isNullOrEmpty()) {
            val attachmentObject = JsonObject()
            val imageData = JsonObject()
            imageData.addProperty("content_type", "image/jpeg")
            imageData.addProperty("data", base64Image)

            attachmentObject.add("img", imageData)
            jsonObject.add("_attachments", attachmentObject)
        }

        return jsonObject
    }

    fun encodeImageToBase64(imagePath: String?): String? {
        if (imagePath.isNullOrEmpty()) return null
        return try {
            val inputStream: InputStream? = if (imagePath.startsWith("content://")) {
                val uri = imagePath.toUri()
                context.contentResolver.openInputStream(uri)
            } else {
                File(imagePath).inputStream()
            }

            inputStream?.use {
                val bytes = it.readBytes()
                Base64.encodeToString(bytes, Base64.NO_WRAP)
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private fun getRoles(): JsonArray {
        val ar = JsonArray()
        for (s in rolesList ?: emptyList())    {
            ar.add(s)
        }
        return ar
    }

    fun setRoles(roles: RealmList<String?>?) {
        rolesList = roles
    }

    fun getRoleAsString(): String {
        return StringUtils.join(rolesList, ",")
    }

    fun getFullName(): String {
        return "$firstName $lastName"
    }

    fun getFullNameWithMiddleName(): String {
        return "$firstName ${middleName ?: ""} $lastName"
    }

    fun addImageUrl(jsonDoc: JsonObject?) {
        if (jsonDoc?.has("_attachments") == true) {
            val element = JsonParser.parseString(jsonDoc["_attachments"].asJsonObject.toString())
            val obj = element.asJsonObject
            val entries = obj.entrySet()
            for ((key1) in entries) {
                userImage = UrlUtils.getUserImageUrl(id, key1)
                break
            }
        }
    }

    fun isManager(): Boolean {
        val roles = getRoles()
        val isManager = roles.toString().lowercase(Locale.ROOT).contains("manager") || userAdmin ?: false
        return isManager
    }

    fun isLeader(): Boolean {
        val roles = getRoles()
        return roles.toString().lowercase(Locale.ROOT).contains("leader")
    }

    fun isGuest(): Boolean {
        val hasGuestId = _id?.startsWith("guest_") == true
        val hasGuestRole = rolesList?.any { it?.lowercase() == "guest" } == true
        return hasGuestId || (hasGuestRole && rolesList?.any { it?.lowercase() == "learner" } != true)
    }

    override fun toString(): String {
        return "$name"
    }

    companion object {
        @JvmStatic
        fun createGuestUser(username: String?, mRealm: Realm, settings: SharedPreferences): RealmUserModel? {
            val `object` = JsonObject()
            `object`.addProperty("_id", "guest_$username")
            `object`.addProperty("name", username)
            `object`.addProperty("firstName", username)
            val rolesArray = JsonArray()
            rolesArray.add("guest")
            `object`.add("roles", rolesArray)
            if (!mRealm.isInTransaction) mRealm.beginTransaction()
            return populateUsersTable(`object`, mRealm, settings)
        }

        @JvmStatic
        fun populateUsersTable(jsonDoc: JsonObject?, mRealm: Realm?, settings: SharedPreferences): RealmUserModel? {
            if (jsonDoc == null || mRealm == null) return null
            try {
                val id = JsonUtils.getString("_id", jsonDoc).takeIf { it.isNotEmpty() } ?: UUID.randomUUID().toString()
                val userName = JsonUtils.getString("name", jsonDoc)
                var user: RealmUserModel? = null

                if (!mRealm.isInTransaction) {
                    mRealm.executeTransaction { realm ->
                        user = realm.where(RealmUserModel::class.java)
                            .equalTo("_id", id)
                            .findFirst()

                        if (user == null && id.startsWith("org.couchdb.user:") && userName.isNotEmpty()) {
                            val guestUser = realm.where(RealmUserModel::class.java)
                                .equalTo("name", userName)
                                .beginsWith("_id", "guest_")
                                .findFirst()

                            if (guestUser != null) {
                                val tempData = JsonObject()
                                tempData.addProperty("_id", id)
                                tempData.addProperty("name", guestUser.name)
                                tempData.addProperty("firstName", guestUser.firstName)
                                tempData.addProperty("lastName", guestUser.lastName)
                                tempData.addProperty("middleName", guestUser.middleName)
                                tempData.addProperty("email", guestUser.email)
                                tempData.addProperty("phoneNumber", guestUser.phoneNumber)
                                tempData.addProperty("level", guestUser.level)
                                tempData.addProperty("language", guestUser.language)
                                tempData.addProperty("gender", guestUser.gender)
                                tempData.addProperty("birthDate", guestUser.dob)
                                tempData.addProperty("planetCode", guestUser.planetCode)
                                tempData.addProperty("parentCode", guestUser.parentCode)
                                tempData.addProperty("userImage", guestUser.userImage)
                                tempData.addProperty("joinDate", guestUser.joinDate)
                                tempData.addProperty("isShowTopbar", guestUser.isShowTopbar)
                                tempData.addProperty("isArchived", guestUser.isArchived)

                                val rolesArray = JsonArray()
                                guestUser.rolesList?.forEach { role ->
                                    rolesArray.add(role)
                                }
                                tempData.add("roles", rolesArray)
                                guestUser.deleteFromRealm()
                                user = realm.createObject(RealmUserModel::class.java, id)
                                user?.let { insertIntoUsers(tempData, it, settings) }
                            }
                        }

                        if (user == null) {
                            user = realm.createObject(RealmUserModel::class.java, id)
                        }
                        user?.let { insertIntoUsers(jsonDoc, it, settings) }
                    }
                } else {
                    user = mRealm.where(RealmUserModel::class.java)
                        .equalTo("_id", id)
                        .findFirst()

                    if (user == null && id.startsWith("org.couchdb.user:") && userName.isNotEmpty()) {
                        val guestUser = mRealm.where(RealmUserModel::class.java)
                            .equalTo("name", userName)
                            .beginsWith("_id", "guest_")
                            .findFirst()

                        if (guestUser != null) {
                            val tempData = JsonObject()
                            tempData.addProperty("_id", id)
                            tempData.addProperty("name", guestUser.name)
                            tempData.addProperty("firstName", guestUser.firstName)
                            tempData.addProperty("lastName", guestUser.lastName)
                            tempData.addProperty("middleName", guestUser.middleName)
                            tempData.addProperty("email", guestUser.email)
                            tempData.addProperty("phoneNumber", guestUser.phoneNumber)
                            tempData.addProperty("level", guestUser.level)
                            tempData.addProperty("language", guestUser.language)
                            tempData.addProperty("gender", guestUser.gender)
                            tempData.addProperty("birthDate", guestUser.dob)
                            tempData.addProperty("planetCode", guestUser.planetCode)
                            tempData.addProperty("parentCode", guestUser.parentCode)
                            tempData.addProperty("userImage", guestUser.userImage)
                            tempData.addProperty("joinDate", guestUser.joinDate)
                            tempData.addProperty("isShowTopbar", guestUser.isShowTopbar)
                            tempData.addProperty("isArchived", guestUser.isArchived)
                            val rolesArray = JsonArray()
                            guestUser.rolesList?.forEach { role ->
                                rolesArray.add(role)
                            }
                            tempData.add("roles", rolesArray)
                            guestUser.deleteFromRealm()
                            user = mRealm.createObject(RealmUserModel::class.java, id)
                            user?.let { insertIntoUsers(tempData, it, settings) }
                        }
                    }

                    if (user == null) {
                        user = mRealm.createObject(RealmUserModel::class.java, id)
                    }
                    user?.let { insertIntoUsers(jsonDoc, it, settings) }
                }
                return user
            } catch (err: Exception) {
                err.printStackTrace()
            }
            return null
        }

        private fun insertIntoUsers(jsonDoc: JsonObject?, user: RealmUserModel, settings: SharedPreferences) {
            if (jsonDoc == null) return

            val planetCodes = JsonUtils.getString("planetCode", jsonDoc)
            val rolesArray = JsonUtils.getJsonArray("roles", jsonDoc)
            val newId = JsonUtils.getString("_id", jsonDoc)

            user.apply {
                _rev = JsonUtils.getString("_rev", jsonDoc)
                _id = newId
                name = JsonUtils.getString("name", jsonDoc)
                setRoles(RealmList<String?>().apply {
                    for (i in 0 until rolesArray.size()) {
                        add(JsonUtils.getString(rolesArray, i))
                    }
                })
                userAdmin = JsonUtils.getBoolean("isUserAdmin", jsonDoc)
                val newJoinDate = JsonUtils.getLong("joinDate", jsonDoc)
                if (newJoinDate != 0L || joinDate == 0L) {
                    joinDate = newJoinDate
                }

                val newFirstName = JsonUtils.getString("firstName", jsonDoc)
                if (newFirstName.isNotEmpty() || firstName.isNullOrEmpty()) {
                    firstName = newFirstName
                }

                val newLastName = JsonUtils.getString("lastName", jsonDoc)
                if (newLastName.isNotEmpty() || lastName.isNullOrEmpty()) {
                    lastName = newLastName
                }

                val newMiddleName = JsonUtils.getString("middleName", jsonDoc)
                if (newMiddleName.isNotEmpty() || middleName.isNullOrEmpty()) {
                    middleName = newMiddleName
                }

                val newEmail = JsonUtils.getString("email", jsonDoc)
                if (newEmail.isNotEmpty() || email.isNullOrEmpty()) {
                    email = newEmail
                }

                val newPhoneNumber = JsonUtils.getString("phoneNumber", jsonDoc)
                if (newPhoneNumber.isNotEmpty() || phoneNumber.isNullOrEmpty()) {
                    phoneNumber = newPhoneNumber
                }

                val newLevel = JsonUtils.getString("level", jsonDoc)
                if (newLevel.isNotEmpty() || level.isNullOrEmpty()) {
                    level = newLevel
                }

                val newLanguage = JsonUtils.getString("language", jsonDoc)
                if (newLanguage.isNotEmpty() || language.isNullOrEmpty()) {
                    language = newLanguage
                }

                val newGender = JsonUtils.getString("gender", jsonDoc)
                if (newGender.isNotEmpty() || gender.isNullOrEmpty()) {
                    gender = newGender
                }

                val newDob = JsonUtils.getString("birthDate", jsonDoc)
                if (newDob.isNotEmpty() || dob.isNullOrEmpty()) {
                    dob = newDob
                }

                val newBirthPlace = JsonUtils.getString("birthPlace", jsonDoc)
                if (newBirthPlace.isNotEmpty() || birthPlace.isNullOrEmpty()) {
                    birthPlace = newBirthPlace
                }

                val newAge = JsonUtils.getString("age", jsonDoc)
                if (newAge.isNotEmpty() || age.isNullOrEmpty()) {
                    age = newAge
                }
                planetCode = planetCodes
                parentCode = JsonUtils.getString("parentCode", jsonDoc)
                if (_id?.isEmpty() == true) {
                    password = JsonUtils.getString("password", jsonDoc)
                }
                password_scheme = JsonUtils.getString("password_scheme", jsonDoc)
                iterations = JsonUtils.getString("iterations", jsonDoc)
                derived_key = JsonUtils.getString("derived_key", jsonDoc)
                salt = JsonUtils.getString("salt", jsonDoc)
                isShowTopbar = true
                isArchived = JsonUtils.getBoolean("isArchived", jsonDoc)
                addImageUrl(jsonDoc)
            }

            if (planetCodes.isNotEmpty()) {
                settings.edit { putString("planetCode", planetCodes) }
            }
        }

        @JvmStatic
        fun isUserExists(realm: Realm, name: String?): Boolean {
            return realm.where(RealmUserModel::class.java)
                .equalTo("name", name)
                .not().beginsWith("_id", "guest").count() > 0
        }

        fun updateUserDetails(realm: Realm, userId: String?, firstName: String?, lastName: String?,
        middleName: String?, email: String?, phoneNumber: String?, level: String?, language: String?,
        gender: String?, dob: String?, onSuccess: () -> Unit) {
            realm.executeTransactionAsync({ mRealm ->
                val user = mRealm.where(RealmUserModel::class.java).equalTo("id", userId).findFirst()
                if (user != null) {
                    user.firstName = firstName
                    user.lastName = lastName
                    user.middleName = middleName
                    user.email = email
                    user.phoneNumber = phoneNumber
                    user.level = level
                    user.language = language
                    user.gender = gender
                    user.dob = dob
                    user.isUpdated = true
                }
            }, {
                onSuccess.invoke()
                Utilities.toast(context, "User details updated successfully")
            }) {
                Utilities.toast(context, "User details update failed")
            }
        }

        @JvmStatic
        fun parseLeadersJson(jsonString: String): List<RealmUserModel> {
            val leadersList = mutableListOf<RealmUserModel>()
            try {
                val jsonObject = JSONObject(jsonString)
                val docsArray = jsonObject.getJSONArray("docs")
                for (i in 0 until docsArray.length()) {
                    val docObject = docsArray.getJSONObject(i)
                    val user = RealmUserModel()
                    user.name = docObject.getString("name")
                    if (!docObject.isNull("firstName")) {
                        user.firstName = docObject.getString("firstName")
                    }
                    if (!docObject.isNull("lastName")) {
                        user.lastName = docObject.getString("lastName")
                    }
                    if (!docObject.isNull("email")) {
                        user.email = docObject.getString("email")
                    }
                    leadersList.add(user)
                }
            } catch (e: JSONException) {
                e.printStackTrace()
            }
            return leadersList
        }

        @JvmStatic
        fun cleanupDuplicateUsers(realm: Realm, onSuccess: () -> Unit) {
            realm.executeTransactionAsync({ mRealm: Realm ->
                val allUsers = mRealm.where(RealmUserModel::class.java).findAll()
                val usersByName = allUsers.groupBy { it.name }

                usersByName.forEach { (_, users) ->
                    if (users.size > 1) {
                        val sortedUsers = users.sortedWith { user1, user2 ->
                            when {
                                user1._id?.startsWith("org.couchdb.user:") == true &&
                                        user2._id?.startsWith("guest_") == true -> -1
                                user1._id?.startsWith("guest_") == true &&
                                        user2._id?.startsWith("org.couchdb.user:") == true -> 1
                                else -> 0
                            }
                        }

                        for (i in 1 until sortedUsers.size) {
                            sortedUsers[i].deleteFromRealm()
                        }
                    }
                }
            }, {
                onSuccess.invoke()
            }) {
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmMyHealthPojo.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.AndroidDecrypter
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmMyHealthPojo : RealmObject() {
    @PrimaryKey
    var _id: String? = null
    var userId: String? = null
    var isUpdated = false
    var _rev: String? = null
    var data: String? = null
    var temperature = 0f
        private set
    var pulse = 0
    var bp: String? = null
    var height = 0f
    var weight = 0f
        private set
    var vision: String? = null
    var date: Long = 0
    var hearing: String? = null
    var conditions: String? = null
    var isSelfExamination = false
    var planetCode: String? = null
    var isHasInfo = false
    var profileId: String? = null
    var creatorId: String? = null
    var gender: String? = null
    var age = 0
    fun getEncryptedDataAsJson(model: RealmUserModel): JsonObject {
        return if (!TextUtils.isEmpty(data)) Gson().fromJson(
            AndroidDecrypter.decrypt(data, model.key, model.iv), JsonObject::class.java
        ) else JsonObject()
    }

    fun setTemperature(temperature: Float) {
        this.temperature = temperature
    }

    fun setWeight(weight: Float) {
        this.weight = weight
    }

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var myHealth = mRealm.where(RealmMyHealthPojo::class.java)
                .equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (myHealth == null) {
                myHealth = mRealm.createObject(RealmMyHealthPojo::class.java, JsonUtils.getString("_id", act))
            }
            myHealth?.data = JsonUtils.getString("data", act)
            myHealth?.userId = JsonUtils.getString("_id", act)
            myHealth?._rev = JsonUtils.getString("_rev", act)
            myHealth?.setTemperature(JsonUtils.getFloat("temperature", act))
            myHealth?.isUpdated = false
            myHealth?.pulse = JsonUtils.getInt("pulse", act)
            myHealth?.height = JsonUtils.getFloat("height", act)
            myHealth?.setWeight(JsonUtils.getFloat("weight", act))
            myHealth?.vision = JsonUtils.getString("vision", act)
            myHealth?.hearing = JsonUtils.getString("hearing", act)
            myHealth?.bp = JsonUtils.getString("bp", act)
            myHealth?.isSelfExamination = JsonUtils.getBoolean("selfExamination", act)
            myHealth?.isHasInfo = JsonUtils.getBoolean("hasInfo", act)
            myHealth?.date = JsonUtils.getLong("date", act)
            myHealth?.profileId = JsonUtils.getString("profileId", act)
            myHealth?.creatorId = JsonUtils.getString("creatorId", act)
            myHealth?.age = JsonUtils.getInt("age", act)
            myHealth?.gender = JsonUtils.getString("gender", act)
            myHealth?.planetCode = JsonUtils.getString("planetCode", act)
            myHealth?.conditions = Gson().toJson(JsonUtils.getJsonObject("conditions", act))
        }

        @JvmStatic
        fun serialize(health: RealmMyHealthPojo): JsonObject {
            val `object` = JsonObject()
            if (!TextUtils.isEmpty(health.userId)) `object`.addProperty("_id", health.userId)
            if (!TextUtils.isEmpty(health._rev)) `object`.addProperty("_rev", health._rev)
            `object`.addProperty("data", health.data)
            JsonUtils.addFloat(`object`, "temperature", health.temperature)
            JsonUtils.addInteger(`object`, "pulse", health.pulse)
            JsonUtils.addString(`object`, "bp", health.bp)
            JsonUtils.addFloat(`object`, "height", health.height)
            JsonUtils.addFloat(`object`, "weight", health.weight)
            JsonUtils.addString(`object`, "vision", health.vision)
            JsonUtils.addString(`object`, "hearing", health.hearing)
            JsonUtils.addLong(`object`, "date", health.date)
            `object`.addProperty("selfExamination", health.isSelfExamination)
            JsonUtils.addString(`object`, "planetCode", health.planetCode)
            `object`.addProperty("hasInfo", health.isHasInfo)
            JsonUtils.addString(`object`, "profileId", health.profileId)
            JsonUtils.addString(`object`, "creatorId", health.profileId)
            JsonUtils.addString(`object`, "gender", health.gender)
            `object`.addProperty("age", health.age)
            JsonUtils.addJson(`object`, "conditions", Gson().fromJson(health.conditions, JsonObject::class.java)
            )
            return `object`
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.AndroidDecrypter
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmMyHealthPojo : RealmObject() {
    @PrimaryKey
    var _id: String? = null
    var userId: String? = null
    var isUpdated = false
    var _rev: String? = null
    var data: String? = null
    var temperature = 0f
        private set
    var pulse = 0
    var bp: String? = null
    var height = 0f
    var weight = 0f
        private set
    var vision: String? = null
    var date: Long = 0
    var hearing: String? = null
    var conditions: String? = null
    var isSelfExamination = false
    var planetCode: String? = null
    var isHasInfo = false
    var profileId: String? = null
    var creatorId: String? = null
    var gender: String? = null
    var age = 0
    fun getEncryptedDataAsJson(model: RealmUserModel): JsonObject {
        return if (!TextUtils.isEmpty(data)) Gson().fromJson(
            AndroidDecrypter.decrypt(data, model.key, model.iv), JsonObject::class.java
        ) else JsonObject()
    }

    fun setTemperature(temperature: Float) {
        this.temperature = temperature
    }

    fun setWeight(weight: Float) {
        this.weight = weight
    }

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var myHealth = mRealm.where(RealmMyHealthPojo::class.java)
                .equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (myHealth == null) {
                myHealth = mRealm.createObject(RealmMyHealthPojo::class.java, JsonUtils.getString("_id", act))
            }
            myHealth?.data = JsonUtils.getString("data", act)
            myHealth?.userId = JsonUtils.getString("_id", act)
            myHealth?._rev = JsonUtils.getString("_rev", act)
            myHealth?.setTemperature(JsonUtils.getFloat("temperature", act))
            myHealth?.isUpdated = false
            myHealth?.pulse = JsonUtils.getInt("pulse", act)
            myHealth?.height = JsonUtils.getFloat("height", act)
            myHealth?.setWeight(JsonUtils.getFloat("weight", act))
            myHealth?.vision = JsonUtils.getString("vision", act)
            myHealth?.hearing = JsonUtils.getString("hearing", act)
            myHealth?.bp = JsonUtils.getString("bp", act)
            myHealth?.isSelfExamination = JsonUtils.getBoolean("selfExamination", act)
            myHealth?.isHasInfo = JsonUtils.getBoolean("hasInfo", act)
            myHealth?.date = JsonUtils.getLong("date", act)
            myHealth?.profileId = JsonUtils.getString("profileId", act)
            myHealth?.creatorId = JsonUtils.getString("creatorId", act)
            myHealth?.age = JsonUtils.getInt("age", act)
            myHealth?.gender = JsonUtils.getString("gender", act)
            myHealth?.planetCode = JsonUtils.getString("planetCode", act)
            myHealth?.conditions = Gson().toJson(JsonUtils.getJsonObject("conditions", act))
        }

        @JvmStatic
        fun serialize(health: RealmMyHealthPojo): JsonObject {
            val `object` = JsonObject()
            if (!TextUtils.isEmpty(health.userId)) `object`.addProperty("_id", health.userId)
            if (!TextUtils.isEmpty(health._rev)) `object`.addProperty("_rev", health._rev)
            `object`.addProperty("data", health.data)
            JsonUtils.addFloat(`object`, "temperature", health.temperature)
            JsonUtils.addInteger(`object`, "pulse", health.pulse)
            JsonUtils.addString(`object`, "bp", health.bp)
            JsonUtils.addFloat(`object`, "height", health.height)
            JsonUtils.addFloat(`object`, "weight", health.weight)
            JsonUtils.addString(`object`, "vision", health.vision)
            JsonUtils.addString(`object`, "hearing", health.hearing)
            JsonUtils.addLong(`object`, "date", health.date)
            `object`.addProperty("selfExamination", health.isSelfExamination)
            JsonUtils.addString(`object`, "planetCode", health.planetCode)
            `object`.addProperty("hasInfo", health.isHasInfo)
            JsonUtils.addString(`object`, "profileId", health.profileId)
            JsonUtils.addString(`object`, "creatorId", health.profileId)
            JsonUtils.addString(`object`, "gender", health.gender)
            `object`.addProperty("age", health.age)
            JsonUtils.addJson(`object`, "conditions", Gson().fromJson(health.conditions, JsonObject::class.java)
            )
            return `object`
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmResourceActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.SharedPreferences
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmResourceActivity : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var createdOn: String? = null
    var _rev: String? = null
    var time: Long = 0
    var title: String? = null
    var resourceId: String? = null
    var parentCode: String? = null
    var type: String? = null
    var user: String? = null
    var androidId: String? = null

    companion object {
        @JvmStatic
        fun serializeResourceActivities(realmResourceActivities: RealmResourceActivity): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", realmResourceActivities.user)
            ob.addProperty("resourceId", realmResourceActivities.resourceId)
            ob.addProperty("type", realmResourceActivities.type)
            ob.addProperty("title", realmResourceActivities.title)
            ob.addProperty("time", realmResourceActivities.time)
            ob.addProperty("createdOn", realmResourceActivities.createdOn)
            ob.addProperty("parentCode", realmResourceActivities.parentCode)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            return ob
        }

        @JvmStatic
        fun onSynced(mRealm: Realm, settings: SharedPreferences) {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }
            val user = mRealm.where(RealmUserModel::class.java).equalTo("id", settings.getString("userId", "")).findFirst()
                ?: return
            if (user.id?.startsWith("guest") == true) {
                return
            }
            val activities = mRealm.createObject(RealmResourceActivity::class.java, UUID.randomUUID().toString())
            activities.user = user.name
            activities._rev = null
            activities._id = null
            activities.parentCode = user.parentCode
            activities.createdOn = user.planetCode
            activities.type = "sync"
            activities.time = Date().time
            mRealm.commitTransaction()
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.content.SharedPreferences
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmResourceActivity : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var createdOn: String? = null
    var _rev: String? = null
    var time: Long = 0
    var title: String? = null
    var resourceId: String? = null
    var parentCode: String? = null
    var type: String? = null
    var user: String? = null
    var androidId: String? = null

    companion object {
        @JvmStatic
        fun serializeResourceActivities(realmResourceActivities: RealmResourceActivity): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", realmResourceActivities.user)
            ob.addProperty("resourceId", realmResourceActivities.resourceId)
            ob.addProperty("type", realmResourceActivities.type)
            ob.addProperty("title", realmResourceActivities.title)
            ob.addProperty("time", realmResourceActivities.time)
            ob.addProperty("createdOn", realmResourceActivities.createdOn)
            ob.addProperty("parentCode", realmResourceActivities.parentCode)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            return ob
        }

        @JvmStatic
        fun onSynced(mRealm: Realm, settings: SharedPreferences) {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }
            val user = mRealm.where(RealmUserModel::class.java).equalTo("id", settings.getString("userId", "")).findFirst()
                ?: return
            if (user.id?.startsWith("guest") == true) {
                return
            }
            val activities = mRealm.createObject(RealmResourceActivity::class.java, UUID.randomUUID().toString())
            activities.user = user.name
            activities._rev = null
            activities._id = null
            activities.parentCode = user.parentCode
            activities.createdOn = user.planetCode
            activities.type = "sync"
            activities.time = Date().time
            mRealm.commitTransaction()
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmSubmitPhotos.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.JsonObject
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmSubmitPhotos : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var submissionId: String? = null
    var courseId: String? = null
    var examId: String? = null
    var memberId: String? = null
    var date: String? = null
    var uniqueId: String? = null
    var photoLocation: String? = null
    var uploaded = false

    companion object {
        @JvmStatic
        fun serializeRealmSubmitPhotos(submit: RealmSubmitPhotos): JsonObject {
            val obj = JsonObject()
            obj.addProperty("id", submit.id)
            obj.addProperty("submissionId", submit.submissionId)
            obj.addProperty("type", "photo")
            obj.addProperty("courseId", submit.courseId)
            obj.addProperty("examId", submit.examId)
            obj.addProperty("memberId", submit.memberId)
            obj.addProperty("date", submit.date)
            obj.addProperty("macAddress", submit.uniqueId)
            obj.addProperty("photoLocation", submit.photoLocation)
            return obj
        }
    }
}
=======
package org.ole.planet.myplanet.model


import com.google.gson.JsonObject
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmSubmitPhotos : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var submissionId: String? = null
    var courseId: String? = null
    var examId: String? = null
    var memberId: String? = null
    var date: String? = null
    var uniqueId: String? = null
    var photoLocation: String? = null
    var uploaded = false

    companion object {
        @JvmStatic
        fun serializeRealmSubmitPhotos(submit: RealmSubmitPhotos): JsonObject {
            val obj = JsonObject()
            obj.addProperty("id", submit.id)
            obj.addProperty("submissionId", submit.submissionId)
            obj.addProperty("type", "photo")
            obj.addProperty("courseId", submit.courseId)
            obj.addProperty("examId", submit.examId)
            obj.addProperty("memberId", submit.memberId)
            obj.addProperty("date", submit.date)
            obj.addProperty("macAddress", submit.uniqueId)
            obj.addProperty("photoLocation", submit.photoLocation)
            return obj
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmMeetup.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Case
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.json.JSONArray
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.TimeUtils

open class RealmMeetup : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var userId: String? = null
    var meetupId: String? = null
    var meetupIdRev: String? = null
    var title: String? = null
    var description: String? = null
    var startDate: Long = 0
    var endDate: Long = 0
    var recurring: String? = "none"
    var day: String? = null
    var startTime: String? = null
    var endTime: String? = null
    var category: String? = null
    var meetupLocation: String? = null
    var meetupLink: String? = null
    var creator: String? = null
    var link: String? = null
    var teamId: String? = null
    var createdDate: Long = 0
    var recurringNumber: Int = 10
    var sync: String? = null
    var sourcePlanet: String? = null

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, meetupDoc: JsonObject) {
            insert("", meetupDoc, mRealm)
        }

        fun insert(userId: String?, meetupDoc: JsonObject, mRealm: Realm) {
            var myMeetupsDB = mRealm.where(RealmMeetup::class.java)
                .equalTo("meetupId", JsonUtils.getString("_id", meetupDoc)).findFirst()
            if (myMeetupsDB == null) {
                myMeetupsDB = mRealm.createObject(RealmMeetup::class.java, JsonUtils.getString("_id", meetupDoc))
            }
            myMeetupsDB?.meetupId = JsonUtils.getString("_id", meetupDoc)
            myMeetupsDB?.userId = userId
            myMeetupsDB?.meetupIdRev = JsonUtils.getString("_rev", meetupDoc)
            myMeetupsDB?.title = JsonUtils.getString("title", meetupDoc)
            myMeetupsDB?.description = JsonUtils.getString("description", meetupDoc)
            myMeetupsDB?.startDate = JsonUtils.getLong("startDate", meetupDoc)
            myMeetupsDB?.endDate = JsonUtils.getLong("endDate", meetupDoc)
            myMeetupsDB?.recurring = JsonUtils.getString("recurring", meetupDoc)
            myMeetupsDB?.startTime = JsonUtils.getString("startTime", meetupDoc)
            myMeetupsDB?.endTime = JsonUtils.getString("endTime", meetupDoc)
            myMeetupsDB?.category = JsonUtils.getString("category", meetupDoc)
            myMeetupsDB?.meetupLocation = JsonUtils.getString("meetupLocation", meetupDoc)
            myMeetupsDB?.meetupLink = JsonUtils.getString("meetupLink", meetupDoc)
            myMeetupsDB?.creator = JsonUtils.getString("createdBy", meetupDoc)
            myMeetupsDB?.day = JsonUtils.getJsonArray("day", meetupDoc).toString()
            myMeetupsDB?.link = JsonUtils.getJsonObject("link", meetupDoc).toString()
            myMeetupsDB?.teamId = JsonUtils.getString("teams", JsonUtils.getJsonObject("link", meetupDoc))
        }

        @JvmStatic
        fun getMyMeetUpIds(realm: Realm?, userId: String?): JsonArray {
            val meetups = realm?.where(RealmMeetup::class.java)?.isNotEmpty("userId")
                ?.equalTo("userId", userId, Case.INSENSITIVE)?.findAll()
            val ids = JsonArray()
            for (lib in meetups ?: emptyList()) {
                ids.add(lib.meetupId)
            }
            return ids
        }

        @JvmStatic
        fun getHashMap(meetups: RealmMeetup): HashMap<String, String> {
            val map = HashMap<String, String>()
            map["Meetup Title"] = checkNull(meetups.title)
            map["Created By"] = checkNull(meetups.creator)
            map["Category"] = checkNull(meetups.category)
            try {
                map["Meetup Date"] = TimeUtils.getFormattedDate(meetups.startDate) +
                        " - " + TimeUtils.getFormattedDate(meetups.endDate)
            } catch (e: Exception) {
                e.printStackTrace()
            }
            map["Meetup Time"] = checkNull(meetups.startTime) + " - " + checkNull(meetups.endTime)
            map["Recurring"] = checkNull(meetups.recurring)
            var recurringDays = ""
            try {
                val ar = JSONArray(meetups.day)
                for (i in 0 until ar.length()) {
                    recurringDays += ar[i].toString() + ", "
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
            map["Recurring Days"] = checkNull(recurringDays)
            map["Location"] = checkNull(meetups.meetupLocation)
            map["Link"] = checkNull(meetups.meetupLink)
            map["Description"] = checkNull(meetups.description)
            return map
        }

        private fun checkNull(s: String?): String {
            return if (TextUtils.isEmpty(s)) "" else s!!
        }

        @JvmStatic
        fun serialize(meetup: RealmMeetup): JsonObject {
            val `object` = JsonObject()
            if (!meetup.meetupId.isNullOrEmpty()) `object`.addProperty("_id", meetup.meetupId)
            if (!meetup.meetupIdRev.isNullOrEmpty()) `object`.addProperty("_rev", meetup.meetupIdRev)
            `object`.addProperty("title", meetup.title)
            `object`.addProperty("description", meetup.description)
            `object`.addProperty("startDate", meetup.startDate)
            `object`.addProperty("endDate", meetup.endDate)
            `object`.addProperty("startTime", meetup.startTime)
            `object`.addProperty("endTime", meetup.endTime)
            `object`.addProperty("recurring", meetup.recurring)
            `object`.addProperty("meetupLocation", meetup.meetupLocation)
            `object`.addProperty("meetupLink", meetup.meetupLink)
            `object`.addProperty("createdBy", meetup.creator)
            `object`.addProperty("teamId", meetup.teamId)
            `object`.addProperty("category", meetup.category)
            `object`.addProperty("createdDate", meetup.createdDate)
            `object`.addProperty("recurringNumber", meetup.recurringNumber)
            `object`.addProperty("sourcePlanet", meetup.sourcePlanet)
            `object`.addProperty("sync", meetup.sync)

            if (!meetup.link.isNullOrEmpty()) {
                val linksJson = Gson().fromJson(meetup.link, JsonObject::class.java)
                `object`.add("link", linksJson)
            }

            return `object`
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Case
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.json.JSONArray
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.TimeUtils

open class RealmMeetup : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var userId: String? = null
    var meetupId: String? = null
    var meetupIdRev: String? = null
    var title: String? = null
    var description: String? = null
    var startDate: Long = 0
    var endDate: Long = 0
    var recurring: String? = "none"
    var day: String? = null
    var startTime: String? = null
    var endTime: String? = null
    var category: String? = null
    var meetupLocation: String? = null
    var meetupLink: String? = null
    var creator: String? = null
    var link: String? = null
    var teamId: String? = null
    var createdDate: Long = 0
    var recurringNumber: Int = 10
    var sync: String? = null
    var sourcePlanet: String? = null

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, meetupDoc: JsonObject) {
            insert("", meetupDoc, mRealm)
        }

        fun insert(userId: String?, meetupDoc: JsonObject, mRealm: Realm) {
            var myMeetupsDB = mRealm.where(RealmMeetup::class.java)
                .equalTo("meetupId", JsonUtils.getString("_id", meetupDoc)).findFirst()
            if (myMeetupsDB == null) {
                myMeetupsDB = mRealm.createObject(RealmMeetup::class.java, JsonUtils.getString("_id", meetupDoc))
            }
            myMeetupsDB?.meetupId = JsonUtils.getString("_id", meetupDoc)
            myMeetupsDB?.userId = userId
            myMeetupsDB?.meetupIdRev = JsonUtils.getString("_rev", meetupDoc)
            myMeetupsDB?.title = JsonUtils.getString("title", meetupDoc)
            myMeetupsDB?.description = JsonUtils.getString("description", meetupDoc)
            myMeetupsDB?.startDate = JsonUtils.getLong("startDate", meetupDoc)
            myMeetupsDB?.endDate = JsonUtils.getLong("endDate", meetupDoc)
            myMeetupsDB?.recurring = JsonUtils.getString("recurring", meetupDoc)
            myMeetupsDB?.startTime = JsonUtils.getString("startTime", meetupDoc)
            myMeetupsDB?.endTime = JsonUtils.getString("endTime", meetupDoc)
            myMeetupsDB?.category = JsonUtils.getString("category", meetupDoc)
            myMeetupsDB?.meetupLocation = JsonUtils.getString("meetupLocation", meetupDoc)
            myMeetupsDB?.meetupLink = JsonUtils.getString("meetupLink", meetupDoc)
            myMeetupsDB?.creator = JsonUtils.getString("createdBy", meetupDoc)
            myMeetupsDB?.day = JsonUtils.getJsonArray("day", meetupDoc).toString()
            myMeetupsDB?.link = JsonUtils.getJsonObject("link", meetupDoc).toString()
            myMeetupsDB?.teamId = JsonUtils.getString("teams", JsonUtils.getJsonObject("link", meetupDoc))
        }

        @JvmStatic
        fun getMyMeetUpIds(realm: Realm?, userId: String?): JsonArray {
            val meetups = realm?.where(RealmMeetup::class.java)?.isNotEmpty("userId")
                ?.equalTo("userId", userId, Case.INSENSITIVE)?.findAll()
            val ids = JsonArray()
            for (lib in meetups ?: emptyList()) {
                ids.add(lib.meetupId)
            }
            return ids
        }

        @JvmStatic
        fun getHashMap(meetups: RealmMeetup): HashMap<String, String> {
            val map = HashMap<String, String>()
            map["Meetup Title"] = checkNull(meetups.title)
            map["Created By"] = checkNull(meetups.creator)
            map["Category"] = checkNull(meetups.category)
            try {
                map["Meetup Date"] = TimeUtils.getFormattedDate(meetups.startDate) +
                        " - " + TimeUtils.getFormattedDate(meetups.endDate)
            } catch (e: Exception) {
                e.printStackTrace()
            }
            map["Meetup Time"] = checkNull(meetups.startTime) + " - " + checkNull(meetups.endTime)
            map["Recurring"] = checkNull(meetups.recurring)
            var recurringDays = ""
            try {
                val ar = JSONArray(meetups.day)
                for (i in 0 until ar.length()) {
                    recurringDays += ar[i].toString() + ", "
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
            map["Recurring Days"] = checkNull(recurringDays)
            map["Location"] = checkNull(meetups.meetupLocation)
            map["Link"] = checkNull(meetups.meetupLink)
            map["Description"] = checkNull(meetups.description)
            return map
        }

        private fun checkNull(s: String?): String {
            return if (TextUtils.isEmpty(s)) "" else s!!
        }

        @JvmStatic
        fun serialize(meetup: RealmMeetup): JsonObject {
            val `object` = JsonObject()
            if (!meetup.meetupId.isNullOrEmpty()) `object`.addProperty("_id", meetup.meetupId)
            if (!meetup.meetupIdRev.isNullOrEmpty()) `object`.addProperty("_rev", meetup.meetupIdRev)
            `object`.addProperty("title", meetup.title)
            `object`.addProperty("description", meetup.description)
            `object`.addProperty("startDate", meetup.startDate)
            `object`.addProperty("endDate", meetup.endDate)
            `object`.addProperty("startTime", meetup.startTime)
            `object`.addProperty("endTime", meetup.endTime)
            `object`.addProperty("recurring", meetup.recurring)
            `object`.addProperty("meetupLocation", meetup.meetupLocation)
            `object`.addProperty("meetupLink", meetup.meetupLink)
            `object`.addProperty("createdBy", meetup.creator)
            `object`.addProperty("teamId", meetup.teamId)
            `object`.addProperty("category", meetup.category)
            `object`.addProperty("createdDate", meetup.createdDate)
            `object`.addProperty("recurringNumber", meetup.recurringNumber)
            `object`.addProperty("sourcePlanet", meetup.sourcePlanet)
            `object`.addProperty("sync", meetup.sync)

            if (!meetup.link.isNullOrEmpty()) {
                val linksJson = Gson().fromJson(meetup.link, JsonObject::class.java)
                `object`.add("link", linksJson)
            }

            return `object`
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmUserChallengeActions.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.UUID

open class RealmUserChallengeActions : RealmObject() {
    @PrimaryKey
    var id: String = UUID.randomUUID().toString()
    var userId: String? = null
    var actionType: String? = null
    var resourceId: String? = null
    var time: Long = 0

    companion object {
        fun createActionAsync(
            userId: String,
            resourceId: String?,
            actionType: String
        ) {
            val realm = Realm.getDefaultInstance()
            realm.executeTransactionAsync({ bgRealm ->
                val action = bgRealm.createObject(
                    RealmUserChallengeActions::class.java,
                    UUID.randomUUID().toString()
                )
                action.userId     = userId
                action.actionType = actionType
                action.resourceId = resourceId
                action.time       = System.currentTimeMillis()
            }, {
                realm.close()
            }, { e ->
                e.printStackTrace()
                realm.close()
            })
        }

        @Deprecated("Use createActionAsync without realm parameter")
        fun createActionAsync(
            realm: Realm,
            userId: String,
            resourceId: String?,
            actionType: String
        ) {
            createActionAsync(userId, resourceId, actionType)
        }
    }
}
=======
package org.ole.planet.myplanet.model


import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.UUID

open class RealmUserChallengeActions : RealmObject() {
    @PrimaryKey
    var id: String = UUID.randomUUID().toString()
    var userId: String? = null
    var actionType: String? = null
    var resourceId: String? = null
    var time: Long = 0

    companion object {
        fun createActionAsync(
            userId: String,
            resourceId: String?,
            actionType: String
        ) {
            val realm = Realm.getDefaultInstance()
            realm.executeTransactionAsync({ bgRealm ->
                val action = bgRealm.createObject(
                    RealmUserChallengeActions::class.java,
                    UUID.randomUUID().toString()
                )
                action.userId     = userId
                action.actionType = actionType
                action.resourceId = resourceId
                action.time       = System.currentTimeMillis()
            }, {
                realm.close()
            }, { e ->
                e.printStackTrace()
                realm.close()
            })
        }

        @Deprecated("Use createActionAsync without realm parameter")
        fun createActionAsync(
            realm: Realm,
            userId: String,
            resourceId: String?,
            actionType: String
        ) {
            createActionAsync(userId, resourceId, actionType)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmMyLife.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.SharedPreferences
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication

open class RealmMyLife : RealmObject {
    @PrimaryKey
    var _id: String? = null
    var imageId: String? = null
    var userId: String? = null
    var title: String? = null
    var isVisible = false
    var weight = 0

    constructor(imageId: String?, userId: String?, title: String?) {
        this.imageId = imageId
        this.userId = userId
        this.title = title
        isVisible = true
    }

    constructor()

    companion object {
        fun getMyLifeByUserId(mRealm: Realm, settings: SharedPreferences?): List<RealmMyLife> {
            val userId = settings?.getString("userId", "--")
            return getMyLifeByUserId(mRealm, userId)
        }

        @JvmStatic
        fun getMyLifeByUserId(mRealm: Realm, userId: String?): List<RealmMyLife> {
            return mRealm.where(RealmMyLife::class.java).equalTo("userId", userId).findAll()
                .sort("weight")
        }

        @JvmStatic
        fun updateWeight(weight: Int, id: String?, userId: String?) {
            MainApplication.applicationScope.launch {
                MainApplication.service.executeTransactionAsync { realm ->
                    val targetItem = realm.where(RealmMyLife::class.java)
                        .equalTo("_id", id)
                        .findFirst()

                    targetItem?.let { item ->
                        val currentWeight = item.weight
                        item.weight = weight

                        val otherItem = realm.where(RealmMyLife::class.java)
                            .equalTo("userId", userId)
                            .equalTo("weight", weight)
                            .notEqualTo("_id", id)
                            .findFirst()

                        otherItem?.weight = currentWeight
                    }
                }
            }
        }

        @JvmStatic
        fun updateVisibility(isVisible: Boolean, id: String?) {
            MainApplication.applicationScope.launch {
                MainApplication.service.executeTransactionAsync { realm ->
                    realm.where(RealmMyLife::class.java)
                        .equalTo("_id", id)
                        .findFirst()
                        ?.isVisible = isVisible
                }
            }
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.content.SharedPreferences
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication

open class RealmMyLife : RealmObject {
    @PrimaryKey
    var _id: String? = null
    var imageId: String? = null
    var userId: String? = null
    var title: String? = null
    var isVisible = false
    var weight = 0

    constructor(imageId: String?, userId: String?, title: String?) {
        this.imageId = imageId
        this.userId = userId
        this.title = title
        isVisible = true
    }

    constructor()

    companion object {
        fun getMyLifeByUserId(mRealm: Realm, settings: SharedPreferences?): List<RealmMyLife> {
            val userId = settings?.getString("userId", "--")
            return getMyLifeByUserId(mRealm, userId)
        }

        @JvmStatic
        fun getMyLifeByUserId(mRealm: Realm, userId: String?): List<RealmMyLife> {
            return mRealm.where(RealmMyLife::class.java).equalTo("userId", userId).findAll()
                .sort("weight")
        }

        @JvmStatic
        fun updateWeight(weight: Int, id: String?, userId: String?) {
            MainApplication.applicationScope.launch {
                MainApplication.service.executeTransactionAsync { realm ->
                    val targetItem = realm.where(RealmMyLife::class.java)
                        .equalTo("_id", id)
                        .findFirst()

                    targetItem?.let { item ->
                        val currentWeight = item.weight
                        item.weight = weight

                        val otherItem = realm.where(RealmMyLife::class.java)
                            .equalTo("userId", userId)
                            .equalTo("weight", weight)
                            .notEqualTo("_id", id)
                            .findFirst()

                        otherItem?.weight = currentWeight
                    }
                }
            }
        }

        @JvmStatic
        fun updateVisibility(isVisible: Boolean, id: String?) {
            MainApplication.applicationScope.launch {
                MainApplication.service.executeTransactionAsync { realm ->
                    realm.where(RealmMyLife::class.java)
                        .equalTo("_id", id)
                        .findFirst()
                        ?.isVisible = isVisible
                }
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmOfflineActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.Context
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.Sort
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmOfflineActivity : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var userName: String? = null
    var userId: String? = null
    var type: String? = null
    var description: String? = null
    var createdOn: String? = null
    var parentCode: String? = null
    var loginTime: Long? = null
    var logoutTime: Long? = null
    var androidId: String? = null
    fun changeRev(r: JsonObject?) {
        if (r != null) {
            _rev = JsonUtils.getString("_rev", r)
            _id = JsonUtils.getString("_id", r)
        }
    }

    companion object {
        @JvmStatic
        fun serializeLoginActivities(realmOfflineActivities: RealmOfflineActivity, context: Context): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", realmOfflineActivities.userName)
            ob.addProperty("type", realmOfflineActivities.type)
            ob.addProperty("loginTime", realmOfflineActivities.loginTime)
            ob.addProperty("logoutTime", realmOfflineActivities.logoutTime)
            ob.addProperty("createdOn", realmOfflineActivities.createdOn)
            ob.addProperty("parentCode", realmOfflineActivities.parentCode)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            ob.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            if (realmOfflineActivities._id != null) {
                ob.addProperty("_id", realmOfflineActivities.logoutTime)
            }
            if (realmOfflineActivities._rev != null) {
                ob.addProperty("_rev", realmOfflineActivities._rev)
            }
            return ob
        }

        @JvmStatic
        fun getRecentLogin(mRealm: Realm): RealmOfflineActivity? {
            return mRealm.where(RealmOfflineActivity::class.java)
                .equalTo("type", UserProfileDbHandler.KEY_LOGIN).sort("loginTime", Sort.DESCENDING)
                .findFirst()
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var activities = mRealm.where(RealmOfflineActivity::class.java).equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (activities == null) {
                activities = mRealm.createObject(RealmOfflineActivity::class.java, JsonUtils.getString("_id", act))
            }
            if (activities != null) {
                activities._rev = JsonUtils.getString("_rev", act)
                activities._id = JsonUtils.getString("_id", act)
                activities.loginTime = JsonUtils.getLong("loginTime", act)
                activities.type = JsonUtils.getString("type", act)
                activities.userName = JsonUtils.getString("user", act)
                activities.parentCode = JsonUtils.getString("parentCode", act)
                activities.createdOn = JsonUtils.getString("createdOn", act)
                activities.userName = JsonUtils.getString("user", act)
                activities.logoutTime = JsonUtils.getLong("logoutTime", act)
                activities.androidId = JsonUtils.getString("androidId", act)
            }
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.content.Context
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.Sort
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmOfflineActivity : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var userName: String? = null
    var userId: String? = null
    var type: String? = null
    var description: String? = null
    var createdOn: String? = null
    var parentCode: String? = null
    var loginTime: Long? = null
    var logoutTime: Long? = null
    var androidId: String? = null
    fun changeRev(r: JsonObject?) {
        if (r != null) {
            _rev = JsonUtils.getString("_rev", r)
            _id = JsonUtils.getString("_id", r)
        }
    }

    companion object {
        @JvmStatic
        fun serializeLoginActivities(realmOfflineActivities: RealmOfflineActivity, context: Context): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", realmOfflineActivities.userName)
            ob.addProperty("type", realmOfflineActivities.type)
            ob.addProperty("loginTime", realmOfflineActivities.loginTime)
            ob.addProperty("logoutTime", realmOfflineActivities.logoutTime)
            ob.addProperty("createdOn", realmOfflineActivities.createdOn)
            ob.addProperty("parentCode", realmOfflineActivities.parentCode)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            ob.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            if (realmOfflineActivities._id != null) {
                ob.addProperty("_id", realmOfflineActivities.logoutTime)
            }
            if (realmOfflineActivities._rev != null) {
                ob.addProperty("_rev", realmOfflineActivities._rev)
            }
            return ob
        }

        @JvmStatic
        fun getRecentLogin(mRealm: Realm): RealmOfflineActivity? {
            return mRealm.where(RealmOfflineActivity::class.java)
                .equalTo("type", UserProfileDbHandler.KEY_LOGIN).sort("loginTime", Sort.DESCENDING)
                .findFirst()
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var activities = mRealm.where(RealmOfflineActivity::class.java).equalTo("_id", JsonUtils.getString("_id", act)).findFirst()
            if (activities == null) {
                activities = mRealm.createObject(RealmOfflineActivity::class.java, JsonUtils.getString("_id", act))
            }
            if (activities != null) {
                activities._rev = JsonUtils.getString("_rev", act)
                activities._id = JsonUtils.getString("_id", act)
                activities.loginTime = JsonUtils.getLong("loginTime", act)
                activities.type = JsonUtils.getString("type", act)
                activities.userName = JsonUtils.getString("user", act)
                activities.parentCode = JsonUtils.getString("parentCode", act)
                activities.createdOn = JsonUtils.getString("createdOn", act)
                activities.userName = JsonUtils.getString("user", act)
                activities.logoutTime = JsonUtils.getLong("logoutTime", act)
                activities.androidId = JsonUtils.getString("androidId", act)
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmMyPersonal.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.Context
import com.google.gson.JsonObject
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmMyPersonal : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var isUploaded = false
    var title: String? = null
    var description: String? = null
    var date: Long = 0
    var userId: String? = null
    var userName: String? = null
    var path: String? = null

    companion object {
        @JvmStatic
        fun serialize(personal: RealmMyPersonal, context: Context): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("title", personal.title)
            `object`.addProperty("uploadDate", Date().time)
            `object`.addProperty("createdDate", personal.date)
            `object`.addProperty("filename", FileUtils.getFileNameFromUrl(personal.path))
            `object`.addProperty("author", personal.userName)
            `object`.addProperty("addedBy", personal.userName)
            `object`.addProperty("description", personal.description)
            `object`.addProperty("resourceType", "Activities")
            `object`.addProperty("private", true)
            val object1 = JsonObject()
            `object`.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            `object`.addProperty("deviceName", NetworkUtils.getDeviceName())
            `object`.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            object1.addProperty("users", personal.userId)
            `object`.add("privateFor", object1)
            return `object`
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.content.Context
import com.google.gson.JsonObject
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmMyPersonal : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var isUploaded = false
    var title: String? = null
    var description: String? = null
    var date: Long = 0
    var userId: String? = null
    var userName: String? = null
    var path: String? = null

    companion object {
        @JvmStatic
        fun serialize(personal: RealmMyPersonal, context: Context): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("title", personal.title)
            `object`.addProperty("uploadDate", Date().time)
            `object`.addProperty("createdDate", personal.date)
            `object`.addProperty("filename", FileUtils.getFileNameFromUrl(personal.path))
            `object`.addProperty("author", personal.userName)
            `object`.addProperty("addedBy", personal.userName)
            `object`.addProperty("description", personal.description)
            `object`.addProperty("resourceType", "Activities")
            `object`.addProperty("private", true)
            val object1 = JsonObject()
            `object`.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            `object`.addProperty("deviceName", NetworkUtils.getDeviceName())
            `object`.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            object1.addProperty("users", personal.userId)
            `object`.add("privateFor", object1)
            return `object`
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmDictionary.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmDictionary(
    @PrimaryKey var id: String = "",
    var word: String = "",
    var meaning: String = "",
    var synonym: String = "",
    var advanceCode: String = "",
    var code: String = "",
    var definition: String = "",
    var language: String = "",
    var antonym: String = ""
) : RealmObject()
=======
package org.ole.planet.myplanet.model


import io.realm.RealmObject
import io.realm.annotations.PrimaryKey

open class RealmDictionary(
    @PrimaryKey var id: String = "",
    var word: String = "",
    var meaning: String = "",
    var synonym: String = "",
    var advanceCode: String = "",
    var code: String = "",
    var definition: String = "",
    var language: String = "",
    var antonym: String = ""
) : RealmObject()
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmTeamLog.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.Context
import android.text.TextUtils
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmTeamLog : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var teamId: String? = null
    var user: String? = null
    var type: String? = null
    var teamType: String? = null
    var createdOn: String? = null
    var parentCode: String? = null
    var time: Long? = null
    var uploaded = false
    companion object {
        @JvmStatic
        fun getVisitCount(realm: Realm, userName: String?, teamId: String?): Long {
            return realm.where(RealmTeamLog::class.java).equalTo("type", "teamVisit").equalTo("user", userName).equalTo("teamId", teamId).count()
        }

        @JvmStatic
        fun getLastVisit(realm: Realm, userName: String?, teamId: String?): Long? {
            return realm.where(RealmTeamLog::class.java)
                .equalTo("type", "teamVisit")
                .equalTo("user", userName)
                .equalTo("teamId", teamId)
                .max("time")?.toLong()
        }

        @JvmStatic
        fun serializeTeamActivities(log: RealmTeamLog, context: Context): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", log.user)
            ob.addProperty("type", log.type)
            ob.addProperty("createdOn", log.createdOn)
            ob.addProperty("parentCode", log.parentCode)
            ob.addProperty("teamType", log.teamType)
            ob.addProperty("time", log.time)
            ob.addProperty("teamId", log.teamId)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            ob.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            if (!TextUtils.isEmpty(log._rev)) {
                ob.addProperty("_rev", log._rev)
                ob.addProperty("_id", log._id)
            }
            return ob
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var tag = mRealm.where(RealmTeamLog::class.java)
                .equalTo("id", JsonUtils.getString("_id", act)).findFirst()
            if (tag == null) {
                tag = mRealm.createObject(RealmTeamLog::class.java, JsonUtils.getString("_id", act))
            }
            if (tag != null) {
                tag._rev = JsonUtils.getString("_rev", act)
                tag._id = JsonUtils.getString("_id", act)
                tag.type = JsonUtils.getString("type", act)
                tag.user = JsonUtils.getString("user", act)
                tag.createdOn = JsonUtils.getString("createdOn", act)
                tag.parentCode = JsonUtils.getString("parentCode", act)
                tag.time = JsonUtils.getLong("time", act)
                tag.teamId = JsonUtils.getString("teamId", act)
                tag.teamType = JsonUtils.getString("teamType", act)
            }
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.content.Context
import android.text.TextUtils
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmTeamLog : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var teamId: String? = null
    var user: String? = null
    var type: String? = null
    var teamType: String? = null
    var createdOn: String? = null
    var parentCode: String? = null
    var time: Long? = null
    var uploaded = false
    companion object {
        @JvmStatic
        fun getVisitCount(realm: Realm, userName: String?, teamId: String?): Long {
            return realm.where(RealmTeamLog::class.java).equalTo("type", "teamVisit").equalTo("user", userName).equalTo("teamId", teamId).count()
        }

        @JvmStatic
        fun getLastVisit(realm: Realm, userName: String?, teamId: String?): Long? {
            return realm.where(RealmTeamLog::class.java)
                .equalTo("type", "teamVisit")
                .equalTo("user", userName)
                .equalTo("teamId", teamId)
                .max("time")?.toLong()
        }

        @JvmStatic
        fun serializeTeamActivities(log: RealmTeamLog, context: Context): JsonObject {
            val ob = JsonObject()
            ob.addProperty("user", log.user)
            ob.addProperty("type", log.type)
            ob.addProperty("createdOn", log.createdOn)
            ob.addProperty("parentCode", log.parentCode)
            ob.addProperty("teamType", log.teamType)
            ob.addProperty("time", log.time)
            ob.addProperty("teamId", log.teamId)
            ob.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            ob.addProperty("deviceName", NetworkUtils.getDeviceName())
            ob.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            if (!TextUtils.isEmpty(log._rev)) {
                ob.addProperty("_rev", log._rev)
                ob.addProperty("_id", log._id)
            }
            return ob
        }

        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            var tag = mRealm.where(RealmTeamLog::class.java)
                .equalTo("id", JsonUtils.getString("_id", act)).findFirst()
            if (tag == null) {
                tag = mRealm.createObject(RealmTeamLog::class.java, JsonUtils.getString("_id", act))
            }
            if (tag != null) {
                tag._rev = JsonUtils.getString("_rev", act)
                tag._id = JsonUtils.getString("_id", act)
                tag.type = JsonUtils.getString("type", act)
                tag.user = JsonUtils.getString("user", act)
                tag.createdOn = JsonUtils.getString("createdOn", act)
                tag.parentCode = JsonUtils.getString("parentCode", act)
                tag.time = JsonUtils.getLong("time", act)
                tag.teamId = JsonUtils.getString("teamId", act)
                tag.teamType = JsonUtils.getString("teamType", act)
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmChatHistory.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmChatHistory : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var user: String? = null
    var aiProvider: String? = null
    var title: String? = null
    var createdDate: String? = null
    var updatedDate: String? = null
    var lastUsed: Long = 0
    var conversations: RealmList<Conversation>? = null
    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            val chatHistoryId = JsonUtils.getString("_id", act)
            val existingChatHistory = mRealm.where(RealmChatHistory::class.java).equalTo("_id", chatHistoryId).findFirst()
            existingChatHistory?.deleteFromRealm()
            val chatHistory = mRealm.createObject(RealmChatHistory::class.java, chatHistoryId)
            chatHistory._rev = JsonUtils.getString("_rev", act)
            chatHistory._id = JsonUtils.getString("_id", act)
            chatHistory.title = JsonUtils.getString("title", act)
            chatHistory.createdDate = JsonUtils.getString("createdDate", act)
            chatHistory.updatedDate = JsonUtils.getString("updatedDate", act)
            chatHistory.user = JsonUtils.getString("user", act)
            chatHistory.aiProvider = JsonUtils.getString("aiProvider", act)
            chatHistory.conversations = parseConversations(mRealm, JsonUtils.getJsonArray("conversations", act))
            chatHistory.lastUsed = Date().time
        }

        private fun parseConversations(realm: Realm, jsonArray: JsonArray): RealmList<Conversation> {
            val conversations = RealmList<Conversation>()
            for (element in jsonArray) {
                val conversation = Gson().fromJson(element, Conversation::class.java)
                val realmConversation = realm.copyToRealm(conversation)
                conversations.add(realmConversation)
            }
            return conversations
        }

        fun addConversationToChatHistory(mRealm: Realm, chatHistoryId: String?, query: String?, response: String?, newRev: String?) {
            val chatHistory = mRealm.where(RealmChatHistory::class.java).equalTo("_id", chatHistoryId).findFirst()
            if (chatHistory != null) {
                if (chatHistory.conversations == null) {
                    chatHistory.conversations = RealmList()
                }
                val conversation = mRealm.createObject(Conversation::class.java)
                conversation.query = query
                conversation.response = response
                chatHistory.conversations?.add(conversation)
                chatHistory.lastUsed = Date().time
                if (!newRev.isNullOrEmpty()) {
                    chatHistory._rev = newRev
                }
            }
        }
    }
}
=======
package org.ole.planet.myplanet.model


import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmChatHistory : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var user: String? = null
    var aiProvider: String? = null
    var title: String? = null
    var createdDate: String? = null
    var updatedDate: String? = null
    var lastUsed: Long = 0
    var conversations: RealmList<Conversation>? = null
    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, act: JsonObject?) {
            val chatHistoryId = JsonUtils.getString("_id", act)
            val existingChatHistory = mRealm.where(RealmChatHistory::class.java).equalTo("_id", chatHistoryId).findFirst()
            existingChatHistory?.deleteFromRealm()
            val chatHistory = mRealm.createObject(RealmChatHistory::class.java, chatHistoryId)
            chatHistory._rev = JsonUtils.getString("_rev", act)
            chatHistory._id = JsonUtils.getString("_id", act)
            chatHistory.title = JsonUtils.getString("title", act)
            chatHistory.createdDate = JsonUtils.getString("createdDate", act)
            chatHistory.updatedDate = JsonUtils.getString("updatedDate", act)
            chatHistory.user = JsonUtils.getString("user", act)
            chatHistory.aiProvider = JsonUtils.getString("aiProvider", act)
            chatHistory.conversations = parseConversations(mRealm, JsonUtils.getJsonArray("conversations", act))
            chatHistory.lastUsed = Date().time
        }

        private fun parseConversations(realm: Realm, jsonArray: JsonArray): RealmList<Conversation> {
            val conversations = RealmList<Conversation>()
            for (element in jsonArray) {
                val conversation = Gson().fromJson(element, Conversation::class.java)
                val realmConversation = realm.copyToRealm(conversation)
                conversations.add(realmConversation)
            }
            return conversations
        }

        fun addConversationToChatHistory(mRealm: Realm, chatHistoryId: String?, query: String?, response: String?, newRev: String?) {
            val chatHistory = mRealm.where(RealmChatHistory::class.java).equalTo("_id", chatHistoryId).findFirst()
            if (chatHistory != null) {
                if (chatHistory.conversations == null) {
                    chatHistory.conversations = RealmList()
                }
                val conversation = mRealm.createObject(Conversation::class.java)
                conversation.query = query
                conversation.response = response
                chatHistory.conversations?.add(conversation)
                chatHistory.lastUsed = Date().time
                if (!newRev.isNullOrEmpty()) {
                    chatHistory._rev = newRev
                }
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmNews.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.Context.MODE_PRIVATE
import android.content.SharedPreferences
import android.text.TextUtils
import androidx.core.content.edit
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.google.gson.JsonSyntaxException
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DownloadUtils.extractLinks
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.UrlUtils

open class RealmNews : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var userId: String? = null
    var user: String? = null
    var message: String? = null
    var docType: String? = null
    var viewableBy: String? = null
    var viewableId: String? = null
    var avatar: String? = null
    var replyTo: String? = null
    var userName: String? = null
    var messagePlanetCode: String? = null
    var messageType: String? = null
    var updatedDate: Long = 0
    var time: Long = 0
    var createdOn: String? = null
    var parentCode: String? = null
    var imageUrls: RealmList<String>? = null
    var images: String? = null
    var labels: RealmList<String>? = null
    var viewIn: String? = null
    var newsId: String? = null
    var newsRev: String? = null
    var newsUser: String? = null
    var aiProvider: String? = null
    var newsTitle: String? = null
    var conversations: String? = null
    var newsCreatedDate: Long = 0
    var newsUpdatedDate: Long = 0
    var chat: Boolean = false
    var isEdited: Boolean = false
    var editedTime: Long = 0
    var sharedBy: String? = null

    val imagesArray: JsonArray
        get() = if (images == null) JsonArray() else Gson().fromJson(images, JsonArray::class.java)

    val labelsArray: JsonArray
        get() {
            val array = JsonArray()
            labels?.forEach { s ->
                array.add(s)
            }
            return array
        }

    fun updateMessage(newMessage: String) {
        this.message = newMessage
        this.isEdited = true
        this.editedTime = Date().time
    }
    fun setLabels(images: JsonArray) {
        labels = RealmList()
        for (ob in images) {
            labels?.add(ob.asString)
        }
    }

    val messageWithoutMarkdown: String?
        get() {
            var ms = message
            for (ob in imagesArray) {
                ms = ms?.replace(JsonUtils.getString("markdown", ob.asJsonObject), "")
            }
            return ms
        }

    val isCommunityNews: Boolean
        get() {
            val array = Gson().fromJson(viewIn, JsonArray::class.java)
            var isCommunity = false
            for (e in array) {
                val `object` = e.asJsonObject
                if (`object`.has("section") && `object`["section"].asString.equals("community", ignoreCase = true)) {
                    isCommunity = true
                    break
                }
            }
            return isCommunity
        }

    companion object {
        private val gson = Gson()
        private val concatenatedLinks = ArrayList<String>()

        @JvmStatic
        fun insert(mRealm: Realm, doc: JsonObject?) {
            var news = mRealm.where(RealmNews::class.java).equalTo("_id", JsonUtils.getString("_id", doc)).findFirst()
            if (news == null) {
                news = mRealm.createObject(RealmNews::class.java, JsonUtils.getString("_id", doc))
            }
            news?._rev = JsonUtils.getString("_rev", doc)
            news?._id = JsonUtils.getString("_id", doc)
            news?.viewableBy = JsonUtils.getString("viewableBy", doc)
            news?.docType = JsonUtils.getString("docType", doc)
            news?.avatar = JsonUtils.getString("avatar", doc)
            news?.updatedDate = JsonUtils.getLong("updatedDate", doc)
            news?.viewableId = JsonUtils.getString("viewableId", doc)
            news?.createdOn = JsonUtils.getString("createdOn", doc)
            news?.messageType = JsonUtils.getString("messageType", doc)
            news?.messagePlanetCode = JsonUtils.getString("messagePlanetCode", doc)
            news?.replyTo = JsonUtils.getString("replyTo", doc)
            news?.parentCode = JsonUtils.getString("parentCode", doc)
            val user = JsonUtils.getJsonObject("user", doc)
            news?.user = Gson().toJson(JsonUtils.getJsonObject("user", doc))
            news?.userId = JsonUtils.getString("_id", user)
            news?.userName = JsonUtils.getString("name", user)
            news?.time = JsonUtils.getLong("time", doc)
            val images = JsonUtils.getJsonArray("images", doc)
            val message = JsonUtils.getString("message", doc)
            news?.message = message
            val links = extractLinks(message)
            val baseUrl = UrlUtils.getUrl()
            for (link in links) {
                val concatenatedLink = "$baseUrl/$link"
                concatenatedLinks.add(concatenatedLink)
            }
            news?.images = Gson().toJson(images)
            val labels = JsonUtils.getJsonArray("labels", doc)
            news?.viewIn = Gson().toJson(JsonUtils.getJsonArray("viewIn", doc))
            news?.setLabels(labels)
            news?.chat = JsonUtils.getBoolean("chat", doc)

            val newsObj = JsonUtils.getJsonObject("news", doc)
            news?.newsId = JsonUtils.getString("_id", newsObj)
            news?.newsRev = JsonUtils.getString("_rev", newsObj)
            news?.newsUser = JsonUtils.getString("user", newsObj)
            news?.aiProvider = JsonUtils.getString("aiProvider", newsObj)
            news?.newsTitle = JsonUtils.getString("title", newsObj)
            news?.conversations = Gson().toJson(JsonUtils.getJsonArray("conversations", newsObj))
            news?.newsCreatedDate = JsonUtils.getLong("createdDate", newsObj)
            news?.newsUpdatedDate = JsonUtils.getLong("updatedDate", newsObj)
            news?.sharedBy = JsonUtils.getString("sharedBy", newsObj)

            saveConcatenatedLinksToPrefs()
        }

        @JvmStatic
        fun serializeNews(news: RealmNews): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("chat", news.chat)
            `object`.addProperty("message", news.message)
            if (news._id != null) `object`.addProperty("_id", news._id)
            if (news._rev != null) `object`.addProperty("_rev", news._rev)
            `object`.addProperty("time", news.time)
            `object`.addProperty("createdOn", news.createdOn)
            `object`.addProperty("docType", news.docType)
            addViewIn(`object`, news)
            `object`.addProperty("avatar", news.avatar)
            `object`.addProperty("messageType", news.messageType)
            `object`.addProperty("messagePlanetCode", news.messagePlanetCode)
            `object`.addProperty("createdOn", news.createdOn)
            `object`.addProperty("replyTo", news.replyTo)
            `object`.addProperty("parentCode", news.parentCode)
            `object`.add("images", news.imagesArray)
            `object`.add("labels", news.labelsArray)
            `object`.add("user", Gson().fromJson(news.user, JsonObject::class.java))
            val newsObject = JsonObject()
            newsObject.addProperty("_id", news.newsId)
            newsObject.addProperty("_rev", news.newsRev)
            newsObject.addProperty("user", news.newsUser)
            newsObject.addProperty("aiProvider", news.aiProvider)
            newsObject.addProperty("title", news.newsTitle)
            newsObject.add("conversations", Gson().fromJson(news.conversations, JsonArray::class.java))
            newsObject.addProperty("createdDate", news.newsCreatedDate)
            newsObject.addProperty("updatedDate", news.newsUpdatedDate)
            newsObject.addProperty("sharedBy", news.sharedBy)
            `object`.add("news", newsObject)
            return `object`
        }

        private fun addViewIn(`object`: JsonObject, news: RealmNews) {
            if (!TextUtils.isEmpty(news.viewableId)) {
                `object`.addProperty("viewableId", news.viewableId)
                `object`.addProperty("viewableBy", news.viewableBy)
            }
            if (!TextUtils.isEmpty(news.viewIn)) {
                val ar = Gson().fromJson(news.viewIn, JsonArray::class.java)
                if (ar.size() > 0) `object`.add("viewIn", ar)
            }
        }

        @JvmStatic
        fun createNews(map: HashMap<String?, String>, mRealm: Realm, user: RealmUserModel?, imageUrls: RealmList<String>?, isReply: Boolean = false): RealmNews {
            val shouldManageTransaction = !mRealm.isInTransaction
            if (shouldManageTransaction) {
                mRealm.beginTransaction()
            }

            val news = mRealm.createObject(RealmNews::class.java, "${UUID.randomUUID()}")
            news.message = map["message"]
            news.time = Date().time
            news.createdOn = user?.planetCode
            news.avatar = ""
            news.docType = "message"
            news.userName = user?.name
            news.parentCode = user?.parentCode
            news.messagePlanetCode = map["messagePlanetCode"]
            news.messageType = map["messageType"]
            news.sharedBy = ""
            if(isReply){
                news.viewIn = map["viewIn"]
            } else {
                news.viewIn = getViewInJson(map)
            }
            news.chat = map["chat"]?.toBoolean() ?: false

            try {
                news.updatedDate = map["updatedDate"]?.toLong() ?: 0
            } catch (e: Exception) {
                e.printStackTrace()
            }

            news.userId = user?.id
            news.replyTo = map["replyTo"] ?: ""
            news.user = Gson().toJson(user?.serialize())
            if (news.imageUrls == null) {
                news.imageUrls = RealmList()
            }
            imageUrls?.forEach { news.imageUrls?.add(it) }

            if (map.containsKey("news")) {
                val newsObj = map["news"]
                val gson = Gson()
                try {
                    val newsJsonString = newsObj?.replace("=", ":")
                    val newsJson = gson.fromJson(newsJsonString, JsonObject::class.java)
                    news.newsId = JsonUtils.getString("_id", newsJson)
                    news.newsRev = JsonUtils.getString("_rev", newsJson)
                    news.newsUser = JsonUtils.getString("user", newsJson)
                    news.aiProvider = JsonUtils.getString("aiProvider", newsJson)
                    news.newsTitle = JsonUtils.getString("title", newsJson)
                    if (newsJson.has("conversations")) {
                        val conversationsElement = newsJson.get("conversations")
                        if (conversationsElement.isJsonPrimitive && conversationsElement.asJsonPrimitive.isString) {
                            val conversationsString = conversationsElement.asString
                            try {
                                val conversationsArray = gson.fromJson(conversationsString, JsonArray::class.java)
                                if (conversationsArray.size() > 0) {
                                    val conversationsList = ArrayList<HashMap<String, String>>()
                                    conversationsArray.forEach { conversationElement ->
                                        val conversationObj = conversationElement.asJsonObject
                                        val conversationMap = HashMap<String, String>()
                                        conversationMap["query"] = conversationObj.get("query").asString
                                        conversationMap["response"] = conversationObj.get("response").asString
                                        conversationsList.add(conversationMap)
                                    }
                                    news.conversations = Gson().toJson(conversationsList)
                                }
                            } catch (e: JsonSyntaxException) {
                                e.printStackTrace()
                            }
                        }
                    }
                    news.newsCreatedDate = JsonUtils.getLong("createdDate", newsJson)
                    news.newsUpdatedDate = JsonUtils.getLong("updatedDate", newsJson)
                } catch (e: JsonSyntaxException) {
                    e.printStackTrace()
                }
            }

            if (shouldManageTransaction) {
                mRealm.commitTransaction()
            }
            return news
        }

        @JvmStatic
        fun getViewInJson(map: HashMap<String?, String>): String {
            val viewInArray = JsonArray()
            if (!TextUtils.isEmpty(map["viewInId"])) {
                val `object` = JsonObject()
                `object`.addProperty("_id", map["viewInId"])
                `object`.addProperty("section", map["viewInSection"])
                `object`.addProperty("name", map["name"])
                viewInArray.add(`object`)
            }
            return Gson().toJson(viewInArray)
        }

        fun saveConcatenatedLinksToPrefs() {
            val settings: SharedPreferences = context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
            val existingJsonLinks = settings.getString("concatenated_links", null)
            val existingConcatenatedLinks = if (existingJsonLinks != null) {
                gson.fromJson(existingJsonLinks, Array<String>::class.java).toMutableList()
            } else {
                mutableListOf()
            }
            val linksToProcess: List<String>
            synchronized(concatenatedLinks) {
                linksToProcess = concatenatedLinks.toList()
            }
            for (link in linksToProcess) {
                if (!existingConcatenatedLinks.contains(link)) {
                    existingConcatenatedLinks.add(link)
                }
            }
            val jsonConcatenatedLinks = gson.toJson(existingConcatenatedLinks)
            settings.edit { putString("concatenated_links", jsonConcatenatedLinks) }
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.content.Context.MODE_PRIVATE
import android.content.SharedPreferences
import android.text.TextUtils
import androidx.core.content.edit
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.google.gson.JsonSyntaxException
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DownloadUtils.extractLinks
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.UrlUtils

open class RealmNews : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var userId: String? = null
    var user: String? = null
    var message: String? = null
    var docType: String? = null
    var viewableBy: String? = null
    var viewableId: String? = null
    var avatar: String? = null
    var replyTo: String? = null
    var userName: String? = null
    var messagePlanetCode: String? = null
    var messageType: String? = null
    var updatedDate: Long = 0
    var time: Long = 0
    var createdOn: String? = null
    var parentCode: String? = null
    var imageUrls: RealmList<String>? = null
    var images: String? = null
    var labels: RealmList<String>? = null
    var viewIn: String? = null
    var newsId: String? = null
    var newsRev: String? = null
    var newsUser: String? = null
    var aiProvider: String? = null
    var newsTitle: String? = null
    var conversations: String? = null
    var newsCreatedDate: Long = 0
    var newsUpdatedDate: Long = 0
    var chat: Boolean = false
    var isEdited: Boolean = false
    var editedTime: Long = 0
    var sharedBy: String? = null

    val imagesArray: JsonArray
        get() = if (images == null) JsonArray() else Gson().fromJson(images, JsonArray::class.java)

    val labelsArray: JsonArray
        get() {
            val array = JsonArray()
            labels?.forEach { s ->
                array.add(s)
            }
            return array
        }

    fun updateMessage(newMessage: String) {
        this.message = newMessage
        this.isEdited = true
        this.editedTime = Date().time
    }
    fun setLabels(images: JsonArray) {
        labels = RealmList()
        for (ob in images) {
            labels?.add(ob.asString)
        }
    }

    val messageWithoutMarkdown: String?
        get() {
            var ms = message
            for (ob in imagesArray) {
                ms = ms?.replace(JsonUtils.getString("markdown", ob.asJsonObject), "")
            }
            return ms
        }

    val isCommunityNews: Boolean
        get() {
            val array = Gson().fromJson(viewIn, JsonArray::class.java)
            var isCommunity = false
            for (e in array) {
                val `object` = e.asJsonObject
                if (`object`.has("section") && `object`["section"].asString.equals("community", ignoreCase = true)) {
                    isCommunity = true
                    break
                }
            }
            return isCommunity
        }

    companion object {
        private val gson = Gson()
        private val concatenatedLinks = ArrayList<String>()

        @JvmStatic
        fun insert(mRealm: Realm, doc: JsonObject?) {
            var news = mRealm.where(RealmNews::class.java).equalTo("_id", JsonUtils.getString("_id", doc)).findFirst()
            if (news == null) {
                news = mRealm.createObject(RealmNews::class.java, JsonUtils.getString("_id", doc))
            }
            news?._rev = JsonUtils.getString("_rev", doc)
            news?._id = JsonUtils.getString("_id", doc)
            news?.viewableBy = JsonUtils.getString("viewableBy", doc)
            news?.docType = JsonUtils.getString("docType", doc)
            news?.avatar = JsonUtils.getString("avatar", doc)
            news?.updatedDate = JsonUtils.getLong("updatedDate", doc)
            news?.viewableId = JsonUtils.getString("viewableId", doc)
            news?.createdOn = JsonUtils.getString("createdOn", doc)
            news?.messageType = JsonUtils.getString("messageType", doc)
            news?.messagePlanetCode = JsonUtils.getString("messagePlanetCode", doc)
            news?.replyTo = JsonUtils.getString("replyTo", doc)
            news?.parentCode = JsonUtils.getString("parentCode", doc)
            val user = JsonUtils.getJsonObject("user", doc)
            news?.user = Gson().toJson(JsonUtils.getJsonObject("user", doc))
            news?.userId = JsonUtils.getString("_id", user)
            news?.userName = JsonUtils.getString("name", user)
            news?.time = JsonUtils.getLong("time", doc)
            val images = JsonUtils.getJsonArray("images", doc)
            val message = JsonUtils.getString("message", doc)
            news?.message = message
            val links = extractLinks(message)
            val baseUrl = UrlUtils.getUrl()
            for (link in links) {
                val concatenatedLink = "$baseUrl/$link"
                concatenatedLinks.add(concatenatedLink)
            }
            news?.images = Gson().toJson(images)
            val labels = JsonUtils.getJsonArray("labels", doc)
            news?.viewIn = Gson().toJson(JsonUtils.getJsonArray("viewIn", doc))
            news?.setLabels(labels)
            news?.chat = JsonUtils.getBoolean("chat", doc)

            val newsObj = JsonUtils.getJsonObject("news", doc)
            news?.newsId = JsonUtils.getString("_id", newsObj)
            news?.newsRev = JsonUtils.getString("_rev", newsObj)
            news?.newsUser = JsonUtils.getString("user", newsObj)
            news?.aiProvider = JsonUtils.getString("aiProvider", newsObj)
            news?.newsTitle = JsonUtils.getString("title", newsObj)
            news?.conversations = Gson().toJson(JsonUtils.getJsonArray("conversations", newsObj))
            news?.newsCreatedDate = JsonUtils.getLong("createdDate", newsObj)
            news?.newsUpdatedDate = JsonUtils.getLong("updatedDate", newsObj)
            news?.sharedBy = JsonUtils.getString("sharedBy", newsObj)

            saveConcatenatedLinksToPrefs()
        }

        @JvmStatic
        fun serializeNews(news: RealmNews): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("chat", news.chat)
            `object`.addProperty("message", news.message)
            if (news._id != null) `object`.addProperty("_id", news._id)
            if (news._rev != null) `object`.addProperty("_rev", news._rev)
            `object`.addProperty("time", news.time)
            `object`.addProperty("createdOn", news.createdOn)
            `object`.addProperty("docType", news.docType)
            addViewIn(`object`, news)
            `object`.addProperty("avatar", news.avatar)
            `object`.addProperty("messageType", news.messageType)
            `object`.addProperty("messagePlanetCode", news.messagePlanetCode)
            `object`.addProperty("createdOn", news.createdOn)
            `object`.addProperty("replyTo", news.replyTo)
            `object`.addProperty("parentCode", news.parentCode)
            `object`.add("images", news.imagesArray)
            `object`.add("labels", news.labelsArray)
            `object`.add("user", Gson().fromJson(news.user, JsonObject::class.java))
            val newsObject = JsonObject()
            newsObject.addProperty("_id", news.newsId)
            newsObject.addProperty("_rev", news.newsRev)
            newsObject.addProperty("user", news.newsUser)
            newsObject.addProperty("aiProvider", news.aiProvider)
            newsObject.addProperty("title", news.newsTitle)
            newsObject.add("conversations", Gson().fromJson(news.conversations, JsonArray::class.java))
            newsObject.addProperty("createdDate", news.newsCreatedDate)
            newsObject.addProperty("updatedDate", news.newsUpdatedDate)
            newsObject.addProperty("sharedBy", news.sharedBy)
            `object`.add("news", newsObject)
            return `object`
        }

        private fun addViewIn(`object`: JsonObject, news: RealmNews) {
            if (!TextUtils.isEmpty(news.viewableId)) {
                `object`.addProperty("viewableId", news.viewableId)
                `object`.addProperty("viewableBy", news.viewableBy)
            }
            if (!TextUtils.isEmpty(news.viewIn)) {
                val ar = Gson().fromJson(news.viewIn, JsonArray::class.java)
                if (ar.size() > 0) `object`.add("viewIn", ar)
            }
        }

        @JvmStatic
        fun createNews(map: HashMap<String?, String>, mRealm: Realm, user: RealmUserModel?, imageUrls: RealmList<String>?, isReply: Boolean = false): RealmNews {
            val shouldManageTransaction = !mRealm.isInTransaction
            if (shouldManageTransaction) {
                mRealm.beginTransaction()
            }

            val news = mRealm.createObject(RealmNews::class.java, "${UUID.randomUUID()}")
            news.message = map["message"]
            news.time = Date().time
            news.createdOn = user?.planetCode
            news.avatar = ""
            news.docType = "message"
            news.userName = user?.name
            news.parentCode = user?.parentCode
            news.messagePlanetCode = map["messagePlanetCode"]
            news.messageType = map["messageType"]
            news.sharedBy = ""
            if(isReply){
                news.viewIn = map["viewIn"]
            } else {
                news.viewIn = getViewInJson(map)
            }
            news.chat = map["chat"]?.toBoolean() ?: false

            try {
                news.updatedDate = map["updatedDate"]?.toLong() ?: 0
            } catch (e: Exception) {
                e.printStackTrace()
            }

            news.userId = user?.id
            news.replyTo = map["replyTo"] ?: ""
            news.user = Gson().toJson(user?.serialize())
            if (news.imageUrls == null) {
                news.imageUrls = RealmList()
            }
            imageUrls?.forEach { news.imageUrls?.add(it) }

            if (map.containsKey("news")) {
                val newsObj = map["news"]
                val gson = Gson()
                try {
                    val newsJsonString = newsObj?.replace("=", ":")
                    val newsJson = gson.fromJson(newsJsonString, JsonObject::class.java)
                    news.newsId = JsonUtils.getString("_id", newsJson)
                    news.newsRev = JsonUtils.getString("_rev", newsJson)
                    news.newsUser = JsonUtils.getString("user", newsJson)
                    news.aiProvider = JsonUtils.getString("aiProvider", newsJson)
                    news.newsTitle = JsonUtils.getString("title", newsJson)
                    if (newsJson.has("conversations")) {
                        val conversationsElement = newsJson.get("conversations")
                        if (conversationsElement.isJsonPrimitive && conversationsElement.asJsonPrimitive.isString) {
                            val conversationsString = conversationsElement.asString
                            try {
                                val conversationsArray = gson.fromJson(conversationsString, JsonArray::class.java)
                                if (conversationsArray.size() > 0) {
                                    val conversationsList = ArrayList<HashMap<String, String>>()
                                    conversationsArray.forEach { conversationElement ->
                                        val conversationObj = conversationElement.asJsonObject
                                        val conversationMap = HashMap<String, String>()
                                        conversationMap["query"] = conversationObj.get("query").asString
                                        conversationMap["response"] = conversationObj.get("response").asString
                                        conversationsList.add(conversationMap)
                                    }
                                    news.conversations = Gson().toJson(conversationsList)
                                }
                            } catch (e: JsonSyntaxException) {
                                e.printStackTrace()
                            }
                        }
                    }
                    news.newsCreatedDate = JsonUtils.getLong("createdDate", newsJson)
                    news.newsUpdatedDate = JsonUtils.getLong("updatedDate", newsJson)
                } catch (e: JsonSyntaxException) {
                    e.printStackTrace()
                }
            }

            if (shouldManageTransaction) {
                mRealm.commitTransaction()
            }
            return news
        }

        @JvmStatic
        fun getViewInJson(map: HashMap<String?, String>): String {
            val viewInArray = JsonArray()
            if (!TextUtils.isEmpty(map["viewInId"])) {
                val `object` = JsonObject()
                `object`.addProperty("_id", map["viewInId"])
                `object`.addProperty("section", map["viewInSection"])
                `object`.addProperty("name", map["name"])
                viewInArray.add(`object`)
            }
            return Gson().toJson(viewInArray)
        }

        fun saveConcatenatedLinksToPrefs() {
            val settings: SharedPreferences = context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
            val existingJsonLinks = settings.getString("concatenated_links", null)
            val existingConcatenatedLinks = if (existingJsonLinks != null) {
                gson.fromJson(existingJsonLinks, Array<String>::class.java).toMutableList()
            } else {
                mutableListOf()
            }
            val linksToProcess: List<String>
            synchronized(concatenatedLinks) {
                linksToProcess = concatenatedLinks.toList()
            }
            for (link in linksToProcess) {
                if (!existingConcatenatedLinks.contains(link)) {
                    existingConcatenatedLinks.add(link)
                }
            }
            val jsonConcatenatedLinks = gson.toJson(existingConcatenatedLinks)
            settings.edit { putString("concatenated_links", jsonConcatenatedLinks) }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmMyLibrary.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.Context
import android.content.SharedPreferences
import com.google.gson.JsonArray
import com.google.gson.JsonNull
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Calendar
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmMyLibrary : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var userId: RealmList<String>? = null
        private set
    var resourceRemoteAddress: String? = null
    var resourceLocalAddress: String? = null
    var resourceOffline: Boolean = false
    var resourceId: String? = null
    var _rev: String? = null
    var downloadedRev: String? = null
    var needsOptimization: Boolean = false
    var publisher: String? = null
    var linkToLicense: String? = null
    var addedBy: String? = null
    var uploadDate: String? = null
    var createdDate: Long = 0
    var openWith: String? = null
    var articleDate: String? = null
    var kind: String? = null
    var language: String? = null
    var author: String? = null
    var year: String? = null
    var medium: String? = null
    var title: String? = null
    var averageRating: String? = null
    var filename: String? = null
    var mediaType: String? = null
    var resourceType: String? = null
    var description: String? = null
    var translationAudioPath: String? = null
    var sum: Int = 0
    var timesRated: Int = 0
    var resourceFor: RealmList<String>? = null
    var subject: RealmList<String>? = null
    var level: RealmList<String>? = null
    var tag: RealmList<String>? = null
    var languages: RealmList<String>? = null
    var courseId: String? = null
    var stepId: String? = null
    var isPrivate: Boolean = false
    var attachments: RealmList<RealmAttachment>? = null

    fun serializeResource(): JsonObject {
        return JsonObject().apply {
            addProperty("_id", _id)
            addProperty("_rev", _rev)
            addProperty("need_optimization", needsOptimization)
            add("resourceFor", resourceFor.toJsonArray())
            addProperty("publisher", publisher)
            addProperty("linkToLicense", linkToLicense)
            addProperty("addedBy", addedBy)
            addProperty("uploadDate", uploadDate)
            addProperty("openWith", openWith)
            add("subject", subject.toJsonArray())
            addProperty("kind", kind)
            addProperty("medium", medium)
            addProperty("language", language)
            addProperty("author", author)
            addProperty("sum", sum)
            addProperty("createdDate", uploadDate)
            add("level", level.toJsonArray())
            add("languages", languages.toJsonArray())
            add("tag", tag.toJsonArray())
            addProperty("timesRated", timesRated)
            addProperty("year", year)
            addProperty("title", title)
            addProperty("averageRating", averageRating)
            addProperty("filename", filename)
            addProperty("mediaType", mediaType)
            addProperty("description", description)
            val ob = JsonObject()
            resourceLocalAddress?.let { addr ->
                ob.add(addr, JsonObject())
            }
            add("_attachments", ob)
        }
    }
    private fun RealmList<String>?.toJsonArray(): JsonArray {
        return JsonArray().apply {
            this@toJsonArray?.forEach { add(it) }
        }
    }
    fun setUserId(userId: String?, realm: Realm? = null) {
        if (userId.isNullOrBlank()) return

        val executeInTransaction = realm != null && !realm.isInTransaction

        if (executeInTransaction) {
            realm.beginTransaction()
        }

        try {
            if (this.userId == null) {
                this.userId = RealmList()
            }
            if (!this.userId!!.contains(userId)) {
                this.userId?.add(userId)
            }

            if (executeInTransaction) {
                realm.commitTransaction()
            }
        } catch (e: Exception) {
            if (executeInTransaction && realm.isInTransaction) {
                realm.cancelTransaction()
            }
            throw e
        }
    }
    fun isResourceOffline(): Boolean {
        return resourceOffline && _rev == downloadedRev
    }
    private fun JsonArray?.setListIfNotNull(targetList: RealmList<String>?, setter: (String) -> Unit) {
        this?.forEach { jsonElement ->
            val value = jsonElement.takeIf { it !is JsonNull }?.asString ?: return@forEach
            if (value !in targetList.orEmpty()) {
                setter(value)
            }
        }
    }

    fun setResourceFor(array: JsonArray, resource: RealmMyLibrary?) {
        array.setListIfNotNull(resource?.resourceFor) { resource?.resourceFor?.add(it) }
    }

    fun setSubject(array: JsonArray, resource: RealmMyLibrary?) {
        array.setListIfNotNull(resource?.subject) { resource?.subject?.add(it) }
    }

    fun setLevel(array: JsonArray, resource: RealmMyLibrary?) {
        array.setListIfNotNull(resource?.level) { resource?.level?.add(it) }
    }

    fun setTag(array: JsonArray, resource: RealmMyLibrary?) {
        array.setListIfNotNull(resource?.tag) { resource?.tag?.add(it) }
    }

    fun setLanguages(array: JsonArray, resource: RealmMyLibrary?) {
        array.setListIfNotNull(resource?.languages) { resource?.languages?.add(it) }
    }

    fun setUserId(userId: RealmList<String>?) {
        this.userId = userId
    }

    val subjectsAsString: String
        get() = subject?.joinToString(", ") ?: ""

    override fun toString(): String {
        return title ?: ""
    }

    fun removeUserId(id: String?) {
        userId?.remove(id)
    }

    fun needToUpdate(): Boolean {
        return !resourceOffline || resourceLocalAddress != null && _rev != downloadedRev
    }

    companion object {
        fun getMyLibraryByUserId(mRealm: Realm, settings: SharedPreferences?): List<RealmMyLibrary> {
            val libs = mRealm.where(RealmMyLibrary::class.java).findAll()
            return getMyLibraryByUserId(settings?.getString("userId", "--"), libs, mRealm)
        }

        fun getMyLibraryByUserId(userId: String?, libs: List<RealmMyLibrary>, mRealm: Realm): List<RealmMyLibrary> {
            val ids = RealmMyTeam.getResourceIdsByUser(userId, mRealm)
            return libs.filter { it.userId?.contains(userId) == true || it.resourceId in ids }
        }

        @JvmStatic
        fun getMyLibraryByUserId(userId: String?, libs: List<RealmMyLibrary>): List<RealmMyLibrary> {
            return libs.filter { it.userId?.contains(userId) == true }
        }

        @JvmStatic
        fun getOurLibrary(userId: String?, libs: List<RealmMyLibrary>): List<RealmMyLibrary> {
            return libs.filter { it.userId?.contains(userId) == false }
        }

        private fun getIds(mRealm: Realm): Array<String?> {
            val list = mRealm.where(RealmMyLibrary::class.java).findAll()
            return list.map { it.resourceId }.toTypedArray()
        }

        @JvmStatic
        fun removeDeletedResource(newIds: List<String?>, mRealm: Realm) {
            val ids = getIds(mRealm)
            ids.filterNot { it in newIds }.forEach { id ->
                mRealm.executeTransaction { realm ->
                    realm.where(RealmMyLibrary::class.java).equalTo("resourceId", id).findAll()
                        .deleteAllFromRealm()
                }
            }
        }

        @JvmStatic
        fun serialize(personal: RealmMyLibrary, user: RealmUserModel?): JsonObject {
            return JsonObject().apply {
                addProperty("title", personal.title)
                addProperty("uploadDate", Date().time)
                addProperty("createdDate", personal.createdDate)
                addProperty("filename", FileUtils.getFileNameFromUrl(personal.resourceLocalAddress))
                addProperty("author", user?.name)
                addProperty("addedBy", user?.id)
                addProperty("medium", personal.medium)
                addProperty("description", personal.description)
                addProperty("year", personal.year)
                addProperty("language", personal.language)
                add("subject", JsonUtils.getAsJsonArray(personal.subject))
                add("level", JsonUtils.getAsJsonArray(personal.level))
                addProperty("resourceType", personal.resourceType)
                addProperty("openWith", personal.openWith)
                add("resourceFor", JsonUtils.getAsJsonArray(personal.resourceFor))
                addProperty("private", false)
                addProperty("isDownloadable", "")
                addProperty("sourcePlanet", user?.planetCode)
                addProperty("resideOn", user?.planetCode)
                addProperty("updatedDate", Calendar.getInstance().timeInMillis)
                addProperty("createdDate", personal.createdDate)
                addProperty("androidId", NetworkUtils.getUniqueIdentifier())
                addProperty("deviceName", NetworkUtils.getDeviceName())
                addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            }
        }

        private fun insertResources(doc: JsonObject, mRealm: Realm) {
            insertMyLibrary("", doc, mRealm)
        }

        @JvmStatic
        fun createStepResource(mRealm: Realm, res: JsonObject, myCoursesID: String?, stepId: String?) {
            insertMyLibrary("", stepId, myCoursesID, res, mRealm)
        }

        @JvmStatic
        fun insertMyLibrary(userId: String?, doc: JsonObject, mRealm: Realm) {
            insertMyLibrary(userId, "", "", doc, mRealm)
        }

        @JvmStatic
        fun createFromResource(resource: RealmMyLibrary?, mRealm: Realm, userId: String?) {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }
            resource?.setUserId(userId)
            mRealm.commitTransaction()
        }

        @JvmStatic
        fun insertMyLibrary(userId: String?, stepId: String?, courseId: String?, doc: JsonObject, mRealm: Realm) {
            if (doc.entrySet().isEmpty()) return
            val resourceId = JsonUtils.getString("_id", doc)
            val settings = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            var resource = mRealm.where(RealmMyLibrary::class.java).equalTo("id", resourceId).findFirst()
            if (resource == null) {
                resource = mRealm.createObject(RealmMyLibrary::class.java, resourceId)
            }
            resource?.apply {
                setUserId(userId)
                _id = resourceId
                if (!stepId.isNullOrBlank()) {
                    this.stepId = stepId
                }
                if (!courseId.isNullOrBlank()) {
                    this.courseId = courseId
                }
                _rev = JsonUtils.getString("_rev", doc)
                this.resourceId = resourceId
                title = JsonUtils.getString("title", doc)
                description = JsonUtils.getString("description", doc)
                if (doc.has("_attachments")) {
                    val attachments = doc["_attachments"].asJsonObject
                    if (this.attachments == null) {
                        this.attachments = RealmList()
                    }

                    attachments.entrySet().forEach { (key, attachmentValue) ->
                        val attachmentObj = attachmentValue.asJsonObject

                        val realmAttachment = mRealm.createObject(RealmAttachment::class.java, UUID.randomUUID().toString())
                        realmAttachment.apply {
                            name = key
                            contentType = attachmentObj.get("content_type")?.asString
                            length = attachmentObj.get("length")?.asLong ?: 0
                            digest = attachmentObj.get("digest")?.asString
                            isStub = attachmentObj.get("stub")?.asBoolean == true
                            revpos = attachmentObj.get("revpos")?.asInt ?: 0
                        }

                        this.attachments?.add(realmAttachment)

                        if (key.indexOf("/") < 0) {
                            resourceRemoteAddress = "${settings.getString("couchdbURL", "http://")}/resources/$resourceId/$key"
                            resourceLocalAddress = key
                            resourceOffline = FileUtils.checkFileExist(context, resourceRemoteAddress)
                        }
                    }
                }
                filename = JsonUtils.getString("filename", doc)
                averageRating = JsonUtils.getString("averageRating", doc)
                uploadDate = JsonUtils.getString("uploadDate", doc)
                year = JsonUtils.getString("year", doc)
                addedBy = JsonUtils.getString("addedBy", doc)
                publisher = JsonUtils.getString("publisher", doc)
                linkToLicense = JsonUtils.getString("linkToLicense", doc)
                openWith = JsonUtils.getString("openWith", doc)
                articleDate = JsonUtils.getString("articleDate", doc)
                kind = JsonUtils.getString("kind", doc)
                createdDate = JsonUtils.getLong("createdDate", doc)
                language = JsonUtils.getString("language", doc)
                author = JsonUtils.getString("author", doc)
                mediaType = JsonUtils.getString("mediaType", doc)
                resourceType = JsonUtils.getString("resourceType", doc)
                timesRated = JsonUtils.getInt("timesRated", doc)
                medium = JsonUtils.getString("medium", doc)
                setResourceFor(JsonUtils.getJsonArray("resourceFor", doc), this)
                setSubject(JsonUtils.getJsonArray("subject", doc), this)
                setLevel(JsonUtils.getJsonArray("level", doc), this)
                setTag(JsonUtils.getJsonArray("tags", doc), this)
                isPrivate = JsonUtils.getBoolean("private", doc)
                setLanguages(JsonUtils.getJsonArray("languages", doc), this)
            }
        }

        @JvmStatic
        fun listToString(list: RealmList<String>?): String {
            return list?.joinToString(", ") ?: ""
        }

        @JvmStatic
        fun save(allDocs: JsonArray, mRealm: Realm): List<String> {
            val list: MutableList<String> = ArrayList()
            allDocs.forEach { doc ->
                val document = JsonUtils.getJsonObject("doc", doc.asJsonObject)
                val id = JsonUtils.getString("_id", document)
                if (!id.startsWith("_design")) {
                    list.add(id)
                    insertResources(document, mRealm)
                }
            }
            return list
        }

        @JvmStatic
        fun getMyLibIds(realm: Realm?, userId: String?): JsonArray {
            val myLibraries = userId?.let { realm?.where(RealmMyLibrary::class.java)?.contains("userId", it)?.findAll() }
            return JsonArray().apply { myLibraries?.forEach { lib -> add(lib.id) }
            }
        }
        @JvmStatic
        fun getLevels(libraries: List<RealmMyLibrary>): Set<String> {
            return libraries.flatMap { it.level ?: emptyList() }.toSet()
        }

        @JvmStatic
        fun getArrayList(libraries: List<RealmMyLibrary>, type: String): Set<String?> {
            return libraries.mapNotNull { if (type == "mediums") it.mediaType else it.language }.filterNot { it.isBlank() }.toSet()
        }

        @JvmStatic
        fun getSubjects(libraries: List<RealmMyLibrary>): Set<String> {
            return libraries.flatMap { it.subject ?: emptyList() }.toSet()
        }
    }
}

open class RealmAttachment : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var name: String? = null
    var contentType: String? = null
    var length: Long = 0
    var digest: String? = null
    var isStub: Boolean = false
    var revpos: Int = 0
}
=======
package org.ole.planet.myplanet.model


import android.content.Context
import android.content.SharedPreferences
import com.google.gson.JsonArray
import com.google.gson.JsonNull
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.util.Calendar
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils

open class RealmMyLibrary : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var userId: RealmList<String>? = null
        private set
    var resourceRemoteAddress: String? = null
    var resourceLocalAddress: String? = null
    var resourceOffline: Boolean = false
    var resourceId: String? = null
    var _rev: String? = null
    var downloadedRev: String? = null
    var needsOptimization: Boolean = false
    var publisher: String? = null
    var linkToLicense: String? = null
    var addedBy: String? = null
    var uploadDate: String? = null
    var createdDate: Long = 0
    var openWith: String? = null
    var articleDate: String? = null
    var kind: String? = null
    var language: String? = null
    var author: String? = null
    var year: String? = null
    var medium: String? = null
    var title: String? = null
    var averageRating: String? = null
    var filename: String? = null
    var mediaType: String? = null
    var resourceType: String? = null
    var description: String? = null
    var translationAudioPath: String? = null
    var sum: Int = 0
    var timesRated: Int = 0
    var resourceFor: RealmList<String>? = null
    var subject: RealmList<String>? = null
    var level: RealmList<String>? = null
    var tag: RealmList<String>? = null
    var languages: RealmList<String>? = null
    var courseId: String? = null
    var stepId: String? = null
    var isPrivate: Boolean = false
    var attachments: RealmList<RealmAttachment>? = null

    fun serializeResource(): JsonObject {
        return JsonObject().apply {
            addProperty("_id", _id)
            addProperty("_rev", _rev)
            addProperty("need_optimization", needsOptimization)
            add("resourceFor", resourceFor.toJsonArray())
            addProperty("publisher", publisher)
            addProperty("linkToLicense", linkToLicense)
            addProperty("addedBy", addedBy)
            addProperty("uploadDate", uploadDate)
            addProperty("openWith", openWith)
            add("subject", subject.toJsonArray())
            addProperty("kind", kind)
            addProperty("medium", medium)
            addProperty("language", language)
            addProperty("author", author)
            addProperty("sum", sum)
            addProperty("createdDate", uploadDate)
            add("level", level.toJsonArray())
            add("languages", languages.toJsonArray())
            add("tag", tag.toJsonArray())
            addProperty("timesRated", timesRated)
            addProperty("year", year)
            addProperty("title", title)
            addProperty("averageRating", averageRating)
            addProperty("filename", filename)
            addProperty("mediaType", mediaType)
            addProperty("description", description)
            val ob = JsonObject()
            resourceLocalAddress?.let { addr ->
                ob.add(addr, JsonObject())
            }
            add("_attachments", ob)
        }
    }
    private fun RealmList<String>?.toJsonArray(): JsonArray {
        return JsonArray().apply {
            this@toJsonArray?.forEach { add(it) }
        }
    }
    fun setUserId(userId: String?, realm: Realm? = null) {
        if (userId.isNullOrBlank()) return

        val executeInTransaction = realm != null && !realm.isInTransaction

        if (executeInTransaction) {
            realm.beginTransaction()
        }

        try {
            if (this.userId == null) {
                this.userId = RealmList()
            }
            if (!this.userId!!.contains(userId)) {
                this.userId?.add(userId)
            }

            if (executeInTransaction) {
                realm.commitTransaction()
            }
        } catch (e: Exception) {
            if (executeInTransaction && realm.isInTransaction) {
                realm.cancelTransaction()
            }
            throw e
        }
    }
    fun isResourceOffline(): Boolean {
        return resourceOffline && _rev == downloadedRev
    }
    private fun JsonArray?.setListIfNotNull(targetList: RealmList<String>?, setter: (String) -> Unit) {
        this?.forEach { jsonElement ->
            val value = jsonElement.takeIf { it !is JsonNull }?.asString ?: return@forEach
            if (value !in targetList.orEmpty()) {
                setter(value)
            }
        }
    }

    fun setResourceFor(array: JsonArray, resource: RealmMyLibrary?) {
        array.setListIfNotNull(resource?.resourceFor) { resource?.resourceFor?.add(it) }
    }

    fun setSubject(array: JsonArray, resource: RealmMyLibrary?) {
        array.setListIfNotNull(resource?.subject) { resource?.subject?.add(it) }
    }

    fun setLevel(array: JsonArray, resource: RealmMyLibrary?) {
        array.setListIfNotNull(resource?.level) { resource?.level?.add(it) }
    }

    fun setTag(array: JsonArray, resource: RealmMyLibrary?) {
        array.setListIfNotNull(resource?.tag) { resource?.tag?.add(it) }
    }

    fun setLanguages(array: JsonArray, resource: RealmMyLibrary?) {
        array.setListIfNotNull(resource?.languages) { resource?.languages?.add(it) }
    }

    fun setUserId(userId: RealmList<String>?) {
        this.userId = userId
    }

    val subjectsAsString: String
        get() = subject?.joinToString(", ") ?: ""

    override fun toString(): String {
        return title ?: ""
    }

    fun removeUserId(id: String?) {
        userId?.remove(id)
    }

    fun needToUpdate(): Boolean {
        return !resourceOffline || resourceLocalAddress != null && _rev != downloadedRev
    }

    companion object {
        fun getMyLibraryByUserId(mRealm: Realm, settings: SharedPreferences?): List<RealmMyLibrary> {
            val libs = mRealm.where(RealmMyLibrary::class.java).findAll()
            return getMyLibraryByUserId(settings?.getString("userId", "--"), libs, mRealm)
        }

        fun getMyLibraryByUserId(userId: String?, libs: List<RealmMyLibrary>, mRealm: Realm): List<RealmMyLibrary> {
            val ids = RealmMyTeam.getResourceIdsByUser(userId, mRealm)
            return libs.filter { it.userId?.contains(userId) == true || it.resourceId in ids }
        }

        @JvmStatic
        fun getMyLibraryByUserId(userId: String?, libs: List<RealmMyLibrary>): List<RealmMyLibrary> {
            return libs.filter { it.userId?.contains(userId) == true }
        }

        @JvmStatic
        fun getOurLibrary(userId: String?, libs: List<RealmMyLibrary>): List<RealmMyLibrary> {
            return libs.filter { it.userId?.contains(userId) == false }
        }

        private fun getIds(mRealm: Realm): Array<String?> {
            val list = mRealm.where(RealmMyLibrary::class.java).findAll()
            return list.map { it.resourceId }.toTypedArray()
        }

        @JvmStatic
        fun removeDeletedResource(newIds: List<String?>, mRealm: Realm) {
            val ids = getIds(mRealm)
            ids.filterNot { it in newIds }.forEach { id ->
                mRealm.executeTransaction { realm ->
                    realm.where(RealmMyLibrary::class.java).equalTo("resourceId", id).findAll()
                        .deleteAllFromRealm()
                }
            }
        }

        @JvmStatic
        fun serialize(personal: RealmMyLibrary, user: RealmUserModel?): JsonObject {
            return JsonObject().apply {
                addProperty("title", personal.title)
                addProperty("uploadDate", Date().time)
                addProperty("createdDate", personal.createdDate)
                addProperty("filename", FileUtils.getFileNameFromUrl(personal.resourceLocalAddress))
                addProperty("author", user?.name)
                addProperty("addedBy", user?.id)
                addProperty("medium", personal.medium)
                addProperty("description", personal.description)
                addProperty("year", personal.year)
                addProperty("language", personal.language)
                add("subject", JsonUtils.getAsJsonArray(personal.subject))
                add("level", JsonUtils.getAsJsonArray(personal.level))
                addProperty("resourceType", personal.resourceType)
                addProperty("openWith", personal.openWith)
                add("resourceFor", JsonUtils.getAsJsonArray(personal.resourceFor))
                addProperty("private", false)
                addProperty("isDownloadable", "")
                addProperty("sourcePlanet", user?.planetCode)
                addProperty("resideOn", user?.planetCode)
                addProperty("updatedDate", Calendar.getInstance().timeInMillis)
                addProperty("createdDate", personal.createdDate)
                addProperty("androidId", NetworkUtils.getUniqueIdentifier())
                addProperty("deviceName", NetworkUtils.getDeviceName())
                addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            }
        }

        private fun insertResources(doc: JsonObject, mRealm: Realm) {
            insertMyLibrary("", doc, mRealm)
        }

        @JvmStatic
        fun createStepResource(mRealm: Realm, res: JsonObject, myCoursesID: String?, stepId: String?) {
            insertMyLibrary("", stepId, myCoursesID, res, mRealm)
        }

        @JvmStatic
        fun insertMyLibrary(userId: String?, doc: JsonObject, mRealm: Realm) {
            insertMyLibrary(userId, "", "", doc, mRealm)
        }

        @JvmStatic
        fun createFromResource(resource: RealmMyLibrary?, mRealm: Realm, userId: String?) {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }
            resource?.setUserId(userId)
            mRealm.commitTransaction()
        }

        @JvmStatic
        fun insertMyLibrary(userId: String?, stepId: String?, courseId: String?, doc: JsonObject, mRealm: Realm) {
            if (doc.entrySet().isEmpty()) return
            val resourceId = JsonUtils.getString("_id", doc)
            val settings = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            var resource = mRealm.where(RealmMyLibrary::class.java).equalTo("id", resourceId).findFirst()
            if (resource == null) {
                resource = mRealm.createObject(RealmMyLibrary::class.java, resourceId)
            }
            resource?.apply {
                setUserId(userId)
                _id = resourceId
                if (!stepId.isNullOrBlank()) {
                    this.stepId = stepId
                }
                if (!courseId.isNullOrBlank()) {
                    this.courseId = courseId
                }
                _rev = JsonUtils.getString("_rev", doc)
                this.resourceId = resourceId
                title = JsonUtils.getString("title", doc)
                description = JsonUtils.getString("description", doc)
                if (doc.has("_attachments")) {
                    val attachments = doc["_attachments"].asJsonObject
                    if (this.attachments == null) {
                        this.attachments = RealmList()
                    }

                    attachments.entrySet().forEach { (key, attachmentValue) ->
                        val attachmentObj = attachmentValue.asJsonObject

                        val realmAttachment = mRealm.createObject(RealmAttachment::class.java, UUID.randomUUID().toString())
                        realmAttachment.apply {
                            name = key
                            contentType = attachmentObj.get("content_type")?.asString
                            length = attachmentObj.get("length")?.asLong ?: 0
                            digest = attachmentObj.get("digest")?.asString
                            isStub = attachmentObj.get("stub")?.asBoolean == true
                            revpos = attachmentObj.get("revpos")?.asInt ?: 0
                        }

                        this.attachments?.add(realmAttachment)

                        if (key.indexOf("/") < 0) {
                            resourceRemoteAddress = "${settings.getString("couchdbURL", "http://")}/resources/$resourceId/$key"
                            resourceLocalAddress = key
                            resourceOffline = FileUtils.checkFileExist(context, resourceRemoteAddress)
                        }
                    }
                }
                filename = JsonUtils.getString("filename", doc)
                averageRating = JsonUtils.getString("averageRating", doc)
                uploadDate = JsonUtils.getString("uploadDate", doc)
                year = JsonUtils.getString("year", doc)
                addedBy = JsonUtils.getString("addedBy", doc)
                publisher = JsonUtils.getString("publisher", doc)
                linkToLicense = JsonUtils.getString("linkToLicense", doc)
                openWith = JsonUtils.getString("openWith", doc)
                articleDate = JsonUtils.getString("articleDate", doc)
                kind = JsonUtils.getString("kind", doc)
                createdDate = JsonUtils.getLong("createdDate", doc)
                language = JsonUtils.getString("language", doc)
                author = JsonUtils.getString("author", doc)
                mediaType = JsonUtils.getString("mediaType", doc)
                resourceType = JsonUtils.getString("resourceType", doc)
                timesRated = JsonUtils.getInt("timesRated", doc)
                medium = JsonUtils.getString("medium", doc)
                setResourceFor(JsonUtils.getJsonArray("resourceFor", doc), this)
                setSubject(JsonUtils.getJsonArray("subject", doc), this)
                setLevel(JsonUtils.getJsonArray("level", doc), this)
                setTag(JsonUtils.getJsonArray("tags", doc), this)
                isPrivate = JsonUtils.getBoolean("private", doc)
                setLanguages(JsonUtils.getJsonArray("languages", doc), this)
            }
        }

        @JvmStatic
        fun listToString(list: RealmList<String>?): String {
            return list?.joinToString(", ") ?: ""
        }

        @JvmStatic
        fun save(allDocs: JsonArray, mRealm: Realm): List<String> {
            val list: MutableList<String> = ArrayList()
            allDocs.forEach { doc ->
                val document = JsonUtils.getJsonObject("doc", doc.asJsonObject)
                val id = JsonUtils.getString("_id", document)
                if (!id.startsWith("_design")) {
                    list.add(id)
                    insertResources(document, mRealm)
                }
            }
            return list
        }

        @JvmStatic
        fun getMyLibIds(realm: Realm?, userId: String?): JsonArray {
            val myLibraries = userId?.let { realm?.where(RealmMyLibrary::class.java)?.contains("userId", it)?.findAll() }
            return JsonArray().apply { myLibraries?.forEach { lib -> add(lib.id) }
            }
        }
        @JvmStatic
        fun getLevels(libraries: List<RealmMyLibrary>): Set<String> {
            return libraries.flatMap { it.level ?: emptyList() }.toSet()
        }

        @JvmStatic
        fun getArrayList(libraries: List<RealmMyLibrary>, type: String): Set<String?> {
            return libraries.mapNotNull { if (type == "mediums") it.mediaType else it.language }.filterNot { it.isBlank() }.toSet()
        }

        @JvmStatic
        fun getSubjects(libraries: List<RealmMyLibrary>): Set<String> {
            return libraries.flatMap { it.subject ?: emptyList() }.toSet()
        }
    }
}

open class RealmAttachment : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var name: String? = null
    var contentType: String? = null
    var length: Long = 0
    var digest: String? = null
    var isStub: Boolean = false
    var revpos: Int = 0
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmSubmission.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.content.Context
import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import io.realm.Case
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.io.IOException
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.UrlUtils

open class RealmSubmission : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var parentId: String? = null
    var type: String? = null
    var userId: String? = null
    var user: String? = null
    var startTime: Long = 0
    var lastUpdateTime: Long = 0
    var answers: RealmList<RealmAnswer>? = null
    var team: String? = null
    var grade: Long = 0
    var status: String? = null
    var uploaded = false
    var sender: String? = null
    var source: String? = null
    var parentCode: String? = null
    var parent: String? = null
    var membershipDoc: RealmMembershipDoc? = null
    var isUpdated = false

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, submission: JsonObject) {
            if (submission.has("_attachments")) {
                return
            }

            var transactionStarted = false

            try {
                if (!mRealm.isInTransaction) {
                    mRealm.beginTransaction()
                    transactionStarted = true
                }

                val id = JsonUtils.getString("_id", submission)
                var sub = mRealm.where(RealmSubmission::class.java).equalTo("_id", id).findFirst()
                if (sub == null) {
                    sub = mRealm.createObject(RealmSubmission::class.java, id)
                }
                sub?._id = id
                sub?.status = JsonUtils.getString("status", submission)
                sub?._rev = JsonUtils.getString("_rev", submission)
                sub?.grade = JsonUtils.getLong("grade", submission)
                sub?.type = JsonUtils.getString("type", submission)
                sub?.uploaded = JsonUtils.getString("status", submission) == "graded"
                sub?.startTime = JsonUtils.getLong("startTime", submission)
                sub?.lastUpdateTime = JsonUtils.getLong("lastUpdateTime", submission)
                sub?.parentId = JsonUtils.getString("parentId", submission)
                sub?.sender = JsonUtils.getString("sender", submission)
                sub?.source = JsonUtils.getString("source", submission)
                sub?.parentCode = JsonUtils.getString("parentCode", submission)
                sub?.parent = Gson().toJson(JsonUtils.getJsonObject("parent", submission))
                sub?.user = Gson().toJson(JsonUtils.getJsonObject("user", submission))
                sub.team = JsonUtils.getString("team", submission)

                val userJson = JsonUtils.getJsonObject("user", submission)
                if (userJson.has("membershipDoc")) {
                    val membershipJson = JsonUtils.getJsonObject("membershipDoc", userJson)
                    if (membershipJson.entrySet().isNotEmpty()) {
                        val membership = mRealm.createObject(RealmMembershipDoc::class.java)
                        membership.teamId = JsonUtils.getString("teamId", membershipJson)
                        sub?.membershipDoc = membership
                    }
                }

                val userId = JsonUtils.getString("_id", JsonUtils.getJsonObject("user", submission))
                sub?.userId = if (userId.contains("@")) {
                    val us = userId.split("@".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
                    if (us[0].startsWith("org.couchdb.user:")) us[0] else "org.couchdb.user:${us[0]}"
                } else {
                    userId
                }

                if (submission.has("answers")) {
                    val answersArray = submission.get("answers").asJsonArray
                    sub?.answers = RealmList<RealmAnswer>()

                    for (i in 0 until answersArray.size()) {
                        val answerJson = answersArray[i].asJsonObject
                        val realmAnswer = mRealm.createObject(RealmAnswer::class.java, UUID.randomUUID().toString())

                        realmAnswer.value = JsonUtils.getString("value", answerJson)
                        realmAnswer.mistakes = JsonUtils.getInt("mistakes", answerJson)
                        realmAnswer.isPassed = JsonUtils.getBoolean("passed", answerJson)
                        realmAnswer.submissionId = sub?._id
                        realmAnswer.examId = sub?.parentId

                        val examIdPart = sub?.parentId?.split("@")?.get(0) ?: sub?.parentId
                        realmAnswer.questionId = if (answerJson.has("questionId")) {
                            JsonUtils.getString("questionId", answerJson)
                        } else {
                            "$examIdPart-$i"
                        }

                        sub?.answers?.add(realmAnswer)
                    }
                }

                if (transactionStarted) {
                    mRealm.commitTransaction()
                }
            } catch (e: Exception) {
                e.printStackTrace()
                if (transactionStarted && mRealm.isInTransaction) {
                    mRealm.cancelTransaction()
                }
            }
        }

        @JvmStatic
        fun serializeExamResult(mRealm: Realm, sub: RealmSubmission, context: Context): JsonObject {
            val `object` = JsonObject()
            val user = mRealm.where(RealmUserModel::class.java).equalTo("id", sub.userId).findFirst()
            var examId = sub.parentId
            if (sub.parentId?.contains("@") == true) {
                examId = sub.parentId!!.split("@".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()[0]
            }
            val exam = mRealm.where(RealmStepExam::class.java).equalTo("id", examId).findFirst()
            if (!TextUtils.isEmpty(sub._id)) {
                `object`.addProperty("_id", sub._id)
            }
            if (!TextUtils.isEmpty(sub._rev)) {
                `object`.addProperty("_rev", sub._rev)
            }
            `object`.addProperty("parentId", sub.parentId)
            `object`.addProperty("type", sub.type)
            `object`.addProperty("team", sub.team)
            `object`.addProperty("grade", sub.grade)
            `object`.addProperty("startTime", sub.startTime)
            `object`.addProperty("lastUpdateTime", sub.lastUpdateTime)
            `object`.addProperty("status", sub.status)
            `object`.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            `object`.addProperty("deviceName", NetworkUtils.getDeviceName())
            `object`.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            `object`.addProperty("sender", sub.sender)
            val prefs = context.getSharedPreferences(Constants.PREFS_NAME, Context.MODE_PRIVATE)
            `object`.addProperty("source", prefs.getString("planetCode", ""))
            `object`.addProperty("parentCode", prefs.getString("parentCode", ""))
            val parent = Gson().fromJson(sub.parent, JsonObject::class.java)
            `object`.add("parent", parent)
            `object`.add("answers", RealmAnswer.serializeRealmAnswer(sub.answers ?: RealmList()))
            if (exam != null && parent == null) `object`.add("parent", RealmStepExam.serializeExam(mRealm, exam))
            if (TextUtils.isEmpty(sub.user)) {
                `object`.add("user", user?.serialize())
            } else {
                `object`.add("user", JsonParser.parseString(sub.user))
            }
            return `object`
        }

        @JvmStatic
        fun isStepCompleted(realm: Realm, id: String?, userId: String?): Boolean {
            val exam = realm.where(RealmStepExam::class.java).equalTo("stepId", id).findFirst() ?: return true
            return exam.id?.let {
                realm.where(RealmSubmission::class.java).equalTo("userId", userId)
                    .contains("parentId", it).notEqualTo("status", "pending").findFirst()
            } != null
        }

        @JvmStatic
        fun createSubmission(sub: RealmSubmission?, mRealm: Realm): RealmSubmission {
            var submission = sub
            if (submission == null || submission.status == "complete" && (submission.type == "exam" || submission.type == "survey"))
                submission = mRealm.createObject(RealmSubmission::class.java, UUID.randomUUID().toString())
            submission!!.lastUpdateTime = Date().time
            return submission
        }

        @JvmStatic
        fun getNoOfSurveySubmissionByUser(userId: String?, mRealm: Realm): Int {
            if (userId == null) return 0

            return mRealm.where(RealmSubmission::class.java)
                .equalTo("userId", userId)
                .equalTo("type", "survey")
                .equalTo("status", "pending", Case.INSENSITIVE)
                .count().toInt()
        }

        @JvmStatic
        fun getExamMap(mRealm: Realm, submissions: List<RealmSubmission>?): HashMap<String?, RealmStepExam> {
            val exams = HashMap<String?, RealmStepExam>()
            for (sub in submissions ?: emptyList()){
                var id = sub.parentId
                if (checkParentId(sub.parentId)) {
                    id = sub.parentId!!.split("@".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()[0]
                }
                val survey = mRealm.where(RealmStepExam::class.java).equalTo("id", id).findFirst()
                if (survey != null) {
                    exams[sub.parentId] = survey
                }
            }
            return exams
        }

        private fun checkParentId(parentId: String?): Boolean {
            return parentId != null && parentId.contains("@")
        }

        @JvmStatic
        fun serialize(mRealm: Realm, submission: RealmSubmission): JsonObject {
            val jsonObject = JsonObject()

            try {
                if (!submission._id.isNullOrEmpty()) {
                    jsonObject.addProperty("_id", submission._id)
                }
                if (!submission._rev.isNullOrEmpty()) {
                    jsonObject.addProperty("_rev", submission._rev)
                }

                jsonObject.addProperty("parentId", submission.parentId ?: "")
                jsonObject.addProperty("type", submission.type ?: "survey")
                jsonObject.addProperty("userId", submission.userId ?: "")
                jsonObject.addProperty("status", submission.status ?: "pending")
                jsonObject.addProperty("team", submission.team ?: "")
                jsonObject.addProperty("uploaded", submission.uploaded)
                jsonObject.addProperty("sender", submission.sender ?: "")
                jsonObject.addProperty("source", submission.source ?: "")
                jsonObject.addProperty("parentCode", submission.parentCode ?: "")
                jsonObject.addProperty("startTime", submission.startTime)
                jsonObject.addProperty("lastUpdateTime", submission.lastUpdateTime)
                jsonObject.addProperty("grade", submission.grade)

                if (!submission.parent.isNullOrEmpty()) {
                    jsonObject.add("parent", JsonParser.parseString(submission.parent))
                }

                if (!submission.user.isNullOrEmpty()) {
                    val userJson = JsonParser.parseString(submission.user).asJsonObject
                    if (submission.membershipDoc != null) {
                        val membershipJson = JsonObject()
                        membershipJson.addProperty("teamId", submission.membershipDoc?.teamId ?: "")

                        userJson.add("membershipDoc", membershipJson)
                    }
                    jsonObject.add("user", userJson)
                }

                val questions = mRealm.where(RealmExamQuestion::class.java)
                    .equalTo("examId", submission.parentId)
                    .findAll()
                val serializedQuestions = RealmExamQuestion.serializeQuestions(questions)
                jsonObject.add("questions", serializedQuestions)

                val answersArray = RealmAnswer.serializeRealmAnswer(submission.answers ?: RealmList())
                jsonObject.add("answers", answersArray)
            } catch (e: Exception) {
                e.printStackTrace()
            }
            return jsonObject
        }
    }
}

open class RealmMembershipDoc : RealmObject() {
    var teamId: String? = null
}
=======
package org.ole.planet.myplanet.model


import android.content.Context
import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import io.realm.Case
import io.realm.Realm
import io.realm.RealmList
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import java.io.IOException
import java.util.Date
import java.util.UUID
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.utilities.Constants
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.UrlUtils

open class RealmSubmission : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var parentId: String? = null
    var type: String? = null
    var userId: String? = null
    var user: String? = null
    var startTime: Long = 0
    var lastUpdateTime: Long = 0
    var answers: RealmList<RealmAnswer>? = null
    var team: String? = null
    var grade: Long = 0
    var status: String? = null
    var uploaded = false
    var sender: String? = null
    var source: String? = null
    var parentCode: String? = null
    var parent: String? = null
    var membershipDoc: RealmMembershipDoc? = null
    var isUpdated = false

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, submission: JsonObject) {
            if (submission.has("_attachments")) {
                return
            }

            var transactionStarted = false

            try {
                if (!mRealm.isInTransaction) {
                    mRealm.beginTransaction()
                    transactionStarted = true
                }

                val id = JsonUtils.getString("_id", submission)
                var sub = mRealm.where(RealmSubmission::class.java).equalTo("_id", id).findFirst()
                if (sub == null) {
                    sub = mRealm.createObject(RealmSubmission::class.java, id)
                }
                sub?._id = id
                sub?.status = JsonUtils.getString("status", submission)
                sub?._rev = JsonUtils.getString("_rev", submission)
                sub?.grade = JsonUtils.getLong("grade", submission)
                sub?.type = JsonUtils.getString("type", submission)
                sub?.uploaded = JsonUtils.getString("status", submission) == "graded"
                sub?.startTime = JsonUtils.getLong("startTime", submission)
                sub?.lastUpdateTime = JsonUtils.getLong("lastUpdateTime", submission)
                sub?.parentId = JsonUtils.getString("parentId", submission)
                sub?.sender = JsonUtils.getString("sender", submission)
                sub?.source = JsonUtils.getString("source", submission)
                sub?.parentCode = JsonUtils.getString("parentCode", submission)
                sub?.parent = Gson().toJson(JsonUtils.getJsonObject("parent", submission))
                sub?.user = Gson().toJson(JsonUtils.getJsonObject("user", submission))
                sub.team = JsonUtils.getString("team", submission)

                val userJson = JsonUtils.getJsonObject("user", submission)
                if (userJson.has("membershipDoc")) {
                    val membershipJson = JsonUtils.getJsonObject("membershipDoc", userJson)
                    if (membershipJson.entrySet().isNotEmpty()) {
                        val membership = mRealm.createObject(RealmMembershipDoc::class.java)
                        membership.teamId = JsonUtils.getString("teamId", membershipJson)
                        sub?.membershipDoc = membership
                    }
                }

                val userId = JsonUtils.getString("_id", JsonUtils.getJsonObject("user", submission))
                sub?.userId = if (userId.contains("@")) {
                    val us = userId.split("@".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
                    if (us[0].startsWith("org.couchdb.user:")) us[0] else "org.couchdb.user:${us[0]}"
                } else {
                    userId
                }

                if (submission.has("answers")) {
                    val answersArray = submission.get("answers").asJsonArray
                    sub?.answers = RealmList<RealmAnswer>()

                    for (i in 0 until answersArray.size()) {
                        val answerJson = answersArray[i].asJsonObject
                        val realmAnswer = mRealm.createObject(RealmAnswer::class.java, UUID.randomUUID().toString())

                        realmAnswer.value = JsonUtils.getString("value", answerJson)
                        realmAnswer.mistakes = JsonUtils.getInt("mistakes", answerJson)
                        realmAnswer.isPassed = JsonUtils.getBoolean("passed", answerJson)
                        realmAnswer.submissionId = sub?._id
                        realmAnswer.examId = sub?.parentId

                        val examIdPart = sub?.parentId?.split("@")?.get(0) ?: sub?.parentId
                        realmAnswer.questionId = if (answerJson.has("questionId")) {
                            JsonUtils.getString("questionId", answerJson)
                        } else {
                            "$examIdPart-$i"
                        }

                        sub?.answers?.add(realmAnswer)
                    }
                }

                if (transactionStarted) {
                    mRealm.commitTransaction()
                }
            } catch (e: Exception) {
                e.printStackTrace()
                if (transactionStarted && mRealm.isInTransaction) {
                    mRealm.cancelTransaction()
                }
            }
        }

        @JvmStatic
        fun serializeExamResult(mRealm: Realm, sub: RealmSubmission, context: Context): JsonObject {
            val `object` = JsonObject()
            val user = mRealm.where(RealmUserModel::class.java).equalTo("id", sub.userId).findFirst()
            var examId = sub.parentId
            if (sub.parentId?.contains("@") == true) {
                examId = sub.parentId!!.split("@".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()[0]
            }
            val exam = mRealm.where(RealmStepExam::class.java).equalTo("id", examId).findFirst()
            if (!TextUtils.isEmpty(sub._id)) {
                `object`.addProperty("_id", sub._id)
            }
            if (!TextUtils.isEmpty(sub._rev)) {
                `object`.addProperty("_rev", sub._rev)
            }
            `object`.addProperty("parentId", sub.parentId)
            `object`.addProperty("type", sub.type)
            `object`.addProperty("team", sub.team)
            `object`.addProperty("grade", sub.grade)
            `object`.addProperty("startTime", sub.startTime)
            `object`.addProperty("lastUpdateTime", sub.lastUpdateTime)
            `object`.addProperty("status", sub.status)
            `object`.addProperty("androidId", NetworkUtils.getUniqueIdentifier())
            `object`.addProperty("deviceName", NetworkUtils.getDeviceName())
            `object`.addProperty("customDeviceName", NetworkUtils.getCustomDeviceName(context))
            `object`.addProperty("sender", sub.sender)
            val prefs = context.getSharedPreferences(Constants.PREFS_NAME, Context.MODE_PRIVATE)
            `object`.addProperty("source", prefs.getString("planetCode", ""))
            `object`.addProperty("parentCode", prefs.getString("parentCode", ""))
            val parent = Gson().fromJson(sub.parent, JsonObject::class.java)
            `object`.add("parent", parent)
            `object`.add("answers", RealmAnswer.serializeRealmAnswer(sub.answers ?: RealmList()))
            if (exam != null && parent == null) `object`.add("parent", RealmStepExam.serializeExam(mRealm, exam))
            if (TextUtils.isEmpty(sub.user)) {
                `object`.add("user", user?.serialize())
            } else {
                `object`.add("user", JsonParser.parseString(sub.user))
            }
            return `object`
        }

        @JvmStatic
        fun isStepCompleted(realm: Realm, id: String?, userId: String?): Boolean {
            val exam = realm.where(RealmStepExam::class.java).equalTo("stepId", id).findFirst() ?: return true
            return exam.id?.let {
                realm.where(RealmSubmission::class.java).equalTo("userId", userId)
                    .contains("parentId", it).notEqualTo("status", "pending").findFirst()
            } != null
        }

        @JvmStatic
        fun createSubmission(sub: RealmSubmission?, mRealm: Realm): RealmSubmission {
            var submission = sub
            if (submission == null || submission.status == "complete" && (submission.type == "exam" || submission.type == "survey"))
                submission = mRealm.createObject(RealmSubmission::class.java, UUID.randomUUID().toString())
            submission!!.lastUpdateTime = Date().time
            return submission
        }

        @JvmStatic
        fun getNoOfSurveySubmissionByUser(userId: String?, mRealm: Realm): Int {
            if (userId == null) return 0

            return mRealm.where(RealmSubmission::class.java)
                .equalTo("userId", userId)
                .equalTo("type", "survey")
                .equalTo("status", "pending", Case.INSENSITIVE)
                .count().toInt()
        }

        @JvmStatic
        fun getExamMap(mRealm: Realm, submissions: List<RealmSubmission>?): HashMap<String?, RealmStepExam> {
            val exams = HashMap<String?, RealmStepExam>()
            for (sub in submissions ?: emptyList()){
                var id = sub.parentId
                if (checkParentId(sub.parentId)) {
                    id = sub.parentId!!.split("@".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()[0]
                }
                val survey = mRealm.where(RealmStepExam::class.java).equalTo("id", id).findFirst()
                if (survey != null) {
                    exams[sub.parentId] = survey
                }
            }
            return exams
        }

        private fun checkParentId(parentId: String?): Boolean {
            return parentId != null && parentId.contains("@")
        }

        @JvmStatic
        fun serialize(mRealm: Realm, submission: RealmSubmission): JsonObject {
            val jsonObject = JsonObject()

            try {
                if (!submission._id.isNullOrEmpty()) {
                    jsonObject.addProperty("_id", submission._id)
                }
                if (!submission._rev.isNullOrEmpty()) {
                    jsonObject.addProperty("_rev", submission._rev)
                }

                jsonObject.addProperty("parentId", submission.parentId ?: "")
                jsonObject.addProperty("type", submission.type ?: "survey")
                jsonObject.addProperty("userId", submission.userId ?: "")
                jsonObject.addProperty("status", submission.status ?: "pending")
                jsonObject.addProperty("team", submission.team ?: "")
                jsonObject.addProperty("uploaded", submission.uploaded)
                jsonObject.addProperty("sender", submission.sender ?: "")
                jsonObject.addProperty("source", submission.source ?: "")
                jsonObject.addProperty("parentCode", submission.parentCode ?: "")
                jsonObject.addProperty("startTime", submission.startTime)
                jsonObject.addProperty("lastUpdateTime", submission.lastUpdateTime)
                jsonObject.addProperty("grade", submission.grade)

                if (!submission.parent.isNullOrEmpty()) {
                    jsonObject.add("parent", JsonParser.parseString(submission.parent))
                }

                if (!submission.user.isNullOrEmpty()) {
                    val userJson = JsonParser.parseString(submission.user).asJsonObject
                    if (submission.membershipDoc != null) {
                        val membershipJson = JsonObject()
                        membershipJson.addProperty("teamId", submission.membershipDoc?.teamId ?: "")

                        userJson.add("membershipDoc", membershipJson)
                    }
                    jsonObject.add("user", userJson)
                }

                val questions = mRealm.where(RealmExamQuestion::class.java)
                    .equalTo("examId", submission.parentId)
                    .findAll()
                val serializedQuestions = RealmExamQuestion.serializeQuestions(questions)
                jsonObject.add("questions", serializedQuestions)

                val answersArray = RealmAnswer.serializeRealmAnswer(submission.answers ?: RealmList())
                jsonObject.add("answers", answersArray)
            } catch (e: Exception) {
                e.printStackTrace()
            }
            return jsonObject
        }
    }
}

open class RealmMembershipDoc : RealmObject() {
    var teamId: String? = null
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/ChatRequestModel.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.annotations.SerializedName

data class ChatRequestModel(
    @SerializedName("data") val data: ContentData,
    @SerializedName("save") val save: Boolean
)

data class ContentData(
    @SerializedName("user") var user: String,
    @SerializedName("content") val content: String,
    @SerializedName("aiProvider") val aiProvider: AiProvider
)

data class ContinueChatModel(
    @SerializedName("data") val data: Data,
    @SerializedName("save") val save: Boolean
)

data class Data(
    @SerializedName("user") var user: String,
    @SerializedName("content") var content: String,
    @SerializedName("aiProvider") val aiProvider: AiProvider,
    @SerializedName("_id") var id: String,
    @SerializedName("_rev") var rev: String
)

data class AiProvider (
    @SerializedName("name") val name: String,
    @SerializedName("model") val model: String
)
=======
package org.ole.planet.myplanet.model


import com.google.gson.annotations.SerializedName

data class ChatRequestModel(
    @SerializedName("data") val data: ContentData,
    @SerializedName("save") val save: Boolean
)

data class ContentData(
    @SerializedName("user") var user: String,
    @SerializedName("content") val content: String,
    @SerializedName("aiProvider") val aiProvider: AiProvider
)

data class ContinueChatModel(
    @SerializedName("data") val data: Data,
    @SerializedName("save") val save: Boolean
)

data class Data(
    @SerializedName("user") var user: String,
    @SerializedName("content") var content: String,
    @SerializedName("aiProvider") val aiProvider: AiProvider,
    @SerializedName("_id") var id: String,
    @SerializedName("_rev") var rev: String
)

data class AiProvider (
    @SerializedName("name") val name: String,
    @SerializedName("model") val model: String
)
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/ChatResponseModel.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import com.google.gson.annotations.SerializedName

data class ChatModel(
    @SerializedName("message") var message: String? = null,
    @SerializedName("error") var error: String? = null,
    @SerializedName("status") var status: String? = null,
    @SerializedName("chat") var chat: String? = null,
    @SerializedName("couchDBResponse") var couchDBResponse: CouchDBResponse? = CouchDBResponse()
)

data class CouchDBResponse(
    @SerializedName("ok") var ok: Boolean? = null,
    @SerializedName("id") var id: String? = null,
    @SerializedName("rev") var rev: String? = null
)
=======
package org.ole.planet.myplanet.model


import com.google.gson.annotations.SerializedName

data class ChatModel(
    @SerializedName("message") var message: String? = null,
    @SerializedName("error") var error: String? = null,
    @SerializedName("status") var status: String? = null,
    @SerializedName("chat") var chat: String? = null,
    @SerializedName("couchDBResponse") var couchDBResponse: CouchDBResponse? = CouchDBResponse()
)

data class CouchDBResponse(
    @SerializedName("ok") var ok: Boolean? = null,
    @SerializedName("id") var id: String? = null,
    @SerializedName("rev") var rev: String? = null
)
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmTeamTask.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmTeamTask : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var title: String? = null
    var description: String? = null
    var link: String? = null
    var sync: String? = null
    var teamId: String? = null
    var isUpdated = false
    var assignee: String? = null
    var deadline: Long = 0
    var completedTime: Long = 0
    var status: String? = null
    var completed = false
    var isNotified = false

    override fun toString(): String {
        return title.orEmpty()
    }

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, obj: JsonObject?) {
            var task = mRealm.where(RealmTeamTask::class.java).equalTo("_id", JsonUtils.getString("_id", obj)).findFirst()
            if (task == null) {
                task = mRealm.createObject(RealmTeamTask::class.java, JsonUtils.getString("_id", obj))
            }
            if (task != null) {
                task._id = JsonUtils.getString("_id", obj)
                task._rev = JsonUtils.getString("_rev", obj)
                task.title = JsonUtils.getString("title", obj)
                task.status = JsonUtils.getString("status", obj)
                task.deadline = JsonUtils.getLong("deadline", obj)
                task.completedTime = JsonUtils.getLong("completedTime", obj)
                task.description = JsonUtils.getString("description", obj)
                task.link = Gson().toJson(JsonUtils.getJsonObject("link", obj))
                task.sync = Gson().toJson(JsonUtils.getJsonObject("sync", obj))
                task.teamId = JsonUtils.getString("teams", JsonUtils.getJsonObject("link", obj))
                val user = JsonUtils.getJsonObject("assignee", obj)
                if (user.has("_id")) {
                    task.assignee = JsonUtils.getString("_id", user)
                }
                task.completed = JsonUtils.getBoolean("completed", obj)
            }
        }

        @JvmStatic
        fun serialize(realm: Realm, task: RealmTeamTask): JsonObject {
            val `object` = JsonObject()
            if (!TextUtils.isEmpty(task._id)) {
                `object`.addProperty("_id", task._id)
                `object`.addProperty("_rev", task._rev)
            }
            `object`.addProperty("title", task.title)
            `object`.addProperty("deadline", task.deadline)
            `object`.addProperty("description", task.description)
            `object`.addProperty("completed", task.completed)
            `object`.addProperty("completedTime", task.completedTime)
            val user = realm.where(RealmUserModel::class.java).equalTo("id", task.assignee).findFirst()
            if (user != null) `object`.add("assignee", user.serialize())
            else `object`.addProperty("assignee", "")
            `object`.add("sync", Gson().fromJson(task.sync, JsonObject::class.java))
            `object`.add("link", Gson().fromJson(task.link, JsonObject::class.java))
            return `object`
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.text.TextUtils
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmTeamTask : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _id: String? = null
    var _rev: String? = null
    var title: String? = null
    var description: String? = null
    var link: String? = null
    var sync: String? = null
    var teamId: String? = null
    var isUpdated = false
    var assignee: String? = null
    var deadline: Long = 0
    var completedTime: Long = 0
    var status: String? = null
    var completed = false
    var isNotified = false

    override fun toString(): String {
        return title.orEmpty()
    }

    companion object {
        @JvmStatic
        fun insert(mRealm: Realm, obj: JsonObject?) {
            var task = mRealm.where(RealmTeamTask::class.java).equalTo("_id", JsonUtils.getString("_id", obj)).findFirst()
            if (task == null) {
                task = mRealm.createObject(RealmTeamTask::class.java, JsonUtils.getString("_id", obj))
            }
            if (task != null) {
                task._id = JsonUtils.getString("_id", obj)
                task._rev = JsonUtils.getString("_rev", obj)
                task.title = JsonUtils.getString("title", obj)
                task.status = JsonUtils.getString("status", obj)
                task.deadline = JsonUtils.getLong("deadline", obj)
                task.completedTime = JsonUtils.getLong("completedTime", obj)
                task.description = JsonUtils.getString("description", obj)
                task.link = Gson().toJson(JsonUtils.getJsonObject("link", obj))
                task.sync = Gson().toJson(JsonUtils.getJsonObject("sync", obj))
                task.teamId = JsonUtils.getString("teams", JsonUtils.getJsonObject("link", obj))
                val user = JsonUtils.getJsonObject("assignee", obj)
                if (user.has("_id")) {
                    task.assignee = JsonUtils.getString("_id", user)
                }
                task.completed = JsonUtils.getBoolean("completed", obj)
            }
        }

        @JvmStatic
        fun serialize(realm: Realm, task: RealmTeamTask): JsonObject {
            val `object` = JsonObject()
            if (!TextUtils.isEmpty(task._id)) {
                `object`.addProperty("_id", task._id)
                `object`.addProperty("_rev", task._rev)
            }
            `object`.addProperty("title", task.title)
            `object`.addProperty("deadline", task.deadline)
            `object`.addProperty("description", task.description)
            `object`.addProperty("completed", task.completed)
            `object`.addProperty("completedTime", task.completedTime)
            val user = realm.where(RealmUserModel::class.java).equalTo("id", task.assignee).findFirst()
            if (user != null) `object`.add("assignee", user.serialize())
            else `object`.addProperty("assignee", "")
            `object`.add("sync", Gson().fromJson(task.sync, JsonObject::class.java))
            `object`.add("link", Gson().fromJson(task.link, JsonObject::class.java))
            return `object`
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/model/RealmStepExam.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.model

import android.text.TextUtils
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmStepExam : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _rev: String? = null
    var createdDate: Long = 0
    var updatedDate: Long = 0
    var createdBy: String? = null
    var totalMarks = 0
    var name: String? = null
    var description: String? = null
    var type: String? = null
    var stepId: String? = null
    var courseId: String? = null
    var sourcePlanet: String? = null
    var passingPercentage: String? = null
    var noOfQuestions = 0
    var isFromNation = false
    var teamId: String? = null
    var isTeamShareAllowed = false

    companion object {
        @JvmStatic
        fun insertCourseStepsExams(myCoursesID: String?, stepId: String?, exam: JsonObject, mRealm: Realm) {
            insertCourseStepsExams(myCoursesID, stepId, exam, "", mRealm)
        }

        @JvmStatic
        fun insertCourseStepsExams(myCoursesID: String?, stepId: String?, exam: JsonObject, parentId: String?, mRealm: Realm) {
            val isInTransaction = mRealm.isInTransaction

            val performInsert = {
                var myExam = mRealm.where(RealmStepExam::class.java).equalTo("id", JsonUtils.getString("_id", exam)).findFirst()
                if (myExam == null) {
                    val id = JsonUtils.getString("_id", exam)
                    myExam = mRealm.createObject(RealmStepExam::class.java,
                        if (TextUtils.isEmpty(id)) {
                            parentId
                        } else {
                            id
                        }
                    )
                }
                checkIdsAndInsert(myCoursesID, stepId, myExam)
                myExam?.type = if (exam.has("type")) JsonUtils.getString("type", exam) else "exam"
                myExam?.name = JsonUtils.getString("name", exam)
                myExam?.description = JsonUtils.getString("description", exam)
                myExam?.passingPercentage = JsonUtils.getString("passingPercentage", exam)
                myExam?._rev = JsonUtils.getString("_rev", exam)
                myExam?.createdBy = JsonUtils.getString("createdBy", exam)
                myExam?.sourcePlanet = JsonUtils.getString("sourcePlanet", exam)
                myExam?.createdDate = JsonUtils.getLong("createdDate", exam)
                myExam?.updatedDate = JsonUtils.getLong("updatedDate", exam)
                myExam?.totalMarks = JsonUtils.getInt("totalMarks", exam)
                myExam?.noOfQuestions = JsonUtils.getJsonArray("questions", exam).size()
                myExam?.isFromNation = !TextUtils.isEmpty(parentId)
                myExam.teamId = JsonUtils.getString("teamId", exam)
                myExam.isTeamShareAllowed = JsonUtils.getBoolean("teamShareAllowed", exam)
                val oldQuestions = mRealm.where(RealmExamQuestion::class.java)
                    .equalTo("examId", JsonUtils.getString("_id", exam)).findAll()
                if (oldQuestions == null || oldQuestions.isEmpty()) {
                    RealmExamQuestion.insertExamQuestions(JsonUtils.getJsonArray("questions", exam), JsonUtils.getString("_id", exam), mRealm)
                }
            }

            if (isInTransaction) {
                performInsert()
            } else {
                mRealm.executeTransaction { performInsert() }
            }
        }

        private fun checkIdsAndInsert(myCoursesID: String?, stepId: String?, myExam: RealmStepExam?) {
            if (!TextUtils.isEmpty(myCoursesID)) {
                myExam?.courseId = myCoursesID
            }
            if (!TextUtils.isEmpty(stepId)) {
                myExam?.stepId = stepId
            }
        }

        @JvmStatic
        fun serializeExam(mRealm: Realm, exam: RealmStepExam): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("_id", exam.id)
            `object`.addProperty("_rev", exam._rev)
            `object`.addProperty("name", exam.name)
            `object`.addProperty("passingPercentage", exam.passingPercentage)
            `object`.addProperty("type", exam.type)
            `object`.addProperty("updatedDate", exam.updatedDate)
            `object`.addProperty("createdDate", exam.createdDate)
            `object`.addProperty("sourcePlanet", exam.sourcePlanet)
            `object`.addProperty("totalMarks", exam.createdDate)
            `object`.addProperty("createdBy", exam.createdBy)
            val question = mRealm.where(RealmExamQuestion::class.java).equalTo("examId", exam.id).findAll()
            `object`.add("questions", RealmExamQuestion.serializeQuestions(question))
            return `object`
        }

        @JvmStatic
        fun getIds(list: List<RealmStepExam>): Array<String?> {
            val ids = arrayOfNulls<String>(list.size)
            for ((i, e) in list.withIndex()) {
                if (e.type?.startsWith("survey") == true) {
                    ids[i] = e.id
                } else {
                    ids[i] = e.id + "@" + e.courseId
                }
            }
            return ids
        }

        @JvmStatic
        fun getSurveyCreationTime(surveyId: String, mRealm: Realm): Long? {
            val survey = mRealm.where(RealmStepExam::class.java).equalTo("id", surveyId).findFirst()
            return survey?.createdDate
        }
    }
}
=======
package org.ole.planet.myplanet.model


import android.text.TextUtils
import com.google.gson.JsonObject
import io.realm.Realm
import io.realm.RealmObject
import io.realm.annotations.PrimaryKey
import org.ole.planet.myplanet.utilities.JsonUtils

open class RealmStepExam : RealmObject() {
    @PrimaryKey
    var id: String? = null
    var _rev: String? = null
    var createdDate: Long = 0
    var updatedDate: Long = 0
    var createdBy: String? = null
    var totalMarks = 0
    var name: String? = null
    var description: String? = null
    var type: String? = null
    var stepId: String? = null
    var courseId: String? = null
    var sourcePlanet: String? = null
    var passingPercentage: String? = null
    var noOfQuestions = 0
    var isFromNation = false
    var teamId: String? = null
    var isTeamShareAllowed = false

    companion object {
        @JvmStatic
        fun insertCourseStepsExams(myCoursesID: String?, stepId: String?, exam: JsonObject, mRealm: Realm) {
            insertCourseStepsExams(myCoursesID, stepId, exam, "", mRealm)
        }

        @JvmStatic
        fun insertCourseStepsExams(myCoursesID: String?, stepId: String?, exam: JsonObject, parentId: String?, mRealm: Realm) {
            val isInTransaction = mRealm.isInTransaction

            val performInsert = {
                var myExam = mRealm.where(RealmStepExam::class.java).equalTo("id", JsonUtils.getString("_id", exam)).findFirst()
                if (myExam == null) {
                    val id = JsonUtils.getString("_id", exam)
                    myExam = mRealm.createObject(RealmStepExam::class.java,
                        if (TextUtils.isEmpty(id)) {
                            parentId
                        } else {
                            id
                        }
                    )
                }
                checkIdsAndInsert(myCoursesID, stepId, myExam)
                myExam?.type = if (exam.has("type")) JsonUtils.getString("type", exam) else "exam"
                myExam?.name = JsonUtils.getString("name", exam)
                myExam?.description = JsonUtils.getString("description", exam)
                myExam?.passingPercentage = JsonUtils.getString("passingPercentage", exam)
                myExam?._rev = JsonUtils.getString("_rev", exam)
                myExam?.createdBy = JsonUtils.getString("createdBy", exam)
                myExam?.sourcePlanet = JsonUtils.getString("sourcePlanet", exam)
                myExam?.createdDate = JsonUtils.getLong("createdDate", exam)
                myExam?.updatedDate = JsonUtils.getLong("updatedDate", exam)
                myExam?.totalMarks = JsonUtils.getInt("totalMarks", exam)
                myExam?.noOfQuestions = JsonUtils.getJsonArray("questions", exam).size()
                myExam?.isFromNation = !TextUtils.isEmpty(parentId)
                myExam.teamId = JsonUtils.getString("teamId", exam)
                myExam.isTeamShareAllowed = JsonUtils.getBoolean("teamShareAllowed", exam)
                val oldQuestions = mRealm.where(RealmExamQuestion::class.java)
                    .equalTo("examId", JsonUtils.getString("_id", exam)).findAll()
                if (oldQuestions == null || oldQuestions.isEmpty()) {
                    RealmExamQuestion.insertExamQuestions(JsonUtils.getJsonArray("questions", exam), JsonUtils.getString("_id", exam), mRealm)
                }
            }

            if (isInTransaction) {
                performInsert()
            } else {
                mRealm.executeTransaction { performInsert() }
            }
        }

        private fun checkIdsAndInsert(myCoursesID: String?, stepId: String?, myExam: RealmStepExam?) {
            if (!TextUtils.isEmpty(myCoursesID)) {
                myExam?.courseId = myCoursesID
            }
            if (!TextUtils.isEmpty(stepId)) {
                myExam?.stepId = stepId
            }
        }

        @JvmStatic
        fun serializeExam(mRealm: Realm, exam: RealmStepExam): JsonObject {
            val `object` = JsonObject()
            `object`.addProperty("_id", exam.id)
            `object`.addProperty("_rev", exam._rev)
            `object`.addProperty("name", exam.name)
            `object`.addProperty("passingPercentage", exam.passingPercentage)
            `object`.addProperty("type", exam.type)
            `object`.addProperty("updatedDate", exam.updatedDate)
            `object`.addProperty("createdDate", exam.createdDate)
            `object`.addProperty("sourcePlanet", exam.sourcePlanet)
            `object`.addProperty("totalMarks", exam.createdDate)
            `object`.addProperty("createdBy", exam.createdBy)
            val question = mRealm.where(RealmExamQuestion::class.java).equalTo("examId", exam.id).findAll()
            `object`.add("questions", RealmExamQuestion.serializeQuestions(question))
            return `object`
        }

        @JvmStatic
        fun getIds(list: List<RealmStepExam>): Array<String?> {
            val ids = arrayOfNulls<String>(list.size)
            for ((i, e) in list.withIndex()) {
                if (e.type?.startsWith("survey") == true) {
                    ids[i] = e.id
                } else {
                    ids[i] = e.id + "@" + e.courseId
                }
            }
            return ids
        }

        @JvmStatic
        fun getSurveyCreationTime(surveyId: String, mRealm: Realm): Long? {
            val survey = mRealm.where(RealmStepExam::class.java).equalTo("id", surveyId).findFirst()
            return survey?.createdDate
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/CourseRatingUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.widget.TextView
import androidx.appcompat.widget.AppCompatRatingBar
import com.google.gson.JsonObject
import java.util.Locale
import org.ole.planet.myplanet.R

object CourseRatingUtils {
    @JvmStatic
    fun showRating(
        context: Context,
        obj: JsonObject?,
        average: TextView?,
        ratingCount: TextView?,
        ratingBar: AppCompatRatingBar?
    ) {
        val averageRating = obj?.get("averageRating")
            ?.takeIf { it.isJsonPrimitive && it.asJsonPrimitive.isNumber }
            ?.asFloat
        val totalRatings = obj?.get("total")
            ?.takeIf { it.isJsonPrimitive && it.asJsonPrimitive.isNumber }
            ?.asInt
        val userRating = when {
            obj?.has("ratingByUser") == true -> obj["ratingByUser"].asFloat
            obj?.has("userRating") == true -> obj["userRating"].asFloat
            else -> null
        }

        average?.text = String.format(Locale.getDefault(), "%.2f", averageRating ?: 0f)
        ratingCount?.text = context.getString(R.string.rating_count_format, totalRatings ?: 0)
        ratingBar?.rating = userRating ?: averageRating ?: 0f
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.widget.TextView
import androidx.appcompat.widget.AppCompatRatingBar
import com.google.gson.JsonObject
import java.util.Locale
import org.ole.planet.myplanet.R

object CourseRatingUtils {
    @JvmStatic
    fun showRating(
        context: Context,
        obj: JsonObject?,
        average: TextView?,
        ratingCount: TextView?,
        ratingBar: AppCompatRatingBar?
    ) {
        val averageRating = obj?.get("averageRating")
            ?.takeIf { it.isJsonPrimitive && it.asJsonPrimitive.isNumber }
            ?.asFloat
        val totalRatings = obj?.get("total")
            ?.takeIf { it.isJsonPrimitive && it.asJsonPrimitive.isNumber }
            ?.asInt
        val userRating = when {
            obj?.has("ratingByUser") == true -> obj["ratingByUser"].asFloat
            obj?.has("userRating") == true -> obj["userRating"].asFloat
            else -> null
        }

        average?.text = String.format(Locale.getDefault(), "%.2f", averageRating ?: 0f)
        ratingCount?.text = context.getString(R.string.rating_count_format, totalRatings ?: 0)
        ratingBar?.rating = userRating ?: averageRating ?: 0f
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/IntentUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import androidx.core.net.toUri
import org.ole.planet.myplanet.ui.viewer.AudioPlayerActivity

object IntentUtils {
    @JvmStatic
    fun openAudioFile(context: Context, path: String?, resourceTitle: String? = null) {
        val intent = Intent(context, AudioPlayerActivity::class.java).apply {
            putExtra("isFullPath", true)
            putExtra("TOUCHED_FILE", path)
            putExtra("RESOURCE_TITLE", resourceTitle)
        }
        context.startActivity(intent)
    }

    @JvmStatic
    fun openPlayStore(context: Context) {
        val appPackageName = context.packageName
        val intent = Intent(Intent.ACTION_VIEW, "market://details?id=$appPackageName".toUri()).apply {
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        try {
            context.startActivity(intent)
        } catch (e: ActivityNotFoundException) {
            val webIntent = Intent(
                Intent.ACTION_VIEW,
                "https://play.google.com/store/apps/details?id=$appPackageName".toUri(),
            ).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }
            context.startActivity(webIntent)
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import androidx.core.net.toUri
import org.ole.planet.myplanet.ui.viewer.AudioPlayerActivity

object IntentUtils {
    @JvmStatic
    fun openAudioFile(context: Context, path: String?, resourceTitle: String? = null) {
        val intent = Intent(context, AudioPlayerActivity::class.java).apply {
            putExtra("isFullPath", true)
            putExtra("TOUCHED_FILE", path)
            putExtra("RESOURCE_TITLE", resourceTitle)
        }
        context.startActivity(intent)
    }

    @JvmStatic
    fun openPlayStore(context: Context) {
        val appPackageName = context.packageName
        val intent = Intent(Intent.ACTION_VIEW, "market://details?id=$appPackageName".toUri()).apply {
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        try {
            context.startActivity(intent)
        } catch (e: ActivityNotFoundException) {
            val webIntent = Intent(
                Intent.ACTION_VIEW,
                "https://play.google.com/store/apps/details?id=$appPackageName".toUri(),
            ).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }
            context.startActivity(webIntent)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/Sha256Utils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import java.io.File
import java.io.FileInputStream
import java.security.MessageDigest

class Sha256Utils {
    fun getCheckSumFromFile(file: File): String {
        return try {
            val digest = MessageDigest.getInstance("SHA-512")
            FileInputStream(file).use { fis ->
                val buffer = ByteArray(DEFAULT_BUFFER_SIZE)
                var read: Int
                while (fis.read(buffer).also { read = it } != -1) {
                    digest.update(buffer, 0, read)
                }
            }
            val hash = digest.digest()
            hash.joinToString(separator = "") { "%02x".format(it) }
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import java.io.File
import java.io.FileInputStream
import java.security.MessageDigest

class Sha256Utils {
    fun getCheckSumFromFile(file: File): String {
        return try {
            val digest = MessageDigest.getInstance("SHA-512")
            FileInputStream(file).use { fis ->
                val buffer = ByteArray(DEFAULT_BUFFER_SIZE)
                var read: Int
                while (fis.read(buffer).also { read = it } != -1) {
                    digest.update(buffer, 0, read)
                }
            }
            val hash = digest.digest()
            hash.joinToString(separator = "") { "%02x".format(it) }
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/SecurePrefs.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.content.SharedPreferences
import androidx.core.content.edit
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey

object SecurePrefs {
    private const val FILE_NAME = "secure_prefs"

    private fun prefs(context: Context): SharedPreferences {
        return try {
            createEncryptedPrefs(context)
        } catch (e: Exception) {
            context.deleteSharedPreferences(FILE_NAME)
            createEncryptedPrefs(context)
        }
    }

    private fun createEncryptedPrefs(context: Context): SharedPreferences {
        val masterKey = MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build()
        return EncryptedSharedPreferences.create(
            context,
            FILE_NAME,
            masterKey,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }

    fun saveCredentials(
        context: Context,
        plainPrefs: SharedPreferences,
        username: String?,
        password: String?
    ) {
        val enc = prefs(context)
        enc.edit {
            putString("loginUserName", username)
            putString("loginUserPassword", password)
        }
        plainPrefs.edit {
            remove("loginUserName")
            remove("loginUserPassword")
        }
    }

    fun getUserName(context: Context, plainPrefs: SharedPreferences): String? {
        val enc = prefs(context)
        var name = enc.getString("loginUserName", null)
        if (name.isNullOrEmpty()) {
            name = plainPrefs.getString("loginUserName", null)
            if (!name.isNullOrEmpty()) {
                enc.edit { putString("loginUserName", name) }
                plainPrefs.edit { remove("loginUserName") }
            }
        }
        return name
    }

    fun getPassword(context: Context, plainPrefs: SharedPreferences): String? {
        val enc = prefs(context)
        var pwd = enc.getString("loginUserPassword", null)
        if (pwd.isNullOrEmpty()) {
            pwd = plainPrefs.getString("loginUserPassword", null)
            if (!pwd.isNullOrEmpty()) {
                enc.edit { putString("loginUserPassword", pwd) }
                plainPrefs.edit { remove("loginUserPassword") }
            }
        }
        return pwd
    }

    fun clearCredentials(context: Context) {
        val enc = prefs(context)
        enc.edit {
            remove("loginUserName")
            remove("loginUserPassword")
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.content.SharedPreferences
import androidx.core.content.edit
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey

object SecurePrefs {
    private const val FILE_NAME = "secure_prefs"

    private fun prefs(context: Context): SharedPreferences {
        return try {
            createEncryptedPrefs(context)
        } catch (e: Exception) {
            context.deleteSharedPreferences(FILE_NAME)
            createEncryptedPrefs(context)
        }
    }

    private fun createEncryptedPrefs(context: Context): SharedPreferences {
        val masterKey = MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build()
        return EncryptedSharedPreferences.create(
            context,
            FILE_NAME,
            masterKey,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }

    fun saveCredentials(
        context: Context,
        plainPrefs: SharedPreferences,
        username: String?,
        password: String?
    ) {
        val enc = prefs(context)
        enc.edit {
            putString("loginUserName", username)
            putString("loginUserPassword", password)
        }
        plainPrefs.edit {
            remove("loginUserName")
            remove("loginUserPassword")
        }
    }

    fun getUserName(context: Context, plainPrefs: SharedPreferences): String? {
        val enc = prefs(context)
        var name = enc.getString("loginUserName", null)
        if (name.isNullOrEmpty()) {
            name = plainPrefs.getString("loginUserName", null)
            if (!name.isNullOrEmpty()) {
                enc.edit { putString("loginUserName", name) }
                plainPrefs.edit { remove("loginUserName") }
            }
        }
        return name
    }

    fun getPassword(context: Context, plainPrefs: SharedPreferences): String? {
        val enc = prefs(context)
        var pwd = enc.getString("loginUserPassword", null)
        if (pwd.isNullOrEmpty()) {
            pwd = plainPrefs.getString("loginUserPassword", null)
            if (!pwd.isNullOrEmpty()) {
                enc.edit { putString("loginUserPassword", pwd) }
                plainPrefs.edit { remove("loginUserPassword") }
            }
        }
        return pwd
    }

    fun clearCredentials(context: Context) {
        val enc = prefs(context)
        enc.edit {
            remove("loginUserName")
            remove("loginUserPassword")
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/MapTileUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.os.Environment
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream

object MapTileUtils {
    @JvmStatic
    fun copyAssets(context: Context) {
        val tiles = arrayOf("dhulikhel.mbtiles", "somalia.mbtiles")
        val assetManager = context.assets
        try {
            for (s in tiles) {
                val outFile = File(Environment.getExternalStorageDirectory().toString() + "/osmdroid", s)
                assetManager.open(s).use { input ->
                    FileOutputStream(outFile).use { output ->
                        copyFile(input, output)
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @Throws(IOException::class)
    private fun copyFile(`in`: InputStream, out: OutputStream) {
        `in`.copyTo(out)
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.os.Environment
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream

object MapTileUtils {
    @JvmStatic
    fun copyAssets(context: Context) {
        val tiles = arrayOf("dhulikhel.mbtiles", "somalia.mbtiles")
        val assetManager = context.assets
        try {
            for (s in tiles) {
                val outFile = File(Environment.getExternalStorageDirectory().toString() + "/osmdroid", s)
                assetManager.open(s).use { input ->
                    FileOutputStream(outFile).use { output ->
                        copyFile(input, output)
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @Throws(IOException::class)
    private fun copyFile(`in`: InputStream, out: OutputStream) {
        `in`.copyTo(out)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/CameraUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.Manifest
import android.annotation.SuppressLint
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.ImageFormat
import android.graphics.SurfaceTexture
import android.hardware.camera2.CameraAccessException
import android.hardware.camera2.CameraCaptureSession
import android.hardware.camera2.CameraDevice
import android.hardware.camera2.CameraManager
import android.hardware.camera2.CaptureRequest
import android.hardware.camera2.params.OutputConfiguration
import android.hardware.camera2.params.SessionConfiguration
import android.media.ImageReader
import android.os.Build
import android.os.Handler
import android.os.HandlerThread
import android.view.Surface
import androidx.core.content.ContextCompat
import java.io.File
import java.io.FileOutputStream
import java.util.Date
import java.util.concurrent.Executor
import org.ole.planet.myplanet.MainApplication.Companion.context

object CameraUtils {
    private var cameraDevice: CameraDevice? = null
    private var captureSession: CameraCaptureSession? = null
    private var imageReader: ImageReader? = null
    private var backgroundHandler: Handler
    private var backgroundThread: HandlerThread = HandlerThread("CameraBackground")
    private val sessionExecutor: Executor by lazy { ContextCompat.getMainExecutor(context) }

    @JvmStatic
    fun capturePhoto(callback: ImageCaptureCallback) {
        if (ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            return
        }
        openCamera(context)
        imageReader = ImageReader.newInstance(IMAGE_WIDTH, IMAGE_HEIGHT, ImageFormat.JPEG, 1)
        imageReader?.setOnImageAvailableListener({ reader ->
            val image = reader.acquireLatestImage()
            val buffer = image.planes[0].buffer
            val bytes = ByteArray(buffer.capacity())
            buffer.get(bytes)
            savePicture(bytes, callback)
            image.close()
        }, backgroundHandler)

        try {
            val captureBuilder = cameraDevice?.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE)
            captureBuilder?.addTarget(imageReader!!.surface)
            captureBuilder?.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)

            val captureCallback = object : CameraCaptureSession.CaptureCallback() {}

            captureSession?.stopRepeating()
            captureSession?.abortCaptures()
            captureSession?.capture(captureBuilder!!.build(), captureCallback, null)
        } catch (e: CameraAccessException) {
            when (e.reason) {
                CameraAccessException.CAMERA_DISCONNECTED -> {
                    reopenCamera(context)
                }
            }
        }
    }

    private fun reopenCamera(context: Context) {
        closeCamera()
        openCamera(context)
    }

    private fun closeCamera() {
        captureSession?.close()
        captureSession = null
        cameraDevice?.close()
        cameraDevice = null
        imageReader?.close()
        imageReader = null
    }

    @JvmStatic
    private fun savePicture(data: ByteArray, callback: ImageCaptureCallback) {
        val pictureFileDir = File("${FileUtils.getOlePath(context)}/userimages")
        if (!pictureFileDir.exists() && !pictureFileDir.mkdirs()) {
            pictureFileDir.mkdirs()
        }
        val photoFile = "${Date().time}.jpg"
        val filename = "${pictureFileDir.path}${File.separator}$photoFile"
        val mainPicture = File(filename)
        try {
            FileOutputStream(mainPicture).use { fos ->
                fos.write(data)
            }
            callback.onImageCapture(mainPicture.absolutePath)
        } catch (error: Exception) {
            error.printStackTrace()
        }
    }

    @SuppressLint("MissingPermission")
    @JvmStatic
    private fun openCamera(context: Context) {
        val manager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        try {
            val cameraId = manager.cameraIdList[0]
            manager.openCamera(cameraId, object : CameraDevice.StateCallback() {
                override fun onOpened(camera: CameraDevice) {
                    cameraDevice = camera
                    createCameraPreview()
                }

                override fun onDisconnected(camera: CameraDevice) {
                    closeCamera()
                    reopenCamera(context)
                }

                override fun onError(camera: CameraDevice, error: Int) {
                    closeCamera()
                }
            }, null)
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }

    private fun createCameraPreview() {
        try {
            val texture = SurfaceTexture(0)
            texture.setDefaultBufferSize(IMAGE_WIDTH, IMAGE_HEIGHT)
            val surface = Surface(texture)
            val captureRequestBuilder = cameraDevice!!.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)
            captureRequestBuilder.addTarget(surface)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                val outputConfigurations = listOf(OutputConfiguration(surface))
                val stateCallback = object : CameraCaptureSession.StateCallback() {
                    override fun onConfigured(session: CameraCaptureSession) {
                        if (cameraDevice == null) return
                        captureSession = session
                        try {
                            captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)
                            captureSession?.setRepeatingRequest(captureRequestBuilder.build(), null, backgroundHandler)
                        } catch (e: CameraAccessException) {
                            e.printStackTrace()
                        }
                    }

                    override fun onConfigureFailed(session: CameraCaptureSession) {}
                }

                val sessionConfiguration = SessionConfiguration(SessionConfiguration.SESSION_REGULAR, outputConfigurations, sessionExecutor, stateCallback)

                cameraDevice?.createCaptureSession(sessionConfiguration)
            } else {
                @Suppress("DEPRECATION")
                cameraDevice?.createCaptureSession(listOf(surface), object : CameraCaptureSession.StateCallback() {
                    override fun onConfigured(session: CameraCaptureSession) {
                        if (cameraDevice == null) return
                        captureSession = session
                        try {
                            captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)
                            captureSession?.setRepeatingRequest(captureRequestBuilder.build(), null, backgroundHandler)
                        } catch (e: CameraAccessException) {
                            e.printStackTrace()
                        }
                    }

                    override fun onConfigureFailed(session: CameraCaptureSession) {} },
                    backgroundHandler
                )
            }
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }

    interface ImageCaptureCallback {
        fun onImageCapture(fileUri: String?)
    }

    init {
        backgroundThread.start()
        backgroundHandler = Handler(backgroundThread.looper)
    }
    private const val IMAGE_WIDTH = 640
    private const val IMAGE_HEIGHT = 480
}
=======
package org.ole.planet.myplanet.utilities


import android.Manifest
import android.annotation.SuppressLint
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.ImageFormat
import android.graphics.SurfaceTexture
import android.hardware.camera2.CameraAccessException
import android.hardware.camera2.CameraCaptureSession
import android.hardware.camera2.CameraDevice
import android.hardware.camera2.CameraManager
import android.hardware.camera2.CaptureRequest
import android.hardware.camera2.params.OutputConfiguration
import android.hardware.camera2.params.SessionConfiguration
import android.media.ImageReader
import android.os.Build
import android.os.Handler
import android.os.HandlerThread
import android.view.Surface
import androidx.core.content.ContextCompat
import java.io.File
import java.io.FileOutputStream
import java.util.Date
import java.util.concurrent.Executor
import org.ole.planet.myplanet.MainApplication.Companion.context

object CameraUtils {
    private var cameraDevice: CameraDevice? = null
    private var captureSession: CameraCaptureSession? = null
    private var imageReader: ImageReader? = null
    private var backgroundHandler: Handler
    private var backgroundThread: HandlerThread = HandlerThread("CameraBackground")
    private val sessionExecutor: Executor by lazy { ContextCompat.getMainExecutor(context) }

    @JvmStatic
    fun capturePhoto(callback: ImageCaptureCallback) {
        if (ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            return
        }
        openCamera(context)
        imageReader = ImageReader.newInstance(IMAGE_WIDTH, IMAGE_HEIGHT, ImageFormat.JPEG, 1)
        imageReader?.setOnImageAvailableListener({ reader ->
            val image = reader.acquireLatestImage()
            val buffer = image.planes[0].buffer
            val bytes = ByteArray(buffer.capacity())
            buffer.get(bytes)
            savePicture(bytes, callback)
            image.close()
        }, backgroundHandler)

        try {
            val captureBuilder = cameraDevice?.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE)
            captureBuilder?.addTarget(imageReader!!.surface)
            captureBuilder?.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)

            val captureCallback = object : CameraCaptureSession.CaptureCallback() {}

            captureSession?.stopRepeating()
            captureSession?.abortCaptures()
            captureSession?.capture(captureBuilder!!.build(), captureCallback, null)
        } catch (e: CameraAccessException) {
            when (e.reason) {
                CameraAccessException.CAMERA_DISCONNECTED -> {
                    reopenCamera(context)
                }
            }
        }
    }

    private fun reopenCamera(context: Context) {
        closeCamera()
        openCamera(context)
    }

    private fun closeCamera() {
        captureSession?.close()
        captureSession = null
        cameraDevice?.close()
        cameraDevice = null
        imageReader?.close()
        imageReader = null
    }

    @JvmStatic
    private fun savePicture(data: ByteArray, callback: ImageCaptureCallback) {
        val pictureFileDir = File("${FileUtils.getOlePath(context)}/userimages")
        if (!pictureFileDir.exists() && !pictureFileDir.mkdirs()) {
            pictureFileDir.mkdirs()
        }
        val photoFile = "${Date().time}.jpg"
        val filename = "${pictureFileDir.path}${File.separator}$photoFile"
        val mainPicture = File(filename)
        try {
            FileOutputStream(mainPicture).use { fos ->
                fos.write(data)
            }
            callback.onImageCapture(mainPicture.absolutePath)
        } catch (error: Exception) {
            error.printStackTrace()
        }
    }

    @SuppressLint("MissingPermission")
    @JvmStatic
    private fun openCamera(context: Context) {
        val manager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        try {
            val cameraId = manager.cameraIdList[0]
            manager.openCamera(cameraId, object : CameraDevice.StateCallback() {
                override fun onOpened(camera: CameraDevice) {
                    cameraDevice = camera
                    createCameraPreview()
                }

                override fun onDisconnected(camera: CameraDevice) {
                    closeCamera()
                    reopenCamera(context)
                }

                override fun onError(camera: CameraDevice, error: Int) {
                    closeCamera()
                }
            }, null)
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }

    private fun createCameraPreview() {
        try {
            val texture = SurfaceTexture(0)
            texture.setDefaultBufferSize(IMAGE_WIDTH, IMAGE_HEIGHT)
            val surface = Surface(texture)
            val captureRequestBuilder = cameraDevice!!.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)
            captureRequestBuilder.addTarget(surface)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                val outputConfigurations = listOf(OutputConfiguration(surface))
                val stateCallback = object : CameraCaptureSession.StateCallback() {
                    override fun onConfigured(session: CameraCaptureSession) {
                        if (cameraDevice == null) return
                        captureSession = session
                        try {
                            captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)
                            captureSession?.setRepeatingRequest(captureRequestBuilder.build(), null, backgroundHandler)
                        } catch (e: CameraAccessException) {
                            e.printStackTrace()
                        }
                    }

                    override fun onConfigureFailed(session: CameraCaptureSession) {}
                }

                val sessionConfiguration = SessionConfiguration(SessionConfiguration.SESSION_REGULAR, outputConfigurations, sessionExecutor, stateCallback)

                cameraDevice?.createCaptureSession(sessionConfiguration)
            } else {
                @Suppress("DEPRECATION")
                cameraDevice?.createCaptureSession(listOf(surface), object : CameraCaptureSession.StateCallback() {
                    override fun onConfigured(session: CameraCaptureSession) {
                        if (cameraDevice == null) return
                        captureSession = session
                        try {
                            captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)
                            captureSession?.setRepeatingRequest(captureRequestBuilder.build(), null, backgroundHandler)
                        } catch (e: CameraAccessException) {
                            e.printStackTrace()
                        }
                    }

                    override fun onConfigureFailed(session: CameraCaptureSession) {} },
                    backgroundHandler
                )
            }
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }

    interface ImageCaptureCallback {
        fun onImageCapture(fileUri: String?)
    }

    init {
        backgroundThread.start()
        backgroundHandler = Handler(backgroundThread.looper)
    }
    private const val IMAGE_WIDTH = 640
    private const val IMAGE_HEIGHT = 480
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/MarkdownDialog.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.os.Bundle
import android.text.Spannable
import android.text.method.LinkMovementMethod
import android.text.style.URLSpan
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.DialogFragment
import androidx.lifecycle.lifecycleScope
import com.mikepenz.materialdrawer.Drawer
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.DialogCampaignChallengeBinding
import org.ole.planet.myplanet.model.RealmUserChallengeActions
import org.ole.planet.myplanet.ui.community.CommunityTabFragment
import org.ole.planet.myplanet.ui.courses.TakeCourseFragment
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.sync.DashboardElementActivity
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText

class MarkdownDialog : DialogFragment() {
    private lateinit var dialogCampaignChallengeBinding: DialogCampaignChallengeBinding
    private var markdownContent: String = ""
    private var courseStatus: String = ""
    private var voiceCount: Int = 0
    private var allVoiceCount: Int = 0
    private var hasUnfinishedSurvey: Boolean = false

    companion object {
        private const val ARG_MARKDOWN_CONTENT = "markdown_content"
        private const val ARG_COURSE_STATUS = "course_status"
        private const val ARG_VOICE_COUNT = "voice_count"
        private const val ARG_ALL_VOICE_COUNT = "all_voice_count"
        private const val ARG_HAS_UNFINISHED_SURVEY = "has_unfinished_survey"

        fun newInstance(markdownContent: String, courseStatus: String, voiceCount: Int, allVoiceCount: Int, hasUnfinishedSurvey: Boolean): MarkdownDialog {
            val fragment = MarkdownDialog()
            val args = Bundle().apply {
                putString(ARG_MARKDOWN_CONTENT, markdownContent)
                putString(ARG_COURSE_STATUS, courseStatus)
                putInt(ARG_VOICE_COUNT, voiceCount)
                putInt(ARG_ALL_VOICE_COUNT, allVoiceCount)
                putBoolean(ARG_HAS_UNFINISHED_SURVEY, hasUnfinishedSurvey)
            }
            fragment.arguments = args
            return fragment
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        markdownContent = arguments?.getString(ARG_MARKDOWN_CONTENT) ?: ""
        courseStatus = arguments?.getString(ARG_COURSE_STATUS) ?: ""
        voiceCount = arguments?.getInt(ARG_VOICE_COUNT, 0) ?: 0
        allVoiceCount = arguments?.getInt(ARG_ALL_VOICE_COUNT, 0) ?: 0
        hasUnfinishedSurvey = arguments?.getBoolean(ARG_HAS_UNFINISHED_SURVEY, false) == true
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        dialogCampaignChallengeBinding = DialogCampaignChallengeBinding.inflate(inflater, container, false)
        return  dialogCampaignChallengeBinding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupMarkdown()
        setupCourseButton((activity as DashboardActivity).result)
        dialogCampaignChallengeBinding.markdownTextView.movementMethod = LinkMovementMethod.getInstance()
        val textWithSpans = dialogCampaignChallengeBinding.markdownTextView.text
        if (textWithSpans is Spannable) {
            val urlSpans = textWithSpans.getSpans(0, textWithSpans.length, URLSpan::class.java)
            for (urlSpan in urlSpans) {
                val start = textWithSpans.getSpanStart(urlSpan)
                val end = textWithSpans.getSpanEnd(urlSpan)
                val dynamicTitle = textWithSpans.subSequence(start, end).toString()
                textWithSpans.setSpan(CustomClickableSpan(urlSpan.url, dynamicTitle, requireActivity()), start, end, textWithSpans.getSpanFlags(urlSpan))
                textWithSpans.removeSpan(urlSpan)
            }
        }
        setupCloseButton()

        val earnedDollarsVoice = allVoiceCount * 2
        val earnedDollarsSurvey = if (!hasUnfinishedSurvey) 1 else 0
        val total = earnedDollarsVoice + earnedDollarsSurvey
        val progressValue = ((total.toDouble() / 500) * 100).toInt().coerceAtMost(100)
        dialogCampaignChallengeBinding.progressBar.progress = progressValue
    }

    override fun onStart() {
        super.onStart()
        val dialog = dialog ?: return

        dialog.window?.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
    }

    private fun setupMarkdown() {
        setMarkdownText(dialogCampaignChallengeBinding.markdownTextView, markdownContent)
    }

    private fun setupCourseButton(drawer: Drawer?) {
        dialogCampaignChallengeBinding.btnStart.apply {
            val dashboardActivity = activity as? DashboardActivity
            val hasSyncAction = dashboardActivity?.let { dashboard ->
                dashboard.databaseService.withRealm { realm ->
                    realm.where(RealmUserChallengeActions::class.java)
                        .equalTo("userId", dashboard.user?.id)
                        .equalTo("actionType", "sync").count() > 0
                }
            } ?: false
            val isCompleted = courseStatus.contains("terminado") && voiceCount >= 5 && hasSyncAction

            visibility = if (isCompleted) View.GONE else View.VISIBLE

            val buttonText = when {
                courseStatus.contains("no iniciado") -> context.getString(R.string.start)
                courseStatus.contains("terminado") && voiceCount < 5 -> context.getString(R.string.next)
                courseStatus.contains("terminado") && voiceCount >= 5 -> context.getString(R.string.sync)
                else -> context.getString(R.string.continuation)
            }

            text = buttonText
            setOnClickListener {
                val courseId = "4e6b78800b6ad18b4e8b0e1e38a98cac"
                when (buttonText) {
                    context.getString(R.string.start), context.getString(R.string.continuation) -> {
                        val fragment = TakeCourseFragment().apply {
                            arguments = Bundle().apply {
                                putString("id", courseId)
                            }
                        }
                        (activity as? OnHomeItemClickListener)?.openCallFragment(fragment)
                    }
                    context.getString(R.string.next) -> {
                        (activity as DashboardActivity).openCallFragment(CommunityTabFragment())
                    }
                    context.getString(R.string.sync) -> {
                        viewLifecycleOwner.lifecycleScope.launch(Dispatchers.IO) {
                            (activity as DashboardElementActivity).logSyncInSharedPrefs()
                        }
                    }
                }
                if (drawer != null && drawer.isDrawerOpen) {
                    drawer.closeDrawer()
                }
                dismiss()
            }
        }
    }

    private fun setupCloseButton() {
        dialogCampaignChallengeBinding.closeButton.setOnClickListener {
            dismiss()
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.os.Bundle
import android.text.Spannable
import android.text.method.LinkMovementMethod
import android.text.style.URLSpan
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.DialogFragment
import androidx.lifecycle.lifecycleScope
import com.mikepenz.materialdrawer.Drawer
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.DialogCampaignChallengeBinding
import org.ole.planet.myplanet.model.RealmUserChallengeActions
import org.ole.planet.myplanet.ui.community.CommunityTabFragment
import org.ole.planet.myplanet.ui.courses.TakeCourseFragment
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.sync.DashboardElementActivity
import org.ole.planet.myplanet.utilities.Markdown.setMarkdownText

class MarkdownDialog : DialogFragment() {
    private lateinit var dialogCampaignChallengeBinding: DialogCampaignChallengeBinding
    private var markdownContent: String = ""
    private var courseStatus: String = ""
    private var voiceCount: Int = 0
    private var allVoiceCount: Int = 0
    private var hasUnfinishedSurvey: Boolean = false

    companion object {
        private const val ARG_MARKDOWN_CONTENT = "markdown_content"
        private const val ARG_COURSE_STATUS = "course_status"
        private const val ARG_VOICE_COUNT = "voice_count"
        private const val ARG_ALL_VOICE_COUNT = "all_voice_count"
        private const val ARG_HAS_UNFINISHED_SURVEY = "has_unfinished_survey"

        fun newInstance(markdownContent: String, courseStatus: String, voiceCount: Int, allVoiceCount: Int, hasUnfinishedSurvey: Boolean): MarkdownDialog {
            val fragment = MarkdownDialog()
            val args = Bundle().apply {
                putString(ARG_MARKDOWN_CONTENT, markdownContent)
                putString(ARG_COURSE_STATUS, courseStatus)
                putInt(ARG_VOICE_COUNT, voiceCount)
                putInt(ARG_ALL_VOICE_COUNT, allVoiceCount)
                putBoolean(ARG_HAS_UNFINISHED_SURVEY, hasUnfinishedSurvey)
            }
            fragment.arguments = args
            return fragment
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        markdownContent = arguments?.getString(ARG_MARKDOWN_CONTENT) ?: ""
        courseStatus = arguments?.getString(ARG_COURSE_STATUS) ?: ""
        voiceCount = arguments?.getInt(ARG_VOICE_COUNT, 0) ?: 0
        allVoiceCount = arguments?.getInt(ARG_ALL_VOICE_COUNT, 0) ?: 0
        hasUnfinishedSurvey = arguments?.getBoolean(ARG_HAS_UNFINISHED_SURVEY, false) == true
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        dialogCampaignChallengeBinding = DialogCampaignChallengeBinding.inflate(inflater, container, false)
        return  dialogCampaignChallengeBinding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupMarkdown()
        setupCourseButton((activity as DashboardActivity).result)
        dialogCampaignChallengeBinding.markdownTextView.movementMethod = LinkMovementMethod.getInstance()
        val textWithSpans = dialogCampaignChallengeBinding.markdownTextView.text
        if (textWithSpans is Spannable) {
            val urlSpans = textWithSpans.getSpans(0, textWithSpans.length, URLSpan::class.java)
            for (urlSpan in urlSpans) {
                val start = textWithSpans.getSpanStart(urlSpan)
                val end = textWithSpans.getSpanEnd(urlSpan)
                val dynamicTitle = textWithSpans.subSequence(start, end).toString()
                textWithSpans.setSpan(CustomClickableSpan(urlSpan.url, dynamicTitle, requireActivity()), start, end, textWithSpans.getSpanFlags(urlSpan))
                textWithSpans.removeSpan(urlSpan)
            }
        }
        setupCloseButton()

        val earnedDollarsVoice = allVoiceCount * 2
        val earnedDollarsSurvey = if (!hasUnfinishedSurvey) 1 else 0
        val total = earnedDollarsVoice + earnedDollarsSurvey
        val progressValue = ((total.toDouble() / 500) * 100).toInt().coerceAtMost(100)
        dialogCampaignChallengeBinding.progressBar.progress = progressValue
    }

    override fun onStart() {
        super.onStart()
        val dialog = dialog ?: return

        dialog.window?.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
    }

    private fun setupMarkdown() {
        setMarkdownText(dialogCampaignChallengeBinding.markdownTextView, markdownContent)
    }

    private fun setupCourseButton(drawer: Drawer?) {
        dialogCampaignChallengeBinding.btnStart.apply {
            val dashboardActivity = activity as? DashboardActivity
            val hasSyncAction = dashboardActivity?.let { dashboard ->
                dashboard.databaseService.withRealm { realm ->
                    realm.where(RealmUserChallengeActions::class.java)
                        .equalTo("userId", dashboard.user?.id)
                        .equalTo("actionType", "sync").count() > 0
                }
            } ?: false
            val isCompleted = courseStatus.contains("terminado") && voiceCount >= 5 && hasSyncAction

            visibility = if (isCompleted) View.GONE else View.VISIBLE

            val buttonText = when {
                courseStatus.contains("no iniciado") -> context.getString(R.string.start)
                courseStatus.contains("terminado") && voiceCount < 5 -> context.getString(R.string.next)
                courseStatus.contains("terminado") && voiceCount >= 5 -> context.getString(R.string.sync)
                else -> context.getString(R.string.continuation)
            }

            text = buttonText
            setOnClickListener {
                val courseId = "4e6b78800b6ad18b4e8b0e1e38a98cac"
                when (buttonText) {
                    context.getString(R.string.start), context.getString(R.string.continuation) -> {
                        val fragment = TakeCourseFragment().apply {
                            arguments = Bundle().apply {
                                putString("id", courseId)
                            }
                        }
                        (activity as? OnHomeItemClickListener)?.openCallFragment(fragment)
                    }
                    context.getString(R.string.next) -> {
                        (activity as DashboardActivity).openCallFragment(CommunityTabFragment())
                    }
                    context.getString(R.string.sync) -> {
                        viewLifecycleOwner.lifecycleScope.launch(Dispatchers.IO) {
                            (activity as DashboardElementActivity).logSyncInSharedPrefs()
                        }
                    }
                }
                if (drawer != null && drawer.isDrawerOpen) {
                    drawer.closeDrawer()
                }
                dismiss()
            }
        }
    }

    private fun setupCloseButton() {
        dialogCampaignChallengeBinding.closeButton.setOnClickListener {
            dismiss()
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/ViewExtensions.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.text.Editable
import android.text.TextWatcher
import android.widget.EditText
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.onStart

fun EditText.textChanges(): Flow<CharSequence?> {
    return callbackFlow {
        val listener = object : TextWatcher {
            override fun afterTextChanged(s: Editable?) = Unit
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) = Unit
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                trySend(s)
            }
        }
        addTextChangedListener(listener)
        awaitClose { removeTextChangedListener(listener) }
    }.onStart { emit(text) }
}
=======
package org.ole.planet.myplanet.utilities


import android.text.Editable
import android.text.TextWatcher
import android.widget.EditText
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.onStart

fun EditText.textChanges(): Flow<CharSequence?> {
    return callbackFlow {
        val listener = object : TextWatcher {
            override fun afterTextChanged(s: Editable?) = Unit
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) = Unit
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                trySend(s)
            }
        }
        addTextChangedListener(listener)
        awaitClose { removeTextChangedListener(listener) }
    }.onStart { emit(text) }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/DownloadUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.app.ActivityManager
import android.app.AlarmManager
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import androidx.core.content.edit
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.workDataOf
import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.components.SingletonComponent
import java.util.regex.Pattern
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.datamanager.DownloadWorker
import org.ole.planet.myplanet.datamanager.MyDownloadService
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.repository.LibraryRepository

object DownloadUtils {
    private const val DOWNLOAD_CHANNEL = "DownloadChannel"
    private const val COMPLETION_CHANNEL = "DownloadCompletionChannel"
    private const val WORKER_CHANNEL = "DownloadWorkerChannel"

    @JvmStatic
    fun createChannels(context: Context) {
        val manager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            if (manager.getNotificationChannel(DOWNLOAD_CHANNEL) == null) {
                val channel = NotificationChannel(
                    DOWNLOAD_CHANNEL,
                    "Download Service",
                    NotificationManager.IMPORTANCE_HIGH
                ).apply {
                    setSound(null, null)
                    description = "Shows download progress for files"
                }
                manager.createNotificationChannel(channel)
            }
            if (manager.getNotificationChannel(COMPLETION_CHANNEL) == null) {
                val channel = NotificationChannel(
                    COMPLETION_CHANNEL,
                    "Download Completion",
                    NotificationManager.IMPORTANCE_HIGH
                ).apply {
                    description = "Notifies when downloads are completed"
                }
                manager.createNotificationChannel(channel)
            }
            if (manager.getNotificationChannel(WORKER_CHANNEL) == null) {
                val channel = NotificationChannel(
                    WORKER_CHANNEL,
                    "Background Downloads",
                    NotificationManager.IMPORTANCE_LOW
                ).apply {
                    description = "Shows progress for background downloads"
                    setSound(null, null)
                }
                manager.createNotificationChannel(channel)
            }
        }
    }

    @JvmStatic
    fun buildInitialNotification(context: Context): Notification {
        createChannels(context)
        return NotificationCompat.Builder(context, DOWNLOAD_CHANNEL)
            .setContentTitle(context.getString(R.string.downloading_files))
            .setContentText(context.getString(R.string.preparing_download))
            .setSmallIcon(R.drawable.ic_download)
            .setProgress(100, 0, true)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setOngoing(true)
            .setSilent(true)
            .setForegroundServiceBehavior(NotificationCompat.FOREGROUND_SERVICE_IMMEDIATE)
            .build()
    }

    @JvmStatic
    fun buildProgressNotification(
        context: Context,
        current: Int,
        total: Int,
        text: String,
        forWorker: Boolean = false
    ): Notification {
        val channel = if (forWorker) WORKER_CHANNEL else DOWNLOAD_CHANNEL
        createChannels(context)
        return NotificationCompat.Builder(context, channel)
            .setContentTitle(context.getString(R.string.downloading_files))
            .setContentText(text)
            .setSmallIcon(R.drawable.ic_download)
            .setProgress(total, current, false)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setOngoing(!forWorker)
            .setSilent(true)
            .build()
    }

    @JvmStatic
    fun buildCompletionNotification(
        context: Context,
        completed: Int,
        total: Int,
        hadErrors: Boolean,
        forWorker: Boolean = false
    ): Notification {
        val channel = if (forWorker) WORKER_CHANNEL else COMPLETION_CHANNEL
        createChannels(context)
        val text = if (hadErrors) {
            val errorMessage = context.getString(R.string.download_progress_with_errors, completed, total)
            errorMessage
        } else {
            context.getString(R.string.download_progress, completed, total)
        }
        return NotificationCompat.Builder(context, channel)
            .setContentTitle(context.getString(R.string.downloads_completed))
            .setContentText(text)
            .setSmallIcon(R.drawable.ic_download)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .build()
    }
    @JvmStatic
    fun downloadAllFiles(dbMyLibrary: List<RealmMyLibrary?>): ArrayList<String> {
        return ArrayList(dbMyLibrary.map { UrlUtils.getUrl(it) })
    }

    @JvmStatic
    fun downloadFiles(
        dbMyLibrary: List<RealmMyLibrary?>,
        selectedItems: ArrayList<Int>
    ): ArrayList<String> {
        return ArrayList(selectedItems.map { UrlUtils.getUrl(dbMyLibrary[it]) })
    }

    @RequiresApi(Build.VERSION_CODES.S)
    fun openDownloadService(context: Context?, urls: ArrayList<String>, fromSync: Boolean) {
        context?.let { ctx ->
            val preferences = ctx.getSharedPreferences(MyDownloadService.PREFS_NAME, Context.MODE_PRIVATE)
            preferences.edit {
                putStringSet("url_list_key", urls.toSet())
            }
            startDownloadServiceSafely(ctx, "url_list_key", fromSync)
        }
    }

    @RequiresApi(Build.VERSION_CODES.S)
    private fun startDownloadServiceSafely(context: Context, urlsKey: String, fromSync: Boolean) {
        if (canStartForegroundService(context)) {
            try {
                MyDownloadService.startService(context, urlsKey, fromSync)
            } catch (e: Exception) {
                e.printStackTrace()
                handleForegroundServiceNotAllowed(context, urlsKey, fromSync)
            }
        } else {
            handleForegroundServiceNotAllowed(context, urlsKey, fromSync)
        }
    }

    private fun handleForegroundServiceNotAllowed(context: Context, urlsKey: String, fromSync: Boolean) {
        if (!fromSync) {
            Utilities.toast(context, context.getString(R.string.download_in_background))
        }
        startDownloadWork(context, urlsKey, fromSync)
    }

    private fun startDownloadWork(context: Context, urlsKey: String, fromSync: Boolean) {
        val workRequest = OneTimeWorkRequestBuilder<DownloadWorker>()
            .setInputData(
                workDataOf(
                    "urls_key" to urlsKey,
                    "fromSync" to fromSync
                )
            )
            .addTag("download_work")
            .build()

        WorkManager.getInstance(context).enqueue(workRequest)
    }

    fun canStartForegroundService(context: Context): Boolean {
        return when {
            Build.VERSION.SDK_INT < Build.VERSION_CODES.O -> true
            Build.VERSION.SDK_INT < Build.VERSION_CODES.S -> {
                isAppInForeground(context)
            }
            else -> {
                isAppInForeground(context) || hasSpecialForegroundPermissions(context)
            }
        }
    }

    private fun isAppInForeground(context: Context): Boolean {
        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val appProcesses = activityManager.runningAppProcesses ?: return false

        val packageName = context.packageName
        return appProcesses.any { processInfo ->
            processInfo.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND &&
                processInfo.processName == packageName
        }
    }

    @RequiresApi(Build.VERSION_CODES.S)
    private fun hasSpecialForegroundPermissions(context: Context): Boolean {
        val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager

        return when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
                alarmManager.canScheduleExactAlarms()
            }
            else -> false
        }
    }

    fun extractLinks(text: String?): ArrayList<String> {
        val links = ArrayList<String>()
        val pattern = Pattern.compile("!\\[.*?]\\((.*?)\\)")
        val matcher = text?.let { pattern.matcher(it) }
        if (matcher != null) {
            while (matcher.find()) {
                val link = matcher.group(1)
                if (link != null) {
                    if (link.isNotEmpty()) {
                        links.add(link)
                    }
                }
            }
        }
        return links
    }

    @JvmStatic
    fun updateResourceOfflineStatus(url: String) {
        val currentFileName = FileUtils.getFileNameFromUrl(url)
        if (currentFileName.isBlank()) {
            return
        }

        MainApplication.applicationScope.launch {
            try {
                libraryRepository.markResourceOfflineByLocalAddress(currentFileName)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    private val libraryRepository: LibraryRepository by lazy {
        val entryPoint = EntryPointAccessors.fromApplication(
            MainApplication.context,
            DownloadUtilsEntryPoint::class.java
        )
        entryPoint.libraryRepository()
    }

    @EntryPoint
    @InstallIn(SingletonComponent::class)
    interface DownloadUtilsEntryPoint {
        fun libraryRepository(): LibraryRepository
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.app.ActivityManager
import android.app.AlarmManager
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import androidx.core.content.edit
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.workDataOf
import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.components.SingletonComponent
import java.util.regex.Pattern
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.datamanager.DownloadWorker
import org.ole.planet.myplanet.datamanager.MyDownloadService
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.repository.LibraryRepository

object DownloadUtils {
    private const val DOWNLOAD_CHANNEL = "DownloadChannel"
    private const val COMPLETION_CHANNEL = "DownloadCompletionChannel"
    private const val WORKER_CHANNEL = "DownloadWorkerChannel"

    @JvmStatic
    fun createChannels(context: Context) {
        val manager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            if (manager.getNotificationChannel(DOWNLOAD_CHANNEL) == null) {
                val channel = NotificationChannel(
                    DOWNLOAD_CHANNEL,
                    "Download Service",
                    NotificationManager.IMPORTANCE_HIGH
                ).apply {
                    setSound(null, null)
                    description = "Shows download progress for files"
                }
                manager.createNotificationChannel(channel)
            }
            if (manager.getNotificationChannel(COMPLETION_CHANNEL) == null) {
                val channel = NotificationChannel(
                    COMPLETION_CHANNEL,
                    "Download Completion",
                    NotificationManager.IMPORTANCE_HIGH
                ).apply {
                    description = "Notifies when downloads are completed"
                }
                manager.createNotificationChannel(channel)
            }
            if (manager.getNotificationChannel(WORKER_CHANNEL) == null) {
                val channel = NotificationChannel(
                    WORKER_CHANNEL,
                    "Background Downloads",
                    NotificationManager.IMPORTANCE_LOW
                ).apply {
                    description = "Shows progress for background downloads"
                    setSound(null, null)
                }
                manager.createNotificationChannel(channel)
            }
        }
    }

    @JvmStatic
    fun buildInitialNotification(context: Context): Notification {
        createChannels(context)
        return NotificationCompat.Builder(context, DOWNLOAD_CHANNEL)
            .setContentTitle(context.getString(R.string.downloading_files))
            .setContentText(context.getString(R.string.preparing_download))
            .setSmallIcon(R.drawable.ic_download)
            .setProgress(100, 0, true)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setOngoing(true)
            .setSilent(true)
            .setForegroundServiceBehavior(NotificationCompat.FOREGROUND_SERVICE_IMMEDIATE)
            .build()
    }

    @JvmStatic
    fun buildProgressNotification(
        context: Context,
        current: Int,
        total: Int,
        text: String,
        forWorker: Boolean = false
    ): Notification {
        val channel = if (forWorker) WORKER_CHANNEL else DOWNLOAD_CHANNEL
        createChannels(context)
        return NotificationCompat.Builder(context, channel)
            .setContentTitle(context.getString(R.string.downloading_files))
            .setContentText(text)
            .setSmallIcon(R.drawable.ic_download)
            .setProgress(total, current, false)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setOngoing(!forWorker)
            .setSilent(true)
            .build()
    }

    @JvmStatic
    fun buildCompletionNotification(
        context: Context,
        completed: Int,
        total: Int,
        hadErrors: Boolean,
        forWorker: Boolean = false
    ): Notification {
        val channel = if (forWorker) WORKER_CHANNEL else COMPLETION_CHANNEL
        createChannels(context)
        val text = if (hadErrors) {
            val errorMessage = context.getString(R.string.download_progress_with_errors, completed, total)
            errorMessage
        } else {
            context.getString(R.string.download_progress, completed, total)
        }
        return NotificationCompat.Builder(context, channel)
            .setContentTitle(context.getString(R.string.downloads_completed))
            .setContentText(text)
            .setSmallIcon(R.drawable.ic_download)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .build()
    }
    @JvmStatic
    fun downloadAllFiles(dbMyLibrary: List<RealmMyLibrary?>): ArrayList<String> {
        return ArrayList(dbMyLibrary.map { UrlUtils.getUrl(it) })
    }

    @JvmStatic
    fun downloadFiles(
        dbMyLibrary: List<RealmMyLibrary?>,
        selectedItems: ArrayList<Int>
    ): ArrayList<String> {
        return ArrayList(selectedItems.map { UrlUtils.getUrl(dbMyLibrary[it]) })
    }

    @RequiresApi(Build.VERSION_CODES.S)
    fun openDownloadService(context: Context?, urls: ArrayList<String>, fromSync: Boolean) {
        context?.let { ctx ->
            val preferences = ctx.getSharedPreferences(MyDownloadService.PREFS_NAME, Context.MODE_PRIVATE)
            preferences.edit {
                putStringSet("url_list_key", urls.toSet())
            }
            startDownloadServiceSafely(ctx, "url_list_key", fromSync)
        }
    }

    @RequiresApi(Build.VERSION_CODES.S)
    private fun startDownloadServiceSafely(context: Context, urlsKey: String, fromSync: Boolean) {
        if (canStartForegroundService(context)) {
            try {
                MyDownloadService.startService(context, urlsKey, fromSync)
            } catch (e: Exception) {
                e.printStackTrace()
                handleForegroundServiceNotAllowed(context, urlsKey, fromSync)
            }
        } else {
            handleForegroundServiceNotAllowed(context, urlsKey, fromSync)
        }
    }

    private fun handleForegroundServiceNotAllowed(context: Context, urlsKey: String, fromSync: Boolean) {
        if (!fromSync) {
            Utilities.toast(context, context.getString(R.string.download_in_background))
        }
        startDownloadWork(context, urlsKey, fromSync)
    }

    private fun startDownloadWork(context: Context, urlsKey: String, fromSync: Boolean) {
        val workRequest = OneTimeWorkRequestBuilder<DownloadWorker>()
            .setInputData(
                workDataOf(
                    "urls_key" to urlsKey,
                    "fromSync" to fromSync
                )
            )
            .addTag("download_work")
            .build()

        WorkManager.getInstance(context).enqueue(workRequest)
    }

    fun canStartForegroundService(context: Context): Boolean {
        return when {
            Build.VERSION.SDK_INT < Build.VERSION_CODES.O -> true
            Build.VERSION.SDK_INT < Build.VERSION_CODES.S -> {
                isAppInForeground(context)
            }
            else -> {
                isAppInForeground(context) || hasSpecialForegroundPermissions(context)
            }
        }
    }

    private fun isAppInForeground(context: Context): Boolean {
        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val appProcesses = activityManager.runningAppProcesses ?: return false

        val packageName = context.packageName
        return appProcesses.any { processInfo ->
            processInfo.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND &&
                processInfo.processName == packageName
        }
    }

    @RequiresApi(Build.VERSION_CODES.S)
    private fun hasSpecialForegroundPermissions(context: Context): Boolean {
        val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager

        return when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
                alarmManager.canScheduleExactAlarms()
            }
            else -> false
        }
    }

    fun extractLinks(text: String?): ArrayList<String> {
        val links = ArrayList<String>()
        val pattern = Pattern.compile("!\\[.*?]\\((.*?)\\)")
        val matcher = text?.let { pattern.matcher(it) }
        if (matcher != null) {
            while (matcher.find()) {
                val link = matcher.group(1)
                if (link != null) {
                    if (link.isNotEmpty()) {
                        links.add(link)
                    }
                }
            }
        }
        return links
    }

    @JvmStatic
    fun updateResourceOfflineStatus(url: String) {
        val currentFileName = FileUtils.getFileNameFromUrl(url)
        if (currentFileName.isBlank()) {
            return
        }

        MainApplication.applicationScope.launch {
            try {
                libraryRepository.markResourceOfflineByLocalAddress(currentFileName)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    private val libraryRepository: LibraryRepository by lazy {
        val entryPoint = EntryPointAccessors.fromApplication(
            MainApplication.context,
            DownloadUtilsEntryPoint::class.java
        )
        entryPoint.libraryRepository()
    }

    @EntryPoint
    @InstallIn(SingletonComponent::class)
    interface DownloadUtilsEntryPoint {
        fun libraryRepository(): LibraryRepository
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/ServerUrlMapper.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.SharedPreferences
import android.net.Uri
import androidx.core.net.toUri
import javax.inject.Inject
import org.ole.planet.myplanet.BuildConfig

class ServerUrlMapper @Inject constructor() {
    private val serverMappings = mapOf(
        "http://${BuildConfig.PLANET_SANPABLO_URL}" to "https://${BuildConfig.PLANET_SANPABLO_CLONE_URL}",
        "http://${BuildConfig.PLANET_URIUR_URL}" to "https://${BuildConfig.PLANET_URIUR_CLONE_URL}",
        "http://${BuildConfig.PLANET_EMBAKASI_URL}" to "https://${BuildConfig.PLANET_EMBAKASI_CLONE_URL}"
    )

    data class UrlMapping(
        val primaryUrl: String,
        val alternativeUrl: String? = null,
        val extractedBaseUrl: String? = null
    )

    private fun extractBaseUrl(url: String): String? {
        return try {
            val uri = url.toUri()
            val baseUrl = "${uri.scheme}://${uri.host}${if (uri.port != -1) ":${uri.port}" else ""}"
            baseUrl
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    fun processUrl(url: String): UrlMapping {
        val extractedUrl = extractBaseUrl(url)
        val alternativeUrl = extractedUrl?.let { baseUrl ->
            val mappedUrl = serverMappings[baseUrl]
            mappedUrl
        }

        val result = UrlMapping(url, alternativeUrl, extractedUrl)
        return result
    }

    fun updateUrlPreferences(editor: SharedPreferences.Editor, uri: Uri, alternativeUrl: String, url: String, settings: SharedPreferences) {
        val urlUser: String
        val urlPwd: String

        if (alternativeUrl.contains("@")) {
            val userinfo = getUserInfo(uri)
            urlUser = userinfo[0]
            urlPwd = userinfo[1]
        } else {
            urlUser = "satellite"
            urlPwd = settings.getString("serverPin", "") ?: ""
        }

        val altUri = alternativeUrl.toUri()

        val couchdbURL = if (alternativeUrl.contains("@")) {
            alternativeUrl
        } else {
            "${altUri.scheme}://$urlUser:$urlPwd@${altUri.host}:${if (altUri.port == -1) (if (altUri.scheme == "http") 80 else 443) else altUri.port}"
        }

        editor.apply {
            putString("url_user", urlUser)
            putString("url_pwd", urlPwd)
            putString("url_Scheme", uri.scheme)
            putString("url_Host", uri.host)
            putString("alternativeUrl", url)
            putString("processedAlternativeUrl", couchdbURL)
            putBoolean("isAlternativeUrl", true)
            apply()
        }
    }

    suspend fun updateServerIfNecessary(
        mapping: UrlMapping,
        settings: SharedPreferences,
        isServerReachable: suspend (String) -> Boolean
    ) {
        val primaryAvailable = isServerReachable(mapping.primaryUrl)
        val alternativeAvailable = mapping.alternativeUrl?.let { isServerReachable(it) } == true

        if (!primaryAvailable && alternativeAvailable) {
            mapping.alternativeUrl.let { alternativeUrl ->
                val editor = settings.edit()
                updateUrlPreferences(editor, mapping.primaryUrl.toUri(), alternativeUrl, mapping.primaryUrl, settings)
            }
        }
    }

    private fun getUserInfo(uri: Uri): Array<String> {
        val defaultInfo = arrayOf("", "")
        val info = uri.userInfo?.split(":")?.dropLastWhile { it.isEmpty() }?.toTypedArray()

        val result = if ((info?.size ?: 0) > 1) {
            arrayOf(info!![0], info[1])
        } else {
            defaultInfo
        }
        return result
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.SharedPreferences
import android.net.Uri
import androidx.core.net.toUri
import javax.inject.Inject
import org.ole.planet.myplanet.BuildConfig

class ServerUrlMapper @Inject constructor() {
    private val serverMappings = mapOf(
        "http://${BuildConfig.PLANET_SANPABLO_URL}" to "https://${BuildConfig.PLANET_SANPABLO_CLONE_URL}",
        "http://${BuildConfig.PLANET_URIUR_URL}" to "https://${BuildConfig.PLANET_URIUR_CLONE_URL}",
        "http://${BuildConfig.PLANET_EMBAKASI_URL}" to "https://${BuildConfig.PLANET_EMBAKASI_CLONE_URL}"
    )

    data class UrlMapping(
        val primaryUrl: String,
        val alternativeUrl: String? = null,
        val extractedBaseUrl: String? = null
    )

    private fun extractBaseUrl(url: String): String? {
        return try {
            val uri = url.toUri()
            val baseUrl = "${uri.scheme}://${uri.host}${if (uri.port != -1) ":${uri.port}" else ""}"
            baseUrl
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    fun processUrl(url: String): UrlMapping {
        val extractedUrl = extractBaseUrl(url)
        val alternativeUrl = extractedUrl?.let { baseUrl ->
            val mappedUrl = serverMappings[baseUrl]
            mappedUrl
        }

        val result = UrlMapping(url, alternativeUrl, extractedUrl)
        return result
    }

    fun updateUrlPreferences(editor: SharedPreferences.Editor, uri: Uri, alternativeUrl: String, url: String, settings: SharedPreferences) {
        val urlUser: String
        val urlPwd: String

        if (alternativeUrl.contains("@")) {
            val userinfo = getUserInfo(uri)
            urlUser = userinfo[0]
            urlPwd = userinfo[1]
        } else {
            urlUser = "satellite"
            urlPwd = settings.getString("serverPin", "") ?: ""
        }

        val altUri = alternativeUrl.toUri()

        val couchdbURL = if (alternativeUrl.contains("@")) {
            alternativeUrl
        } else {
            "${altUri.scheme}://$urlUser:$urlPwd@${altUri.host}:${if (altUri.port == -1) (if (altUri.scheme == "http") 80 else 443) else altUri.port}"
        }

        editor.apply {
            putString("url_user", urlUser)
            putString("url_pwd", urlPwd)
            putString("url_Scheme", uri.scheme)
            putString("url_Host", uri.host)
            putString("alternativeUrl", url)
            putString("processedAlternativeUrl", couchdbURL)
            putBoolean("isAlternativeUrl", true)
            apply()
        }
    }

    suspend fun updateServerIfNecessary(
        mapping: UrlMapping,
        settings: SharedPreferences,
        isServerReachable: suspend (String) -> Boolean
    ) {
        val primaryAvailable = isServerReachable(mapping.primaryUrl)
        val alternativeAvailable = mapping.alternativeUrl?.let { isServerReachable(it) } == true

        if (!primaryAvailable && alternativeAvailable) {
            mapping.alternativeUrl.let { alternativeUrl ->
                val editor = settings.edit()
                updateUrlPreferences(editor, mapping.primaryUrl.toUri(), alternativeUrl, mapping.primaryUrl, settings)
            }
        }
    }

    private fun getUserInfo(uri: Uri): Array<String> {
        val defaultInfo = arrayOf("", "")
        val info = uri.userInfo?.split(":")?.dropLastWhile { it.isEmpty() }?.toTypedArray()

        val result = if ((info?.size ?: 0) > 1) {
            arrayOf(info!![0], info[1])
        } else {
            defaultInfo
        }
        return result
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/AndroidDecrypter.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import de.rtner.misc.BinTools
import de.rtner.security.auth.spi.PBKDF2Engine
import de.rtner.security.auth.spi.PBKDF2Parameters
import java.security.NoSuchAlgorithmException
import java.security.SecureRandom
import java.util.Locale
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

class AndroidDecrypter {
    companion object {
        @JvmStatic
        @Throws(Exception::class)
        fun encrypt(plainText: String, key: String?, iv: String?): String {
            val clean = plainText.toByteArray()
            val ivSize = 16
            val ivBytes = ByteArray(ivSize)
            iv?.let { hexStringToByteArray(it) }?.let { System.arraycopy(it, 0, ivBytes, 0, ivBytes.size) }
            val ivParameterSpec = IvParameterSpec(ivBytes)
            val keyBytes = ByteArray(32)
            key?.let { hexStringToByteArray(it) }?.let { System.arraycopy(it, 0, keyBytes, 0, keyBytes.size) }
            val secretKeySpec = SecretKeySpec(keyBytes, "AES")
            val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec)
            val encrypted = cipher.doFinal(clean)
            val encryptedIVAndText = ByteArray(ivSize + encrypted.size)
            System.arraycopy(ivBytes, 0, encryptedIVAndText, 0, ivSize)
            System.arraycopy(encrypted, 0, encryptedIVAndText, ivSize, encrypted.size)
            return bytesToHex(encrypted)
        }

        @JvmStatic
        fun hexStringToByteArray(s: String): ByteArray {
            val len = s.length
            val data = ByteArray(len / 2)
            var i = 0
            while (i < len) {
                data[i / 2] = ((Character.digit(s[i], 16) shl 4) + Character.digit(s[i + 1], 16)).toByte()
                i += 2
            }
            return data
        }

        @JvmStatic
        private fun bytesToHex(hashInBytes: ByteArray): String {
            val sb = StringBuilder()
            for (b in hashInBytes) {
                sb.append(String.format("%02x", b))
            }
            return sb.toString()
        }

        @JvmStatic
        fun decrypt(encrypted: String?, key: String?, initVector: String?): String? {
            try {
                if (encrypted == null || key == null || initVector == null) {
                    return null
                }
                val iv = IvParameterSpec(hexStringToByteArray(initVector))
                val skeySpec = SecretKeySpec(hexStringToByteArray(key), "AES")

                val cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING")
                cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv)
                val original = cipher.doFinal(hexStringToByteArray(encrypted))
                return String(original)
            } catch (ex: Exception) {
                ex.printStackTrace()
            }
            return null
        }

        @JvmStatic
        fun androidDecrypter(usrId: String?, usrRawPwd: String?, dbPwdKeyValue: String?, dbSalt: String?): Boolean {
            try {
                val p = PBKDF2Parameters("HmacSHA1", "utf-8", dbSalt?.toByteArray(), 10)
                val dk = PBKDF2Engine(p).deriveKey(usrRawPwd, 20)
                println("$usrId Value ${BinTools.bin2hex(dk).lowercase(Locale.ROOT)}")
                return dbPwdKeyValue.equals(BinTools.bin2hex(dk).lowercase(Locale.ROOT), ignoreCase = true)

            } catch (e: Exception) {
                e.printStackTrace()
            }
            return false
        }

        @JvmStatic
        fun generateIv(): String {
            try {
                val iv = ByteArray(16)
                val random = SecureRandom()
                random.nextBytes(iv)
                return bytesToHex(iv)
            } catch (e: Exception) {
                e.printStackTrace()
            }
            return ""
        }

        @JvmStatic
        fun generateKey(): String? {
            val keyGenerator: KeyGenerator
            val secretKey: SecretKey
            try {
                keyGenerator = KeyGenerator.getInstance("AES")
                keyGenerator.init(256)
                secretKey = keyGenerator.generateKey()
                val binary = secretKey.encoded
                return bytesToHex(binary)
            } catch (e: NoSuchAlgorithmException) {
                e.printStackTrace()
            }
            return null
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import de.rtner.misc.BinTools
import de.rtner.security.auth.spi.PBKDF2Engine
import de.rtner.security.auth.spi.PBKDF2Parameters
import java.security.NoSuchAlgorithmException
import java.security.SecureRandom
import java.util.Locale
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

class AndroidDecrypter {
    companion object {
        @JvmStatic
        @Throws(Exception::class)
        fun encrypt(plainText: String, key: String?, iv: String?): String {
            val clean = plainText.toByteArray()
            val ivSize = 16
            val ivBytes = ByteArray(ivSize)
            iv?.let { hexStringToByteArray(it) }?.let { System.arraycopy(it, 0, ivBytes, 0, ivBytes.size) }
            val ivParameterSpec = IvParameterSpec(ivBytes)
            val keyBytes = ByteArray(32)
            key?.let { hexStringToByteArray(it) }?.let { System.arraycopy(it, 0, keyBytes, 0, keyBytes.size) }
            val secretKeySpec = SecretKeySpec(keyBytes, "AES")
            val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec)
            val encrypted = cipher.doFinal(clean)
            val encryptedIVAndText = ByteArray(ivSize + encrypted.size)
            System.arraycopy(ivBytes, 0, encryptedIVAndText, 0, ivSize)
            System.arraycopy(encrypted, 0, encryptedIVAndText, ivSize, encrypted.size)
            return bytesToHex(encrypted)
        }

        @JvmStatic
        fun hexStringToByteArray(s: String): ByteArray {
            val len = s.length
            val data = ByteArray(len / 2)
            var i = 0
            while (i < len) {
                data[i / 2] = ((Character.digit(s[i], 16) shl 4) + Character.digit(s[i + 1], 16)).toByte()
                i += 2
            }
            return data
        }

        @JvmStatic
        private fun bytesToHex(hashInBytes: ByteArray): String {
            val sb = StringBuilder()
            for (b in hashInBytes) {
                sb.append(String.format("%02x", b))
            }
            return sb.toString()
        }

        @JvmStatic
        fun decrypt(encrypted: String?, key: String?, initVector: String?): String? {
            try {
                if (encrypted == null || key == null || initVector == null) {
                    return null
                }
                val iv = IvParameterSpec(hexStringToByteArray(initVector))
                val skeySpec = SecretKeySpec(hexStringToByteArray(key), "AES")

                val cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING")
                cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv)
                val original = cipher.doFinal(hexStringToByteArray(encrypted))
                return String(original)
            } catch (ex: Exception) {
                ex.printStackTrace()
            }
            return null
        }

        @JvmStatic
        fun androidDecrypter(usrId: String?, usrRawPwd: String?, dbPwdKeyValue: String?, dbSalt: String?): Boolean {
            try {
                val p = PBKDF2Parameters("HmacSHA1", "utf-8", dbSalt?.toByteArray(), 10)
                val dk = PBKDF2Engine(p).deriveKey(usrRawPwd, 20)
                println("$usrId Value ${BinTools.bin2hex(dk).lowercase(Locale.ROOT)}")
                return dbPwdKeyValue.equals(BinTools.bin2hex(dk).lowercase(Locale.ROOT), ignoreCase = true)

            } catch (e: Exception) {
                e.printStackTrace()
            }
            return false
        }

        @JvmStatic
        fun generateIv(): String {
            try {
                val iv = ByteArray(16)
                val random = SecureRandom()
                random.nextBytes(iv)
                return bytesToHex(iv)
            } catch (e: Exception) {
                e.printStackTrace()
            }
            return ""
        }

        @JvmStatic
        fun generateKey(): String? {
            val keyGenerator: KeyGenerator
            val secretKey: SecretKey
            try {
                keyGenerator = KeyGenerator.getInstance("AES")
                keyGenerator.init(256)
                secretKey = keyGenerator.generateKey()
                val binary = secretKey.encoded
                return bytesToHex(binary)
            } catch (e: NoSuchAlgorithmException) {
                e.printStackTrace()
            }
            return null
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/FileUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.app.PendingIntent
import android.app.usage.StorageStatsManager
import android.content.Context
import android.content.Intent
import android.content.pm.PackageInstaller
import android.database.Cursor
import android.net.Uri
import android.os.Environment
import android.os.StatFs
import android.os.storage.StorageManager
import android.provider.MediaStore
import android.text.format.Formatter
import androidx.core.net.toUri
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.net.URLDecoder
import java.nio.charset.StandardCharsets
import java.util.UUID

object FileUtils {
    @JvmStatic
    fun getOlePath(context: Context): String {
        return context.getExternalFilesDir(null)?.let { "${it}/ole/" } ?: ""
    }

    @JvmStatic
    @Throws(IOException::class)
    fun fullyReadFileToBytes(f: File): ByteArray = f.readBytes()

    private fun createFilePath(context: Context, folder: String, filename: String): File {
        val baseDirectory = File(context.getExternalFilesDir(null), folder)

        if (filename.contains("/")) {
            val subDirPath = filename.substring(0, filename.lastIndexOf('/'))
            val fullDir = File(baseDirectory, subDirPath)

            try {
                if (!fullDir.exists() && !fullDir.mkdirs()) {
                    throw IOException("Failed to create directory: ${fullDir.absolutePath}")
                }
            } catch (e: IOException) {
                e.printStackTrace()
                throw RuntimeException("Failed to create directory: ${fullDir.absolutePath}", e)
            }

            val actualFilename = filename.substring(filename.lastIndexOf('/') + 1)
            return File(fullDir, actualFilename)
        } else {
            try {
                if (!baseDirectory.exists() && !baseDirectory.mkdirs()) {
                    throw IOException("Failed to create directory: ${baseDirectory.absolutePath}")
                }
            } catch (e: IOException) {
                e.printStackTrace()
                throw RuntimeException("Failed to create directory: ${baseDirectory.absolutePath}", e)
            }
            return File(baseDirectory, filename)
        }
    }

    @JvmStatic
    fun getSDPathFromUrl(context: Context, url: String?): File {
        return createFilePath(context, "/ole/${getIdFromUrl(url)}", getFileNameFromUrl(url))
    }

    @JvmStatic
    fun checkFileExist(context: Context, url: String?): Boolean {
        if (url.isNullOrEmpty()) return false
        val f = getSDPathFromUrl(context, url)
        return f.exists()
    }

    @JvmStatic
    fun getFileNameFromLocalAddress(path: String?): String {
        if (path.isNullOrBlank()) return ""
        return path.substringAfterLast('/')
    }

    @JvmStatic
    fun getFileNameFromUrl(url: String?): String {
        return try {
            url?.toUri()?.lastPathSegment?.let {
                URLDecoder.decode(it, StandardCharsets.UTF_8.name())
            } ?: ""
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }
    }

    @JvmStatic
    fun getIdFromUrl(url: String?): String {
        return try {
            url?.toUri()?.pathSegments?.let { segments ->
                val idx = segments.indexOf("resources")
                if (idx != -1 && idx + 1 < segments.size) segments[idx + 1] else ""
            } ?: ""
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }
    }

    @JvmStatic
    fun getFileExtension(address: String?): String {
        return address?.let { File(it).extension } ?: ""
    }

    @JvmStatic
    fun installApk(activity: Context, file: String?) {
        if (file?.endsWith("apk") != true) return
        val toInstall = File(file)
        if (!toInstall.exists()) return
        try {
            val packageInstaller = activity.packageManager.packageInstaller
            val params = PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL)
            val sessionId = packageInstaller.createSession(params)
            val session = packageInstaller.openSession(sessionId)
            addApkToInstallSession(toInstall, session)
            val intent = Intent(activity, activity.javaClass)
            val pendingIntent = PendingIntent.getActivity(activity, 0, intent,
                PendingIntent.FLAG_IMMUTABLE)
            val intentSender = pendingIntent.intentSender
            session.commit(intentSender)
            session.close()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @Throws(IOException::class)
    private fun addApkToInstallSession(apkFile: File, session: PackageInstaller.Session) {
        session.openWrite("my_app_session", 0, -1).use { output ->
            apkFile.inputStream().use { input ->
                input.copyTo(output)
                session.fsync(output)
            }
        }
    }


    @JvmStatic
    fun getRealPathFromURI(context: Context, contentUri: Uri?): String? {
        var cursor: Cursor? = null
        return try {
            val proj = arrayOf(MediaStore.Images.Media.DATA)
            cursor = contentUri?.let { context.contentResolver.query(it, proj, null, null, null) }
            val columnIndex = cursor?.getColumnIndexOrThrow(MediaStore.Images.Media.DATA)
            cursor?.moveToFirst()
            cursor?.getString(columnIndex ?: 0)
        } finally {
            cursor?.close()
        }
    }

    @JvmStatic
    fun copyUriToFile(context: Context, sourceUri: Uri, destinationFile: File) {
        context.contentResolver.openInputStream(sourceUri)?.use { inputStream ->
            FileOutputStream(destinationFile).use { outputStream ->
                inputStream.copyTo(outputStream)
            }
        }
    }

    @JvmStatic
    fun getPathFromURI(context: Context, uri: Uri?): String? {
        var filePath: String? = null
        if (uri != null) {
            when (uri.scheme) {
                "content" -> {
                    context.contentResolver.query(uri, null, null, null, null)?.use { cursor ->
                        if (cursor.moveToFirst()) {
                            val columnIndex = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME)
                            val fileName = cursor.getString(columnIndex)
                            val cacheDir = context.cacheDir
                            val destinationFile = File(cacheDir, fileName)
                            copyUriToFile(context, uri, destinationFile)
                            filePath = destinationFile.absolutePath
                        }
                    }
                }
                "file" -> filePath = uri.path
            }
        }
        return filePath
    }

    @JvmStatic
    @Throws(Exception::class)
    fun getStringFromFile(fl: File?): String {
        return fl?.inputStream()?.bufferedReader()?.use { it.readText() } ?: ""
    }

    @JvmStatic
    fun openOleFolder(context: Context): Intent {
        val intent = Intent(Intent.ACTION_GET_CONTENT)
        val uri = getOlePath(context).toUri()
        intent.setDataAndType(uri, "*/*")
        intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)
        return Intent.createChooser(intent, "Open folder")
    }

    @JvmStatic
    fun getImagePath(context: Context, uri: Uri?): String? {
        if (uri == null) return null
        val projection = arrayOf(MediaStore.Images.Media._ID, MediaStore.Images.Media.DATA)
        return try {
            context.contentResolver.query(uri, projection, null, null, null)?.use { firstCursor ->
                if (firstCursor.moveToFirst()) {
                    val idIndex = firstCursor.getColumnIndex(MediaStore.Images.Media._ID)
                    if (idIndex >= 0) {
                        val documentId = firstCursor.getString(idIndex)
                        val selection = "${MediaStore.Images.Media._ID} = ?"
                        val args = arrayOf(documentId)
                        context.contentResolver.query(
                            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                            projection,
                            selection,
                            args,
                            null
                        )?.use { cursor ->
                            if (cursor.moveToFirst()) {
                                val dataIndex = cursor.getColumnIndex(MediaStore.Images.Media.DATA)
                                if (dataIndex >= 0) return cursor.getString(dataIndex)
                            }
                        }
                    }
                }
            }
            null
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    @JvmStatic
    fun externalMemoryAvailable(): Boolean {
        return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED
    }

    @JvmStatic
    val availableExternalMemorySize: Long
        /**
         * Find space left in the external memory.
         */
        get() =// Not the best way to check, shows internal memory
            // when there is not external memory mounted
            if (externalMemoryAvailable()) {
                val path = Environment.getExternalStorageDirectory()
                val stat = StatFs(path.path)
                val blockSize = stat.blockSizeLong
                val availableBlocks = stat.availableBlocksLong
                availableBlocks * blockSize
            } else {
                0
            }

    /**
     * Coverts Bytes to KB/MB/GB and changes magnitude accordingly.
     *
     * @param size
     * @return A string with size followed by an appropriate suffix
     */
    @JvmStatic
    fun formatSize(context: Context, size: Long): String {
        return Formatter.formatFileSize(context, size)
    }

    @JvmStatic
    fun totalMemoryCapacity(context: Context): Long = getStorageStats(context).first

    @JvmStatic
    fun totalAvailableMemory(context: Context): Long = getStorageStats(context).second

    @JvmStatic
    fun totalAvailableMemoryRatio(context: Context): Long {
        val total = totalMemoryCapacity(context)
        val available = totalAvailableMemory(context)
        return Math.round(available.toDouble() / total.toDouble() * 100)
    }

    @JvmStatic
    fun availableOverTotalMemoryFormattedString(context: Context): String {
        val available = totalAvailableMemory(context)
        val total = totalMemoryCapacity(context)
        return formatSize(context, available) + "/" + formatSize(context, total)
    }

    private fun getStorageStats(context: Context): Pair<Long, Long> {
        val storageStatsManager =
            context.getSystemService(Context.STORAGE_STATS_SERVICE) as StorageStatsManager
        val storageManager = context.getSystemService(Context.STORAGE_SERVICE) as StorageManager
        val storageVolume = storageManager.primaryStorageVolume

        // Get UUID of the internal storage
        val uuid =
            storageVolume.uuid?.let { UUID.fromString(it) } ?: StorageManager.UUID_DEFAULT

        // Get the total bytes and available bytes
        val totalBytes = storageStatsManager.getTotalBytes(uuid)
        val availableBytes = storageStatsManager.getFreeBytes(uuid)

        return Pair(totalBytes, availableBytes)
    }
    fun nameWithoutExtension(fileName: String?): String? {
        return fileName?.let { File(it).name.takeIf { name -> name.isNotEmpty() } }?.substringBeforeLast('.')
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.app.PendingIntent
import android.app.usage.StorageStatsManager
import android.content.Context
import android.content.Intent
import android.content.pm.PackageInstaller
import android.database.Cursor
import android.net.Uri
import android.os.Environment
import android.os.StatFs
import android.os.storage.StorageManager
import android.provider.MediaStore
import android.text.format.Formatter
import androidx.core.net.toUri
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.net.URLDecoder
import java.nio.charset.StandardCharsets
import java.util.UUID

object FileUtils {
    @JvmStatic
    fun getOlePath(context: Context): String {
        return context.getExternalFilesDir(null)?.let { "${it}/ole/" } ?: ""
    }

    @JvmStatic
    @Throws(IOException::class)
    fun fullyReadFileToBytes(f: File): ByteArray = f.readBytes()

    private fun createFilePath(context: Context, folder: String, filename: String): File {
        val baseDirectory = File(context.getExternalFilesDir(null), folder)

        if (filename.contains("/")) {
            val subDirPath = filename.substring(0, filename.lastIndexOf('/'))
            val fullDir = File(baseDirectory, subDirPath)

            try {
                if (!fullDir.exists() && !fullDir.mkdirs()) {
                    throw IOException("Failed to create directory: ${fullDir.absolutePath}")
                }
            } catch (e: IOException) {
                e.printStackTrace()
                throw RuntimeException("Failed to create directory: ${fullDir.absolutePath}", e)
            }

            val actualFilename = filename.substring(filename.lastIndexOf('/') + 1)
            return File(fullDir, actualFilename)
        } else {
            try {
                if (!baseDirectory.exists() && !baseDirectory.mkdirs()) {
                    throw IOException("Failed to create directory: ${baseDirectory.absolutePath}")
                }
            } catch (e: IOException) {
                e.printStackTrace()
                throw RuntimeException("Failed to create directory: ${baseDirectory.absolutePath}", e)
            }
            return File(baseDirectory, filename)
        }
    }

    @JvmStatic
    fun getSDPathFromUrl(context: Context, url: String?): File {
        return createFilePath(context, "/ole/${getIdFromUrl(url)}", getFileNameFromUrl(url))
    }

    @JvmStatic
    fun checkFileExist(context: Context, url: String?): Boolean {
        if (url.isNullOrEmpty()) return false
        val f = getSDPathFromUrl(context, url)
        return f.exists()
    }

    @JvmStatic
    fun getFileNameFromLocalAddress(path: String?): String {
        if (path.isNullOrBlank()) return ""
        return path.substringAfterLast('/')
    }

    @JvmStatic
    fun getFileNameFromUrl(url: String?): String {
        return try {
            url?.toUri()?.lastPathSegment?.let {
                URLDecoder.decode(it, StandardCharsets.UTF_8.name())
            } ?: ""
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }
    }

    @JvmStatic
    fun getIdFromUrl(url: String?): String {
        return try {
            url?.toUri()?.pathSegments?.let { segments ->
                val idx = segments.indexOf("resources")
                if (idx != -1 && idx + 1 < segments.size) segments[idx + 1] else ""
            } ?: ""
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }
    }

    @JvmStatic
    fun getFileExtension(address: String?): String {
        return address?.let { File(it).extension } ?: ""
    }

    @JvmStatic
    fun installApk(activity: Context, file: String?) {
        if (file?.endsWith("apk") != true) return
        val toInstall = File(file)
        if (!toInstall.exists()) return
        try {
            val packageInstaller = activity.packageManager.packageInstaller
            val params = PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL)
            val sessionId = packageInstaller.createSession(params)
            val session = packageInstaller.openSession(sessionId)
            addApkToInstallSession(toInstall, session)
            val intent = Intent(activity, activity.javaClass)
            val pendingIntent = PendingIntent.getActivity(activity, 0, intent,
                PendingIntent.FLAG_IMMUTABLE)
            val intentSender = pendingIntent.intentSender
            session.commit(intentSender)
            session.close()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @Throws(IOException::class)
    private fun addApkToInstallSession(apkFile: File, session: PackageInstaller.Session) {
        session.openWrite("my_app_session", 0, -1).use { output ->
            apkFile.inputStream().use { input ->
                input.copyTo(output)
                session.fsync(output)
            }
        }
    }


    @JvmStatic
    fun getRealPathFromURI(context: Context, contentUri: Uri?): String? {
        var cursor: Cursor? = null
        return try {
            val proj = arrayOf(MediaStore.Images.Media.DATA)
            cursor = contentUri?.let { context.contentResolver.query(it, proj, null, null, null) }
            val columnIndex = cursor?.getColumnIndexOrThrow(MediaStore.Images.Media.DATA)
            cursor?.moveToFirst()
            cursor?.getString(columnIndex ?: 0)
        } finally {
            cursor?.close()
        }
    }

    @JvmStatic
    fun copyUriToFile(context: Context, sourceUri: Uri, destinationFile: File) {
        context.contentResolver.openInputStream(sourceUri)?.use { inputStream ->
            FileOutputStream(destinationFile).use { outputStream ->
                inputStream.copyTo(outputStream)
            }
        }
    }

    @JvmStatic
    fun getPathFromURI(context: Context, uri: Uri?): String? {
        var filePath: String? = null
        if (uri != null) {
            when (uri.scheme) {
                "content" -> {
                    context.contentResolver.query(uri, null, null, null, null)?.use { cursor ->
                        if (cursor.moveToFirst()) {
                            val columnIndex = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME)
                            val fileName = cursor.getString(columnIndex)
                            val cacheDir = context.cacheDir
                            val destinationFile = File(cacheDir, fileName)
                            copyUriToFile(context, uri, destinationFile)
                            filePath = destinationFile.absolutePath
                        }
                    }
                }
                "file" -> filePath = uri.path
            }
        }
        return filePath
    }

    @JvmStatic
    @Throws(Exception::class)
    fun getStringFromFile(fl: File?): String {
        return fl?.inputStream()?.bufferedReader()?.use { it.readText() } ?: ""
    }

    @JvmStatic
    fun openOleFolder(context: Context): Intent {
        val intent = Intent(Intent.ACTION_GET_CONTENT)
        val uri = getOlePath(context).toUri()
        intent.setDataAndType(uri, "*/*")
        intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)
        return Intent.createChooser(intent, "Open folder")
    }

    @JvmStatic
    fun getImagePath(context: Context, uri: Uri?): String? {
        if (uri == null) return null
        val projection = arrayOf(MediaStore.Images.Media._ID, MediaStore.Images.Media.DATA)
        return try {
            context.contentResolver.query(uri, projection, null, null, null)?.use { firstCursor ->
                if (firstCursor.moveToFirst()) {
                    val idIndex = firstCursor.getColumnIndex(MediaStore.Images.Media._ID)
                    if (idIndex >= 0) {
                        val documentId = firstCursor.getString(idIndex)
                        val selection = "${MediaStore.Images.Media._ID} = ?"
                        val args = arrayOf(documentId)
                        context.contentResolver.query(
                            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                            projection,
                            selection,
                            args,
                            null
                        )?.use { cursor ->
                            if (cursor.moveToFirst()) {
                                val dataIndex = cursor.getColumnIndex(MediaStore.Images.Media.DATA)
                                if (dataIndex >= 0) return cursor.getString(dataIndex)
                            }
                        }
                    }
                }
            }
            null
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    @JvmStatic
    fun externalMemoryAvailable(): Boolean {
        return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED
    }

    @JvmStatic
    val availableExternalMemorySize: Long
        /**
         * Find space left in the external memory.
         */
        get() =// Not the best way to check, shows internal memory
            // when there is not external memory mounted
            if (externalMemoryAvailable()) {
                val path = Environment.getExternalStorageDirectory()
                val stat = StatFs(path.path)
                val blockSize = stat.blockSizeLong
                val availableBlocks = stat.availableBlocksLong
                availableBlocks * blockSize
            } else {
                0
            }

    /**
     * Coverts Bytes to KB/MB/GB and changes magnitude accordingly.
     *
     * @param size
     * @return A string with size followed by an appropriate suffix
     */
    @JvmStatic
    fun formatSize(context: Context, size: Long): String {
        return Formatter.formatFileSize(context, size)
    }

    @JvmStatic
    fun totalMemoryCapacity(context: Context): Long = getStorageStats(context).first

    @JvmStatic
    fun totalAvailableMemory(context: Context): Long = getStorageStats(context).second

    @JvmStatic
    fun totalAvailableMemoryRatio(context: Context): Long {
        val total = totalMemoryCapacity(context)
        val available = totalAvailableMemory(context)
        return Math.round(available.toDouble() / total.toDouble() * 100)
    }

    @JvmStatic
    fun availableOverTotalMemoryFormattedString(context: Context): String {
        val available = totalAvailableMemory(context)
        val total = totalMemoryCapacity(context)
        return formatSize(context, available) + "/" + formatSize(context, total)
    }

    private fun getStorageStats(context: Context): Pair<Long, Long> {
        val storageStatsManager =
            context.getSystemService(Context.STORAGE_STATS_SERVICE) as StorageStatsManager
        val storageManager = context.getSystemService(Context.STORAGE_SERVICE) as StorageManager
        val storageVolume = storageManager.primaryStorageVolume

        // Get UUID of the internal storage
        val uuid =
            storageVolume.uuid?.let { UUID.fromString(it) } ?: StorageManager.UUID_DEFAULT

        // Get the total bytes and available bytes
        val totalBytes = storageStatsManager.getTotalBytes(uuid)
        val availableBytes = storageStatsManager.getFreeBytes(uuid)

        return Pair(totalBytes, availableBytes)
    }
    fun nameWithoutExtension(fileName: String?): String? {
        return fileName?.let { File(it).name.takeIf { name -> name.isNotEmpty() } }?.substringBeforeLast('.')
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/Constants.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import androidx.preference.PreferenceManager
import org.ole.planet.myplanet.model.RealmAchievement
import org.ole.planet.myplanet.model.RealmCertification
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmOfflineActivity
import org.ole.planet.myplanet.model.RealmRating
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmTeamLog
import org.ole.planet.myplanet.model.RealmTeamTask

object Constants {
    const val KEY_LOGIN = "isLoggedIn"
    const val DICTIONARY_URL = "http://157.245.241.39:8000/output.json"
    var shelfDataList = mutableListOf<ShelfData>()
    const val KEY_SYNC = "beta_wifi_switch"
    const val KEY_MEETUPS = "key_meetup"
    const val KEY_AUTOSYNC_ = "auto_sync_with_server"
    const val KEY_AUTOSYNC_WEEKLY = "force_weekly_sync"
    const val KEY_AUTOSYNC_MONTHLY = "force_monthly_sync"
    const val KEY_UPGRADE_MAX = "beta_upgrade_max"
    const val PREFS_NAME = "OLE_PLANET"
    var classList = mutableMapOf<String, Class<*>>()
    var LABELS = mutableMapOf<String, String>()
    const val KEY_NOTIFICATION_SHOWN = "notification_shown"
    const val SELECTED_LANGUAGE = "app_language"

    init {
        initClasses()
        shelfDataList = mutableListOf(
            ShelfData("resourceIds", "resources", "resourceId"),
            ShelfData("meetupIds", "meetups", "meetupId"),
            ShelfData("courseIds", "courses", "courseId"),
            ShelfData("myTeamIds", "teams", "teamId")
        )
        LABELS = mutableMapOf(
            "Offer" to "offer",
            "Request for advice" to "advice"
        )
    }

    private fun initClasses() {
        classList["news"] = RealmNews::class.java
        classList["tags"] = RealmTag::class.java
        classList["login_activities"] = RealmOfflineActivity::class.java
        classList["ratings"] = RealmRating::class.java
        classList["submissions"] = RealmSubmission::class.java
        classList["courses"] = RealmMyCourse::class.java
        classList["achievements"] = RealmAchievement::class.java
        classList["feedback"] = RealmFeedback::class.java
        classList["teams"] = RealmMyTeam::class.java
        classList["tasks"] = RealmTeamTask::class.java
        classList["meetups"] = RealmMeetup::class.java
        classList["health"] = RealmMyHealthPojo::class.java
        classList["certifications"] = RealmCertification::class.java
        classList["team_activities"] = RealmTeamLog::class.java
        classList["courses_progress"] = RealmCourseProgress::class.java
    }

    @JvmStatic
    fun showBetaFeature(s: String, context: Context): Boolean {
        val preferences = PreferenceManager.getDefaultSharedPreferences(context)
        return preferences.getBoolean("beta_function", false)
    }

    @JvmStatic
    fun isBetaWifiFeatureEnabled(context: Context): Boolean {
        val preferences = PreferenceManager.getDefaultSharedPreferences(context)
        val betaEnabled = preferences.getBoolean("beta_function", false)
        val wifiSwitchEnabled = preferences.getBoolean(KEY_SYNC, false)
        return betaEnabled && wifiSwitchEnabled
    }

    @JvmStatic
    fun autoSynFeature(s: String?, context: Context): Boolean {
        val preferences = PreferenceManager.getDefaultSharedPreferences(context)
        return preferences.getBoolean(s, false)
    }

    class ShelfData(
        @JvmField var key: String,
        @JvmField var type: String,
        @JvmField var categoryKey: String
    )
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import androidx.preference.PreferenceManager
import org.ole.planet.myplanet.model.RealmAchievement
import org.ole.planet.myplanet.model.RealmCertification
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyHealthPojo
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmOfflineActivity
import org.ole.planet.myplanet.model.RealmRating
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmTeamLog
import org.ole.planet.myplanet.model.RealmTeamTask

object Constants {
    const val KEY_LOGIN = "isLoggedIn"
    const val DICTIONARY_URL = "http://157.245.241.39:8000/output.json"
    var shelfDataList = mutableListOf<ShelfData>()
    const val KEY_SYNC = "beta_wifi_switch"
    const val KEY_MEETUPS = "key_meetup"
    const val KEY_AUTOSYNC_ = "auto_sync_with_server"
    const val KEY_AUTOSYNC_WEEKLY = "force_weekly_sync"
    const val KEY_AUTOSYNC_MONTHLY = "force_monthly_sync"
    const val KEY_UPGRADE_MAX = "beta_upgrade_max"
    const val PREFS_NAME = "OLE_PLANET"
    var classList = mutableMapOf<String, Class<*>>()
    var LABELS = mutableMapOf<String, String>()
    const val KEY_NOTIFICATION_SHOWN = "notification_shown"
    const val SELECTED_LANGUAGE = "app_language"

    init {
        initClasses()
        shelfDataList = mutableListOf(
            ShelfData("resourceIds", "resources", "resourceId"),
            ShelfData("meetupIds", "meetups", "meetupId"),
            ShelfData("courseIds", "courses", "courseId"),
            ShelfData("myTeamIds", "teams", "teamId")
        )
        LABELS = mutableMapOf(
            "Offer" to "offer",
            "Request for advice" to "advice"
        )
    }

    private fun initClasses() {
        classList["news"] = RealmNews::class.java
        classList["tags"] = RealmTag::class.java
        classList["login_activities"] = RealmOfflineActivity::class.java
        classList["ratings"] = RealmRating::class.java
        classList["submissions"] = RealmSubmission::class.java
        classList["courses"] = RealmMyCourse::class.java
        classList["achievements"] = RealmAchievement::class.java
        classList["feedback"] = RealmFeedback::class.java
        classList["teams"] = RealmMyTeam::class.java
        classList["tasks"] = RealmTeamTask::class.java
        classList["meetups"] = RealmMeetup::class.java
        classList["health"] = RealmMyHealthPojo::class.java
        classList["certifications"] = RealmCertification::class.java
        classList["team_activities"] = RealmTeamLog::class.java
        classList["courses_progress"] = RealmCourseProgress::class.java
    }

    @JvmStatic
    fun showBetaFeature(s: String, context: Context): Boolean {
        val preferences = PreferenceManager.getDefaultSharedPreferences(context)
        return preferences.getBoolean("beta_function", false)
    }

    @JvmStatic
    fun isBetaWifiFeatureEnabled(context: Context): Boolean {
        val preferences = PreferenceManager.getDefaultSharedPreferences(context)
        val betaEnabled = preferences.getBoolean("beta_function", false)
        val wifiSwitchEnabled = preferences.getBoolean(KEY_SYNC, false)
        return betaEnabled && wifiSwitchEnabled
    }

    @JvmStatic
    fun autoSynFeature(s: String?, context: Context): Boolean {
        val preferences = PreferenceManager.getDefaultSharedPreferences(context)
        return preferences.getBoolean(s, false)
    }

    class ShelfData(
        @JvmField var key: String,
        @JvmField var type: String,
        @JvmField var categoryKey: String
    )
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/Utilities.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.content.SharedPreferences
import android.util.Patterns
import android.webkit.MimeTypeMap
import android.widget.Toast
import androidx.core.graphics.toColorInt
import fisk.chipcloud.ChipCloudConfig
import java.math.BigInteger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication

object Utilities {
    fun isValidEmail(target: CharSequence): Boolean {
        return !target.isNullOrEmpty() && Patterns.EMAIL_ADDRESS.matcher(target).matches()
    }

    @JvmStatic
    fun toast(context: Context?, message: CharSequence?, duration: Int = Toast.LENGTH_LONG) {
        context ?: return
        MainApplication.applicationScope.launch(Dispatchers.Main) {
            Toast.makeText(context, message, duration).show()
        }
    }

    fun getCloudConfig(): ChipCloudConfig {
        return ChipCloudConfig()
            .useInsetPadding(true)
            .checkedChipColor("#e0e0e0".toColorInt())
            .checkedTextColor("#000000".toColorInt())
            .uncheckedChipColor("#e0e0e0".toColorInt())
            .uncheckedTextColor("#000000".toColorInt())
    }

    fun checkNA(s: String?): String {
        return if (s.isNullOrEmpty()) "N/A" else s
    }

    fun getUserName(settings: SharedPreferences): String {
        return settings.getString("name", "") ?: ""
    }

    fun toHex(arg: String?): String {
        return arg?.toByteArray()?.let { String.format("%x", BigInteger(1, it)) } ?: ""
    }

    fun getMimeType(url: String?): String? {
        val extension = FileUtils.getFileExtension(url)
        return MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension)
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.content.SharedPreferences
import android.util.Patterns
import android.webkit.MimeTypeMap
import android.widget.Toast
import androidx.core.graphics.toColorInt
import fisk.chipcloud.ChipCloudConfig
import java.math.BigInteger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication

object Utilities {
    fun isValidEmail(target: CharSequence): Boolean {
        return !target.isNullOrEmpty() && Patterns.EMAIL_ADDRESS.matcher(target).matches()
    }

    @JvmStatic
    fun toast(context: Context?, message: CharSequence?, duration: Int = Toast.LENGTH_LONG) {
        context ?: return
        MainApplication.applicationScope.launch(Dispatchers.Main) {
            Toast.makeText(context, message, duration).show()
        }
    }

    fun getCloudConfig(): ChipCloudConfig {
        return ChipCloudConfig()
            .useInsetPadding(true)
            .checkedChipColor("#e0e0e0".toColorInt())
            .checkedTextColor("#000000".toColorInt())
            .uncheckedChipColor("#e0e0e0".toColorInt())
            .uncheckedTextColor("#000000".toColorInt())
    }

    fun checkNA(s: String?): String {
        return if (s.isNullOrEmpty()) "N/A" else s
    }

    fun getUserName(settings: SharedPreferences): String {
        return settings.getString("name", "") ?: ""
    }

    fun toHex(arg: String?): String {
        return arg?.toByteArray()?.let { String.format("%x", BigInteger(1, it)) } ?: ""
    }

    fun getMimeType(url: String?): String? {
        val extension = FileUtils.getFileExtension(url)
        return MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/CustomClickableSpan.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.content.Intent
import android.text.style.ClickableSpan
import android.view.View
import org.ole.planet.myplanet.ui.viewer.WebViewActivity

class CustomClickableSpan(private val url: String, private val title: String, private val context: Context) : ClickableSpan() {
    override fun onClick(widget: View) {
        openLinkInWebView(url, title)
    }

    private fun openLinkInWebView(link: String?, title: String) {
        if (!link.isNullOrEmpty()) {
            val webViewIntent = Intent(context, WebViewActivity::class.java)
            webViewIntent.putExtra("title", title)
            webViewIntent.putExtra("link", link)
            context.startActivity(webViewIntent)
        } else {
            Utilities.toast(context, "Invalid link")
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.content.Intent
import android.text.style.ClickableSpan
import android.view.View
import org.ole.planet.myplanet.ui.viewer.WebViewActivity

class CustomClickableSpan(private val url: String, private val title: String, private val context: Context) : ClickableSpan() {
    override fun onClick(widget: View) {
        openLinkInWebView(url, title)
    }

    private fun openLinkInWebView(link: String?, title: String) {
        if (!link.isNullOrEmpty()) {
            val webViewIntent = Intent(context, WebViewActivity::class.java)
            webViewIntent.putExtra("title", title)
            webViewIntent.putExtra("link", link)
            context.startActivity(webViewIntent)
        } else {
            Utilities.toast(context, "Invalid link")
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/ThemeManager.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.view.ViewGroup
import android.widget.ArrayAdapter
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatDelegate
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

object ThemeManager {
    fun showThemeDialog(context: Context) {
        val options = arrayOf(
            context.getString(R.string.dark_mode_off),
            context.getString(R.string.dark_mode_on),
            context.getString(R.string.dark_mode_follow_system)
        )
        val currentMode = getCurrentThemeMode(context)
        val checkedItem = when (currentMode) {
            ThemeMode.LIGHT -> 0
            ThemeMode.DARK -> 1
            else -> 2
        }
        val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
            .setTitle(context.getString(R.string.select_theme_mode))
            .setSingleChoiceItems(ArrayAdapter(context, R.layout.checked_list_item, options), checkedItem) { dialog, which ->
                val selectedMode = when (which) {
                    0 -> ThemeMode.LIGHT
                    1 -> ThemeMode.DARK
                    2 -> ThemeMode.FOLLOW_SYSTEM
                    else -> ThemeMode.FOLLOW_SYSTEM
                }
                setThemeMode(context, selectedMode)
                dialog.dismiss()
            }
            .setNegativeButton(R.string.cancel, null)
        val dialog = builder.create()
        dialog.show()
        dialog.window?.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
    }

    fun getCurrentThemeMode(context: Context): String {
        val sharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        return sharedPreferences.getString("theme_mode", ThemeMode.FOLLOW_SYSTEM) ?: ThemeMode.FOLLOW_SYSTEM
    }

    fun setThemeMode(context: Context, themeMode: String) {
        val sharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        with(sharedPreferences.edit()) {
            putString("theme_mode", themeMode)
            apply()
        }
        AppCompatDelegate.setDefaultNightMode(
            when (themeMode) {
                ThemeMode.LIGHT -> AppCompatDelegate.MODE_NIGHT_NO
                ThemeMode.DARK -> AppCompatDelegate.MODE_NIGHT_YES
                else -> AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM
            }
        )
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.view.ViewGroup
import android.widget.ArrayAdapter
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatDelegate
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

object ThemeManager {
    fun showThemeDialog(context: Context) {
        val options = arrayOf(
            context.getString(R.string.dark_mode_off),
            context.getString(R.string.dark_mode_on),
            context.getString(R.string.dark_mode_follow_system)
        )
        val currentMode = getCurrentThemeMode(context)
        val checkedItem = when (currentMode) {
            ThemeMode.LIGHT -> 0
            ThemeMode.DARK -> 1
            else -> 2
        }
        val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme)
            .setTitle(context.getString(R.string.select_theme_mode))
            .setSingleChoiceItems(ArrayAdapter(context, R.layout.checked_list_item, options), checkedItem) { dialog, which ->
                val selectedMode = when (which) {
                    0 -> ThemeMode.LIGHT
                    1 -> ThemeMode.DARK
                    2 -> ThemeMode.FOLLOW_SYSTEM
                    else -> ThemeMode.FOLLOW_SYSTEM
                }
                setThemeMode(context, selectedMode)
                dialog.dismiss()
            }
            .setNegativeButton(R.string.cancel, null)
        val dialog = builder.create()
        dialog.show()
        dialog.window?.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
    }

    fun getCurrentThemeMode(context: Context): String {
        val sharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        return sharedPreferences.getString("theme_mode", ThemeMode.FOLLOW_SYSTEM) ?: ThemeMode.FOLLOW_SYSTEM
    }

    fun setThemeMode(context: Context, themeMode: String) {
        val sharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        with(sharedPreferences.edit()) {
            putString("theme_mode", themeMode)
            apply()
        }
        AppCompatDelegate.setDefaultNightMode(
            when (themeMode) {
                ThemeMode.LIGHT -> AppCompatDelegate.MODE_NIGHT_NO
                ThemeMode.DARK -> AppCompatDelegate.MODE_NIGHT_YES
                else -> AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM
            }
        )
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/NotificationUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.app.NotificationChannel
import android.app.NotificationManager.IMPORTANCE_DEFAULT
import android.app.NotificationManager.IMPORTANCE_HIGH
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Build
import android.provider.Settings
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.repository.NotificationRepository
import org.ole.planet.myplanet.service.getBroadcastService
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity

object NotificationUtils {
    const val CHANNEL_GENERAL = "general_notifications"
    const val CHANNEL_SURVEYS = "survey_notifications"
    const val CHANNEL_TASKS = "task_notifications"
    const val CHANNEL_SYSTEM = "system_notifications"
    const val CHANNEL_TEAM = "team_notifications"
    const val TYPE_SURVEY = "survey"
    const val TYPE_TASK = "task"
    const val TYPE_STORAGE = "storage"
    const val TYPE_JOIN_REQUEST = "join_request"
    const val TYPE_RESOURCE = "resource"
    const val TYPE_COURSE = "course"
    private const val PREFS_NAME = "notification_preferences"
    private const val KEY_ENABLED = "notifications_enabled"
    private const val KEY_SURVEY_ENABLED = "survey_notifications_enabled"
    private const val KEY_TASK_ENABLED = "task_notifications_enabled"
    private const val KEY_SYSTEM_ENABLED = "system_notifications_enabled"
    private const val KEY_TEAM_ENABLED = "team_notifications_enabled"
    private const val KEY_ACTIVE_NOTIFICATIONS = "active_notifications"
    const val ACTION_MARK_AS_READ = "mark_as_read"
    const val ACTION_OPEN_NOTIFICATION = "open_notification"
    const val ACTION_STORAGE_SETTINGS = "storage_settings"
    const val EXTRA_NOTIFICATION_ID = "notification_id"
    const val EXTRA_NOTIFICATION_TYPE = "notification_type"
    const val EXTRA_RELATED_ID = "related_id"

    data class NotificationConfig(
        val id: String,
        val type: String,
        val title: String,
        val message: String,
        val priority: Int = NotificationCompat.PRIORITY_DEFAULT,
        val category: String = NotificationCompat.CATEGORY_MESSAGE,
        val actionable: Boolean = false,
        val bigTextStyle: Boolean = true,
        val autoCancel: Boolean = true,
        val silent: Boolean = false,
        val targetActivity: Class<*>? = null,
        val extras: Map<String, String> = emptyMap(),
        val relatedId: String? = null
    )

    @JvmStatic
    fun create(context: Context, smallIcon: Int, contentTitle: String?, contentText: String?) {
        val manager = context.getSystemService(Context.NOTIFICATION_SERVICE) as android.app.NotificationManager
        val a = NotificationCompat.Builder(context, "11")
        setChannel(manager)
        val notification = a.setContentTitle(contentTitle).setContentText(contentText).setSmallIcon(smallIcon)
            .setProgress(0, 0, true).setAutoCancel(true).build()
        manager.notify(111, notification)
    }

    @JvmStatic
    fun cancel(context: Context, id: Int) {
        val nm = NotificationManagerCompat.from(context)
        nm.cancel(id)
    }

    @JvmStatic
    fun cancelAll(context: Context) {
        val nm = NotificationManagerCompat.from(context)
        nm.cancelAll()
    }

    @JvmStatic
    fun setChannel(notificationManager: android.app.NotificationManager?) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val importance = android.app.NotificationManager.IMPORTANCE_LOW
            val notificationChannel = NotificationChannel("11", "ole", importance)
            notificationManager?.createNotificationChannel(notificationChannel)
        }
    }

    @JvmStatic
    fun getInstance(context: Context): NotificationManager {
        return NotificationManager(context)
    }

    class NotificationManager(private val context: Context) {
        private val notificationManager = NotificationManagerCompat.from(context)
        private val preferences: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        private val activeNotifications = mutableSetOf<String>()
        private val sessionShownNotifications = mutableSetOf<String>()

        init {
            loadActiveNotifications()
            createNotificationChannels()
        }

        private fun createNotificationChannels() {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                val channels = listOf(
                    NotificationChannel(CHANNEL_GENERAL, "General Notifications", IMPORTANCE_DEFAULT).apply {
                        description = "General app notifications"
                        enableLights(true)
                        enableVibration(true)
                    },

                    NotificationChannel(CHANNEL_SURVEYS, "Survey Notifications", IMPORTANCE_HIGH).apply {
                        description = "New surveys and survey reminders"
                        enableLights(true)
                        enableVibration(true)
                        setShowBadge(true)
                    },

                    NotificationChannel(CHANNEL_TASKS, "Task Notifications", IMPORTANCE_HIGH).apply {
                        description = "Task assignments and deadlines"
                        enableLights(true)
                        enableVibration(true)
                        setShowBadge(true)
                    },

                    NotificationChannel(CHANNEL_SYSTEM, "System Notifications", IMPORTANCE_DEFAULT).apply {
                        description = "Storage warnings and system updates"
                        enableLights(true)
                        enableVibration(false)
                    },

                    NotificationChannel(CHANNEL_TEAM, "Team Notifications", IMPORTANCE_DEFAULT).apply {
                        description = "Team join requests and team updates"
                        enableLights(true)
                        enableVibration(true)
                    }
                )

                val systemNotificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as android.app.NotificationManager
                channels.forEach { channel ->
                    systemNotificationManager.createNotificationChannel(channel)
                }
            }
        }

        fun showNotification(config: NotificationConfig): Boolean {
            if (!canShowNotification(config.type)) {
                return false
            }

            if (sessionShownNotifications.contains(config.id)) {
                return false
            }

            val notificationId = config.id.hashCode()
            val activeNotifications = notificationManager.activeNotifications
            val isAlreadyShowing = activeNotifications.any { it.id == notificationId }

            if (isAlreadyShowing) {
                return false
            }

            try {
                val notification = buildNotification(config)
                notificationManager.notify(notificationId, notification)
                markNotificationAsShown(config.id)
                return true
            } catch (e: Exception) {
                e.printStackTrace()
                return false
            }
        }

        private fun buildNotification(config: NotificationConfig): android.app.Notification {
            val channelId = getChannelForType(config.type)
            val intent = createNotificationIntent(config)
            val pendingIntent = PendingIntent.getActivity(
                context,
                config.id.hashCode(),
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )

            val builder = NotificationCompat.Builder(context, channelId)
                .setSmallIcon(getIconForType(config.type))
                .setContentTitle(config.title)
                .setContentText(config.message)
                .setPriority(config.priority)
                .setCategory(config.category)
                .setContentIntent(pendingIntent)
                .setAutoCancel(config.autoCancel)
                .setWhen(System.currentTimeMillis())
                .setShowWhen(true)
                .setColor(ContextCompat.getColor(context, R.color.colorPrimary))

            if (!config.silent) {
                builder.setDefaults(NotificationCompat.DEFAULT_ALL)
            }

            if (config.bigTextStyle) {
                builder.setStyle(NotificationCompat.BigTextStyle().bigText(config.message))
            }

            if (config.actionable) {
                addNotificationActions(builder, config)
            }

            return builder.build()
        }

        private fun addNotificationActions(builder: NotificationCompat.Builder, config: NotificationConfig) {
            val markAsReadIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                action = ACTION_MARK_AS_READ
                putExtra(EXTRA_NOTIFICATION_ID, config.id)
            }
            val markAsReadPendingIntent = PendingIntent.getBroadcast(
                context, (config.id + "_mark_read").hashCode(), markAsReadIntent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            builder.addAction(R.drawable.ole_logo, "Mark as Read", markAsReadPendingIntent)

            when (config.type) {
                TYPE_SURVEY -> {
                    val openIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                        action = ACTION_OPEN_NOTIFICATION
                        putExtra(EXTRA_NOTIFICATION_TYPE, config.type)
                        putExtra(EXTRA_NOTIFICATION_ID, config.id)
                        putExtra(EXTRA_RELATED_ID, config.relatedId)
                    }
                    val openPendingIntent = PendingIntent.getBroadcast(
                        context, (config.id + "_open").hashCode(), openIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )
                    builder.addAction(R.drawable.survey, "Take Survey", openPendingIntent)
                }

                TYPE_TASK -> {
                    val openIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                        action = ACTION_OPEN_NOTIFICATION
                        putExtra(EXTRA_NOTIFICATION_TYPE, config.type)
                        putExtra(EXTRA_NOTIFICATION_ID, config.id)
                        putExtra(EXTRA_RELATED_ID, config.relatedId)
                    }
                    val openPendingIntent = PendingIntent.getBroadcast(
                        context, (config.id + "_open").hashCode(), openIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )
                    builder.addAction(R.drawable.team, "View Task", openPendingIntent)
                }

                TYPE_STORAGE -> {
                    val storageIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                        action = ACTION_STORAGE_SETTINGS
                        putExtra(EXTRA_NOTIFICATION_ID, config.id)
                    }
                    val storagePendingIntent = PendingIntent.getBroadcast(
                        context, (config.id + "_storage").hashCode(), storageIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )
                    builder.addAction(R.drawable.ole_logo, "Storage Settings", storagePendingIntent)
                }

                TYPE_JOIN_REQUEST -> {
                    val openIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                        action = ACTION_OPEN_NOTIFICATION
                        putExtra(EXTRA_NOTIFICATION_TYPE, config.type)
                        putExtra(EXTRA_NOTIFICATION_ID, config.id)
                        putExtra(EXTRA_RELATED_ID, config.relatedId)
                    }
                    val openPendingIntent = PendingIntent.getBroadcast(
                        context, (config.id + "_open").hashCode(), openIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )
                    builder.addAction(R.drawable.business, "Review", openPendingIntent)
                }

                TYPE_RESOURCE -> {
                    val openIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                        action = ACTION_OPEN_NOTIFICATION
                        putExtra(EXTRA_NOTIFICATION_TYPE, config.type)
                        putExtra(EXTRA_NOTIFICATION_ID, config.id)
                        putExtra(EXTRA_RELATED_ID, config.relatedId)
                    }
                    val openPendingIntent = PendingIntent.getBroadcast(
                        context, (config.id + "_open").hashCode(), openIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )
                    builder.addAction(R.drawable.ourlibrary, "View Resource", openPendingIntent)
                }
            }
        }

        private fun createNotificationIntent(config: NotificationConfig): Intent {
            val targetClass = config.targetActivity ?: DashboardActivity::class.java
            return Intent(context, targetClass).apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                putExtra("notification_type", config.type)
                putExtra("notification_id", config.id)
                putExtra("from_notification", true)
                config.extras.forEach { (key, value) ->
                    putExtra(key, value)
                }
            }
        }

        private fun canShowNotification(type: String): Boolean {
            val notificationsEnabled = notificationManager.areNotificationsEnabled()

            if (!notificationsEnabled) {
                return false
            }

            val globalEnabled = preferences.getBoolean(KEY_ENABLED, true)

            if (!globalEnabled) {
                return false
            }

            val typeEnabled = when (type) {
                TYPE_SURVEY -> preferences.getBoolean(KEY_SURVEY_ENABLED, true)
                TYPE_TASK -> preferences.getBoolean(KEY_TASK_ENABLED, true)
                TYPE_STORAGE, TYPE_RESOURCE, TYPE_COURSE -> preferences.getBoolean(KEY_SYSTEM_ENABLED, true)
                TYPE_JOIN_REQUEST -> preferences.getBoolean(KEY_TEAM_ENABLED, true)
                else -> true
            }

            return typeEnabled
        }

        private fun getChannelForType(type: String): String {
            return when (type) {
                TYPE_SURVEY -> CHANNEL_SURVEYS
                TYPE_TASK -> CHANNEL_TASKS
                TYPE_STORAGE, TYPE_RESOURCE, TYPE_COURSE -> CHANNEL_SYSTEM
                TYPE_JOIN_REQUEST -> CHANNEL_TEAM
                else -> CHANNEL_GENERAL
            }
        }

        private fun getIconForType(type: String): Int {
            return when (type) {
                TYPE_SURVEY -> R.drawable.survey
                TYPE_TASK -> R.drawable.team
                TYPE_STORAGE -> android.R.drawable.stat_sys_warning
                TYPE_JOIN_REQUEST -> R.drawable.business
                TYPE_RESOURCE -> R.drawable.ourlibrary
                TYPE_COURSE -> R.drawable.ourcourses
                else -> R.drawable.ic_home
            }
        }

        private fun markNotificationAsShown(notificationId: String) {
            activeNotifications.add(notificationId)
            sessionShownNotifications.add(notificationId)
            saveActiveNotifications()
        }

        fun clearNotification(notificationId: String) {
            notificationManager.cancel(notificationId.hashCode())
            activeNotifications.remove(notificationId)
            saveActiveNotifications()
        }

        private fun loadActiveNotifications() {
            val saved = preferences.getStringSet(KEY_ACTIVE_NOTIFICATIONS, emptySet()) ?: emptySet()
            activeNotifications.addAll(saved)
        }

        private fun saveActiveNotifications() {
            preferences.edit { putStringSet(KEY_ACTIVE_NOTIFICATIONS, activeNotifications) }
        }

        fun createSurveyNotification(surveyId: String, surveyTitle: String): NotificationConfig {
            return NotificationConfig(
                id = surveyId,
                type = TYPE_SURVEY,
                title = " New Survey Available",
                message = surveyTitle,
                priority = NotificationCompat.PRIORITY_HIGH,
                category = NotificationCompat.CATEGORY_REMINDER,
                actionable = true,
                extras = mapOf("surveyId" to surveyId),
                relatedId = surveyId
            )
        }

        fun createTaskNotification(taskId: String, taskTitle: String, deadline: String): NotificationConfig {
            val priority = if (isTaskUrgent(deadline)) {
                NotificationCompat.PRIORITY_HIGH
            } else {
                NotificationCompat.PRIORITY_DEFAULT
            }

            return NotificationConfig(
                id = taskId,
                type = TYPE_TASK,
                title = " New Task Assigned",
                message = "$taskTitle\nDue: $deadline",
                priority = priority,
                category = NotificationCompat.CATEGORY_REMINDER,
                actionable = true,
                extras = mapOf("taskId" to taskId),
                relatedId = taskId
            )
        }

        fun createJoinRequestNotification(requestId: String, requesterName: String, teamName: String): NotificationConfig {
            return NotificationConfig(
                id = requestId,
                type = TYPE_JOIN_REQUEST,
                title = " Team Join Request",
                message = "$requesterName wants to join $teamName",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_SOCIAL,
                actionable = true,
                extras = mapOf("requestId" to requestId, "teamName" to teamName),
                relatedId = requestId
            )
        }

        fun createStorageWarningNotification(storagePercentage: Int, customId: String): NotificationConfig {
            val priority = if (storagePercentage > 95) {
                NotificationCompat.PRIORITY_HIGH
            } else {
                NotificationCompat.PRIORITY_DEFAULT
            }

            return NotificationConfig(
                id = customId,
                type = TYPE_STORAGE,
                title = " Storage Warning",
                message = "Device storage is at $storagePercentage%. Consider freeing up space.",
                priority = priority,
                category = NotificationCompat.CATEGORY_STATUS,
                actionable = true,
                relatedId = "storage"
            )
        }

        fun createResourceNotification(notificationId: String, resourceCount: Int): NotificationConfig {
            return NotificationConfig(
                id = notificationId,
                type = TYPE_RESOURCE,
                title = " New Resources Available",
                message = "$resourceCount new resources have been added",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_RECOMMENDATION,
                actionable = true,
                extras = mapOf("resourceCount" to resourceCount.toString()),
                relatedId = notificationId
            )
        }

        private fun isTaskUrgent(deadline: String): Boolean {
            return try {
                val deadlineTime = TimeUtils.parseDate(deadline) ?: return false
                val currentTime = System.currentTimeMillis()
                val timeDiff = deadlineTime - currentTime
                val daysUntilDeadline = timeDiff / (1000 * 60 * 60 * 24)
                daysUntilDeadline <= 2
            } catch (e: Exception) {
                e.printStackTrace()
                false
            }
        }
    }
}

@AndroidEntryPoint
class NotificationActionReceiver : BroadcastReceiver() {
    @Inject
    lateinit var notificationRepository: NotificationRepository
    override fun onReceive(context: Context, intent: Intent) {
        val pendingResult = goAsync()
        MainApplication.applicationScope.launch {
            try {
                val action = intent.action
                val notificationId = intent.getStringExtra(NotificationUtils.EXTRA_NOTIFICATION_ID)

                when (action) {
                    NotificationUtils.ACTION_MARK_AS_READ -> {
                        markNotificationAsRead(context, notificationId)
                        notificationId?.let {
                            NotificationUtils.getInstance(context).clearNotification(it)
                        }
                    }

                    NotificationUtils.ACTION_STORAGE_SETTINGS -> {
                        markNotificationAsRead(context, notificationId)
                        val storageIntent = Intent(Settings.ACTION_INTERNAL_STORAGE_SETTINGS).apply {
                            flags = Intent.FLAG_ACTIVITY_NEW_TASK
                        }
                        context.startActivity(storageIntent)
                        notificationId?.let {
                            NotificationUtils.getInstance(context).clearNotification(it)
                        }
                    }

                    NotificationUtils.ACTION_OPEN_NOTIFICATION -> {
                        markNotificationAsRead(context, notificationId)
                        val notificationType = intent.getStringExtra(NotificationUtils.EXTRA_NOTIFICATION_TYPE)
                        val relatedId = intent.getStringExtra(NotificationUtils.EXTRA_RELATED_ID)

                        val dashboardIntent = Intent(context, DashboardActivity::class.java).apply {
                            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
                            putExtra("notification_type", notificationType)
                            putExtra("notification_id", notificationId)
                            putExtra("related_id", relatedId)
                            putExtra("auto_navigate", true)
                        }
                        context.startActivity(dashboardIntent)
                        notificationId?.let {
                            NotificationUtils.getInstance(context).clearNotification(it)
                        }
                    }
                }
            } finally {
                pendingResult.finish()
            }
        }
    }

    private suspend fun markNotificationAsRead(context: Context, notificationId: String?) {
        if (notificationId == null) {
            return
        }

        try {
            withContext(Dispatchers.IO) {
                notificationRepository.markNotificationsAsRead(setOf(notificationId))
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }

        withContext(Dispatchers.Main) {
            delay(200)
            val broadcastIntent = Intent("org.ole.planet.myplanet.NOTIFICATION_READ_FROM_SYSTEM")
            broadcastIntent.setPackage(context.packageName)
            broadcastIntent.putExtra("notification_id", notificationId)
            context.sendBroadcast(broadcastIntent)

            try {
                val localBroadcastIntent = Intent("org.ole.planet.myplanet.NOTIFICATION_READ_FROM_SYSTEM_LOCAL")
                localBroadcastIntent.putExtra("notification_id", notificationId)
                val broadcastService = getBroadcastService(context)
                broadcastService.sendBroadcast(localBroadcastIntent)
            } catch (e: Exception) {
                e.printStackTrace()
            }

            try {
                val dashboardIntent = Intent(context, DashboardActivity::class.java)
                dashboardIntent.action = "REFRESH_NOTIFICATION_BADGE"
                dashboardIntent.putExtra("notification_id", notificationId)
                dashboardIntent.flags = Intent.FLAG_ACTIVITY_SINGLE_TOP or Intent.FLAG_ACTIVITY_NEW_TASK
                context.startActivity(dashboardIntent)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.app.NotificationChannel
import android.app.NotificationManager.IMPORTANCE_DEFAULT
import android.app.NotificationManager.IMPORTANCE_HIGH
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Build
import android.provider.Settings
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.repository.NotificationRepository
import org.ole.planet.myplanet.service.getBroadcastService
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity

object NotificationUtils {
    const val CHANNEL_GENERAL = "general_notifications"
    const val CHANNEL_SURVEYS = "survey_notifications"
    const val CHANNEL_TASKS = "task_notifications"
    const val CHANNEL_SYSTEM = "system_notifications"
    const val CHANNEL_TEAM = "team_notifications"
    const val TYPE_SURVEY = "survey"
    const val TYPE_TASK = "task"
    const val TYPE_STORAGE = "storage"
    const val TYPE_JOIN_REQUEST = "join_request"
    const val TYPE_RESOURCE = "resource"
    const val TYPE_COURSE = "course"
    private const val PREFS_NAME = "notification_preferences"
    private const val KEY_ENABLED = "notifications_enabled"
    private const val KEY_SURVEY_ENABLED = "survey_notifications_enabled"
    private const val KEY_TASK_ENABLED = "task_notifications_enabled"
    private const val KEY_SYSTEM_ENABLED = "system_notifications_enabled"
    private const val KEY_TEAM_ENABLED = "team_notifications_enabled"
    private const val KEY_ACTIVE_NOTIFICATIONS = "active_notifications"
    const val ACTION_MARK_AS_READ = "mark_as_read"
    const val ACTION_OPEN_NOTIFICATION = "open_notification"
    const val ACTION_STORAGE_SETTINGS = "storage_settings"
    const val EXTRA_NOTIFICATION_ID = "notification_id"
    const val EXTRA_NOTIFICATION_TYPE = "notification_type"
    const val EXTRA_RELATED_ID = "related_id"

    data class NotificationConfig(
        val id: String,
        val type: String,
        val title: String,
        val message: String,
        val priority: Int = NotificationCompat.PRIORITY_DEFAULT,
        val category: String = NotificationCompat.CATEGORY_MESSAGE,
        val actionable: Boolean = false,
        val bigTextStyle: Boolean = true,
        val autoCancel: Boolean = true,
        val silent: Boolean = false,
        val targetActivity: Class<*>? = null,
        val extras: Map<String, String> = emptyMap(),
        val relatedId: String? = null
    )

    @JvmStatic
    fun create(context: Context, smallIcon: Int, contentTitle: String?, contentText: String?) {
        val manager = context.getSystemService(Context.NOTIFICATION_SERVICE) as android.app.NotificationManager
        val a = NotificationCompat.Builder(context, "11")
        setChannel(manager)
        val notification = a.setContentTitle(contentTitle).setContentText(contentText).setSmallIcon(smallIcon)
            .setProgress(0, 0, true).setAutoCancel(true).build()
        manager.notify(111, notification)
    }

    @JvmStatic
    fun cancel(context: Context, id: Int) {
        val nm = NotificationManagerCompat.from(context)
        nm.cancel(id)
    }

    @JvmStatic
    fun cancelAll(context: Context) {
        val nm = NotificationManagerCompat.from(context)
        nm.cancelAll()
    }

    @JvmStatic
    fun setChannel(notificationManager: android.app.NotificationManager?) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val importance = android.app.NotificationManager.IMPORTANCE_LOW
            val notificationChannel = NotificationChannel("11", "ole", importance)
            notificationManager?.createNotificationChannel(notificationChannel)
        }
    }

    @JvmStatic
    fun getInstance(context: Context): NotificationManager {
        return NotificationManager(context)
    }

    class NotificationManager(private val context: Context) {
        private val notificationManager = NotificationManagerCompat.from(context)
        private val preferences: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        private val activeNotifications = mutableSetOf<String>()
        private val sessionShownNotifications = mutableSetOf<String>()

        init {
            loadActiveNotifications()
            createNotificationChannels()
        }

        private fun createNotificationChannels() {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                val channels = listOf(
                    NotificationChannel(CHANNEL_GENERAL, "General Notifications", IMPORTANCE_DEFAULT).apply {
                        description = "General app notifications"
                        enableLights(true)
                        enableVibration(true)
                    },

                    NotificationChannel(CHANNEL_SURVEYS, "Survey Notifications", IMPORTANCE_HIGH).apply {
                        description = "New surveys and survey reminders"
                        enableLights(true)
                        enableVibration(true)
                        setShowBadge(true)
                    },

                    NotificationChannel(CHANNEL_TASKS, "Task Notifications", IMPORTANCE_HIGH).apply {
                        description = "Task assignments and deadlines"
                        enableLights(true)
                        enableVibration(true)
                        setShowBadge(true)
                    },

                    NotificationChannel(CHANNEL_SYSTEM, "System Notifications", IMPORTANCE_DEFAULT).apply {
                        description = "Storage warnings and system updates"
                        enableLights(true)
                        enableVibration(false)
                    },

                    NotificationChannel(CHANNEL_TEAM, "Team Notifications", IMPORTANCE_DEFAULT).apply {
                        description = "Team join requests and team updates"
                        enableLights(true)
                        enableVibration(true)
                    }
                )

                val systemNotificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as android.app.NotificationManager
                channels.forEach { channel ->
                    systemNotificationManager.createNotificationChannel(channel)
                }
            }
        }

        fun showNotification(config: NotificationConfig): Boolean {
            if (!canShowNotification(config.type)) {
                return false
            }

            if (sessionShownNotifications.contains(config.id)) {
                return false
            }

            val notificationId = config.id.hashCode()
            val activeNotifications = notificationManager.activeNotifications
            val isAlreadyShowing = activeNotifications.any { it.id == notificationId }

            if (isAlreadyShowing) {
                return false
            }

            try {
                val notification = buildNotification(config)
                notificationManager.notify(notificationId, notification)
                markNotificationAsShown(config.id)
                return true
            } catch (e: Exception) {
                e.printStackTrace()
                return false
            }
        }

        private fun buildNotification(config: NotificationConfig): android.app.Notification {
            val channelId = getChannelForType(config.type)
            val intent = createNotificationIntent(config)
            val pendingIntent = PendingIntent.getActivity(
                context,
                config.id.hashCode(),
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )

            val builder = NotificationCompat.Builder(context, channelId)
                .setSmallIcon(getIconForType(config.type))
                .setContentTitle(config.title)
                .setContentText(config.message)
                .setPriority(config.priority)
                .setCategory(config.category)
                .setContentIntent(pendingIntent)
                .setAutoCancel(config.autoCancel)
                .setWhen(System.currentTimeMillis())
                .setShowWhen(true)
                .setColor(ContextCompat.getColor(context, R.color.colorPrimary))

            if (!config.silent) {
                builder.setDefaults(NotificationCompat.DEFAULT_ALL)
            }

            if (config.bigTextStyle) {
                builder.setStyle(NotificationCompat.BigTextStyle().bigText(config.message))
            }

            if (config.actionable) {
                addNotificationActions(builder, config)
            }

            return builder.build()
        }

        private fun addNotificationActions(builder: NotificationCompat.Builder, config: NotificationConfig) {
            val markAsReadIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                action = ACTION_MARK_AS_READ
                putExtra(EXTRA_NOTIFICATION_ID, config.id)
            }
            val markAsReadPendingIntent = PendingIntent.getBroadcast(
                context, (config.id + "_mark_read").hashCode(), markAsReadIntent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            builder.addAction(R.drawable.ole_logo, "Mark as Read", markAsReadPendingIntent)

            when (config.type) {
                TYPE_SURVEY -> {
                    val openIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                        action = ACTION_OPEN_NOTIFICATION
                        putExtra(EXTRA_NOTIFICATION_TYPE, config.type)
                        putExtra(EXTRA_NOTIFICATION_ID, config.id)
                        putExtra(EXTRA_RELATED_ID, config.relatedId)
                    }
                    val openPendingIntent = PendingIntent.getBroadcast(
                        context, (config.id + "_open").hashCode(), openIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )
                    builder.addAction(R.drawable.survey, "Take Survey", openPendingIntent)
                }

                TYPE_TASK -> {
                    val openIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                        action = ACTION_OPEN_NOTIFICATION
                        putExtra(EXTRA_NOTIFICATION_TYPE, config.type)
                        putExtra(EXTRA_NOTIFICATION_ID, config.id)
                        putExtra(EXTRA_RELATED_ID, config.relatedId)
                    }
                    val openPendingIntent = PendingIntent.getBroadcast(
                        context, (config.id + "_open").hashCode(), openIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )
                    builder.addAction(R.drawable.team, "View Task", openPendingIntent)
                }

                TYPE_STORAGE -> {
                    val storageIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                        action = ACTION_STORAGE_SETTINGS
                        putExtra(EXTRA_NOTIFICATION_ID, config.id)
                    }
                    val storagePendingIntent = PendingIntent.getBroadcast(
                        context, (config.id + "_storage").hashCode(), storageIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )
                    builder.addAction(R.drawable.ole_logo, "Storage Settings", storagePendingIntent)
                }

                TYPE_JOIN_REQUEST -> {
                    val openIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                        action = ACTION_OPEN_NOTIFICATION
                        putExtra(EXTRA_NOTIFICATION_TYPE, config.type)
                        putExtra(EXTRA_NOTIFICATION_ID, config.id)
                        putExtra(EXTRA_RELATED_ID, config.relatedId)
                    }
                    val openPendingIntent = PendingIntent.getBroadcast(
                        context, (config.id + "_open").hashCode(), openIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )
                    builder.addAction(R.drawable.business, "Review", openPendingIntent)
                }

                TYPE_RESOURCE -> {
                    val openIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                        action = ACTION_OPEN_NOTIFICATION
                        putExtra(EXTRA_NOTIFICATION_TYPE, config.type)
                        putExtra(EXTRA_NOTIFICATION_ID, config.id)
                        putExtra(EXTRA_RELATED_ID, config.relatedId)
                    }
                    val openPendingIntent = PendingIntent.getBroadcast(
                        context, (config.id + "_open").hashCode(), openIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )
                    builder.addAction(R.drawable.ourlibrary, "View Resource", openPendingIntent)
                }
            }
        }

        private fun createNotificationIntent(config: NotificationConfig): Intent {
            val targetClass = config.targetActivity ?: DashboardActivity::class.java
            return Intent(context, targetClass).apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                putExtra("notification_type", config.type)
                putExtra("notification_id", config.id)
                putExtra("from_notification", true)
                config.extras.forEach { (key, value) ->
                    putExtra(key, value)
                }
            }
        }

        private fun canShowNotification(type: String): Boolean {
            val notificationsEnabled = notificationManager.areNotificationsEnabled()

            if (!notificationsEnabled) {
                return false
            }

            val globalEnabled = preferences.getBoolean(KEY_ENABLED, true)

            if (!globalEnabled) {
                return false
            }

            val typeEnabled = when (type) {
                TYPE_SURVEY -> preferences.getBoolean(KEY_SURVEY_ENABLED, true)
                TYPE_TASK -> preferences.getBoolean(KEY_TASK_ENABLED, true)
                TYPE_STORAGE, TYPE_RESOURCE, TYPE_COURSE -> preferences.getBoolean(KEY_SYSTEM_ENABLED, true)
                TYPE_JOIN_REQUEST -> preferences.getBoolean(KEY_TEAM_ENABLED, true)
                else -> true
            }

            return typeEnabled
        }

        private fun getChannelForType(type: String): String {
            return when (type) {
                TYPE_SURVEY -> CHANNEL_SURVEYS
                TYPE_TASK -> CHANNEL_TASKS
                TYPE_STORAGE, TYPE_RESOURCE, TYPE_COURSE -> CHANNEL_SYSTEM
                TYPE_JOIN_REQUEST -> CHANNEL_TEAM
                else -> CHANNEL_GENERAL
            }
        }

        private fun getIconForType(type: String): Int {
            return when (type) {
                TYPE_SURVEY -> R.drawable.survey
                TYPE_TASK -> R.drawable.team
                TYPE_STORAGE -> android.R.drawable.stat_sys_warning
                TYPE_JOIN_REQUEST -> R.drawable.business
                TYPE_RESOURCE -> R.drawable.ourlibrary
                TYPE_COURSE -> R.drawable.ourcourses
                else -> R.drawable.ic_home
            }
        }

        private fun markNotificationAsShown(notificationId: String) {
            activeNotifications.add(notificationId)
            sessionShownNotifications.add(notificationId)
            saveActiveNotifications()
        }

        fun clearNotification(notificationId: String) {
            notificationManager.cancel(notificationId.hashCode())
            activeNotifications.remove(notificationId)
            saveActiveNotifications()
        }

        private fun loadActiveNotifications() {
            val saved = preferences.getStringSet(KEY_ACTIVE_NOTIFICATIONS, emptySet()) ?: emptySet()
            activeNotifications.addAll(saved)
        }

        private fun saveActiveNotifications() {
            preferences.edit { putStringSet(KEY_ACTIVE_NOTIFICATIONS, activeNotifications) }
        }

        fun createSurveyNotification(surveyId: String, surveyTitle: String): NotificationConfig {
            return NotificationConfig(
                id = surveyId,
                type = TYPE_SURVEY,
                title = " New Survey Available",
                message = surveyTitle,
                priority = NotificationCompat.PRIORITY_HIGH,
                category = NotificationCompat.CATEGORY_REMINDER,
                actionable = true,
                extras = mapOf("surveyId" to surveyId),
                relatedId = surveyId
            )
        }

        fun createTaskNotification(taskId: String, taskTitle: String, deadline: String): NotificationConfig {
            val priority = if (isTaskUrgent(deadline)) {
                NotificationCompat.PRIORITY_HIGH
            } else {
                NotificationCompat.PRIORITY_DEFAULT
            }

            return NotificationConfig(
                id = taskId,
                type = TYPE_TASK,
                title = " New Task Assigned",
                message = "$taskTitle\nDue: $deadline",
                priority = priority,
                category = NotificationCompat.CATEGORY_REMINDER,
                actionable = true,
                extras = mapOf("taskId" to taskId),
                relatedId = taskId
            )
        }

        fun createJoinRequestNotification(requestId: String, requesterName: String, teamName: String): NotificationConfig {
            return NotificationConfig(
                id = requestId,
                type = TYPE_JOIN_REQUEST,
                title = " Team Join Request",
                message = "$requesterName wants to join $teamName",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_SOCIAL,
                actionable = true,
                extras = mapOf("requestId" to requestId, "teamName" to teamName),
                relatedId = requestId
            )
        }

        fun createStorageWarningNotification(storagePercentage: Int, customId: String): NotificationConfig {
            val priority = if (storagePercentage > 95) {
                NotificationCompat.PRIORITY_HIGH
            } else {
                NotificationCompat.PRIORITY_DEFAULT
            }

            return NotificationConfig(
                id = customId,
                type = TYPE_STORAGE,
                title = " Storage Warning",
                message = "Device storage is at $storagePercentage%. Consider freeing up space.",
                priority = priority,
                category = NotificationCompat.CATEGORY_STATUS,
                actionable = true,
                relatedId = "storage"
            )
        }

        fun createResourceNotification(notificationId: String, resourceCount: Int): NotificationConfig {
            return NotificationConfig(
                id = notificationId,
                type = TYPE_RESOURCE,
                title = " New Resources Available",
                message = "$resourceCount new resources have been added",
                priority = NotificationCompat.PRIORITY_DEFAULT,
                category = NotificationCompat.CATEGORY_RECOMMENDATION,
                actionable = true,
                extras = mapOf("resourceCount" to resourceCount.toString()),
                relatedId = notificationId
            )
        }

        private fun isTaskUrgent(deadline: String): Boolean {
            return try {
                val deadlineTime = TimeUtils.parseDate(deadline) ?: return false
                val currentTime = System.currentTimeMillis()
                val timeDiff = deadlineTime - currentTime
                val daysUntilDeadline = timeDiff / (1000 * 60 * 60 * 24)
                daysUntilDeadline <= 2
            } catch (e: Exception) {
                e.printStackTrace()
                false
            }
        }
    }
}

@AndroidEntryPoint
class NotificationActionReceiver : BroadcastReceiver() {
    @Inject
    lateinit var notificationRepository: NotificationRepository
    override fun onReceive(context: Context, intent: Intent) {
        val pendingResult = goAsync()
        MainApplication.applicationScope.launch {
            try {
                val action = intent.action
                val notificationId = intent.getStringExtra(NotificationUtils.EXTRA_NOTIFICATION_ID)

                when (action) {
                    NotificationUtils.ACTION_MARK_AS_READ -> {
                        markNotificationAsRead(context, notificationId)
                        notificationId?.let {
                            NotificationUtils.getInstance(context).clearNotification(it)
                        }
                    }

                    NotificationUtils.ACTION_STORAGE_SETTINGS -> {
                        markNotificationAsRead(context, notificationId)
                        val storageIntent = Intent(Settings.ACTION_INTERNAL_STORAGE_SETTINGS).apply {
                            flags = Intent.FLAG_ACTIVITY_NEW_TASK
                        }
                        context.startActivity(storageIntent)
                        notificationId?.let {
                            NotificationUtils.getInstance(context).clearNotification(it)
                        }
                    }

                    NotificationUtils.ACTION_OPEN_NOTIFICATION -> {
                        markNotificationAsRead(context, notificationId)
                        val notificationType = intent.getStringExtra(NotificationUtils.EXTRA_NOTIFICATION_TYPE)
                        val relatedId = intent.getStringExtra(NotificationUtils.EXTRA_RELATED_ID)

                        val dashboardIntent = Intent(context, DashboardActivity::class.java).apply {
                            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
                            putExtra("notification_type", notificationType)
                            putExtra("notification_id", notificationId)
                            putExtra("related_id", relatedId)
                            putExtra("auto_navigate", true)
                        }
                        context.startActivity(dashboardIntent)
                        notificationId?.let {
                            NotificationUtils.getInstance(context).clearNotification(it)
                        }
                    }
                }
            } finally {
                pendingResult.finish()
            }
        }
    }

    private suspend fun markNotificationAsRead(context: Context, notificationId: String?) {
        if (notificationId == null) {
            return
        }

        try {
            withContext(Dispatchers.IO) {
                notificationRepository.markNotificationsAsRead(setOf(notificationId))
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }

        withContext(Dispatchers.Main) {
            delay(200)
            val broadcastIntent = Intent("org.ole.planet.myplanet.NOTIFICATION_READ_FROM_SYSTEM")
            broadcastIntent.setPackage(context.packageName)
            broadcastIntent.putExtra("notification_id", notificationId)
            context.sendBroadcast(broadcastIntent)

            try {
                val localBroadcastIntent = Intent("org.ole.planet.myplanet.NOTIFICATION_READ_FROM_SYSTEM_LOCAL")
                localBroadcastIntent.putExtra("notification_id", notificationId)
                val broadcastService = getBroadcastService(context)
                broadcastService.sendBroadcast(localBroadcastIntent)
            } catch (e: Exception) {
                e.printStackTrace()
            }

            try {
                val dashboardIntent = Intent(context, DashboardActivity::class.java)
                dashboardIntent.action = "REFRESH_NOTIFICATION_BADGE"
                dashboardIntent.putExtra("notification_id", notificationId)
                dashboardIntent.flags = Intent.FLAG_ACTIVITY_SINGLE_TOP or Intent.FLAG_ACTIVITY_NEW_TASK
                context.startActivity(dashboardIntent)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/SharedPrefManager.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.content.SharedPreferences
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import org.ole.planet.myplanet.model.User
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

class SharedPrefManager @Inject constructor(@ApplicationContext context: Context) {
    private var privateMode = 0
    private var pref: SharedPreferences = context.getSharedPreferences(PREFS_NAME, privateMode)
    private var editor: SharedPreferences.Editor = pref.edit()
    private val gson = Gson()

    companion object {
        private const val SAVED_USERS = "savedUsers"
        private const val REPLIED_NEWS_ID = "repliedNewsId"
        const val MANUAL_CONFIG = "manualConfig"
        private const val SELECTED_TEAM_ID = "selectedTeamId"
        const val FIRST_LAUNCH = "firstLaunch"
        private const val TEAM_NAME = "teamName"
    }

    enum class SyncKey(val key: String) {
        CHAT_HISTORY("chat_history_synced"),
        TEAMS("teams_synced"),
        FEEDBACK("feedback_synced"),
        ACHIEVEMENTS("achievements_synced"),
        HEALTH("health_synced"),
        COURSES("courses_synced"),
        RESOURCES("resources_synced"),
        EXAMS("exams_synced")
    }

    fun getSavedUsers(): List<User> {
        val usersJson = pref.getString(SAVED_USERS, null)
        return if (usersJson != null) {
            val type = object : TypeToken<List<User>>() {}.type
            gson.fromJson(usersJson, type)
        } else {
            emptyList()
        }
    }

    fun setSavedUsers(users: List<User>) {
        editor.putString(SAVED_USERS, gson.toJson(users))
        editor.apply()
    }

    fun setRepliedNewsId(repliedNewsId: String?) {
        editor.putString(REPLIED_NEWS_ID, repliedNewsId)
        editor.apply()
    }

    fun getManualConfig(): Boolean {
        return pref.getBoolean(MANUAL_CONFIG, false)
    }

    fun setManualConfig(manualConfig: Boolean) {
        editor.putBoolean(MANUAL_CONFIG, manualConfig)
        editor.apply()
    }

    fun getSelectedTeamId(): String? {
        return if (pref.getString(SELECTED_TEAM_ID, "") != "") pref.getString(
            SELECTED_TEAM_ID, "") else ""
    }

    fun setSelectedTeamId(selectedTeamId: String?) {
        editor.putString(SELECTED_TEAM_ID, selectedTeamId)
        editor.apply()
    }

    fun getFirstLaunch(): Boolean {
        return pref.getBoolean(FIRST_LAUNCH, false)
    }

    fun setFirstLaunch(firstLaunch: Boolean) {
        editor.putBoolean(FIRST_LAUNCH, firstLaunch)
        editor.apply()
    }

    fun getTeamName(): String? {
        return if (pref.getString(TEAM_NAME, "") != "") {
            pref.getString(TEAM_NAME, "")
        } else {
            ""
        }
    }

    fun setTeamName(teamName: String?) {
        editor.putString(TEAM_NAME, teamName)
        editor.apply()
    }

    private fun isSynced(key: SyncKey): Boolean {
        return pref.getBoolean(key.key, false)
    }

    private fun setSynced(key: SyncKey, synced: Boolean) {
        editor.putBoolean(key.key, synced)
        if (synced) {
            editor.putLong("${key.key}_time", System.currentTimeMillis())
        }
        editor.apply()
    }

    fun isChatHistorySynced(): Boolean = isSynced(SyncKey.CHAT_HISTORY)

    fun setChatHistorySynced(synced: Boolean) = setSynced(SyncKey.CHAT_HISTORY, synced)

    fun isTeamsSynced(): Boolean = isSynced(SyncKey.TEAMS)

    fun setTeamsSynced(synced: Boolean) = setSynced(SyncKey.TEAMS, synced)

    fun isFeedbackSynced(): Boolean = isSynced(SyncKey.FEEDBACK)

    fun setFeedbackSynced(synced: Boolean) = setSynced(SyncKey.FEEDBACK, synced)

    fun isAchievementsSynced(): Boolean = isSynced(SyncKey.ACHIEVEMENTS)

    fun setAchievementsSynced(synced: Boolean) = setSynced(SyncKey.ACHIEVEMENTS, synced)

    fun isHealthSynced(): Boolean = isSynced(SyncKey.HEALTH)

    fun setHealthSynced(synced: Boolean) = setSynced(SyncKey.HEALTH, synced)

    fun isCoursesSynced(): Boolean = isSynced(SyncKey.COURSES)

    fun setCoursesSynced(synced: Boolean) = setSynced(SyncKey.COURSES, synced)

    fun isResourcesSynced(): Boolean = isSynced(SyncKey.RESOURCES)

    fun setResourcesSynced(synced: Boolean) = setSynced(SyncKey.RESOURCES, synced)

    fun isExamsSynced(): Boolean = isSynced(SyncKey.EXAMS)

    fun setExamsSynced(synced: Boolean) = setSynced(SyncKey.EXAMS, synced)
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.content.SharedPreferences
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import org.ole.planet.myplanet.model.User
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

class SharedPrefManager @Inject constructor(@ApplicationContext context: Context) {
    private var privateMode = 0
    private var pref: SharedPreferences = context.getSharedPreferences(PREFS_NAME, privateMode)
    private var editor: SharedPreferences.Editor = pref.edit()
    private val gson = Gson()

    companion object {
        private const val SAVED_USERS = "savedUsers"
        private const val REPLIED_NEWS_ID = "repliedNewsId"
        const val MANUAL_CONFIG = "manualConfig"
        private const val SELECTED_TEAM_ID = "selectedTeamId"
        const val FIRST_LAUNCH = "firstLaunch"
        private const val TEAM_NAME = "teamName"
    }

    enum class SyncKey(val key: String) {
        CHAT_HISTORY("chat_history_synced"),
        TEAMS("teams_synced"),
        FEEDBACK("feedback_synced"),
        ACHIEVEMENTS("achievements_synced"),
        HEALTH("health_synced"),
        COURSES("courses_synced"),
        RESOURCES("resources_synced"),
        EXAMS("exams_synced")
    }

    fun getSavedUsers(): List<User> {
        val usersJson = pref.getString(SAVED_USERS, null)
        return if (usersJson != null) {
            val type = object : TypeToken<List<User>>() {}.type
            gson.fromJson(usersJson, type)
        } else {
            emptyList()
        }
    }

    fun setSavedUsers(users: List<User>) {
        editor.putString(SAVED_USERS, gson.toJson(users))
        editor.apply()
    }

    fun setRepliedNewsId(repliedNewsId: String?) {
        editor.putString(REPLIED_NEWS_ID, repliedNewsId)
        editor.apply()
    }

    fun getManualConfig(): Boolean {
        return pref.getBoolean(MANUAL_CONFIG, false)
    }

    fun setManualConfig(manualConfig: Boolean) {
        editor.putBoolean(MANUAL_CONFIG, manualConfig)
        editor.apply()
    }

    fun getSelectedTeamId(): String? {
        return if (pref.getString(SELECTED_TEAM_ID, "") != "") pref.getString(
            SELECTED_TEAM_ID, "") else ""
    }

    fun setSelectedTeamId(selectedTeamId: String?) {
        editor.putString(SELECTED_TEAM_ID, selectedTeamId)
        editor.apply()
    }

    fun getFirstLaunch(): Boolean {
        return pref.getBoolean(FIRST_LAUNCH, false)
    }

    fun setFirstLaunch(firstLaunch: Boolean) {
        editor.putBoolean(FIRST_LAUNCH, firstLaunch)
        editor.apply()
    }

    fun getTeamName(): String? {
        return if (pref.getString(TEAM_NAME, "") != "") {
            pref.getString(TEAM_NAME, "")
        } else {
            ""
        }
    }

    fun setTeamName(teamName: String?) {
        editor.putString(TEAM_NAME, teamName)
        editor.apply()
    }

    private fun isSynced(key: SyncKey): Boolean {
        return pref.getBoolean(key.key, false)
    }

    private fun setSynced(key: SyncKey, synced: Boolean) {
        editor.putBoolean(key.key, synced)
        if (synced) {
            editor.putLong("${key.key}_time", System.currentTimeMillis())
        }
        editor.apply()
    }

    fun isChatHistorySynced(): Boolean = isSynced(SyncKey.CHAT_HISTORY)

    fun setChatHistorySynced(synced: Boolean) = setSynced(SyncKey.CHAT_HISTORY, synced)

    fun isTeamsSynced(): Boolean = isSynced(SyncKey.TEAMS)

    fun setTeamsSynced(synced: Boolean) = setSynced(SyncKey.TEAMS, synced)

    fun isFeedbackSynced(): Boolean = isSynced(SyncKey.FEEDBACK)

    fun setFeedbackSynced(synced: Boolean) = setSynced(SyncKey.FEEDBACK, synced)

    fun isAchievementsSynced(): Boolean = isSynced(SyncKey.ACHIEVEMENTS)

    fun setAchievementsSynced(synced: Boolean) = setSynced(SyncKey.ACHIEVEMENTS, synced)

    fun isHealthSynced(): Boolean = isSynced(SyncKey.HEALTH)

    fun setHealthSynced(synced: Boolean) = setSynced(SyncKey.HEALTH, synced)

    fun isCoursesSynced(): Boolean = isSynced(SyncKey.COURSES)

    fun setCoursesSynced(synced: Boolean) = setSynced(SyncKey.COURSES, synced)

    fun isResourcesSynced(): Boolean = isSynced(SyncKey.RESOURCES)

    fun setResourcesSynced(synced: Boolean) = setSynced(SyncKey.RESOURCES, synced)

    fun isExamsSynced(): Boolean = isSynced(SyncKey.EXAMS)

    fun setExamsSynced(synced: Boolean) = setSynced(SyncKey.EXAMS, synced)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/ServerConfigUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.ServerAddressesModel

object ServerConfigUtils {
    fun getServerAddresses(context: Context): List<ServerAddressesModel> {
        return listOf(
            ServerAddressesModel(context.getString(R.string.sync_planet_learning), BuildConfig.PLANET_LEARNING_URL),
            ServerAddressesModel(context.getString(R.string.sync_guatemala), BuildConfig.PLANET_GUATEMALA_URL),
            ServerAddressesModel(context.getString(R.string.sync_san_pablo), BuildConfig.PLANET_SANPABLO_URL),
            ServerAddressesModel(context.getString(R.string.sync_planet_earth), BuildConfig.PLANET_EARTH_URL),
            ServerAddressesModel(context.getString(R.string.sync_somalia), BuildConfig.PLANET_SOMALIA_URL),
            ServerAddressesModel(context.getString(R.string.sync_vi), BuildConfig.PLANET_VI_URL),
            ServerAddressesModel(context.getString(R.string.sync_xela), BuildConfig.PLANET_XELA_URL),
            ServerAddressesModel(context.getString(R.string.sync_uriur), BuildConfig.PLANET_URIUR_URL),
            ServerAddressesModel(context.getString(R.string.sync_ruiru), BuildConfig.PLANET_RUIRU_URL),
            ServerAddressesModel(context.getString(R.string.sync_embakasi), BuildConfig.PLANET_EMBAKASI_URL),
            ServerAddressesModel(context.getString(R.string.sync_cambridge), BuildConfig.PLANET_CAMBRIDGE_URL),
        )
    }

    fun getFilteredList(
        showAdditionalServers: Boolean,
        serverList: List<ServerAddressesModel>,
        pinnedUrl: String?
    ): List<ServerAddressesModel> {
        val pinnedServer = serverList.find { it.url == pinnedUrl }
        return if (showAdditionalServers) {
            serverList
        } else {
            val topThree = serverList.take(3).toMutableList()
            if (pinnedServer != null && !topThree.contains(pinnedServer)) {
                listOf(pinnedServer) + topThree
            } else {
                topThree
            }
        }
    }

    fun removeProtocol(url: String): String {
        return url.removePrefix("https://").removePrefix("http://")
    }

    fun getPinForUrl(url: String): String {
        val pinMap = mapOf(
            BuildConfig.PLANET_LEARNING_URL to BuildConfig.PLANET_LEARNING_PIN,
            BuildConfig.PLANET_GUATEMALA_URL to BuildConfig.PLANET_GUATEMALA_PIN,
            BuildConfig.PLANET_SANPABLO_URL to BuildConfig.PLANET_SANPABLO_PIN,
            BuildConfig.PLANET_EARTH_URL to BuildConfig.PLANET_EARTH_PIN,
            BuildConfig.PLANET_SOMALIA_URL to BuildConfig.PLANET_SOMALIA_PIN,
            BuildConfig.PLANET_VI_URL to BuildConfig.PLANET_VI_PIN,
            BuildConfig.PLANET_XELA_URL to BuildConfig.PLANET_XELA_PIN,
            BuildConfig.PLANET_URIUR_URL to BuildConfig.PLANET_URIUR_PIN,
            BuildConfig.PLANET_RUIRU_URL to BuildConfig.PLANET_RUIRU_PIN,
            BuildConfig.PLANET_EMBAKASI_URL to BuildConfig.PLANET_EMBAKASI_PIN,
            BuildConfig.PLANET_CAMBRIDGE_URL to BuildConfig.PLANET_CAMBRIDGE_PIN,
        )
        return pinMap[url] ?: ""
    }

    fun saveAlternativeUrl(
        url: String,
        password: String,
        settings: android.content.SharedPreferences,
        editor: android.content.SharedPreferences.Editor,
    ): String {
        val uri = android.net.Uri.parse(url)
        val (urlUser, urlPwd, couchdbURL) = if (url.contains("@")) {
            val userinfo = org.ole.planet.myplanet.ui.sync.ProcessUserDataActivity.getUserInfo(uri)
            Triple(userinfo[0], userinfo[1], url)
        } else {
            val user = "satellite"
            val dbUrl = "${uri.scheme}://$user:$password@${uri.host}:${if (uri.port == -1) (if (uri.scheme == "http") 80 else 443) else uri.port}"
            Triple(user, password, dbUrl)
        }

        editor.putString("serverPin", password)
        editor.putString("url_user", urlUser)
        editor.putString("url_pwd", urlPwd)
        editor.putString("url_Scheme", uri.scheme)
        editor.putString("url_Host", uri.host)
        editor.putString("alternativeUrl", url)
        editor.putString("processedAlternativeUrl", couchdbURL)
        editor.putBoolean("isAlternativeUrl", true)
        editor.apply()

        return couchdbURL
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.ServerAddressesModel

object ServerConfigUtils {
    fun getServerAddresses(context: Context): List<ServerAddressesModel> {
        return listOf(
            ServerAddressesModel(context.getString(R.string.sync_planet_learning), BuildConfig.PLANET_LEARNING_URL),
            ServerAddressesModel(context.getString(R.string.sync_guatemala), BuildConfig.PLANET_GUATEMALA_URL),
            ServerAddressesModel(context.getString(R.string.sync_san_pablo), BuildConfig.PLANET_SANPABLO_URL),
            ServerAddressesModel(context.getString(R.string.sync_planet_earth), BuildConfig.PLANET_EARTH_URL),
            ServerAddressesModel(context.getString(R.string.sync_somalia), BuildConfig.PLANET_SOMALIA_URL),
            ServerAddressesModel(context.getString(R.string.sync_vi), BuildConfig.PLANET_VI_URL),
            ServerAddressesModel(context.getString(R.string.sync_xela), BuildConfig.PLANET_XELA_URL),
            ServerAddressesModel(context.getString(R.string.sync_uriur), BuildConfig.PLANET_URIUR_URL),
            ServerAddressesModel(context.getString(R.string.sync_ruiru), BuildConfig.PLANET_RUIRU_URL),
            ServerAddressesModel(context.getString(R.string.sync_embakasi), BuildConfig.PLANET_EMBAKASI_URL),
            ServerAddressesModel(context.getString(R.string.sync_cambridge), BuildConfig.PLANET_CAMBRIDGE_URL),
        )
    }

    fun getFilteredList(
        showAdditionalServers: Boolean,
        serverList: List<ServerAddressesModel>,
        pinnedUrl: String?
    ): List<ServerAddressesModel> {
        val pinnedServer = serverList.find { it.url == pinnedUrl }
        return if (showAdditionalServers) {
            serverList
        } else {
            val topThree = serverList.take(3).toMutableList()
            if (pinnedServer != null && !topThree.contains(pinnedServer)) {
                listOf(pinnedServer) + topThree
            } else {
                topThree
            }
        }
    }

    fun removeProtocol(url: String): String {
        return url.removePrefix("https://").removePrefix("http://")
    }

    fun getPinForUrl(url: String): String {
        val pinMap = mapOf(
            BuildConfig.PLANET_LEARNING_URL to BuildConfig.PLANET_LEARNING_PIN,
            BuildConfig.PLANET_GUATEMALA_URL to BuildConfig.PLANET_GUATEMALA_PIN,
            BuildConfig.PLANET_SANPABLO_URL to BuildConfig.PLANET_SANPABLO_PIN,
            BuildConfig.PLANET_EARTH_URL to BuildConfig.PLANET_EARTH_PIN,
            BuildConfig.PLANET_SOMALIA_URL to BuildConfig.PLANET_SOMALIA_PIN,
            BuildConfig.PLANET_VI_URL to BuildConfig.PLANET_VI_PIN,
            BuildConfig.PLANET_XELA_URL to BuildConfig.PLANET_XELA_PIN,
            BuildConfig.PLANET_URIUR_URL to BuildConfig.PLANET_URIUR_PIN,
            BuildConfig.PLANET_RUIRU_URL to BuildConfig.PLANET_RUIRU_PIN,
            BuildConfig.PLANET_EMBAKASI_URL to BuildConfig.PLANET_EMBAKASI_PIN,
            BuildConfig.PLANET_CAMBRIDGE_URL to BuildConfig.PLANET_CAMBRIDGE_PIN,
        )
        return pinMap[url] ?: ""
    }

    fun saveAlternativeUrl(
        url: String,
        password: String,
        settings: android.content.SharedPreferences,
        editor: android.content.SharedPreferences.Editor,
    ): String {
        val uri = android.net.Uri.parse(url)
        val (urlUser, urlPwd, couchdbURL) = if (url.contains("@")) {
            val userinfo = org.ole.planet.myplanet.ui.sync.ProcessUserDataActivity.getUserInfo(uri)
            Triple(userinfo[0], userinfo[1], url)
        } else {
            val user = "satellite"
            val dbUrl = "${uri.scheme}://$user:$password@${uri.host}:${if (uri.port == -1) (if (uri.scheme == "http") 80 else 443) else uri.port}"
            Triple(user, password, dbUrl)
        }

        editor.putString("serverPin", password)
        editor.putString("url_user", urlUser)
        editor.putString("url_pwd", urlPwd)
        editor.putString("url_Scheme", uri.scheme)
        editor.putString("url_Host", uri.host)
        editor.putString("alternativeUrl", url)
        editor.putString("processedAlternativeUrl", couchdbURL)
        editor.putBoolean("isAlternativeUrl", true)
        editor.apply()

        return couchdbURL
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/VersionUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.provider.Settings
import androidx.core.content.pm.PackageInfoCompat.getLongVersionCode

object VersionUtils {
    @JvmStatic
    fun getVersionCode(context: Context): Int {
        try {
            val pInfo = context.packageManager.getPackageInfo(context.packageName, 0)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                return getLongVersionCode(pInfo).toInt()
            } else {
                @Suppress("DEPRECATION")
                return pInfo.versionCode
            }
        } catch (e: PackageManager.NameNotFoundException) {
            e.printStackTrace()
        }
        return 0
    }

    @JvmStatic
    fun getVersionName(context: Context): String? {
        try {
            val pInfo = context.packageManager.getPackageInfo(context.packageName, 0)
            return pInfo.versionName
        } catch (e: PackageManager.NameNotFoundException) {
            e.printStackTrace()
        }
        return ""
    }

    @JvmStatic
    fun getAndroidId(context: Context): String {
        return Settings.Secure.getString(context.contentResolver, Settings.Secure.ANDROID_ID)
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.provider.Settings
import androidx.core.content.pm.PackageInfoCompat.getLongVersionCode

object VersionUtils {
    @JvmStatic
    fun getVersionCode(context: Context): Int {
        try {
            val pInfo = context.packageManager.getPackageInfo(context.packageName, 0)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                return getLongVersionCode(pInfo).toInt()
            } else {
                @Suppress("DEPRECATION")
                return pInfo.versionCode
            }
        } catch (e: PackageManager.NameNotFoundException) {
            e.printStackTrace()
        }
        return 0
    }

    @JvmStatic
    fun getVersionName(context: Context): String? {
        try {
            val pInfo = context.packageManager.getPackageInfo(context.packageName, 0)
            return pInfo.versionName
        } catch (e: PackageManager.NameNotFoundException) {
            e.printStackTrace()
        }
        return ""
    }

    @JvmStatic
    fun getAndroidId(context: Context): String {
        return Settings.Secure.getString(context.contentResolver, Settings.Secure.ANDROID_ID)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/NetworkUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothManager
import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.wifi.WifiInfo
import android.net.wifi.WifiManager
import android.os.Build
import android.provider.Settings
import androidx.core.net.toUri
import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.components.SingletonComponent
import java.util.Locale
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.di.ApplicationScope
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

object NetworkUtils {
    private val coroutineScope: CoroutineScope by lazy {
        val entryPoint = EntryPointAccessors.fromApplication(context, NetworkUtilsEntryPoint::class.java)
        entryPoint.applicationScope()
    }

    @EntryPoint
    @InstallIn(SingletonComponent::class)
    interface NetworkUtilsEntryPoint {
        @ApplicationScope
        fun applicationScope(): CoroutineScope
    }

    private val connectivityManager: ConnectivityManager by lazy {
        context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
    }

    private val _currentNetwork = MutableStateFlow(provideDefaultCurrentNetwork())

    val isNetworkConnectedFlow: StateFlow<Boolean> by lazy {
        _currentNetwork
            .map { it.isConnected() }
            .stateIn(scope = coroutineScope, started = SharingStarted.WhileSubscribed(), initialValue = _currentNetwork.value.isConnected())
    }

    val isNetworkConnected: Boolean
        get() = isNetworkConnectedFlow.value

    private val networkCallback = NetworkCallback()

    fun startListenNetworkState() {
        if (_currentNetwork.value.isListening) {
            return
        }

        _currentNetwork.update {
            provideDefaultCurrentNetwork().copy(isListening = true)
        }

        connectivityManager.registerDefaultNetworkCallback(networkCallback)
    }

    fun stopListenNetworkState() {
        if (!_currentNetwork.value.isListening) {
            return
        }

        connectivityManager.unregisterNetworkCallback(networkCallback)
        _currentNetwork.update { provideDefaultCurrentNetwork() }
    }

    private class NetworkCallback : ConnectivityManager.NetworkCallback() {
        override fun onAvailable(network: Network) {
            _currentNetwork.update {
                it.copy(isAvailable = true)
            }
        }

        override fun onLost(network: Network) {
            _currentNetwork.update {
                it.copy(isAvailable = false, networkCapabilities = null)
            }
        }

        override fun onUnavailable() {
            _currentNetwork.update {
                it.copy(isAvailable = false, networkCapabilities = null)
            }
        }

        override fun onCapabilitiesChanged(network: Network, networkCapabilities: NetworkCapabilities) {
            _currentNetwork.update {
                it.copy(networkCapabilities = networkCapabilities)
            }
        }

        override fun onBlockedStatusChanged(network: Network, blocked: Boolean) {
            _currentNetwork.update {
                it.copy(isBlocked = blocked)
            }
        }
    }

    private fun provideDefaultCurrentNetwork(): CurrentNetwork {
        return CurrentNetwork(isListening = false, networkCapabilities = null, isAvailable = false, isBlocked = false)
    }

    private data class CurrentNetwork(val isListening: Boolean, val networkCapabilities: NetworkCapabilities?, val isAvailable: Boolean, val isBlocked: Boolean)

    private fun CurrentNetwork.isConnected(): Boolean {
        return isListening && isAvailable && !isBlocked && networkCapabilities.isNetworkCapabilitiesValid()
    }

    private fun NetworkCapabilities?.isNetworkCapabilitiesValid(): Boolean = when {
        this == null -> false
        hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) && hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED) && (hasTransport(NetworkCapabilities.TRANSPORT_WIFI) || hasTransport(NetworkCapabilities.TRANSPORT_VPN) || hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) || hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)) -> true
        else -> false
    }

    fun isWifiEnabled(): Boolean {
        val wifiManager = context.applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
        return wifiManager.isWifiEnabled
    }

    fun isWifiConnected(): Boolean {
        val network = connectivityManager.activeNetwork
        val capabilities = connectivityManager.getNetworkCapabilities(network)
        return capabilities != null && capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)
    }

    fun isWifiBluetoothEnabled(): Boolean {
        return isBluetoothEnabled() || isWifiEnabled()
    }

    fun isBluetoothEnabled(): Boolean {
        val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
        val adapter: BluetoothAdapter? = bluetoothManager.adapter
        return adapter != null && adapter.isEnabled
    }

    fun getCurrentNetworkId(context: Context): Int {
        var ssid = -1
        val connManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = connManager.activeNetwork
        val capabilities = connManager.getNetworkCapabilities(network)
        if (capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) == true) {
            val wifiManager = context.applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager?
            val connectionInfo: WifiInfo? = wifiManager?.connectionInfo
            if (!connectionInfo?.ssid.isNullOrEmpty()) {
                ssid = connectionInfo.networkId
            }
        }
        return ssid
    }

    fun getUniqueIdentifier(): String {
        val androidId = Settings.Secure.getString(context.contentResolver, Settings.Secure.ANDROID_ID)
        val buildId = Build.ID
        return androidId + "_" + buildId
    }

    fun getDeviceName(): String {
        val manufacturer = Build.MANUFACTURER
        val model = Build.MODEL
        return if (model.startsWith(manufacturer)) {
            model.uppercase(Locale.ROOT)
        } else {
            "$manufacturer $model".uppercase(Locale.ROOT)
        }
    }

    fun getCustomDeviceName(context: Context): String {
        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            .getString("customDeviceName", "") ?: ""
    }

    fun extractProtocol(url: String): String? {
        val uri = url.toUri()
        val scheme = uri.scheme
        return if (scheme != null) "$scheme://" else null
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothManager
import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.wifi.WifiInfo
import android.net.wifi.WifiManager
import android.os.Build
import android.provider.Settings
import androidx.core.net.toUri
import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.components.SingletonComponent
import java.util.Locale
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.di.ApplicationScope
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

object NetworkUtils {
    private val coroutineScope: CoroutineScope by lazy {
        val entryPoint = EntryPointAccessors.fromApplication(context, NetworkUtilsEntryPoint::class.java)
        entryPoint.applicationScope()
    }

    @EntryPoint
    @InstallIn(SingletonComponent::class)
    interface NetworkUtilsEntryPoint {
        @ApplicationScope
        fun applicationScope(): CoroutineScope
    }

    private val connectivityManager: ConnectivityManager by lazy {
        context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
    }

    private val _currentNetwork = MutableStateFlow(provideDefaultCurrentNetwork())

    val isNetworkConnectedFlow: StateFlow<Boolean> by lazy {
        _currentNetwork
            .map { it.isConnected() }
            .stateIn(scope = coroutineScope, started = SharingStarted.WhileSubscribed(), initialValue = _currentNetwork.value.isConnected())
    }

    val isNetworkConnected: Boolean
        get() = isNetworkConnectedFlow.value

    private val networkCallback = NetworkCallback()

    fun startListenNetworkState() {
        if (_currentNetwork.value.isListening) {
            return
        }

        _currentNetwork.update {
            provideDefaultCurrentNetwork().copy(isListening = true)
        }

        connectivityManager.registerDefaultNetworkCallback(networkCallback)
    }

    fun stopListenNetworkState() {
        if (!_currentNetwork.value.isListening) {
            return
        }

        connectivityManager.unregisterNetworkCallback(networkCallback)
        _currentNetwork.update { provideDefaultCurrentNetwork() }
    }

    private class NetworkCallback : ConnectivityManager.NetworkCallback() {
        override fun onAvailable(network: Network) {
            _currentNetwork.update {
                it.copy(isAvailable = true)
            }
        }

        override fun onLost(network: Network) {
            _currentNetwork.update {
                it.copy(isAvailable = false, networkCapabilities = null)
            }
        }

        override fun onUnavailable() {
            _currentNetwork.update {
                it.copy(isAvailable = false, networkCapabilities = null)
            }
        }

        override fun onCapabilitiesChanged(network: Network, networkCapabilities: NetworkCapabilities) {
            _currentNetwork.update {
                it.copy(networkCapabilities = networkCapabilities)
            }
        }

        override fun onBlockedStatusChanged(network: Network, blocked: Boolean) {
            _currentNetwork.update {
                it.copy(isBlocked = blocked)
            }
        }
    }

    private fun provideDefaultCurrentNetwork(): CurrentNetwork {
        return CurrentNetwork(isListening = false, networkCapabilities = null, isAvailable = false, isBlocked = false)
    }

    private data class CurrentNetwork(val isListening: Boolean, val networkCapabilities: NetworkCapabilities?, val isAvailable: Boolean, val isBlocked: Boolean)

    private fun CurrentNetwork.isConnected(): Boolean {
        return isListening && isAvailable && !isBlocked && networkCapabilities.isNetworkCapabilitiesValid()
    }

    private fun NetworkCapabilities?.isNetworkCapabilitiesValid(): Boolean = when {
        this == null -> false
        hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) && hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED) && (hasTransport(NetworkCapabilities.TRANSPORT_WIFI) || hasTransport(NetworkCapabilities.TRANSPORT_VPN) || hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) || hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)) -> true
        else -> false
    }

    fun isWifiEnabled(): Boolean {
        val wifiManager = context.applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
        return wifiManager.isWifiEnabled
    }

    fun isWifiConnected(): Boolean {
        val network = connectivityManager.activeNetwork
        val capabilities = connectivityManager.getNetworkCapabilities(network)
        return capabilities != null && capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)
    }

    fun isWifiBluetoothEnabled(): Boolean {
        return isBluetoothEnabled() || isWifiEnabled()
    }

    fun isBluetoothEnabled(): Boolean {
        val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
        val adapter: BluetoothAdapter? = bluetoothManager.adapter
        return adapter != null && adapter.isEnabled
    }

    fun getCurrentNetworkId(context: Context): Int {
        var ssid = -1
        val connManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = connManager.activeNetwork
        val capabilities = connManager.getNetworkCapabilities(network)
        if (capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) == true) {
            val wifiManager = context.applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager?
            val connectionInfo: WifiInfo? = wifiManager?.connectionInfo
            if (!connectionInfo?.ssid.isNullOrEmpty()) {
                ssid = connectionInfo.networkId
            }
        }
        return ssid
    }

    fun getUniqueIdentifier(): String {
        val androidId = Settings.Secure.getString(context.contentResolver, Settings.Secure.ANDROID_ID)
        val buildId = Build.ID
        return androidId + "_" + buildId
    }

    fun getDeviceName(): String {
        val manufacturer = Build.MANUFACTURER
        val model = Build.MODEL
        return if (model.startsWith(manufacturer)) {
            model.uppercase(Locale.ROOT)
        } else {
            "$manufacturer $model".uppercase(Locale.ROOT)
        }
    }

    fun getCustomDeviceName(context: Context): String {
        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            .getString("customDeviceName", "") ?: ""
    }

    fun extractProtocol(url: String): String? {
        val uri = url.toUri()
        val scheme = uri.scheme
        return if (scheme != null) "$scheme://" else null
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/LocaleHelper.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.content.res.Configuration
import androidx.core.content.edit
import androidx.preference.PreferenceManager
import java.util.Locale

object LocaleHelper {
    private const val SELECTED_LANGUAGE = "Locale.Helper.Selected.Language"

    fun onAttach(context: Context): Context {
        val lang = getPersistedData(context, Locale.getDefault().language)
        return setLocale(context, lang)
    }

    fun getLanguage(context: Context): String {
        return getPersistedData(context, Locale.getDefault().language)
    }

    fun setLocale(context: Context, language: String): Context {
        persist(context, language)

        val locale = Locale(language)
        Locale.setDefault(locale)

        val res = context.resources
        val configuration = Configuration(res.configuration)
        configuration.setLocale(locale)
        configuration.setLayoutDirection(locale)

        return context.createConfigurationContext(configuration)
    }

    private fun getPersistedData(context: Context, defaultLanguage: String): String {
        val preferences = PreferenceManager.getDefaultSharedPreferences(context)
        return preferences.getString(SELECTED_LANGUAGE, defaultLanguage) ?: defaultLanguage
    }

    private fun persist(context: Context, language: String) {
        val preferences = PreferenceManager.getDefaultSharedPreferences(context)
        preferences.edit { putString(SELECTED_LANGUAGE, language) }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.content.res.Configuration
import androidx.core.content.edit
import androidx.preference.PreferenceManager
import java.util.Locale

object LocaleHelper {
    private const val SELECTED_LANGUAGE = "Locale.Helper.Selected.Language"

    fun onAttach(context: Context): Context {
        val lang = getPersistedData(context, Locale.getDefault().language)
        return setLocale(context, lang)
    }

    fun getLanguage(context: Context): String {
        return getPersistedData(context, Locale.getDefault().language)
    }

    fun setLocale(context: Context, language: String): Context {
        persist(context, language)

        val locale = Locale(language)
        Locale.setDefault(locale)

        val res = context.resources
        val configuration = Configuration(res.configuration)
        configuration.setLocale(locale)
        configuration.setLayoutDirection(locale)

        return context.createConfigurationContext(configuration)
    }

    private fun getPersistedData(context: Context, defaultLanguage: String): String {
        val preferences = PreferenceManager.getDefaultSharedPreferences(context)
        return preferences.getString(SELECTED_LANGUAGE, defaultLanguage) ?: defaultLanguage
    }

    private fun persist(context: Context, language: String) {
        val preferences = PreferenceManager.getDefaultSharedPreferences(context)
        preferences.edit { putString(SELECTED_LANGUAGE, language) }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/UrlUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.content.SharedPreferences
import android.util.Base64
import androidx.core.net.toUri
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

object UrlUtils {
    val header: String
        get() {
            val settings = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            val credentials = "${settings.getString("url_user", "")}:${settings.getString("url_pwd", "")}".toByteArray()
            return "Basic ${Base64.encodeToString(credentials, Base64.NO_WRAP)}"
        }

    val hostUrl: String
        get() {
            val settings = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            var scheme = settings.getString("url_Scheme", "")
            var hostIp = settings.getString("url_Host", "")
            val isAlternativeUrl = settings.getBoolean("isAlternativeUrl", false)
            val alternativeUrl = settings.getString("processedAlternativeUrl", "")

            if (isAlternativeUrl && !alternativeUrl.isNullOrEmpty()) {
                try {
                    val uri = alternativeUrl.toUri()
                    hostIp = uri.host ?: hostIp
                    scheme = uri.scheme ?: scheme
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }

            return if (hostIp?.endsWith(".org") == true || hostIp?.endsWith(".gt") == true) {
                "$scheme://$hostIp/ml/"
            } else {
                "$scheme://$hostIp:5000/"
            }
        }
    fun baseUrl(settings: SharedPreferences): String {
        var url = if (settings.getBoolean("isAlternativeUrl", false)) {
            settings.getString("processedAlternativeUrl", "")
        } else {
            settings.getString("couchdbURL", "")
        }
        if (url != null && url.endsWith("/db")) {
            url = url.removeSuffix("/db")
        }
        return url ?: ""
    }

    fun dbUrl(settings: SharedPreferences): String {
        val base = baseUrl(settings)
        return if (base.endsWith("/db")) base else "$base/db"
    }

    fun dbUrl(url: String): String {
        return if (url.endsWith("/db")) url else "$url/db"
    }

    fun getUrl(library: RealmMyLibrary?): String {
        return getUrl(library?.resourceId, library?.resourceLocalAddress)
    }

    fun getUrl(id: String?, file: String?): String {
        return "${getUrl()}/resources/$id/$file"
    }

    fun getUserImageUrl(userId: String?, imageName: String): String {
        return "${getUrl()}/_users/$userId/$imageName"
    }

    fun getUrl(): String {
        val settings = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        return dbUrl(settings)
    }

    fun getUpdateUrl(settings: SharedPreferences): String {
        val url = baseUrl(settings)
        return "$url/versions"
    }

    fun getChecksumUrl(settings: SharedPreferences): String {
        val url = baseUrl(settings)
        return "$url/fs/myPlanet.apk.sha256"
    }

    fun getHealthAccessUrl(settings: SharedPreferences): String {
        val url = baseUrl(settings)
        return String.format("%s/healthaccess?p=%s", url, settings.getString("serverPin", "0000"))
    }

    fun getApkVersionUrl(settings: SharedPreferences): String {
        val url = baseUrl(settings)
        return "$url/apkversion"
    }

    fun getApkUpdateUrl(path: String?): String {
        val preferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val url = baseUrl(preferences)
        return "$url$path"
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.content.SharedPreferences
import android.util.Base64
import androidx.core.net.toUri
import org.ole.planet.myplanet.MainApplication.Companion.context
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME

object UrlUtils {
    val header: String
        get() {
            val settings = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            val credentials = "${settings.getString("url_user", "")}:${settings.getString("url_pwd", "")}".toByteArray()
            return "Basic ${Base64.encodeToString(credentials, Base64.NO_WRAP)}"
        }

    val hostUrl: String
        get() {
            val settings = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
            var scheme = settings.getString("url_Scheme", "")
            var hostIp = settings.getString("url_Host", "")
            val isAlternativeUrl = settings.getBoolean("isAlternativeUrl", false)
            val alternativeUrl = settings.getString("processedAlternativeUrl", "")

            if (isAlternativeUrl && !alternativeUrl.isNullOrEmpty()) {
                try {
                    val uri = alternativeUrl.toUri()
                    hostIp = uri.host ?: hostIp
                    scheme = uri.scheme ?: scheme
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }

            return if (hostIp?.endsWith(".org") == true || hostIp?.endsWith(".gt") == true) {
                "$scheme://$hostIp/ml/"
            } else {
                "$scheme://$hostIp:5000/"
            }
        }
    fun baseUrl(settings: SharedPreferences): String {
        var url = if (settings.getBoolean("isAlternativeUrl", false)) {
            settings.getString("processedAlternativeUrl", "")
        } else {
            settings.getString("couchdbURL", "")
        }
        if (url != null && url.endsWith("/db")) {
            url = url.removeSuffix("/db")
        }
        return url ?: ""
    }

    fun dbUrl(settings: SharedPreferences): String {
        val base = baseUrl(settings)
        return if (base.endsWith("/db")) base else "$base/db"
    }

    fun dbUrl(url: String): String {
        return if (url.endsWith("/db")) url else "$url/db"
    }

    fun getUrl(library: RealmMyLibrary?): String {
        return getUrl(library?.resourceId, library?.resourceLocalAddress)
    }

    fun getUrl(id: String?, file: String?): String {
        return "${getUrl()}/resources/$id/$file"
    }

    fun getUserImageUrl(userId: String?, imageName: String): String {
        return "${getUrl()}/_users/$userId/$imageName"
    }

    fun getUrl(): String {
        val settings = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        return dbUrl(settings)
    }

    fun getUpdateUrl(settings: SharedPreferences): String {
        val url = baseUrl(settings)
        return "$url/versions"
    }

    fun getChecksumUrl(settings: SharedPreferences): String {
        val url = baseUrl(settings)
        return "$url/fs/myPlanet.apk.sha256"
    }

    fun getHealthAccessUrl(settings: SharedPreferences): String {
        val url = baseUrl(settings)
        return String.format("%s/healthaccess?p=%s", url, settings.getString("serverPin", "0000"))
    }

    fun getApkVersionUrl(settings: SharedPreferences): String {
        val url = baseUrl(settings)
        return "$url/apkversion"
    }

    fun getApkUpdateUrl(path: String?): String {
        val preferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val url = baseUrl(preferences)
        return "$url$path"
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/ANRWatchdog.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.os.Handler
import android.os.Looper
import android.os.SystemClock

class ANRWatchdog(private val timeout: Long = DEFAULT_ANR_TIMEOUT, private val listener: ANRListener? = null) {
    companion object {
        private const val DEFAULT_ANR_TIMEOUT = 5000L
    }

    private var isWatching = false
    private var tick = 0L
    private val mainHandler = Handler(Looper.getMainLooper())
    private val tickUpdater = Runnable { updateTick() }


    private fun updateTick() {
        tick = SystemClock.elapsedRealtime()
    }

    interface ANRListener {
        fun onAppNotResponding(message: String, blockedThread: Thread, duration: Long)
    }

    fun start() {
        if (isWatching) {
            return
        }

        isWatching = true
        tick = SystemClock.elapsedRealtime()
        mainHandler.post(tickUpdater)

        Thread({
            val threadName = Thread.currentThread().name
            Thread.currentThread().name = "ANRWatchdog"

            while (isWatching) {
                val lastTick = tick
                val currentTime = SystemClock.elapsedRealtime()
                mainHandler.post(tickUpdater)

                try {
                    Thread.sleep(timeout / 2)
                } catch (e: InterruptedException) {
                    e.printStackTrace()
                }

                if (isWatching && lastTick == tick) {
                    val duration = currentTime - lastTick
                    val mainThread = Looper.getMainLooper().thread

                    val message = StringBuilder("ANR detected on thread ")
                        .append(mainThread.name)
                        .append(" (")
                        .append(mainThread.id)
                        .append(")\n")

                    for (element in mainThread.stackTrace) {
                        message.append("\tat ").append(element.toString()).append('\n')
                    }

                    listener?.onAppNotResponding(message.toString(), mainThread, duration)
                    try {
                        Thread.sleep(timeout)
                    } catch (e: InterruptedException) {
                        e.printStackTrace()
                    }
                }
            }
            Thread.currentThread().name = threadName
        }, "ANRWatchdog").start()
    }

    fun stop() {
        isWatching = false
        mainHandler.removeCallbacks(tickUpdater)
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.os.Handler
import android.os.Looper
import android.os.SystemClock

class ANRWatchdog(private val timeout: Long = DEFAULT_ANR_TIMEOUT, private val listener: ANRListener? = null) {
    companion object {
        private const val DEFAULT_ANR_TIMEOUT = 5000L
    }

    private var isWatching = false
    private var tick = 0L
    private val mainHandler = Handler(Looper.getMainLooper())
    private val tickUpdater = Runnable { updateTick() }


    private fun updateTick() {
        tick = SystemClock.elapsedRealtime()
    }

    interface ANRListener {
        fun onAppNotResponding(message: String, blockedThread: Thread, duration: Long)
    }

    fun start() {
        if (isWatching) {
            return
        }

        isWatching = true
        tick = SystemClock.elapsedRealtime()
        mainHandler.post(tickUpdater)

        Thread({
            val threadName = Thread.currentThread().name
            Thread.currentThread().name = "ANRWatchdog"

            while (isWatching) {
                val lastTick = tick
                val currentTime = SystemClock.elapsedRealtime()
                mainHandler.post(tickUpdater)

                try {
                    Thread.sleep(timeout / 2)
                } catch (e: InterruptedException) {
                    e.printStackTrace()
                }

                if (isWatching && lastTick == tick) {
                    val duration = currentTime - lastTick
                    val mainThread = Looper.getMainLooper().thread

                    val message = StringBuilder("ANR detected on thread ")
                        .append(mainThread.name)
                        .append(" (")
                        .append(mainThread.id)
                        .append(")\n")

                    for (element in mainThread.stackTrace) {
                        message.append("\tat ").append(element.toString()).append('\n')
                    }

                    listener?.onAppNotResponding(message.toString(), mainThread, duration)
                    try {
                        Thread.sleep(timeout)
                    } catch (e: InterruptedException) {
                        e.printStackTrace()
                    }
                }
            }
            Thread.currentThread().name = threadName
        }, "ANRWatchdog").start()
    }

    fun stop() {
        isWatching = false
        mainHandler.removeCallbacks(tickUpdater)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/ImageUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.widget.ImageView
import com.bumptech.glide.Glide
import org.ole.planet.myplanet.R

object ImageUtils {
    fun loadImage(userImage: String?, imageView: ImageView) {
        if (!userImage.isNullOrEmpty()) {
            Glide.with(imageView.context)
                .load(userImage)
                .placeholder(R.drawable.profile)
                .error(R.drawable.profile)
                .into(imageView)
        } else {
            imageView.setImageResource(R.drawable.ole_logo)
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.widget.ImageView
import com.bumptech.glide.Glide
import org.ole.planet.myplanet.R

object ImageUtils {
    fun loadImage(userImage: String?, imageView: ImageView) {
        if (!userImage.isNullOrEmpty()) {
            Glide.with(imageView.context)
                .load(userImage)
                .placeholder(R.drawable.profile)
                .error(R.drawable.profile)
                .into(imageView)
        } else {
            imageView.setImageResource(R.drawable.ole_logo)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/EdgeToEdgeUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.app.Activity
import android.graphics.Color
import android.view.View
import android.view.Window
import androidx.core.view.ViewCompat
import androidx.core.view.WindowCompat
import androidx.core.view.WindowInsetsCompat

object EdgeToEdgeUtils {
    /**
     * Sets up edge-to-edge display with transparent system bars and proper window insets handling
     * Works across all supported SDK versions (26-36)
     * @param activity The activity to apply edge-to-edge to
     * @param rootView The root view that should handle window insets
     * @param lightStatusBar Whether to use light status bar icons (default: true)
     * @param lightNavigationBar Whether to use light navigation bar icons (default: true)
     */
    fun setupEdgeToEdge(
        activity: Activity,
        rootView: View,
        lightStatusBar: Boolean = true,
        lightNavigationBar: Boolean = true
    ) {
        configureEdgeToEdge(activity, rootView, lightStatusBar, lightNavigationBar)

        // Set up window insets listener
        ViewCompat.setOnApplyWindowInsetsListener(rootView) { view, windowInsets ->
            val insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars())
            view.setPadding(insets.left, insets.top, insets.right, insets.bottom)
            WindowInsetsCompat.CONSUMED
        }
    }

    /**
     * Extension function to set transparent system bars with proper SDK handling
     */
    private fun Window.setTransparentSystemBars() {
        statusBarColor = Color.TRANSPARENT
        navigationBarColor = Color.TRANSPARENT
    }

    /**
     * Sets up edge-to-edge with keyboard handling
     */
    fun setupEdgeToEdgeWithKeyboard(
        activity: Activity,
        rootView: View,
        lightStatusBar: Boolean = true,
        lightNavigationBar: Boolean = true
    ) {
        configureEdgeToEdge(activity, rootView, lightStatusBar, lightNavigationBar)

        ViewCompat.setOnApplyWindowInsetsListener(rootView) { view, windowInsets ->
            val systemBarsInsets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars())
            val imeInsets = windowInsets.getInsets(WindowInsetsCompat.Type.ime())

            view.setPadding(
                systemBarsInsets.left,
                systemBarsInsets.top,
                systemBarsInsets.right,
                maxOf(systemBarsInsets.bottom, imeInsets.bottom)
            )
            WindowInsetsCompat.CONSUMED
        }
    }

    private fun configureEdgeToEdge(
        activity: Activity,
        rootView: View,
        lightStatusBar: Boolean,
        lightNavigationBar: Boolean
    ) {
        WindowCompat.setDecorFitsSystemWindows(activity.window, false)
        activity.window.setTransparentSystemBars()

        val controller = WindowCompat.getInsetsController(activity.window, rootView)
        controller.isAppearanceLightStatusBars = lightStatusBar
        controller.isAppearanceLightNavigationBars = lightNavigationBar
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.app.Activity
import android.graphics.Color
import android.view.View
import android.view.Window
import androidx.core.view.ViewCompat
import androidx.core.view.WindowCompat
import androidx.core.view.WindowInsetsCompat

object EdgeToEdgeUtils {
    /**
     * Sets up edge-to-edge display with transparent system bars and proper window insets handling
     * Works across all supported SDK versions (26-36)
     * @param activity The activity to apply edge-to-edge to
     * @param rootView The root view that should handle window insets
     * @param lightStatusBar Whether to use light status bar icons (default: true)
     * @param lightNavigationBar Whether to use light navigation bar icons (default: true)
     */
    fun setupEdgeToEdge(
        activity: Activity,
        rootView: View,
        lightStatusBar: Boolean = true,
        lightNavigationBar: Boolean = true
    ) {
        configureEdgeToEdge(activity, rootView, lightStatusBar, lightNavigationBar)

        // Set up window insets listener
        ViewCompat.setOnApplyWindowInsetsListener(rootView) { view, windowInsets ->
            val insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars())
            view.setPadding(insets.left, insets.top, insets.right, insets.bottom)
            WindowInsetsCompat.CONSUMED
        }
    }

    /**
     * Extension function to set transparent system bars with proper SDK handling
     */
    private fun Window.setTransparentSystemBars() {
        statusBarColor = Color.TRANSPARENT
        navigationBarColor = Color.TRANSPARENT
    }

    /**
     * Sets up edge-to-edge with keyboard handling
     */
    fun setupEdgeToEdgeWithKeyboard(
        activity: Activity,
        rootView: View,
        lightStatusBar: Boolean = true,
        lightNavigationBar: Boolean = true
    ) {
        configureEdgeToEdge(activity, rootView, lightStatusBar, lightNavigationBar)

        ViewCompat.setOnApplyWindowInsetsListener(rootView) { view, windowInsets ->
            val systemBarsInsets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars())
            val imeInsets = windowInsets.getInsets(WindowInsetsCompat.Type.ime())

            view.setPadding(
                systemBarsInsets.left,
                systemBarsInsets.top,
                systemBarsInsets.right,
                maxOf(systemBarsInsets.bottom, imeInsets.bottom)
            )
            WindowInsetsCompat.CONSUMED
        }
    }

    private fun configureEdgeToEdge(
        activity: Activity,
        rootView: View,
        lightStatusBar: Boolean,
        lightNavigationBar: Boolean
    ) {
        WindowCompat.setDecorFitsSystemWindows(activity.window, false)
        activity.window.setTransparentSystemBars()

        val controller = WindowCompat.getInsetsController(activity.window, rootView)
        controller.isAppearanceLightStatusBars = lightStatusBar
        controller.isAppearanceLightNavigationBars = lightNavigationBar
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/Markdown.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.app.Dialog
import android.content.Context
import android.graphics.Color
import android.text.Layout
import android.text.Spannable
import android.text.TextPaint
import android.text.method.LinkMovementMethod
import android.text.style.AlignmentSpan
import android.text.style.ClickableSpan
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.widget.ImageView
import android.widget.TextView
import androidx.core.graphics.drawable.toDrawable
import com.bumptech.glide.Glide
import com.github.chrisbanes.photoview.PhotoView
import io.noties.markwon.AbstractMarkwonPlugin
import io.noties.markwon.Markwon
import io.noties.markwon.MarkwonConfiguration
import io.noties.markwon.MarkwonPlugin
import io.noties.markwon.MarkwonSpansFactory
import io.noties.markwon.RenderProps
import io.noties.markwon.core.MarkwonTheme
import io.noties.markwon.ext.tables.TablePlugin
import io.noties.markwon.html.HtmlPlugin
import io.noties.markwon.html.HtmlTag
import io.noties.markwon.html.tag.SimpleTagHandler
import io.noties.markwon.image.ImageProps
import io.noties.markwon.image.ImagesPlugin
import io.noties.markwon.image.file.FileSchemeHandler
import io.noties.markwon.image.network.NetworkSchemeHandler
import io.noties.markwon.image.network.OkHttpNetworkSchemeHandler
import io.noties.markwon.movement.MovementMethodPlugin
import java.util.regex.Pattern
import org.commonmark.node.Image
import org.ole.planet.myplanet.R

object Markdown {
    private var currentZoomDialog: Dialog? = null

    fun create(context: Context): Markwon {
        return Markwon.builder(context)
            .usePlugin(HtmlPlugin.create())
            .usePlugin(ImagesPlugin.create())
            .usePlugin(MovementMethodPlugin.create(LinkMovementMethod.getInstance()))
            .usePlugin(TablePlugin.create(context))
            .usePlugin(HtmlPlugin.create { plugin: HtmlPlugin -> plugin.addHandler(AlignTagHandler()) })
            .usePlugin(object : AbstractMarkwonPlugin() {
                override fun configure(registry: MarkwonPlugin.Registry) {
                    registry.require(ImagesPlugin::class.java) { imagesPlugin ->
                        imagesPlugin.addSchemeHandler(FileSchemeHandler.createWithAssets(context.assets))
                        imagesPlugin.addSchemeHandler(NetworkSchemeHandler.create())
                        imagesPlugin.addSchemeHandler(OkHttpNetworkSchemeHandler.create())
                    }
                }

                override fun configureSpansFactory(builder: MarkwonSpansFactory.Builder) {
                    builder.appendFactory(Image::class.java) { configuration, props ->
                        val url = ImageProps.DESTINATION.require(props)
                        CustomImageSpan(configuration.theme(), url)
                    }
                }
            }).build()
    }

    fun setMarkdownText(textView: TextView, markdown: String) {
        val markwon = create(textView.context)
        markwon.setMarkdown(textView, markdown)
        textView.movementMethod = CustomLinkMovementMethod()
    }

    private class CustomImageSpan(private val theme: MarkwonTheme, private val url: String) : ClickableSpan() {
        override fun onClick(widget: View) {
            showZoomableImage(widget.context, url)
        }

        override fun updateDrawState(ds: TextPaint) {
            theme.applyLinkStyle(ds)
        }
    }

    private fun showZoomableImage(context: Context, imageUrl: String) {
        currentZoomDialog?.dismiss()

        val dialog = Dialog(context, android.R.style.Theme_Black_NoTitleBar_Fullscreen)
        currentZoomDialog = dialog

        val view = LayoutInflater.from(context).inflate(R.layout.dialog_zoomable_image, null)
        val photoView = view.findViewById<PhotoView>(R.id.photoView)
        val closeButton = view.findViewById<ImageView>(R.id.closeButton)

        dialog.setContentView(view)
        dialog.window?.setBackgroundDrawable(Color.BLACK.toDrawable())

        Glide.with(photoView.context)
            .load(imageUrl)
            .error(R.drawable.ic_loading)
            .into(photoView)

        closeButton.setOnClickListener {
            dialog.dismiss()
            currentZoomDialog = null
        }

        dialog.setOnDismissListener {
            currentZoomDialog = null
        }

        dialog.show()
    }

    fun prependBaseUrlToImages(
        markdownContent: String?,
        baseUrl: String,
        width: Int = 150,
        height: Int = 100
    ): String {
        val pattern = "!\\[.*?]\\((.*?)\\)"
        val imagePattern = Pattern.compile(pattern)
        val matcher = markdownContent?.let { imagePattern.matcher(it) }
            ?: return markdownContent.orEmpty()
        val result = StringBuffer()
        while (matcher.find()) {
            val relativePath = matcher.group(1)
            val modifiedPath = relativePath?.replaceFirst("resources/".toRegex(), "")
            val fullUrl = baseUrl + modifiedPath
            matcher.appendReplacement(result, "<img src=$fullUrl width=$width height=$height/>")
        }
        matcher.appendTail(result)
        return result.toString()
    }

    private class CustomLinkMovementMethod : LinkMovementMethod() {
        override fun onTouchEvent(widget: TextView, buffer: Spannable, event: MotionEvent): Boolean {
            if (event.action == MotionEvent.ACTION_UP) {
                var x = event.x.toInt()
                var y = event.y.toInt()

                x -= widget.totalPaddingLeft
                y -= widget.totalPaddingTop

                x += widget.scrollX
                y += widget.scrollY

                val layout = widget.layout
                val line = layout.getLineForVertical(y)
                val offset = layout.getOffsetForHorizontal(line, x.toFloat())

                val imageSpans = buffer.getSpans(offset, offset, CustomImageSpan::class.java)
                if (imageSpans.isNotEmpty()) {
                    imageSpans[0].onClick(widget)
                    return true
                }
            }
            return super.onTouchEvent(widget, buffer, event)
        }
    }

    class AlignTagHandler : SimpleTagHandler() {
        override fun getSpans(configuration: MarkwonConfiguration, renderProps: RenderProps, tag: HtmlTag): Any {
            val alignment: Layout.Alignment = if (tag.attributes().containsKey("center")) {
                Layout.Alignment.ALIGN_CENTER
            } else if (tag.attributes().containsKey("end")) {
                Layout.Alignment.ALIGN_OPPOSITE
            } else {
                Layout.Alignment.ALIGN_NORMAL
            }
            return AlignmentSpan.Standard(alignment)
        }

        override fun supportedTags(): Collection<String> {
            return setOf("align")
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.app.Dialog
import android.content.Context
import android.graphics.Color
import android.text.Layout
import android.text.Spannable
import android.text.TextPaint
import android.text.method.LinkMovementMethod
import android.text.style.AlignmentSpan
import android.text.style.ClickableSpan
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.widget.ImageView
import android.widget.TextView
import androidx.core.graphics.drawable.toDrawable
import com.bumptech.glide.Glide
import com.github.chrisbanes.photoview.PhotoView
import io.noties.markwon.AbstractMarkwonPlugin
import io.noties.markwon.Markwon
import io.noties.markwon.MarkwonConfiguration
import io.noties.markwon.MarkwonPlugin
import io.noties.markwon.MarkwonSpansFactory
import io.noties.markwon.RenderProps
import io.noties.markwon.core.MarkwonTheme
import io.noties.markwon.ext.tables.TablePlugin
import io.noties.markwon.html.HtmlPlugin
import io.noties.markwon.html.HtmlTag
import io.noties.markwon.html.tag.SimpleTagHandler
import io.noties.markwon.image.ImageProps
import io.noties.markwon.image.ImagesPlugin
import io.noties.markwon.image.file.FileSchemeHandler
import io.noties.markwon.image.network.NetworkSchemeHandler
import io.noties.markwon.image.network.OkHttpNetworkSchemeHandler
import io.noties.markwon.movement.MovementMethodPlugin
import java.util.regex.Pattern
import org.commonmark.node.Image
import org.ole.planet.myplanet.R

object Markdown {
    private var currentZoomDialog: Dialog? = null

    fun create(context: Context): Markwon {
        return Markwon.builder(context)
            .usePlugin(HtmlPlugin.create())
            .usePlugin(ImagesPlugin.create())
            .usePlugin(MovementMethodPlugin.create(LinkMovementMethod.getInstance()))
            .usePlugin(TablePlugin.create(context))
            .usePlugin(HtmlPlugin.create { plugin: HtmlPlugin -> plugin.addHandler(AlignTagHandler()) })
            .usePlugin(object : AbstractMarkwonPlugin() {
                override fun configure(registry: MarkwonPlugin.Registry) {
                    registry.require(ImagesPlugin::class.java) { imagesPlugin ->
                        imagesPlugin.addSchemeHandler(FileSchemeHandler.createWithAssets(context.assets))
                        imagesPlugin.addSchemeHandler(NetworkSchemeHandler.create())
                        imagesPlugin.addSchemeHandler(OkHttpNetworkSchemeHandler.create())
                    }
                }

                override fun configureSpansFactory(builder: MarkwonSpansFactory.Builder) {
                    builder.appendFactory(Image::class.java) { configuration, props ->
                        val url = ImageProps.DESTINATION.require(props)
                        CustomImageSpan(configuration.theme(), url)
                    }
                }
            }).build()
    }

    fun setMarkdownText(textView: TextView, markdown: String) {
        val markwon = create(textView.context)
        markwon.setMarkdown(textView, markdown)
        textView.movementMethod = CustomLinkMovementMethod()
    }

    private class CustomImageSpan(private val theme: MarkwonTheme, private val url: String) : ClickableSpan() {
        override fun onClick(widget: View) {
            showZoomableImage(widget.context, url)
        }

        override fun updateDrawState(ds: TextPaint) {
            theme.applyLinkStyle(ds)
        }
    }

    private fun showZoomableImage(context: Context, imageUrl: String) {
        currentZoomDialog?.dismiss()

        val dialog = Dialog(context, android.R.style.Theme_Black_NoTitleBar_Fullscreen)
        currentZoomDialog = dialog

        val view = LayoutInflater.from(context).inflate(R.layout.dialog_zoomable_image, null)
        val photoView = view.findViewById<PhotoView>(R.id.photoView)
        val closeButton = view.findViewById<ImageView>(R.id.closeButton)

        dialog.setContentView(view)
        dialog.window?.setBackgroundDrawable(Color.BLACK.toDrawable())

        Glide.with(photoView.context)
            .load(imageUrl)
            .error(R.drawable.ic_loading)
            .into(photoView)

        closeButton.setOnClickListener {
            dialog.dismiss()
            currentZoomDialog = null
        }

        dialog.setOnDismissListener {
            currentZoomDialog = null
        }

        dialog.show()
    }

    fun prependBaseUrlToImages(
        markdownContent: String?,
        baseUrl: String,
        width: Int = 150,
        height: Int = 100
    ): String {
        val pattern = "!\\[.*?]\\((.*?)\\)"
        val imagePattern = Pattern.compile(pattern)
        val matcher = markdownContent?.let { imagePattern.matcher(it) }
            ?: return markdownContent.orEmpty()
        val result = StringBuffer()
        while (matcher.find()) {
            val relativePath = matcher.group(1)
            val modifiedPath = relativePath?.replaceFirst("resources/".toRegex(), "")
            val fullUrl = baseUrl + modifiedPath
            matcher.appendReplacement(result, "<img src=$fullUrl width=$width height=$height/>")
        }
        matcher.appendTail(result)
        return result.toString()
    }

    private class CustomLinkMovementMethod : LinkMovementMethod() {
        override fun onTouchEvent(widget: TextView, buffer: Spannable, event: MotionEvent): Boolean {
            if (event.action == MotionEvent.ACTION_UP) {
                var x = event.x.toInt()
                var y = event.y.toInt()

                x -= widget.totalPaddingLeft
                y -= widget.totalPaddingTop

                x += widget.scrollX
                y += widget.scrollY

                val layout = widget.layout
                val line = layout.getLineForVertical(y)
                val offset = layout.getOffsetForHorizontal(line, x.toFloat())

                val imageSpans = buffer.getSpans(offset, offset, CustomImageSpan::class.java)
                if (imageSpans.isNotEmpty()) {
                    imageSpans[0].onClick(widget)
                    return true
                }
            }
            return super.onTouchEvent(widget, buffer, event)
        }
    }

    class AlignTagHandler : SimpleTagHandler() {
        override fun getSpans(configuration: MarkwonConfiguration, renderProps: RenderProps, tag: HtmlTag): Any {
            val alignment: Layout.Alignment = if (tag.attributes().containsKey("center")) {
                Layout.Alignment.ALIGN_CENTER
            } else if (tag.attributes().containsKey("end")) {
                Layout.Alignment.ALIGN_OPPOSITE
            } else {
                Layout.Alignment.ALIGN_NORMAL
            }
            return AlignmentSpan.Standard(alignment)
        }

        override fun supportedTags(): Collection<String> {
            return setOf("align")
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/KeyboardUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.app.Activity
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.view.inputmethod.InputMethodManager
import android.widget.EditText

object KeyboardUtils {
    @JvmStatic
    fun hideSoftKeyboard(activity: Activity) {
        try {
            val inputMethodManager = activity.getSystemService(Activity.INPUT_METHOD_SERVICE) as InputMethodManager
            inputMethodManager.hideSoftInputFromWindow(activity.currentFocus?.windowToken, 0)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @JvmStatic
    fun setupUI(v: View, activity: Activity) {
        // Set up touch listener for non-text box views to hide keyboard.
        val onTouchListener = View.OnTouchListener { _: View?, _: MotionEvent? ->
            hideSoftKeyboard(activity)
            false
        }
        if (v !is EditText) {
            v.setOnTouchListener(onTouchListener)
        }

        //If a layout container, iterate over children and seed recursion.
        if (v is ViewGroup) {
            for (i in 0 until v.childCount) {
                val innerView = v.getChildAt(i)
                setupUI(innerView, activity)
            }
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.app.Activity
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.view.inputmethod.InputMethodManager
import android.widget.EditText

object KeyboardUtils {
    @JvmStatic
    fun hideSoftKeyboard(activity: Activity) {
        try {
            val inputMethodManager = activity.getSystemService(Activity.INPUT_METHOD_SERVICE) as InputMethodManager
            inputMethodManager.hideSoftInputFromWindow(activity.currentFocus?.windowToken, 0)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @JvmStatic
    fun setupUI(v: View, activity: Activity) {
        // Set up touch listener for non-text box views to hide keyboard.
        val onTouchListener = View.OnTouchListener { _: View?, _: MotionEvent? ->
            hideSoftKeyboard(activity)
            false
        }
        if (v !is EditText) {
            v.setOnTouchListener(onTouchListener)
        }

        //If a layout container, iterate over children and seed recursion.
        if (v is ViewGroup) {
            for (i in 0 until v.childCount) {
                val innerView = v.getChildAt(i)
                setupUI(innerView, activity)
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/TextViewExtensions.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.text.SpannableStringBuilder
import android.text.Spanned
import android.text.TextUtils
import android.text.method.LinkMovementMethod
import android.text.style.ClickableSpan
import android.view.View
import android.widget.TextView
import org.ole.planet.myplanet.R

fun TextView.makeExpandable(
    fullText: CharSequence,
    collapsedMaxLines: Int = 6,
    expandLabel: String = context.getString(R.string.show_more),
    collapseLabel: String = context.getString(R.string.show_less)
) {
    var isExpanded = false

    fun refresh() {
        text = fullText
        if (!isExpanded) {
            maxLines = collapsedMaxLines
            ellipsize = TextUtils.TruncateAt.END

            post {
                if (lineCount > collapsedMaxLines) {
                    val lastChar = layout.getLineEnd(collapsedMaxLines - 2)
                    val safeLastChar = minOf(lastChar, fullText.length)

                    if (safeLastChar > 0 && safeLastChar <= fullText.length) {
                        val visiblePortion = SpannableStringBuilder(fullText.subSequence(0, safeLastChar))
                        visiblePortion.append(" ").also { sb ->
                            val start = sb.length
                            sb.append(expandLabel)
                            sb.setSpan(object : ClickableSpan() {
                                override fun onClick(widget: View) {
                                    isExpanded = true
                                    refresh()
                                }
                            }, start, sb.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                        }

                        text = visiblePortion
                        movementMethod = LinkMovementMethod.getInstance()
                    }
                }
            }
        } else {
            val expanded = SpannableStringBuilder(fullText).apply {
                append(" ")
                val start = length
                append(collapseLabel)
                setSpan(object : ClickableSpan() {
                    override fun onClick(widget: View) {
                        isExpanded = false
                        refresh()
                    }
                }, start, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            }
            text = expanded
            movementMethod = LinkMovementMethod.getInstance()
            maxLines = Int.MAX_VALUE
            ellipsize = null
        }
    }
    refresh()
}
=======
package org.ole.planet.myplanet.utilities


import android.text.SpannableStringBuilder
import android.text.Spanned
import android.text.TextUtils
import android.text.method.LinkMovementMethod
import android.text.style.ClickableSpan
import android.view.View
import android.widget.TextView
import org.ole.planet.myplanet.R

fun TextView.makeExpandable(
    fullText: CharSequence,
    collapsedMaxLines: Int = 6,
    expandLabel: String = context.getString(R.string.show_more),
    collapseLabel: String = context.getString(R.string.show_less)
) {
    var isExpanded = false

    fun refresh() {
        text = fullText
        if (!isExpanded) {
            maxLines = collapsedMaxLines
            ellipsize = TextUtils.TruncateAt.END

            post {
                if (lineCount > collapsedMaxLines) {
                    val lastChar = layout.getLineEnd(collapsedMaxLines - 2)
                    val safeLastChar = minOf(lastChar, fullText.length)

                    if (safeLastChar > 0 && safeLastChar <= fullText.length) {
                        val visiblePortion = SpannableStringBuilder(fullText.subSequence(0, safeLastChar))
                        visiblePortion.append(" ").also { sb ->
                            val start = sb.length
                            sb.append(expandLabel)
                            sb.setSpan(object : ClickableSpan() {
                                override fun onClick(widget: View) {
                                    isExpanded = true
                                    refresh()
                                }
                            }, start, sb.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                        }

                        text = visiblePortion
                        movementMethod = LinkMovementMethod.getInstance()
                    }
                }
            }
        } else {
            val expanded = SpannableStringBuilder(fullText).apply {
                append(" ")
                val start = length
                append(collapseLabel)
                setSpan(object : ClickableSpan() {
                    override fun onClick(widget: View) {
                        isExpanded = false
                        refresh()
                    }
                }, start, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            }
            text = expanded
            movementMethod = LinkMovementMethod.getInstance()
            maxLines = Int.MAX_VALUE
            ellipsize = null
        }
    }
    refresh()
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/AuthHelper.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.widget.Toast
import io.realm.Realm
import java.text.Normalizer
import java.util.regex.Pattern
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.ManagerSync
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.sync.LoginActivity

object AuthHelper {
    private val specialCharPattern = Pattern.compile(
        ".*[].*"
    )

    fun validateUsername(context: Context, username: String, realm: Realm? = null): String? {
        val firstChar = username.firstOrNull()
        return when {
            username.isEmpty() -> context.getString(R.string.username_cannot_be_empty)
            username.contains(" ") -> context.getString(R.string.invalid_username)
            firstChar != null && !firstChar.isDigit() && !firstChar.isLetter() ->
                context.getString(R.string.must_start_with_letter_or_number)
            hasInvalidCharacters(username) ||
                specialCharPattern.matcher(username).matches() ||
                hasDiacriticCharacters(username) ->
                context.getString(R.string.only_letters_numbers_and_are_allowed)
            realm != null && RealmUserModel.isUserExists(realm, username) ->
                context.getString(R.string.username_taken)
            else -> null
        }
    }

    private fun hasInvalidCharacters(input: String) =
        input.any { it != '_' && it != '.' && it != '-' && !it.isDigit() && !it.isLetter() }

    private fun hasDiacriticCharacters(input: String): Boolean {
        val normalized = Normalizer.normalize(input, Normalizer.Form.NFD)
        return !normalized.codePoints().allMatch { code ->
            Character.isLetterOrDigit(code) ||
                code == '.'.code ||
                code == '-'.code ||
                code == '_'.code
        }
    }

    fun login(activity: LoginActivity, name: String?, password: String?) {
        if (activity.forceSyncTrigger()) return

        val settings = activity.settings
        SecurePrefs.saveCredentials(activity, settings, name, password)

        val isLoggedIn = activity.authenticateUser(settings, name, password, false)
        if (isLoggedIn) {
            Toast.makeText(activity, activity.getString(R.string.welcome, name), Toast.LENGTH_SHORT).show()
            activity.onLogin()
            activity.saveUsers(name, password, "member")
            return
        }

        ManagerSync.instance.login(name, password, object : SyncListener {
            override fun onSyncStarted() {
                activity.customProgressDialog.setText(activity.getString(R.string.please_wait))
                activity.customProgressDialog.show()
            }

            override fun onSyncComplete() {
                activity.customProgressDialog.dismiss()
                val log = activity.authenticateUser(activity.settings, name, password, true)
                if (log) {
                    Toast.makeText(activity.applicationContext, activity.getString(R.string.thank_you), Toast.LENGTH_SHORT).show()
                    activity.onLogin()
                    activity.saveUsers(name, password, "member")
                } else {
                    activity.alertDialogOkay(activity.getString(R.string.err_msg_login))
                }
                activity.syncIconDrawable.stop()
                activity.syncIconDrawable.selectDrawable(0)
            }

            override fun onSyncFailed(msg: String?) {
                Toast.makeText(activity, msg, Toast.LENGTH_LONG).show()
                activity.customProgressDialog.dismiss()
                activity.syncIconDrawable.stop()
                activity.syncIconDrawable.selectDrawable(0)
            }
        })
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.widget.Toast
import io.realm.Realm
import java.text.Normalizer
import java.util.regex.Pattern
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.ManagerSync
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.sync.LoginActivity

object AuthHelper {
    private val specialCharPattern = Pattern.compile(
        ".*[].*"
    )

    fun validateUsername(context: Context, username: String, realm: Realm? = null): String? {
        val firstChar = username.firstOrNull()
        return when {
            username.isEmpty() -> context.getString(R.string.username_cannot_be_empty)
            username.contains(" ") -> context.getString(R.string.invalid_username)
            firstChar != null && !firstChar.isDigit() && !firstChar.isLetter() ->
                context.getString(R.string.must_start_with_letter_or_number)
            hasInvalidCharacters(username) ||
                specialCharPattern.matcher(username).matches() ||
                hasDiacriticCharacters(username) ->
                context.getString(R.string.only_letters_numbers_and_are_allowed)
            realm != null && RealmUserModel.isUserExists(realm, username) ->
                context.getString(R.string.username_taken)
            else -> null
        }
    }

    private fun hasInvalidCharacters(input: String) =
        input.any { it != '_' && it != '.' && it != '-' && !it.isDigit() && !it.isLetter() }

    private fun hasDiacriticCharacters(input: String): Boolean {
        val normalized = Normalizer.normalize(input, Normalizer.Form.NFD)
        return !normalized.codePoints().allMatch { code ->
            Character.isLetterOrDigit(code) ||
                code == '.'.code ||
                code == '-'.code ||
                code == '_'.code
        }
    }

    fun login(activity: LoginActivity, name: String?, password: String?) {
        if (activity.forceSyncTrigger()) return

        val settings = activity.settings
        SecurePrefs.saveCredentials(activity, settings, name, password)

        val isLoggedIn = activity.authenticateUser(settings, name, password, false)
        if (isLoggedIn) {
            Toast.makeText(activity, activity.getString(R.string.welcome, name), Toast.LENGTH_SHORT).show()
            activity.onLogin()
            activity.saveUsers(name, password, "member")
            return
        }

        ManagerSync.instance.login(name, password, object : SyncListener {
            override fun onSyncStarted() {
                activity.customProgressDialog.setText(activity.getString(R.string.please_wait))
                activity.customProgressDialog.show()
            }

            override fun onSyncComplete() {
                activity.customProgressDialog.dismiss()
                val log = activity.authenticateUser(activity.settings, name, password, true)
                if (log) {
                    Toast.makeText(activity.applicationContext, activity.getString(R.string.thank_you), Toast.LENGTH_SHORT).show()
                    activity.onLogin()
                    activity.saveUsers(name, password, "member")
                } else {
                    activity.alertDialogOkay(activity.getString(R.string.err_msg_login))
                }
                activity.syncIconDrawable.stop()
                activity.syncIconDrawable.selectDrawable(0)
            }

            override fun onSyncFailed(msg: String?) {
                Toast.makeText(activity, msg, Toast.LENGTH_LONG).show()
                activity.customProgressDialog.dismiss()
                activity.syncIconDrawable.stop()
                activity.syncIconDrawable.selectDrawable(0)
            }
        })
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/ResourceOpener.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.app.Activity
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.widget.Toast
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseResourceFragment
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.viewer.AudioPlayerActivity
import org.ole.planet.myplanet.ui.viewer.CSVViewerActivity
import org.ole.planet.myplanet.ui.viewer.ImageViewerActivity
import org.ole.planet.myplanet.ui.viewer.MarkdownViewerActivity
import org.ole.planet.myplanet.ui.viewer.PDFReaderActivity
import org.ole.planet.myplanet.ui.viewer.TextFileViewerActivity
import org.ole.planet.myplanet.ui.viewer.VideoPlayerActivity

object ResourceOpener {
    private fun resourcePath(item: RealmMyLibrary): String {
        return "${item.id}/${item.resourceLocalAddress}"
    }

    fun openIntent(activity: Activity, items: RealmMyLibrary, typeClass: Class<*>) {
        val fileOpenIntent = Intent(activity, typeClass)
        if (items.resourceLocalAddress?.contains("ole/audio") == true ||
            items.resourceLocalAddress?.contains("ole/video") == true) {
            fileOpenIntent.putExtra("TOUCHED_FILE", items.resourceLocalAddress)
            fileOpenIntent.putExtra("RESOURCE_TITLE", items.title)
        } else {
            fileOpenIntent.putExtra("TOUCHED_FILE", resourcePath(items))
            fileOpenIntent.putExtra("RESOURCE_TITLE", items.title)
        }
        activity.startActivity(fileOpenIntent)
    }

    fun openPdf(activity: Activity, item: RealmMyLibrary) {
        val fileOpenIntent = Intent(activity, PDFReaderActivity::class.java)
        fileOpenIntent.putExtra("TOUCHED_FILE", resourcePath(item))
        fileOpenIntent.putExtra("resourceId", item.id)
        activity.startActivity(fileOpenIntent)
    }

    private fun checkMoreFileExtensions(activity: Activity, extension: String?, items: RealmMyLibrary) {
        when (extension) {
            "txt" -> openIntent(activity, items, TextFileViewerActivity::class.java)
            "md" -> openIntent(activity, items, MarkdownViewerActivity::class.java)
            "csv" -> openIntent(activity, items, CSVViewerActivity::class.java)
            else -> Toast.makeText(activity,
                activity.getString(R.string.this_file_type_is_currently_unsupported),
                Toast.LENGTH_LONG).show()
        }
    }

    fun checkFileExtension(activity: Activity, items: RealmMyLibrary) {
        val filenameArray = items.resourceLocalAddress?.split(".")?.toTypedArray()
        val extension = filenameArray?.get(filenameArray.size - 1)
        val mimetype = Utilities.getMimeType(items.resourceLocalAddress)

        if (mimetype != null) {
            when {
                mimetype.contains("image") -> openIntent(activity, items, ImageViewerActivity::class.java)
                mimetype.contains("pdf") -> openPdf(activity, items)
                mimetype.contains("audio") -> openIntent(activity, items, AudioPlayerActivity::class.java)
                else -> checkMoreFileExtensions(activity, extension, items)
            }
        }
    }

    fun playVideo(activity: Activity, videoType: String, items: RealmMyLibrary) {
        val intent = Intent(activity, VideoPlayerActivity::class.java)
        val bundle = Bundle()
        bundle.putString("videoType", videoType)
        if (videoType == "online") {
            bundle.putString("videoURL", "${UrlUtils.getUrl(items)}")
            bundle.putString("Auth", "${BaseResourceFragment.auth}")
        } else if (videoType == "offline") {
            if (items.resourceRemoteAddress == null && items.resourceLocalAddress != null) {
                bundle.putString("videoURL", items.resourceLocalAddress)
            } else {
                bundle.putString(
                    "videoURL",
                    Uri.fromFile(FileUtils.getSDPathFromUrl(activity, items.resourceRemoteAddress)).toString()
                )
            }
            bundle.putString("Auth", "")
        }
        intent.putExtras(bundle)
        activity.startActivity(intent)
    }

    fun openFileType(activity: Activity, items: RealmMyLibrary, videoType: String, profileDbHandler: UserProfileDbHandler) {
        val mimetype = Utilities.getMimeType(resourcePath(items))
        if (mimetype == null) {
            Utilities.toast(activity, activity.getString(R.string.unable_to_open_resource))
            return
        }
        profileDbHandler.setResourceOpenCount(items, UserProfileDbHandler.KEY_RESOURCE_OPEN)
        if (mimetype.startsWith("video")) {
            playVideo(activity, videoType, items)
        } else {
            checkFileExtension(activity, items)
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.app.Activity
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.widget.Toast
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.BaseResourceFragment
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.viewer.AudioPlayerActivity
import org.ole.planet.myplanet.ui.viewer.CSVViewerActivity
import org.ole.planet.myplanet.ui.viewer.ImageViewerActivity
import org.ole.planet.myplanet.ui.viewer.MarkdownViewerActivity
import org.ole.planet.myplanet.ui.viewer.PDFReaderActivity
import org.ole.planet.myplanet.ui.viewer.TextFileViewerActivity
import org.ole.planet.myplanet.ui.viewer.VideoPlayerActivity

object ResourceOpener {
    private fun resourcePath(item: RealmMyLibrary): String {
        return "${item.id}/${item.resourceLocalAddress}"
    }

    fun openIntent(activity: Activity, items: RealmMyLibrary, typeClass: Class<*>) {
        val fileOpenIntent = Intent(activity, typeClass)
        if (items.resourceLocalAddress?.contains("ole/audio") == true ||
            items.resourceLocalAddress?.contains("ole/video") == true) {
            fileOpenIntent.putExtra("TOUCHED_FILE", items.resourceLocalAddress)
            fileOpenIntent.putExtra("RESOURCE_TITLE", items.title)
        } else {
            fileOpenIntent.putExtra("TOUCHED_FILE", resourcePath(items))
            fileOpenIntent.putExtra("RESOURCE_TITLE", items.title)
        }
        activity.startActivity(fileOpenIntent)
    }

    fun openPdf(activity: Activity, item: RealmMyLibrary) {
        val fileOpenIntent = Intent(activity, PDFReaderActivity::class.java)
        fileOpenIntent.putExtra("TOUCHED_FILE", resourcePath(item))
        fileOpenIntent.putExtra("resourceId", item.id)
        activity.startActivity(fileOpenIntent)
    }

    private fun checkMoreFileExtensions(activity: Activity, extension: String?, items: RealmMyLibrary) {
        when (extension) {
            "txt" -> openIntent(activity, items, TextFileViewerActivity::class.java)
            "md" -> openIntent(activity, items, MarkdownViewerActivity::class.java)
            "csv" -> openIntent(activity, items, CSVViewerActivity::class.java)
            else -> Toast.makeText(activity,
                activity.getString(R.string.this_file_type_is_currently_unsupported),
                Toast.LENGTH_LONG).show()
        }
    }

    fun checkFileExtension(activity: Activity, items: RealmMyLibrary) {
        val filenameArray = items.resourceLocalAddress?.split(".")?.toTypedArray()
        val extension = filenameArray?.get(filenameArray.size - 1)
        val mimetype = Utilities.getMimeType(items.resourceLocalAddress)

        if (mimetype != null) {
            when {
                mimetype.contains("image") -> openIntent(activity, items, ImageViewerActivity::class.java)
                mimetype.contains("pdf") -> openPdf(activity, items)
                mimetype.contains("audio") -> openIntent(activity, items, AudioPlayerActivity::class.java)
                else -> checkMoreFileExtensions(activity, extension, items)
            }
        }
    }

    fun playVideo(activity: Activity, videoType: String, items: RealmMyLibrary) {
        val intent = Intent(activity, VideoPlayerActivity::class.java)
        val bundle = Bundle()
        bundle.putString("videoType", videoType)
        if (videoType == "online") {
            bundle.putString("videoURL", "${UrlUtils.getUrl(items)}")
            bundle.putString("Auth", "${BaseResourceFragment.auth}")
        } else if (videoType == "offline") {
            if (items.resourceRemoteAddress == null && items.resourceLocalAddress != null) {
                bundle.putString("videoURL", items.resourceLocalAddress)
            } else {
                bundle.putString(
                    "videoURL",
                    Uri.fromFile(FileUtils.getSDPathFromUrl(activity, items.resourceRemoteAddress)).toString()
                )
            }
            bundle.putString("Auth", "")
        }
        intent.putExtras(bundle)
        activity.startActivity(intent)
    }

    fun openFileType(activity: Activity, items: RealmMyLibrary, videoType: String, profileDbHandler: UserProfileDbHandler) {
        val mimetype = Utilities.getMimeType(resourcePath(items))
        if (mimetype == null) {
            Utilities.toast(activity, activity.getString(R.string.unable_to_open_resource))
            return
        }
        profileDbHandler.setResourceOpenCount(items, UserProfileDbHandler.KEY_RESOURCE_OPEN)
        if (mimetype.startsWith("video")) {
            playVideo(activity, videoType, items)
        } else {
            checkFileExtension(activity, items)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/TimeUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.text.format.DateUtils
import java.time.Instant
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.Period
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.Locale

object TimeUtils {
    private val defaultLocale: Locale
        get() = Locale.getDefault()

    private val utcZone: ZoneId = ZoneId.of("UTC")

    private val defaultDateFormatter by lazy {
        DateTimeFormatter.ofPattern("EEEE, MMM dd, yyyy", defaultLocale).withZone(utcZone)
    }

    private val dateTimeFormatter by lazy {
        DateTimeFormatter
            .ofPattern("EEE dd, MMMM yyyy , hh:mm a", defaultLocale)
            .withZone(ZoneId.systemDefault())
    }

    private val tzFormatter by lazy {
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneId.systemDefault())
    }

    private val dateOnlyFormatter by lazy {
        DateTimeFormatter.ofPattern("EEE dd, MMMM yyyy", defaultLocale).withZone(ZoneId.systemDefault())
    }

    private val fallbackDateFormatter by lazy {
        DateTimeFormatter.ofPattern("dd, MMMM yyyy", defaultLocale).withZone(ZoneId.systemDefault())
    }

    fun getRelativeTime(timestamp: Long): String {
        val timeNow = System.currentTimeMillis()
        return if (timestamp < timeNow) {
            DateUtils.getRelativeTimeSpanString(timestamp, timeNow, 0).toString()
        } else "Just now"
    }

    fun getFormattedDate(date: Long?): String =
        try {
            val instant = date?.let { Instant.ofEpochMilli(it) } ?: Instant.now()
            defaultDateFormatter.format(instant)
        } catch (e: Exception) {
            e.printStackTrace()
            "N/A"
        }

    fun getFormattedDateWithTime(date: Long): String =
        try {
            val instant = Instant.ofEpochMilli(date)
            dateTimeFormatter.format(instant)
        } catch (e: Exception) {
            e.printStackTrace()
            "N/A"
        }

    fun formatDateTZ(data: Long): String =
        try {
            val instant = Instant.ofEpochMilli(data)
            tzFormatter.format(instant)
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }

    fun getAge(date: String): Int {
        return try {
            if (date.isBlank()) return 0
            val cleaned = date.replace("T", " ").replace(".000Z", "")
            val dob =
                try {
                    LocalDateTime
                        .parse(cleaned, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
                        .toLocalDate()
                } catch (e: Exception) {
                    LocalDate.parse(cleaned, DateTimeFormatter.ofPattern("yyyy-MM-dd"))
                }
            val today = LocalDate.now()
            Period.between(dob, today).years
        } catch (e: Exception) {
            e.printStackTrace()
            0
        }
    }

    fun getFormattedDate(
        stringDate: String?,
        pattern: String?,
    ): String {
        return try {
            if (stringDate.isNullOrBlank() || pattern.isNullOrBlank()) return "N/A"
            val formatter = DateTimeFormatter.ofPattern(pattern, defaultLocale).withZone(utcZone)
            val instant = if (stringDate.contains("T")) {
                Instant.from(formatter.parse(stringDate))
            } else {
                val dateOnlyFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd", defaultLocale)
                LocalDate.parse(stringDate, dateOnlyFormatter).atStartOfDay(utcZone).toInstant()
            }
            getFormattedDate(instant.toEpochMilli())
        } catch (e: Exception) {
            e.printStackTrace()
            "N/A"
        }
    }

    fun formatDate(date: Long): String =
        try {
            dateOnlyFormatter.format(Instant.ofEpochMilli(date))
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }

    fun formatDate(
        date: Long,
        format: String?,
    ): String =
        try {
            val formatter = DateTimeFormatter.ofPattern(format ?: "", defaultLocale).withZone(ZoneId.systemDefault())
            formatter.format(Instant.ofEpochMilli(date))
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }

    fun parseDate(dateString: String): Long? =
        try {
            val localDate = runCatching {
                LocalDate.parse(dateString, dateOnlyFormatter)
            }.recoverCatching {
                LocalDate.parse(dateString, fallbackDateFormatter)
            }.getOrThrow()
            localDate.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }

    fun parseInstantFromString(dateString: String): Instant? =
        try {
            if (dateString.contains("T")) {
                Instant.parse(dateString)
            } else {
                Instant.parse("${dateString}T00:00:00.000Z")
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }

    fun convertToISO8601(date: String): String {
        return try {
            val calendar = java.util.Calendar.getInstance()
            val parts = date.split("-")
            if (parts.size == 3) {
                calendar.set(parts[0].toInt(), parts[1].toInt() - 1, parts[2].toInt(), 0, 0, 0)
                calendar.set(java.util.Calendar.MILLISECOND, 0)
                String.format(
                    Locale.US,
                    "%04d-%02d-%02dT%02d:%02d:%02d.%03dZ",
                    calendar.get(java.util.Calendar.YEAR),
                    calendar.get(java.util.Calendar.MONTH) + 1,
                    calendar.get(java.util.Calendar.DAY_OF_MONTH),
                    calendar.get(java.util.Calendar.HOUR_OF_DAY),
                    calendar.get(java.util.Calendar.MINUTE),
                    calendar.get(java.util.Calendar.SECOND),
                    calendar.get(java.util.Calendar.MILLISECOND)
                )
            } else {
                date
            }
        } catch (_: Exception) {
            date
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.text.format.DateUtils
import java.time.Instant
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.Period
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.Locale

object TimeUtils {
    private val defaultLocale: Locale
        get() = Locale.getDefault()

    private val utcZone: ZoneId = ZoneId.of("UTC")

    private val defaultDateFormatter by lazy {
        DateTimeFormatter.ofPattern("EEEE, MMM dd, yyyy", defaultLocale).withZone(utcZone)
    }

    private val dateTimeFormatter by lazy {
        DateTimeFormatter
            .ofPattern("EEE dd, MMMM yyyy , hh:mm a", defaultLocale)
            .withZone(ZoneId.systemDefault())
    }

    private val tzFormatter by lazy {
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneId.systemDefault())
    }

    private val dateOnlyFormatter by lazy {
        DateTimeFormatter.ofPattern("EEE dd, MMMM yyyy", defaultLocale).withZone(ZoneId.systemDefault())
    }

    private val fallbackDateFormatter by lazy {
        DateTimeFormatter.ofPattern("dd, MMMM yyyy", defaultLocale).withZone(ZoneId.systemDefault())
    }

    fun getRelativeTime(timestamp: Long): String {
        val timeNow = System.currentTimeMillis()
        return if (timestamp < timeNow) {
            DateUtils.getRelativeTimeSpanString(timestamp, timeNow, 0).toString()
        } else "Just now"
    }

    fun getFormattedDate(date: Long?): String =
        try {
            val instant = date?.let { Instant.ofEpochMilli(it) } ?: Instant.now()
            defaultDateFormatter.format(instant)
        } catch (e: Exception) {
            e.printStackTrace()
            "N/A"
        }

    fun getFormattedDateWithTime(date: Long): String =
        try {
            val instant = Instant.ofEpochMilli(date)
            dateTimeFormatter.format(instant)
        } catch (e: Exception) {
            e.printStackTrace()
            "N/A"
        }

    fun formatDateTZ(data: Long): String =
        try {
            val instant = Instant.ofEpochMilli(data)
            tzFormatter.format(instant)
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }

    fun getAge(date: String): Int {
        return try {
            if (date.isBlank()) return 0
            val cleaned = date.replace("T", " ").replace(".000Z", "")
            val dob =
                try {
                    LocalDateTime
                        .parse(cleaned, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
                        .toLocalDate()
                } catch (e: Exception) {
                    LocalDate.parse(cleaned, DateTimeFormatter.ofPattern("yyyy-MM-dd"))
                }
            val today = LocalDate.now()
            Period.between(dob, today).years
        } catch (e: Exception) {
            e.printStackTrace()
            0
        }
    }

    fun getFormattedDate(
        stringDate: String?,
        pattern: String?,
    ): String {
        return try {
            if (stringDate.isNullOrBlank() || pattern.isNullOrBlank()) return "N/A"
            val formatter = DateTimeFormatter.ofPattern(pattern, defaultLocale).withZone(utcZone)
            val instant = if (stringDate.contains("T")) {
                Instant.from(formatter.parse(stringDate))
            } else {
                val dateOnlyFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd", defaultLocale)
                LocalDate.parse(stringDate, dateOnlyFormatter).atStartOfDay(utcZone).toInstant()
            }
            getFormattedDate(instant.toEpochMilli())
        } catch (e: Exception) {
            e.printStackTrace()
            "N/A"
        }
    }

    fun formatDate(date: Long): String =
        try {
            dateOnlyFormatter.format(Instant.ofEpochMilli(date))
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }

    fun formatDate(
        date: Long,
        format: String?,
    ): String =
        try {
            val formatter = DateTimeFormatter.ofPattern(format ?: "", defaultLocale).withZone(ZoneId.systemDefault())
            formatter.format(Instant.ofEpochMilli(date))
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }

    fun parseDate(dateString: String): Long? =
        try {
            val localDate = runCatching {
                LocalDate.parse(dateString, dateOnlyFormatter)
            }.recoverCatching {
                LocalDate.parse(dateString, fallbackDateFormatter)
            }.getOrThrow()
            localDate.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }

    fun parseInstantFromString(dateString: String): Instant? =
        try {
            if (dateString.contains("T")) {
                Instant.parse(dateString)
            } else {
                Instant.parse("${dateString}T00:00:00.000Z")
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }

    fun convertToISO8601(date: String): String {
        return try {
            val calendar = java.util.Calendar.getInstance()
            val parts = date.split("-")
            if (parts.size == 3) {
                calendar.set(parts[0].toInt(), parts[1].toInt() - 1, parts[2].toInt(), 0, 0, 0)
                calendar.set(java.util.Calendar.MILLISECOND, 0)
                String.format(
                    Locale.US,
                    "%04d-%02d-%02dT%02d:%02d:%02d.%03dZ",
                    calendar.get(java.util.Calendar.YEAR),
                    calendar.get(java.util.Calendar.MONTH) + 1,
                    calendar.get(java.util.Calendar.DAY_OF_MONTH),
                    calendar.get(java.util.Calendar.HOUR_OF_DAY),
                    calendar.get(java.util.Calendar.MINUTE),
                    calendar.get(java.util.Calendar.SECOND),
                    calendar.get(java.util.Calendar.MILLISECOND)
                )
            } else {
                date
            }
        } catch (_: Exception) {
            date
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/DialogUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.app.Activity
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.provider.Settings
import android.view.ContextThemeWrapper
import android.view.LayoutInflater
import android.view.View
import androidx.appcompat.app.AlertDialog
import com.google.android.material.snackbar.Snackbar
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.DialogProgressBinding
import org.ole.planet.myplanet.datamanager.MyDownloadService
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.sync.SyncActivity
import org.ole.planet.myplanet.ui.userprofile.BecomeMemberActivity

object DialogUtils {
    @JvmStatic
    fun getProgressDialog(context: Context): CustomProgressDialog {
        val prgDialog = CustomProgressDialog(context)
        prgDialog.setTitle(context.getString(R.string.downloading_file))
        prgDialog.setMax(100)
        prgDialog.setNegativeButton(context.getString(R.string.stop_download), isVisible = true) {
            context.stopService(Intent(context, MyDownloadService::class.java))
            prgDialog.dismiss()
        }
        return prgDialog
    }

    fun guestDialog(context: Context) {
        val profileDbHandler = UserProfileDbHandler(context)
        val builder = android.app.AlertDialog.Builder(context, R.style.CustomAlertDialog)
        builder.setTitle(context.getString(R.string.become_a_member))
        builder.setMessage(context.getString(R.string.to_access_this_feature_become_a_member))
        builder.setCancelable(false)
        builder.setPositiveButton(context.getString(R.string.become_a_member), null)
        builder.setNegativeButton(context.getString(R.string.cancel), null)

        val dialog = builder.create()
        dialog.show()

        val becomeMember = dialog.getButton(android.app.AlertDialog.BUTTON_POSITIVE)
        val cancel = dialog.getButton(android.app.AlertDialog.BUTTON_NEGATIVE)
        becomeMember.contentDescription = context.getString(R.string.confirm_membership)
        cancel.contentDescription = context.getString(R.string.cancel)

        becomeMember.setOnClickListener {
            val guest = true
            val intent = Intent(context, BecomeMemberActivity::class.java)
            intent.putExtra("username", profileDbHandler.userModel?.name)
            intent.putExtra("guest", guest)
            context.startActivity(intent)
        }
        cancel.setOnClickListener {
            dialog.dismiss()
        }
    }

    @JvmStatic
    fun showError(prgDialog: CustomProgressDialog?, message: String?) {
        prgDialog?.setTitle(message)
        prgDialog?.disableNegativeButton()
    }

    @JvmStatic
    fun showWifiSettingDialog(context: Context) {
        if (!NetworkUtils.isWifiBluetoothEnabled()) return
        showDialog(context)
    }

    private fun showDialog(context: Context) {
        if (MainApplication.syncFailedCount > 3) {
            val pd = AlertDialog.Builder(context, R.style.AlertDialogTheme)
            var message = ""
            if (NetworkUtils.isBluetoothEnabled()) message += "Bluetooth"
            if (NetworkUtils.isWifiEnabled()) {
                if (message.isNotEmpty()) message += " and "
                    message += "Wi-Fi"
            }
            if (message.isNotEmpty()) {
            message += context.getString(R.string.is_on_please_turn_of_to_save_battery)
            } else {
            message = context.getString(R.string.is_on_please_turn_of_to_save_battery)
            }
            pd.setMessage(message)
            pd.setPositiveButton(context.getString(R.string.go_to_settings)) { _, _ ->
                MainApplication.syncFailedCount = 0
                val intent = Intent(Settings.ACTION_WIFI_SETTINGS)
                context.startActivity(intent)
            }.setNegativeButton(context.getString(R.string.cancel), null)
            pd.setCancelable(false)
            val d = pd.create()
            d.show()
        }
    }

    @JvmStatic
    fun showSnack(v: View?, s: String?) {
        if (v != null) {
            s?.let { Snackbar.make(v, it, Snackbar.LENGTH_LONG).show() }
        }
    }

    @JvmStatic
    fun showAlert(context: Context?, title: String?, message: String?) {
        if (context is Activity && !context.isFinishing) {
            AlertDialog.Builder(context, R.style.AlertDialogTheme)
                .setTitle(title)
                .setMessage(message)
                .setPositiveButton(R.string.finish) { _, _ ->
                    if (context is SyncActivity && message == context.getString(R.string.invalid_configuration)) {
                        context.settingDialog()
                    }
                }
                .show()
        }
    }

    @JvmStatic
    fun getDialog(
        context: Context,
        message: String,
        pos: String,
        listener: DialogInterface.OnClickListener?
    ): AlertDialog {
        return AlertDialog.Builder(ContextThemeWrapper(context, R.style.CustomAlertDialog))
            .setMessage(message)
            .setIcon(R.drawable.courses)
            .setPositiveButton(pos, listener)
            .setNegativeButton(R.string.button_cancel, null)
            .create()
    }

    @JvmStatic
    fun getDialog(context: Context, title: String, v: View): AlertDialog {
        return AlertDialog.Builder(ContextThemeWrapper(context, R.style.CustomAlertDialog))
            .setTitle(title)
            .setIcon(R.drawable.ic_edit)
            .setView(v)
            .setPositiveButton(R.string.submit, null)
            .setNegativeButton(R.string.cancel, null)
            .create()
    }

    @JvmStatic
    fun getUpdateDialog(context: Context, info: MyPlanet?, progressDialog: CustomProgressDialog?): AlertDialog.Builder {
        return AlertDialog.Builder(context, R.style.CustomAlertDialog)
            .setTitle(R.string.new_version_of_my_planet_available)
            .setMessage(R.string.download_first_to_continue)
            .setNeutralButton(R.string.upgrade_local) { _, _ ->
                startDownloadUpdate(context, UrlUtils.getApkUpdateUrl(info?.localapkpath), progressDialog)
            }
            .setPositiveButton(R.string.upgrade) { _, _ ->
                info?.apkpath?.let { startDownloadUpdate(context, it, progressDialog) }
            }
    }

    @JvmStatic
    fun startDownloadUpdate(context: Context, path: String, progressDialog: CustomProgressDialog?) {
        Service(context.applicationContext).checkCheckSum(object : Service.ChecksumCallback {
            override fun onMatch() {
                Utilities.toast(context, context.getString(R.string.apk_already_exists))
                FileUtils.installApk(context, path)
            }

            override fun onFail() {
                val urls = arrayListOf(path)
                if (progressDialog != null) {
                    progressDialog.setText(context.getString(R.string.downloading_file))
                    progressDialog.setCancelable(false)
                    progressDialog.show()
                }
                MyDownloadService.startService(context, "$urls", false)
            }
        }, path)
    }

    @JvmStatic
    fun getCustomProgressDialog(context: Context): CustomProgressDialog {
        return CustomProgressDialog(context)
    }

    class CustomProgressDialog(context: Context) {
        private val binding: DialogProgressBinding = DialogProgressBinding.inflate(LayoutInflater.from(context))
        private val dialogBuilder: AlertDialog.Builder = AlertDialog.Builder(context, R.style.CustomAlertDialog)
        private val progressBar = binding.progressBar
        private val progressText = binding.progressText
        private val progressTitle = binding.progressTitle
        private var dialog: AlertDialog? = null
        private var positiveButtonAction: (() -> Unit)? = null
        private var negativeButtonAction: (() -> Unit)? = null

        init {
            dialogBuilder.setView(binding.root)
            dialogBuilder.setCancelable(false)
            binding.buttonPositive.setOnClickListener {
                positiveButtonAction?.invoke()
            }
            binding.buttonNegative.setOnClickListener {
                negativeButtonAction?.invoke()
            }
        }
        fun setPositiveButton(text: String, isVisible: Boolean = true, listener: () -> Unit) {
            binding.buttonPositive.text = text
            positiveButtonAction = listener
            binding.buttonPositive.visibility = if (isVisible) View.VISIBLE else View.GONE
        }

        fun setNegativeButton(text: String = "Cancel", isVisible: Boolean = true, listener: () -> Unit) {
            binding.buttonNegative.text = text
            negativeButtonAction = listener
            binding.buttonNegative.visibility = if (isVisible) View.VISIBLE else View.GONE
        }

        fun show() {
            if (dialog == null) {
                dialog = dialogBuilder.create()
            }
            if (dialog?.isShowing == false) {
                dialog?.show()
            }
        }

        fun dismiss() {
            dialog?.dismiss()
        }

        fun setCancelable(state: Boolean) {
            dialog?.setCancelable(state)
        }

        private fun setIndeterminate() {
            progressBar.isIndeterminate = false
        }

        fun setMax(maxValue: Int) {
            progressBar.max = maxValue
        }

        fun setProgress(value: Int) {
            setIndeterminate()
            progressBar.progress = value
        }

        fun setText(text: String) {
            progressText.text = text
            progressText.visibility = View.VISIBLE
        }

        fun setTitle(text: String?) {
            progressTitle.visibility = View.VISIBLE
            progressTitle.text = text
        }
        fun isShowing(): Boolean {
            return dialog?.isShowing == true
        }

        fun disableNegativeButton() {
            binding.buttonNegative.isEnabled = false
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.app.Activity
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.provider.Settings
import android.view.ContextThemeWrapper
import android.view.LayoutInflater
import android.view.View
import androidx.appcompat.app.AlertDialog
import com.google.android.material.snackbar.Snackbar
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.databinding.DialogProgressBinding
import org.ole.planet.myplanet.datamanager.MyDownloadService
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.sync.SyncActivity
import org.ole.planet.myplanet.ui.userprofile.BecomeMemberActivity

object DialogUtils {
    @JvmStatic
    fun getProgressDialog(context: Context): CustomProgressDialog {
        val prgDialog = CustomProgressDialog(context)
        prgDialog.setTitle(context.getString(R.string.downloading_file))
        prgDialog.setMax(100)
        prgDialog.setNegativeButton(context.getString(R.string.stop_download), isVisible = true) {
            context.stopService(Intent(context, MyDownloadService::class.java))
            prgDialog.dismiss()
        }
        return prgDialog
    }

    fun guestDialog(context: Context) {
        val profileDbHandler = UserProfileDbHandler(context)
        val builder = android.app.AlertDialog.Builder(context, R.style.CustomAlertDialog)
        builder.setTitle(context.getString(R.string.become_a_member))
        builder.setMessage(context.getString(R.string.to_access_this_feature_become_a_member))
        builder.setCancelable(false)
        builder.setPositiveButton(context.getString(R.string.become_a_member), null)
        builder.setNegativeButton(context.getString(R.string.cancel), null)

        val dialog = builder.create()
        dialog.show()

        val becomeMember = dialog.getButton(android.app.AlertDialog.BUTTON_POSITIVE)
        val cancel = dialog.getButton(android.app.AlertDialog.BUTTON_NEGATIVE)
        becomeMember.contentDescription = context.getString(R.string.confirm_membership)
        cancel.contentDescription = context.getString(R.string.cancel)

        becomeMember.setOnClickListener {
            val guest = true
            val intent = Intent(context, BecomeMemberActivity::class.java)
            intent.putExtra("username", profileDbHandler.userModel?.name)
            intent.putExtra("guest", guest)
            context.startActivity(intent)
        }
        cancel.setOnClickListener {
            dialog.dismiss()
        }
    }

    @JvmStatic
    fun showError(prgDialog: CustomProgressDialog?, message: String?) {
        prgDialog?.setTitle(message)
        prgDialog?.disableNegativeButton()
    }

    @JvmStatic
    fun showWifiSettingDialog(context: Context) {
        if (!NetworkUtils.isWifiBluetoothEnabled()) return
        showDialog(context)
    }

    private fun showDialog(context: Context) {
        if (MainApplication.syncFailedCount > 3) {
            val pd = AlertDialog.Builder(context, R.style.AlertDialogTheme)
            var message = ""
            if (NetworkUtils.isBluetoothEnabled()) message += "Bluetooth"
            if (NetworkUtils.isWifiEnabled()) {
                if (message.isNotEmpty()) message += " and "
                    message += "Wi-Fi"
            }
            if (message.isNotEmpty()) {
            message += context.getString(R.string.is_on_please_turn_of_to_save_battery)
            } else {
            message = context.getString(R.string.is_on_please_turn_of_to_save_battery)
            }
            pd.setMessage(message)
            pd.setPositiveButton(context.getString(R.string.go_to_settings)) { _, _ ->
                MainApplication.syncFailedCount = 0
                val intent = Intent(Settings.ACTION_WIFI_SETTINGS)
                context.startActivity(intent)
            }.setNegativeButton(context.getString(R.string.cancel), null)
            pd.setCancelable(false)
            val d = pd.create()
            d.show()
        }
    }

    @JvmStatic
    fun showSnack(v: View?, s: String?) {
        if (v != null) {
            s?.let { Snackbar.make(v, it, Snackbar.LENGTH_LONG).show() }
        }
    }

    @JvmStatic
    fun showAlert(context: Context?, title: String?, message: String?) {
        if (context is Activity && !context.isFinishing) {
            AlertDialog.Builder(context, R.style.AlertDialogTheme)
                .setTitle(title)
                .setMessage(message)
                .setPositiveButton(R.string.finish) { _, _ ->
                    if (context is SyncActivity && message == context.getString(R.string.invalid_configuration)) {
                        context.settingDialog()
                    }
                }
                .show()
        }
    }

    @JvmStatic
    fun getDialog(
        context: Context,
        message: String,
        pos: String,
        listener: DialogInterface.OnClickListener?
    ): AlertDialog {
        return AlertDialog.Builder(ContextThemeWrapper(context, R.style.CustomAlertDialog))
            .setMessage(message)
            .setIcon(R.drawable.courses)
            .setPositiveButton(pos, listener)
            .setNegativeButton(R.string.button_cancel, null)
            .create()
    }

    @JvmStatic
    fun getDialog(context: Context, title: String, v: View): AlertDialog {
        return AlertDialog.Builder(ContextThemeWrapper(context, R.style.CustomAlertDialog))
            .setTitle(title)
            .setIcon(R.drawable.ic_edit)
            .setView(v)
            .setPositiveButton(R.string.submit, null)
            .setNegativeButton(R.string.cancel, null)
            .create()
    }

    @JvmStatic
    fun getUpdateDialog(context: Context, info: MyPlanet?, progressDialog: CustomProgressDialog?): AlertDialog.Builder {
        return AlertDialog.Builder(context, R.style.CustomAlertDialog)
            .setTitle(R.string.new_version_of_my_planet_available)
            .setMessage(R.string.download_first_to_continue)
            .setNeutralButton(R.string.upgrade_local) { _, _ ->
                startDownloadUpdate(context, UrlUtils.getApkUpdateUrl(info?.localapkpath), progressDialog)
            }
            .setPositiveButton(R.string.upgrade) { _, _ ->
                info?.apkpath?.let { startDownloadUpdate(context, it, progressDialog) }
            }
    }

    @JvmStatic
    fun startDownloadUpdate(context: Context, path: String, progressDialog: CustomProgressDialog?) {
        Service(context.applicationContext).checkCheckSum(object : Service.ChecksumCallback {
            override fun onMatch() {
                Utilities.toast(context, context.getString(R.string.apk_already_exists))
                FileUtils.installApk(context, path)
            }

            override fun onFail() {
                val urls = arrayListOf(path)
                if (progressDialog != null) {
                    progressDialog.setText(context.getString(R.string.downloading_file))
                    progressDialog.setCancelable(false)
                    progressDialog.show()
                }
                MyDownloadService.startService(context, "$urls", false)
            }
        }, path)
    }

    @JvmStatic
    fun getCustomProgressDialog(context: Context): CustomProgressDialog {
        return CustomProgressDialog(context)
    }

    class CustomProgressDialog(context: Context) {
        private val binding: DialogProgressBinding = DialogProgressBinding.inflate(LayoutInflater.from(context))
        private val dialogBuilder: AlertDialog.Builder = AlertDialog.Builder(context, R.style.CustomAlertDialog)
        private val progressBar = binding.progressBar
        private val progressText = binding.progressText
        private val progressTitle = binding.progressTitle
        private var dialog: AlertDialog? = null
        private var positiveButtonAction: (() -> Unit)? = null
        private var negativeButtonAction: (() -> Unit)? = null

        init {
            dialogBuilder.setView(binding.root)
            dialogBuilder.setCancelable(false)
            binding.buttonPositive.setOnClickListener {
                positiveButtonAction?.invoke()
            }
            binding.buttonNegative.setOnClickListener {
                negativeButtonAction?.invoke()
            }
        }
        fun setPositiveButton(text: String, isVisible: Boolean = true, listener: () -> Unit) {
            binding.buttonPositive.text = text
            positiveButtonAction = listener
            binding.buttonPositive.visibility = if (isVisible) View.VISIBLE else View.GONE
        }

        fun setNegativeButton(text: String = "Cancel", isVisible: Boolean = true, listener: () -> Unit) {
            binding.buttonNegative.text = text
            negativeButtonAction = listener
            binding.buttonNegative.visibility = if (isVisible) View.VISIBLE else View.GONE
        }

        fun show() {
            if (dialog == null) {
                dialog = dialogBuilder.create()
            }
            if (dialog?.isShowing == false) {
                dialog?.show()
            }
        }

        fun dismiss() {
            dialog?.dismiss()
        }

        fun setCancelable(state: Boolean) {
            dialog?.setCancelable(state)
        }

        private fun setIndeterminate() {
            progressBar.isIndeterminate = false
        }

        fun setMax(maxValue: Int) {
            progressBar.max = maxValue
        }

        fun setProgress(value: Int) {
            setIndeterminate()
            progressBar.progress = value
        }

        fun setText(text: String) {
            progressText.text = text
            progressText.visibility = View.VISIBLE
        }

        fun setTitle(text: String?) {
            progressTitle.visibility = View.VISIBLE
            progressTitle.text = text
        }
        fun isShowing(): Boolean {
            return dialog?.isShowing == true
        }

        fun disableNegativeButton() {
            binding.buttonNegative.isEnabled = false
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/CustomSpinner.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.util.AttributeSet
import androidx.appcompat.widget.AppCompatSpinner

class CustomSpinner(context: Context, attrs: AttributeSet?) : AppCompatSpinner(context, attrs) {
    private var listener: OnItemSelectedListener? = null

    override fun setSelection(position: Int) {
        super.setSelection(position)
        listener?.onItemSelected(null, null, position, 0)
    }

    fun onSameItemSelected(listener: OnItemSelectedListener) {
        this.listener = listener
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.util.AttributeSet
import androidx.appcompat.widget.AppCompatSpinner

class CustomSpinner(context: Context, attrs: AttributeSet?) : AppCompatSpinner(context, attrs) {
    private var listener: OnItemSelectedListener? = null

    override fun setSelection(position: Int) {
        super.setSelection(position)
        listener?.onItemSelected(null, null, position, 0)
    }

    fun onSameItemSelected(listener: OnItemSelectedListener) {
        this.listener = listener
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/DiffUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import androidx.recyclerview.widget.DiffUtil as RecyclerDiffUtil

object DiffUtils {
    fun <T : Any> itemCallback(
        areItemsTheSame: (oldItem: T, newItem: T) -> Boolean,
        areContentsTheSame: (oldItem: T, newItem: T) -> Boolean
    ): RecyclerDiffUtil.ItemCallback<T> {
        return object : RecyclerDiffUtil.ItemCallback<T>() {
            override fun areItemsTheSame(oldItem: T, newItem: T) = areItemsTheSame(oldItem, newItem)
            override fun areContentsTheSame(oldItem: T, newItem: T) = areContentsTheSame(oldItem, newItem)
        }
    }

    fun <T> calculateDiff(
        oldList: List<T>,
        newList: List<T>,
        areItemsTheSame: (oldItem: T, newItem: T) -> Boolean,
        areContentsTheSame: (oldItem: T, newItem: T) -> Boolean,
        getChangePayload: ((oldItem: T, newItem: T) -> Any?)? = null
    ): RecyclerDiffUtil.DiffResult {
        val callback = object : RecyclerDiffUtil.Callback() {
            override fun getOldListSize() = oldList.size
            override fun getNewListSize() = newList.size
            override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int) =
                areItemsTheSame(oldList[oldItemPosition], newList[newItemPosition])

            override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int) =
                areContentsTheSame(oldList[oldItemPosition], newList[newItemPosition])

            override fun getChangePayload(oldItemPosition: Int, newItemPosition: Int): Any? {
                return getChangePayload?.invoke(oldList[oldItemPosition], newList[newItemPosition])
            }
        }
        return RecyclerDiffUtil.calculateDiff(callback)
    }
}
=======
package org.ole.planet.myplanet.utilities


import androidx.recyclerview.widget.DiffUtil as RecyclerDiffUtil

object DiffUtils {
    fun <T : Any> itemCallback(
        areItemsTheSame: (oldItem: T, newItem: T) -> Boolean,
        areContentsTheSame: (oldItem: T, newItem: T) -> Boolean
    ): RecyclerDiffUtil.ItemCallback<T> {
        return object : RecyclerDiffUtil.ItemCallback<T>() {
            override fun areItemsTheSame(oldItem: T, newItem: T) = areItemsTheSame(oldItem, newItem)
            override fun areContentsTheSame(oldItem: T, newItem: T) = areContentsTheSame(oldItem, newItem)
        }
    }

    fun <T> calculateDiff(
        oldList: List<T>,
        newList: List<T>,
        areItemsTheSame: (oldItem: T, newItem: T) -> Boolean,
        areContentsTheSame: (oldItem: T, newItem: T) -> Boolean,
        getChangePayload: ((oldItem: T, newItem: T) -> Any?)? = null
    ): RecyclerDiffUtil.DiffResult {
        val callback = object : RecyclerDiffUtil.Callback() {
            override fun getOldListSize() = oldList.size
            override fun getNewListSize() = newList.size
            override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int) =
                areItemsTheSame(oldList[oldItemPosition], newList[newItemPosition])

            override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int) =
                areContentsTheSame(oldList[oldItemPosition], newList[newItemPosition])

            override fun getChangePayload(oldItemPosition: Int, newItemPosition: Int): Any? {
                return getChangePayload?.invoke(oldList[oldItemPosition], newList[newItemPosition])
            }
        }
        return RecyclerDiffUtil.calculateDiff(callback)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/JsonUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import com.google.gson.JsonArray
import com.google.gson.JsonElement
import com.google.gson.JsonNull
import com.google.gson.JsonObject
import com.google.gson.JsonParser.parseString
import io.realm.RealmList

object JsonUtils {
    @JvmStatic
    fun getString(fieldName: String, jsonObject: JsonObject?): String {
        return try {
            if (jsonObject?.has(fieldName) == true) {
                val el: JsonElement = jsonObject.get(fieldName)
                if (el is JsonNull) {
                    ""
                } else if (el.isJsonPrimitive && el.asJsonPrimitive.isString) {
                    el.asString
                } else {
                    ""
                }
            } else {
                ""
            }
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }
    }

    @JvmStatic
    fun getString(array: JsonArray, index: Int): String {
        return try {
            val el: JsonElement = array.get(index)
            if (el is JsonNull) "" else el.asString
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }
    }

    @JvmStatic
    fun getAsJsonArray(list: RealmList<String>?): JsonArray {
        val array = JsonArray()
        list?.forEach { s -> array.add(s) }
        return array
    }

    @JvmStatic
    fun getStringAsJsonArray(s: String?): JsonArray {
        val arrayElement = parseString(s)
        return arrayElement.asJsonArray
    }

    @JvmStatic
    fun getBoolean(fieldName: String, jsonObject: JsonObject?): Boolean {
        return try {
            if (jsonObject?.has(fieldName) == true) {
                val el: JsonElement? = jsonObject.get(fieldName)
                el !is JsonNull && el?.asBoolean == true
            } else {
                false
            }
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    @JvmStatic
    fun addString(`object`: JsonObject, fieldName: String, value: String?) {
        if (!value.isNullOrEmpty()) `object`.addProperty(fieldName, value)
    }

    @JvmStatic
    fun addLong(`object`: JsonObject, fieldName: String, value: Long) {
        if (value > 0) `object`.addProperty(fieldName, value)
    }

    @JvmStatic
    fun addInteger(`object`: JsonObject, fieldName: String, value: Int) {
        if (value != 0) `object`.addProperty(fieldName, value)
    }

    @JvmStatic
    fun addFloat(`object`: JsonObject, fieldName: String, value: Float) {
        if (value != 0f) `object`.addProperty(fieldName, value)
    }

    @JvmStatic
    fun addJson(`object`: JsonObject, fieldName: String, value: JsonObject?) {
        if (value != null && value.keySet().size > 0) `object`.add(fieldName, value)
    }

    @JvmStatic
    fun getInt(fieldName: String, jsonObject: JsonObject?): Int {
        return try {
            if (jsonObject?.has(fieldName) == true) {
                val el: JsonElement = jsonObject.get(fieldName)
                if (el is JsonNull || el.asString.isEmpty()) 0 else el.asInt
            } else {
                0
            }
        } catch (e: Exception) {
            e.printStackTrace()
            0
        }
    }

    @JvmStatic
    fun getFloat(fieldName: String, jsonObject: JsonObject?): Float {
        return try {
            if (jsonObject?.has(fieldName) == true) {
                val el: JsonElement = jsonObject.get(fieldName)
                if (el is JsonNull || el.asString.isEmpty()) 0f else el.asFloat
            } else {
                getInt(fieldName, jsonObject).toFloat()
            }
        } catch (e: Exception) {
            e.printStackTrace()
            0f
        }
    }

    @JvmStatic
    fun getJsonArray(fieldName: String, jsonObject: JsonObject?): JsonArray {
        return try {
            val array: JsonElement? = jsonObject?.let {
                getJsonElement(fieldName, it, JsonArray::class.java)
            }
            if (array is JsonNull || array !is JsonArray) JsonArray() else array.asJsonArray
        } catch (e: Exception) {
            e.printStackTrace()
            JsonArray()
        }
    }

    @JvmStatic
    fun getJsonObject(fieldName: String, jsonObject: JsonObject?): JsonObject {
        return try {
            val el: JsonElement? = jsonObject?.let {
                getJsonElement(fieldName, it, JsonObject::class.java)
            }
            if (el is JsonObject) el else JsonObject()
        } catch (e: Exception) {
            e.printStackTrace()
            JsonObject()
        }
    }

    @JvmStatic
    fun getJsonElement(fieldName: String, jsonObject: JsonObject, type: Class<*>): JsonElement {
        return try {
            val jsonElement: JsonElement = if (type == JsonObject::class.java) JsonObject() else JsonArray()
            if (jsonObject.has(fieldName)) {
                jsonObject.get(fieldName)
            } else {
                jsonElement
            }
        } catch (e: Exception) {
            e.printStackTrace()
            JsonObject()
        }
    }

    @JvmStatic
    fun getLong(fieldName: String, jsonObject: JsonObject?): Long {
        return try {
            if (jsonObject?.has(fieldName) == true) {
                val el: JsonElement = jsonObject.get(fieldName)
                if (el is JsonNull) 0L else el.asLong
            } else {
                0L
            }
        } catch (e: Exception) {
            e.printStackTrace()
            0L
        }
    }
}
=======
package org.ole.planet.myplanet.utilities


import com.google.gson.JsonArray
import com.google.gson.JsonElement
import com.google.gson.JsonNull
import com.google.gson.JsonObject
import com.google.gson.JsonParser.parseString
import io.realm.RealmList

object JsonUtils {
    @JvmStatic
    fun getString(fieldName: String, jsonObject: JsonObject?): String {
        return try {
            if (jsonObject?.has(fieldName) == true) {
                val el: JsonElement = jsonObject.get(fieldName)
                if (el is JsonNull) {
                    ""
                } else if (el.isJsonPrimitive && el.asJsonPrimitive.isString) {
                    el.asString
                } else {
                    ""
                }
            } else {
                ""
            }
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }
    }

    @JvmStatic
    fun getString(array: JsonArray, index: Int): String {
        return try {
            val el: JsonElement = array.get(index)
            if (el is JsonNull) "" else el.asString
        } catch (e: Exception) {
            e.printStackTrace()
            ""
        }
    }

    @JvmStatic
    fun getAsJsonArray(list: RealmList<String>?): JsonArray {
        val array = JsonArray()
        list?.forEach { s -> array.add(s) }
        return array
    }

    @JvmStatic
    fun getStringAsJsonArray(s: String?): JsonArray {
        val arrayElement = parseString(s)
        return arrayElement.asJsonArray
    }

    @JvmStatic
    fun getBoolean(fieldName: String, jsonObject: JsonObject?): Boolean {
        return try {
            if (jsonObject?.has(fieldName) == true) {
                val el: JsonElement? = jsonObject.get(fieldName)
                el !is JsonNull && el?.asBoolean == true
            } else {
                false
            }
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    @JvmStatic
    fun addString(`object`: JsonObject, fieldName: String, value: String?) {
        if (!value.isNullOrEmpty()) `object`.addProperty(fieldName, value)
    }

    @JvmStatic
    fun addLong(`object`: JsonObject, fieldName: String, value: Long) {
        if (value > 0) `object`.addProperty(fieldName, value)
    }

    @JvmStatic
    fun addInteger(`object`: JsonObject, fieldName: String, value: Int) {
        if (value != 0) `object`.addProperty(fieldName, value)
    }

    @JvmStatic
    fun addFloat(`object`: JsonObject, fieldName: String, value: Float) {
        if (value != 0f) `object`.addProperty(fieldName, value)
    }

    @JvmStatic
    fun addJson(`object`: JsonObject, fieldName: String, value: JsonObject?) {
        if (value != null && value.keySet().size > 0) `object`.add(fieldName, value)
    }

    @JvmStatic
    fun getInt(fieldName: String, jsonObject: JsonObject?): Int {
        return try {
            if (jsonObject?.has(fieldName) == true) {
                val el: JsonElement = jsonObject.get(fieldName)
                if (el is JsonNull || el.asString.isEmpty()) 0 else el.asInt
            } else {
                0
            }
        } catch (e: Exception) {
            e.printStackTrace()
            0
        }
    }

    @JvmStatic
    fun getFloat(fieldName: String, jsonObject: JsonObject?): Float {
        return try {
            if (jsonObject?.has(fieldName) == true) {
                val el: JsonElement = jsonObject.get(fieldName)
                if (el is JsonNull || el.asString.isEmpty()) 0f else el.asFloat
            } else {
                getInt(fieldName, jsonObject).toFloat()
            }
        } catch (e: Exception) {
            e.printStackTrace()
            0f
        }
    }

    @JvmStatic
    fun getJsonArray(fieldName: String, jsonObject: JsonObject?): JsonArray {
        return try {
            val array: JsonElement? = jsonObject?.let {
                getJsonElement(fieldName, it, JsonArray::class.java)
            }
            if (array is JsonNull || array !is JsonArray) JsonArray() else array.asJsonArray
        } catch (e: Exception) {
            e.printStackTrace()
            JsonArray()
        }
    }

    @JvmStatic
    fun getJsonObject(fieldName: String, jsonObject: JsonObject?): JsonObject {
        return try {
            val el: JsonElement? = jsonObject?.let {
                getJsonElement(fieldName, it, JsonObject::class.java)
            }
            if (el is JsonObject) el else JsonObject()
        } catch (e: Exception) {
            e.printStackTrace()
            JsonObject()
        }
    }

    @JvmStatic
    fun getJsonElement(fieldName: String, jsonObject: JsonObject, type: Class<*>): JsonElement {
        return try {
            val jsonElement: JsonElement = if (type == JsonObject::class.java) JsonObject() else JsonArray()
            if (jsonObject.has(fieldName)) {
                jsonObject.get(fieldName)
            } else {
                jsonElement
            }
        } catch (e: Exception) {
            e.printStackTrace()
            JsonObject()
        }
    }

    @JvmStatic
    fun getLong(fieldName: String, jsonObject: JsonObject?): Long {
        return try {
            if (jsonObject?.has(fieldName) == true) {
                val el: JsonElement = jsonObject.get(fieldName)
                if (el is JsonNull) 0L else el.asLong
            } else {
                0L
            }
        } catch (e: Exception) {
            e.printStackTrace()
            0L
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/CheckboxListView.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import android.util.AttributeSet
import android.view.View
import android.widget.AdapterView
import android.widget.ListView

class CheckboxListView : ListView, AdapterView.OnItemClickListener {
    @JvmField
    var selectedItemsList = ArrayList<Int>()
    var listener: CheckChangeListener? = null

    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) {
        onItemClickListener = this
    }

    fun interface CheckChangeListener {
        fun onCheckChange()
    }

    fun setCheckChangeListener(listener: CheckChangeListener?) {
        this.listener = listener
    }

    constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : super(
        context,
        attrs,
        defStyleAttr
    )

    constructor(context: Context?) : super(context) {
        onItemClickListener = this
    }

    override fun onItemClick(adapterView: AdapterView<*>?, view: View, i: Int, l: Long) {
        if (selectedItemsList.contains(i)) {
            selectedItemsList.remove(i)
        } else {
            selectedItemsList.add(i)
        }
        if (listener != null) listener?.onCheckChange()
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import android.util.AttributeSet
import android.view.View
import android.widget.AdapterView
import android.widget.ListView

class CheckboxListView : ListView, AdapterView.OnItemClickListener {
    @JvmField
    var selectedItemsList = ArrayList<Int>()
    var listener: CheckChangeListener? = null

    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs) {
        onItemClickListener = this
    }

    fun interface CheckChangeListener {
        fun onCheckChange()
    }

    fun setCheckChangeListener(listener: CheckChangeListener?) {
        this.listener = listener
    }

    constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : super(
        context,
        attrs,
        defStyleAttr
    )

    constructor(context: Context?) : super(context) {
        onItemClickListener = this
    }

    override fun onItemClick(adapterView: AdapterView<*>?, view: View, i: Int, l: Long) {
        if (selectedItemsList.contains(i)) {
            selectedItemsList.remove(i)
        } else {
            selectedItemsList.add(i)
        }
        if (listener != null) listener?.onCheckChange()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/SyncTimeLogger.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.Context
import androidx.core.net.toUri
import java.util.Locale
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.TimeUnit
import kotlin.math.roundToInt
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.service.UploadManager

object SyncTimeLogger {
    private val processTimes = ConcurrentHashMap<String, Long>()
    private val processItemCounts = ConcurrentHashMap<String, Int>()
    private var startTime: Long = 0
    private var endTime: Long = 0
    private var isLogging = false

    fun startLogging() {
        startTime = System.currentTimeMillis()
        isLogging = true
        processTimes.clear()
        processItemCounts.clear()
    }

    fun stopLogging(uploadManager: UploadManager? = null) {
        if (!isLogging) return

        endTime = System.currentTimeMillis()
        isLogging = false
        val summary = generateSummary()
        saveSummaryToRealm(summary, uploadManager)
    }

    private fun saveSummaryToRealm(summary: String, uploadManager: UploadManager? = null) {
        val settings = MainApplication.context.getSharedPreferences(Constants.PREFS_NAME, Context.MODE_PRIVATE)
        MainApplication.applicationScope.launch(Dispatchers.IO) {
            MainApplication.createLog("sync summary", summary)
            val updateUrl = "${settings.getString("serverURL", "")}"
            val serverUrlMapper = ServerUrlMapper()
            val mapping = serverUrlMapper.processUrl(updateUrl)

            val primaryAvailable = MainApplication.isServerReachable(mapping.primaryUrl)
            val alternativeAvailable =
                mapping.alternativeUrl?.let { MainApplication.isServerReachable(it) } == true

            if (!primaryAvailable && alternativeAvailable) {
                mapping.alternativeUrl?.let { alternativeUrl ->
                    val uri = updateUrl.toUri()
                    val editor = settings.edit()


                    serverUrlMapper.updateUrlPreferences(
                        editor,
                        uri,
                        alternativeUrl,
                        mapping.primaryUrl,
                        settings
                    )
                }
            }
            try {
                uploadManager?.uploadCrashLog()
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun startProcess(processName: String) {
        if (!isLogging) return

        val key = "$processName:start"
        processTimes[key] = System.currentTimeMillis()
    }

    fun endProcess(processName: String, itemCount: Int = 0) {
        if (!isLogging) return

        val startKey = "$processName:start"
        val endTime = System.currentTimeMillis()

        if (!processTimes.containsKey(startKey)) {
            return
        }

        val startTime = processTimes[startKey] ?: return
        val duration = endTime - startTime

        processTimes[processName] = duration
        processItemCounts[processName] = itemCount
    }

    private fun generateSummary(): String {
        val totalDuration = endTime - startTime
        val totalMinutes = TimeUnit.MILLISECONDS.toMinutes(totalDuration)
        val totalSeconds = TimeUnit.MILLISECONDS.toSeconds(totalDuration) % 60

        val summaryBuilder = StringBuilder()
        summaryBuilder.append("=== SYNC TIME SUMMARY ===\n")
        summaryBuilder.append("Total sync time: $totalMinutes min $totalSeconds sec (${formatTime(totalDuration)})\n")
        summaryBuilder.append("Individual process times:\n")

        processTimes.entries
            .filter { !it.key.endsWith(":start") }
            .sortedByDescending { it.value }
            .forEach { (process, duration) ->
                val percentage = (duration.toDouble() / totalDuration.toDouble() * 100).roundToInt()
                val itemCount = processItemCounts[process] ?: 0

                if (itemCount > 0) {
                    val itemsPerSecond = if (duration > 0) (itemCount * 1000.0 / duration).toInt() else 0
                    summaryBuilder.append(String.format(Locale.US, "%-30s: %10s (%3d%%) - %d items at %d items/sec\n",
                        process, formatTime(duration), percentage, itemCount, itemsPerSecond
                    ))
                } else {
                    summaryBuilder.append(String.format(Locale.US,"%-30s: %10s (%3d%%)\n",
                        process, formatTime(duration), percentage))
                }
            }

        summaryBuilder.append("=========================")
        return summaryBuilder.toString()
    }

    private fun formatTime(timeMs: Long): String {
        return when {
            timeMs < 1000 -> "${timeMs}ms"
            timeMs < 60000 -> String.format(Locale.US, "%.2fs", timeMs / 1000.0)
            else -> {
                val minutes = TimeUnit.MILLISECONDS.toMinutes(timeMs)
                val seconds = TimeUnit.MILLISECONDS.toSeconds(timeMs) % 60
                val millis = timeMs % 1000
                "${minutes}m ${seconds}.${millis}s"
            }
        }
    }

}
=======
package org.ole.planet.myplanet.utilities


import android.content.Context
import androidx.core.net.toUri
import java.util.Locale
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.TimeUnit
import kotlin.math.roundToInt
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.service.UploadManager

object SyncTimeLogger {
    private val processTimes = ConcurrentHashMap<String, Long>()
    private val processItemCounts = ConcurrentHashMap<String, Int>()
    private var startTime: Long = 0
    private var endTime: Long = 0
    private var isLogging = false

    fun startLogging() {
        startTime = System.currentTimeMillis()
        isLogging = true
        processTimes.clear()
        processItemCounts.clear()
    }

    fun stopLogging(uploadManager: UploadManager? = null) {
        if (!isLogging) return

        endTime = System.currentTimeMillis()
        isLogging = false
        val summary = generateSummary()
        saveSummaryToRealm(summary, uploadManager)
    }

    private fun saveSummaryToRealm(summary: String, uploadManager: UploadManager? = null) {
        val settings = MainApplication.context.getSharedPreferences(Constants.PREFS_NAME, Context.MODE_PRIVATE)
        MainApplication.applicationScope.launch(Dispatchers.IO) {
            MainApplication.createLog("sync summary", summary)
            val updateUrl = "${settings.getString("serverURL", "")}"
            val serverUrlMapper = ServerUrlMapper()
            val mapping = serverUrlMapper.processUrl(updateUrl)

            val primaryAvailable = MainApplication.isServerReachable(mapping.primaryUrl)
            val alternativeAvailable =
                mapping.alternativeUrl?.let { MainApplication.isServerReachable(it) } == true

            if (!primaryAvailable && alternativeAvailable) {
                mapping.alternativeUrl?.let { alternativeUrl ->
                    val uri = updateUrl.toUri()
                    val editor = settings.edit()


                    serverUrlMapper.updateUrlPreferences(
                        editor,
                        uri,
                        alternativeUrl,
                        mapping.primaryUrl,
                        settings
                    )
                }
            }
            try {
                uploadManager?.uploadCrashLog()
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun startProcess(processName: String) {
        if (!isLogging) return

        val key = "$processName:start"
        processTimes[key] = System.currentTimeMillis()
    }

    fun endProcess(processName: String, itemCount: Int = 0) {
        if (!isLogging) return

        val startKey = "$processName:start"
        val endTime = System.currentTimeMillis()

        if (!processTimes.containsKey(startKey)) {
            return
        }

        val startTime = processTimes[startKey] ?: return
        val duration = endTime - startTime

        processTimes[processName] = duration
        processItemCounts[processName] = itemCount
    }

    private fun generateSummary(): String {
        val totalDuration = endTime - startTime
        val totalMinutes = TimeUnit.MILLISECONDS.toMinutes(totalDuration)
        val totalSeconds = TimeUnit.MILLISECONDS.toSeconds(totalDuration) % 60

        val summaryBuilder = StringBuilder()
        summaryBuilder.append("=== SYNC TIME SUMMARY ===\n")
        summaryBuilder.append("Total sync time: $totalMinutes min $totalSeconds sec (${formatTime(totalDuration)})\n")
        summaryBuilder.append("Individual process times:\n")

        processTimes.entries
            .filter { !it.key.endsWith(":start") }
            .sortedByDescending { it.value }
            .forEach { (process, duration) ->
                val percentage = (duration.toDouble() / totalDuration.toDouble() * 100).roundToInt()
                val itemCount = processItemCounts[process] ?: 0

                if (itemCount > 0) {
                    val itemsPerSecond = if (duration > 0) (itemCount * 1000.0 / duration).toInt() else 0
                    summaryBuilder.append(String.format(Locale.US, "%-30s: %10s (%3d%%) - %d items at %d items/sec\n",
                        process, formatTime(duration), percentage, itemCount, itemsPerSecond
                    ))
                } else {
                    summaryBuilder.append(String.format(Locale.US,"%-30s: %10s (%3d%%)\n",
                        process, formatTime(duration), percentage))
                }
            }

        summaryBuilder.append("=========================")
        return summaryBuilder.toString()
    }

    private fun formatTime(timeMs: Long): String {
        return when {
            timeMs < 1000 -> "${timeMs}ms"
            timeMs < 60000 -> String.format(Locale.US, "%.2fs", timeMs / 1000.0)
            else -> {
                val minutes = TimeUnit.MILLISECONDS.toMinutes(timeMs)
                val seconds = TimeUnit.MILLISECONDS.toSeconds(timeMs) % 60
                val millis = timeMs % 1000
                "${minutes}m ${seconds}.${millis}s"
            }
        }
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/utilities/DimenUtils.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.utilities

import android.content.res.Resources
import android.util.DisplayMetrics
import kotlin.math.roundToInt

object DimenUtils {
    @JvmStatic
    fun dpToPx(dp: Int): Int {
        val displayMetrics = Resources.getSystem().displayMetrics
        return (dp * (displayMetrics.xdpi / DisplayMetrics.DENSITY_DEFAULT)).roundToInt()
    }
}
=======
package org.ole.planet.myplanet.utilities


import android.content.res.Resources
import android.util.DisplayMetrics
import kotlin.math.roundToInt

object DimenUtils {
    @JvmStatic
    fun dpToPx(dp: Int): Int {
        val displayMetrics = Resources.getSystem().displayMetrics
        return (dp * (displayMetrics.xdpi / DisplayMetrics.DENSITY_DEFAULT)).roundToInt()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/TeamRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import android.content.SharedPreferences
import androidx.core.net.toUri
import com.google.gson.Gson
import com.google.gson.JsonObject
import java.util.Calendar
import java.util.Date
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmTeamLog
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.AndroidDecrypter
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper

class TeamRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
    private val userProfileDbHandler: UserProfileDbHandler,
    private val uploadManager: UploadManager,
    private val gson: Gson,
    @AppPreferences private val preferences: SharedPreferences,
    private val serverUrlMapper: ServerUrlMapper,
) : RealmRepository(databaseService), TeamRepository {

    override suspend fun getShareableTeams(): List<RealmMyTeam> {
        return queryList(RealmMyTeam::class.java) {
            isEmpty("teamId")
            notEqualTo("status", "archived")
            equalTo("type", "team")
        }
    }

    override suspend fun getShareableEnterprises(): List<RealmMyTeam> {
        return queryList(RealmMyTeam::class.java) {
            isEmpty("teamId")
            notEqualTo("status", "archived")
            equalTo("type", "enterprise")
        }
    }

    override suspend fun getTeamResources(teamId: String): List<RealmMyLibrary> {
        val resourceIds = getResourceIds(teamId)
        return if (resourceIds.isEmpty()) {
            emptyList()
        } else {
            queryList(RealmMyLibrary::class.java) {
                `in`("resourceId", resourceIds.toTypedArray())
            }
        }
    }

    override suspend fun getTeamByDocumentIdOrTeamId(id: String): RealmMyTeam? {
        if (id.isBlank()) return null
        return findByField(RealmMyTeam::class.java, "_id", id)
            ?: findByField(RealmMyTeam::class.java, "teamId", id)
    }

    override suspend fun getTeamLinks(): List<RealmMyTeam> {
        return queryList(RealmMyTeam::class.java) {
            equalTo("docType", "link")
        }
    }

    override suspend fun getTeamById(teamId: String): RealmMyTeam? {
        if (teamId.isBlank()) return null
        return findByField(RealmMyTeam::class.java, "_id", teamId)
    }

    override suspend fun getTaskTeamInfo(taskId: String): Triple<String, String, String>? {
        return withRealm { realm ->
            val task = realm.where(RealmTeamTask::class.java)
                .equalTo("id", taskId)
                .findFirst()

            task?.let {
                val linkJson = org.json.JSONObject(it.link ?: "{}")
                val teamId = linkJson.optString("teams")
                if (teamId.isNotEmpty()) {
                    val teamObject = realm.where(RealmMyTeam::class.java).equalTo("_id", teamId).findFirst()
                    teamObject?.let { team ->
                        Triple(teamId, team.name ?: "", team.type ?: "")
                    }
                } else {
                    null
                }
            }
        }
    }

    override suspend fun getJoinRequestTeamId(requestId: String): String? {
        return withRealm { realm ->
            realm.where(RealmMyTeam::class.java)
                .equalTo("_id", requestId)
                .equalTo("docType", "request")
                .findFirst()?.teamId
        }
    }

    override suspend fun getTeamTransactions(
        teamId: String,
        startDate: Long?,
        endDate: Long?,
        sortAscending: Boolean,
    ): Flow<List<RealmMyTeam>> {
        return queryListFlow(RealmMyTeam::class.java) {
            equalTo("teamId", teamId)
            equalTo("docType", "transaction")
            notEqualTo("status", "archived")
            startDate?.let { greaterThanOrEqualTo("date", it) }
            endDate?.let { lessThanOrEqualTo("date", it) }
        }.map { transactions ->
            if (sortAscending) {
                transactions.sortedBy { it.date }
            } else {
                transactions.sortedByDescending { it.date }
            }
        }
    }

    override suspend fun createTransaction(
        teamId: String,
        type: String,
        note: String,
        amount: Int,
        date: Long,
        parentCode: String?,
        planetCode: String?,
    ): Result<Unit> {
        if (teamId.isBlank()) {
            return Result.failure(IllegalArgumentException("teamId cannot be blank"))
        }
        return runCatching {
            executeTransaction { realm ->
                val transaction = realm.createObject(RealmMyTeam::class.java, UUID.randomUUID().toString())
                transaction.status = "active"
                transaction.date = date
                transaction.type = type
                transaction.description = note
                transaction.teamId = teamId
                transaction.amount = amount
                transaction.parentCode = parentCode
                transaction.teamPlanetCode = planetCode
                transaction.teamType = "sync"
                transaction.docType = "transaction"
                transaction.updated = true
            }
        }
    }

    override suspend fun addReport(report: JsonObject) {
        executeTransaction { realm ->
            val reportId = JsonUtils.getString("_id", report)
            val reportEntry = realm.where(RealmMyTeam::class.java)
                .equalTo("_id", reportId)
                .findFirst()
                ?: realm.createObject(RealmMyTeam::class.java, reportId)
            RealmMyTeam.populateTeamFields(report, reportEntry)
        }
    }

    override suspend fun updateReport(reportId: String, payload: JsonObject) {
        if (reportId.isBlank()) return
        executeTransaction { realm ->
            val report = realm.where(RealmMyTeam::class.java)
                .equalTo("_id", reportId)
                .findFirst()
                ?: return@executeTransaction
            RealmMyTeam.populateReportFields(payload, report)
            report.updated = true
            if (report.updatedDate == 0L) {
                report.updatedDate = System.currentTimeMillis()
            }
        }
    }

    override suspend fun archiveReport(reportId: String) {
        if (reportId.isBlank()) return
        executeTransaction { realm ->
            realm.where(RealmMyTeam::class.java)
                .equalTo("_id", reportId)
                .findFirst()?.apply {
                    status = "archived"
                    updated = true
                }
        }
    }

    override suspend fun isMember(userId: String?, teamId: String): Boolean {
        userId ?: return false
        return count(RealmMyTeam::class.java) {
            equalTo("userId", userId)
            equalTo("teamId", teamId)
            equalTo("docType", "membership")
        } > 0
    }

    override suspend fun isTeamLeader(teamId: String, userId: String?): Boolean {
        if (teamId.isBlank() || userId.isNullOrBlank()) return false
        return count(RealmMyTeam::class.java) {
            equalTo("teamId", teamId)
            equalTo("docType", "membership")
            equalTo("userId", userId)
            equalTo("isLeader", true)
        } > 0
    }

    override suspend fun hasPendingRequest(teamId: String, userId: String?): Boolean {
        if (teamId.isBlank() || userId.isNullOrBlank()) return false
        return count(RealmMyTeam::class.java) {
            equalTo("docType", "request")
            equalTo("teamId", teamId)
            equalTo("userId", userId)
        } > 0
    }

    override suspend fun getTeamMemberStatuses(userId: String?, teamIds: Collection<String>): Map<String, TeamMemberStatus> {
        if (userId.isNullOrBlank() || teamIds.isEmpty()) return emptyMap()

        val validIds = teamIds.filter { it.isNotBlank() }.distinct()
        if (validIds.isEmpty()) return emptyMap()

        val memberships = queryList(RealmMyTeam::class.java) {
            equalTo("userId", userId)
            equalTo("docType", "membership")
            `in`("teamId", validIds.toTypedArray())
        }

        val pendingRequests = queryList(RealmMyTeam::class.java) {
            equalTo("userId", userId)
            equalTo("docType", "request")
            `in`("teamId", validIds.toTypedArray())
        }

        val membershipMap = memberships
            .mapNotNull { it.teamId }
            .toSet()

        val leaderMap = memberships
            .filter { it.isLeader }
            .mapNotNull { it.teamId }
            .toSet()

        val pendingRequestMap = pendingRequests
            .mapNotNull { it.teamId }
            .toSet()

        return validIds.associateWith { teamId ->
            TeamMemberStatus(
                isMember = teamId in membershipMap,
                isLeader = teamId in leaderMap,
                hasPendingRequest = teamId in pendingRequestMap
            )
        }
    }

    override suspend fun getRecentVisitCounts(teamIds: Collection<String>): Map<String, Long> {
        if (teamIds.isEmpty()) return emptyMap()

        val validIds = teamIds.filter { it.isNotBlank() }.distinct()
        if (validIds.isEmpty()) return emptyMap()

        val cutoff = Calendar.getInstance().apply { add(Calendar.DAY_OF_YEAR, -30) }.timeInMillis

        val recentLogs = queryList(RealmTeamLog::class.java) {
            equalTo("type", "teamVisit")
            greaterThan("time", cutoff)
            `in`("teamId", validIds.toTypedArray())
        }

        return recentLogs
            .mapNotNull { it.teamId }
            .groupingBy { it }
            .eachCount()
            .mapValues { it.value.toLong() }
    }

    override suspend fun requestToJoin(teamId: String, userId: String?, userPlanetCode: String?, teamType: String?) {
        if (teamId.isBlank() || userId.isNullOrBlank()) return
        executeTransaction { realm ->
            val request = realm.createObject(RealmMyTeam::class.java, AndroidDecrypter.generateIv())
            request.docType = "request"
            request.createdDate = Date().time
            request.teamType = teamType
            request.userId = userId
            request.teamId = teamId
            request.updated = true
            request.teamPlanetCode = userPlanetCode
            request.userPlanetCode = userPlanetCode
        }
    }

    override suspend fun respondToMemberRequest(
        teamId: String,
        userId: String,
        accept: Boolean,
    ): Result<Unit> {
        if (teamId.isBlank() || userId.isBlank()) {
            return Result.failure(IllegalArgumentException("teamId and userId cannot be blank"))
        }

        return runCatching {
            executeTransaction { realm ->
                val request = realm.where(RealmMyTeam::class.java)
                    .equalTo("teamId", teamId)
                    .equalTo("userId", userId)
                    .equalTo("docType", "request")
                    .findFirst()
                    ?: throw IllegalStateException("Request not found for user $userId")

                if (accept) {
                    request.docType = "membership"
                    request.updated = true
                } else {
                    request.deleteFromRealm()
                }
            }
        }
    }

    override suspend fun leaveTeam(teamId: String, userId: String?) {
        if (teamId.isBlank() || userId.isNullOrBlank()) return
        executeTransaction { realm ->
            val memberships = realm.where(RealmMyTeam::class.java)
                .equalTo("userId", userId)
                .equalTo("teamId", teamId)
                .equalTo("docType", "membership")
                .findAll()
            memberships.forEach { member ->
                member?.deleteFromRealm()
            }
        }
    }

    override suspend fun removeMember(teamId: String, userId: String) {
        if (teamId.isBlank() || userId.isBlank()) return
        executeTransaction { realm ->
            realm.where(RealmMyTeam::class.java)
                .equalTo("teamId", teamId)
                .equalTo("userId", userId)
                .equalTo("docType", "membership")
                .findAll()
                .deleteAllFromRealm()
        }
    }

    override suspend fun addResourceLinks(
        teamId: String,
        resources: List<RealmMyLibrary>,
        user: RealmUserModel?,
    ) {
        if (teamId.isBlank() || resources.isEmpty() || user == null) return
        executeTransaction { realm ->
            resources.forEach { resource ->
                val teamResource = realm.createObject(RealmMyTeam::class.java, UUID.randomUUID().toString())
                teamResource.teamId = teamId
                teamResource.title = resource.title
                teamResource.status = user.parentCode
                teamResource.resourceId = resource._id
                teamResource.docType = "resourceLink"
                teamResource.updated = true
                teamResource.teamType = "local"
                teamResource.teamPlanetCode = user.planetCode
                teamResource.userPlanetCode = user.planetCode
            }
        }
    }

    override suspend fun removeResourceLink(teamId: String, resourceId: String) {
        if (teamId.isBlank() || resourceId.isBlank()) return
        executeTransaction { realm ->
            realm.where(RealmMyTeam::class.java)
                .equalTo("teamId", teamId)
                .equalTo("resourceId", resourceId)
                .equalTo("docType", "resourceLink")
                .findFirst()
                ?.let { teamResource ->
                    teamResource.resourceId = ""
                    teamResource.updated = true
                }
        }
    }

    override suspend fun getPendingTasksForUser(
        userId: String,
        start: Long,
        end: Long,
    ): List<RealmTeamTask> {
        if (userId.isBlank() || start > end) return emptyList()
        return queryList(RealmTeamTask::class.java) {
            equalTo("completed", false)
            equalTo("assignee", userId)
            equalTo("isNotified", false)
            between("deadline", start, end)
        }
    }

    override suspend fun markTasksNotified(taskIds: Collection<String>) {
        if (taskIds.isEmpty()) return
        val validIds = taskIds.mapNotNull { it.takeIf(String::isNotBlank) }.distinct()
        if (validIds.isEmpty()) return
        executeTransaction { realm ->
            val tasks = realm.where(RealmTeamTask::class.java)
                .`in`("id", validIds.toTypedArray())
                .findAll()
            tasks.forEach { task ->
                task.isNotified = true
            }
        }
    }

    override suspend fun getTasksByTeamId(teamId: String): Flow<List<RealmTeamTask>> {
        return queryListFlow(RealmTeamTask::class.java) {
            equalTo("teamId", teamId)
            notEqualTo("status", "archived")
        }
    }

    override suspend fun deleteTask(taskId: String) {
        delete(RealmTeamTask::class.java, "id", taskId)
    }

    override suspend fun upsertTask(task: RealmTeamTask) {
        if (task.link.isNullOrBlank()) {
            val linkObj = JsonObject().apply { addProperty("teams", task.teamId) }
            task.link = gson.toJson(linkObj)
        }
        if (task.sync.isNullOrBlank()) {
            val syncObj = JsonObject().apply {
                addProperty("type", "local")
                addProperty("planetCode", userProfileDbHandler.userModel?.planetCode)
            }
            task.sync = gson.toJson(syncObj)
        }
        save(task)
    }

    override suspend fun assignTask(taskId: String, assigneeId: String?) {
        update(RealmTeamTask::class.java, "id", taskId) { task ->
            task.assignee = assigneeId
            task.isUpdated = true
        }
    }

    override suspend fun setTaskCompletion(taskId: String, completed: Boolean) {
        update(RealmTeamTask::class.java, "id", taskId) { task ->
            task.completed = completed
            task.completedTime = if (completed) Date().time else 0
            task.isUpdated = true
        }
    }

    override suspend fun logTeamVisit(
        teamId: String,
        userName: String?,
        userPlanetCode: String?,
        userParentCode: String?,
        teamType: String?,
    ) {
        if (teamId.isBlank() || userName.isNullOrBlank()) return
        executeTransaction { realm ->
            val log = realm.createObject(RealmTeamLog::class.java, UUID.randomUUID().toString())
            log.teamId = teamId
            log.user = userName
            log.createdOn = userPlanetCode
            log.type = "teamVisit"
            log.teamType = teamType
            log.parentCode = userParentCode
            log.time = Date().time
        }
    }

    override suspend fun createTeam(
        category: String?,
        name: String,
        description: String,
        services: String,
        rules: String,
        teamType: String?,
        isPublic: Boolean,
        user: RealmUserModel,
    ): Result<String> {
        return runCatching {
            val teamId = AndroidDecrypter.generateIv()
            executeTransaction { realm ->
                val team = realm.createObject(RealmMyTeam::class.java, teamId)
                team.status = "active"
                team.createdDate = Date().time
                if (category == "enterprise") {
                    team.type = "enterprise"
                    team.services = services
                    team.rules = rules
                } else {
                    team.type = "team"
                    team.teamType = teamType
                }
                team.name = name
                team.description = description
                team.createdBy = user._id
                team.teamId = ""
                team.isPublic = isPublic
                team.userId = user.id
                team.parentCode = user.parentCode
                team.teamPlanetCode = user.planetCode
                team.updated = true

                val membershipId = AndroidDecrypter.generateIv()
                val membership = realm.createObject(RealmMyTeam::class.java, membershipId)
                membership.userId = user._id
                membership.teamId = teamId
                membership.teamPlanetCode = user.planetCode
                membership.userPlanetCode = user.planetCode
                membership.docType = "membership"
                membership.isLeader = true
                membership.teamType = teamType
                membership.updated = true
            }
            teamId
        }
    }

    override suspend fun updateTeam(
        teamId: String,
        name: String,
        description: String,
        services: String,
        rules: String,
        updatedBy: String?,
    ): Result<Boolean> {
        return runCatching {
            var updated = false
            executeTransaction { realm ->
                val teamToUpdate = realm.where(RealmMyTeam::class.java)
                    .equalTo("_id", teamId)
                    .findFirst()
                    ?: realm.where(RealmMyTeam::class.java)
                        .equalTo("teamId", teamId)
                        .findFirst()
                teamToUpdate?.let { team ->
                    team.name = name
                    team.services = services
                    team.rules = rules
                    team.description = description
                    updatedBy?.let { team.createdBy = it }
                    team.limit = 12
                    team.updated = true
                    updated = true
                }
            }
            updated
        }
    }

    override suspend fun updateTeamDetails(
        teamId: String,
        name: String,
        description: String,
        services: String,
        rules: String,
        teamType: String,
        isPublic: Boolean,
        createdBy: String,
    ): Boolean {
        if (teamId.isBlank()) return false
        val updated = AtomicBoolean(false)
        val applyUpdates: (RealmMyTeam) -> Unit = { team ->
            team.name = name
            team.description = description
            team.services = services
            team.rules = rules
            team.teamType = teamType
            team.isPublic = isPublic
            team.createdBy = createdBy.takeIf { it.isNotBlank() } ?: team.createdBy
            team.updated = true
            updated.set(true)
        }

        update(RealmMyTeam::class.java, "_id", teamId, applyUpdates)
        if (!updated.get()) {
            update(RealmMyTeam::class.java, "teamId", teamId, applyUpdates)
        }

        return updated.get()
    }

    override suspend fun syncTeamActivities() {
        val updateUrl = preferences.getString("serverURL", "") ?: ""
        val mapping = serverUrlMapper.processUrl(updateUrl)

        val primaryAvailable = MainApplication.isServerReachable(mapping.primaryUrl)
        val alternativeAvailable =
            mapping.alternativeUrl?.let { MainApplication.isServerReachable(it) } == true

        if (!primaryAvailable && alternativeAvailable) {
            mapping.alternativeUrl?.let { alternativeUrl ->
                val uri = updateUrl.toUri()
                val editor = preferences.edit()
                serverUrlMapper.updateUrlPreferences(editor, uri, alternativeUrl, mapping.primaryUrl, preferences)
            }
        }

        uploadTeamActivities()
    }

    private suspend fun uploadTeamActivities() {
        try {
            val apiInterface = client?.create(ApiInterface::class.java)
            withContext(Dispatchers.IO) {
                uploadManager.uploadTeams()
                executeTransaction { realm ->
                    uploadManager.uploadTeamActivities(realm, apiInterface)
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private suspend fun getResourceIds(teamId: String): List<String> {
        return queryList(RealmMyTeam::class.java) {
            equalTo("teamId", teamId)
            beginGroup()
                .isNull("docType")
                .or().equalTo("docType", "")
                .or().equalTo("docType", "resourceLink")
                .or().equalTo("docType", "link")
            endGroup()
            isNotNull("resourceId")
            isNotEmpty("resourceId")
        }.mapNotNull { it.resourceId }
    }
}
=======
package org.ole.planet.myplanet.repository


import android.content.SharedPreferences
import androidx.core.net.toUri
import com.google.gson.Gson
import com.google.gson.JsonObject
import java.util.Calendar
import java.util.Date
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean
import javax.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.datamanager.ApiClient.client
import org.ole.planet.myplanet.datamanager.ApiInterface
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmTeamLog
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.service.UploadManager
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.utilities.AndroidDecrypter
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper

class TeamRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
    private val userProfileDbHandler: UserProfileDbHandler,
    private val uploadManager: UploadManager,
    private val gson: Gson,
    @AppPreferences private val preferences: SharedPreferences,
    private val serverUrlMapper: ServerUrlMapper,
) : RealmRepository(databaseService), TeamRepository {

    override suspend fun getShareableTeams(): List<RealmMyTeam> {
        return queryList(RealmMyTeam::class.java) {
            isEmpty("teamId")
            notEqualTo("status", "archived")
            equalTo("type", "team")
        }
    }

    override suspend fun getShareableEnterprises(): List<RealmMyTeam> {
        return queryList(RealmMyTeam::class.java) {
            isEmpty("teamId")
            notEqualTo("status", "archived")
            equalTo("type", "enterprise")
        }
    }

    override suspend fun getTeamResources(teamId: String): List<RealmMyLibrary> {
        val resourceIds = getResourceIds(teamId)
        return if (resourceIds.isEmpty()) {
            emptyList()
        } else {
            queryList(RealmMyLibrary::class.java) {
                `in`("resourceId", resourceIds.toTypedArray())
            }
        }
    }

    override suspend fun getTeamByDocumentIdOrTeamId(id: String): RealmMyTeam? {
        if (id.isBlank()) return null
        return findByField(RealmMyTeam::class.java, "_id", id)
            ?: findByField(RealmMyTeam::class.java, "teamId", id)
    }

    override suspend fun getTeamLinks(): List<RealmMyTeam> {
        return queryList(RealmMyTeam::class.java) {
            equalTo("docType", "link")
        }
    }

    override suspend fun getTeamById(teamId: String): RealmMyTeam? {
        if (teamId.isBlank()) return null
        return findByField(RealmMyTeam::class.java, "_id", teamId)
    }

    override suspend fun getTaskTeamInfo(taskId: String): Triple<String, String, String>? {
        return withRealm { realm ->
            val task = realm.where(RealmTeamTask::class.java)
                .equalTo("id", taskId)
                .findFirst()

            task?.let {
                val linkJson = org.json.JSONObject(it.link ?: "{}")
                val teamId = linkJson.optString("teams")
                if (teamId.isNotEmpty()) {
                    val teamObject = realm.where(RealmMyTeam::class.java).equalTo("_id", teamId).findFirst()
                    teamObject?.let { team ->
                        Triple(teamId, team.name ?: "", team.type ?: "")
                    }
                } else {
                    null
                }
            }
        }
    }

    override suspend fun getJoinRequestTeamId(requestId: String): String? {
        return withRealm { realm ->
            realm.where(RealmMyTeam::class.java)
                .equalTo("_id", requestId)
                .equalTo("docType", "request")
                .findFirst()?.teamId
        }
    }

    override suspend fun getTeamTransactions(
        teamId: String,
        startDate: Long?,
        endDate: Long?,
        sortAscending: Boolean,
    ): Flow<List<RealmMyTeam>> {
        return queryListFlow(RealmMyTeam::class.java) {
            equalTo("teamId", teamId)
            equalTo("docType", "transaction")
            notEqualTo("status", "archived")
            startDate?.let { greaterThanOrEqualTo("date", it) }
            endDate?.let { lessThanOrEqualTo("date", it) }
        }.map { transactions ->
            if (sortAscending) {
                transactions.sortedBy { it.date }
            } else {
                transactions.sortedByDescending { it.date }
            }
        }
    }

    override suspend fun createTransaction(
        teamId: String,
        type: String,
        note: String,
        amount: Int,
        date: Long,
        parentCode: String?,
        planetCode: String?,
    ): Result<Unit> {
        if (teamId.isBlank()) {
            return Result.failure(IllegalArgumentException("teamId cannot be blank"))
        }
        return runCatching {
            executeTransaction { realm ->
                val transaction = realm.createObject(RealmMyTeam::class.java, UUID.randomUUID().toString())
                transaction.status = "active"
                transaction.date = date
                transaction.type = type
                transaction.description = note
                transaction.teamId = teamId
                transaction.amount = amount
                transaction.parentCode = parentCode
                transaction.teamPlanetCode = planetCode
                transaction.teamType = "sync"
                transaction.docType = "transaction"
                transaction.updated = true
            }
        }
    }

    override suspend fun addReport(report: JsonObject) {
        executeTransaction { realm ->
            val reportId = JsonUtils.getString("_id", report)
            val reportEntry = realm.where(RealmMyTeam::class.java)
                .equalTo("_id", reportId)
                .findFirst()
                ?: realm.createObject(RealmMyTeam::class.java, reportId)
            RealmMyTeam.populateTeamFields(report, reportEntry)
        }
    }

    override suspend fun updateReport(reportId: String, payload: JsonObject) {
        if (reportId.isBlank()) return
        executeTransaction { realm ->
            val report = realm.where(RealmMyTeam::class.java)
                .equalTo("_id", reportId)
                .findFirst()
                ?: return@executeTransaction
            RealmMyTeam.populateReportFields(payload, report)
            report.updated = true
            if (report.updatedDate == 0L) {
                report.updatedDate = System.currentTimeMillis()
            }
        }
    }

    override suspend fun archiveReport(reportId: String) {
        if (reportId.isBlank()) return
        executeTransaction { realm ->
            realm.where(RealmMyTeam::class.java)
                .equalTo("_id", reportId)
                .findFirst()?.apply {
                    status = "archived"
                    updated = true
                }
        }
    }

    override suspend fun isMember(userId: String?, teamId: String): Boolean {
        userId ?: return false
        return count(RealmMyTeam::class.java) {
            equalTo("userId", userId)
            equalTo("teamId", teamId)
            equalTo("docType", "membership")
        } > 0
    }

    override suspend fun isTeamLeader(teamId: String, userId: String?): Boolean {
        if (teamId.isBlank() || userId.isNullOrBlank()) return false
        return count(RealmMyTeam::class.java) {
            equalTo("teamId", teamId)
            equalTo("docType", "membership")
            equalTo("userId", userId)
            equalTo("isLeader", true)
        } > 0
    }

    override suspend fun hasPendingRequest(teamId: String, userId: String?): Boolean {
        if (teamId.isBlank() || userId.isNullOrBlank()) return false
        return count(RealmMyTeam::class.java) {
            equalTo("docType", "request")
            equalTo("teamId", teamId)
            equalTo("userId", userId)
        } > 0
    }

    override suspend fun getTeamMemberStatuses(userId: String?, teamIds: Collection<String>): Map<String, TeamMemberStatus> {
        if (userId.isNullOrBlank() || teamIds.isEmpty()) return emptyMap()

        val validIds = teamIds.filter { it.isNotBlank() }.distinct()
        if (validIds.isEmpty()) return emptyMap()

        val memberships = queryList(RealmMyTeam::class.java) {
            equalTo("userId", userId)
            equalTo("docType", "membership")
            `in`("teamId", validIds.toTypedArray())
        }

        val pendingRequests = queryList(RealmMyTeam::class.java) {
            equalTo("userId", userId)
            equalTo("docType", "request")
            `in`("teamId", validIds.toTypedArray())
        }

        val membershipMap = memberships
            .mapNotNull { it.teamId }
            .toSet()

        val leaderMap = memberships
            .filter { it.isLeader }
            .mapNotNull { it.teamId }
            .toSet()

        val pendingRequestMap = pendingRequests
            .mapNotNull { it.teamId }
            .toSet()

        return validIds.associateWith { teamId ->
            TeamMemberStatus(
                isMember = teamId in membershipMap,
                isLeader = teamId in leaderMap,
                hasPendingRequest = teamId in pendingRequestMap
            )
        }
    }

    override suspend fun getRecentVisitCounts(teamIds: Collection<String>): Map<String, Long> {
        if (teamIds.isEmpty()) return emptyMap()

        val validIds = teamIds.filter { it.isNotBlank() }.distinct()
        if (validIds.isEmpty()) return emptyMap()

        val cutoff = Calendar.getInstance().apply { add(Calendar.DAY_OF_YEAR, -30) }.timeInMillis

        val recentLogs = queryList(RealmTeamLog::class.java) {
            equalTo("type", "teamVisit")
            greaterThan("time", cutoff)
            `in`("teamId", validIds.toTypedArray())
        }

        return recentLogs
            .mapNotNull { it.teamId }
            .groupingBy { it }
            .eachCount()
            .mapValues { it.value.toLong() }
    }

    override suspend fun requestToJoin(teamId: String, userId: String?, userPlanetCode: String?, teamType: String?) {
        if (teamId.isBlank() || userId.isNullOrBlank()) return
        executeTransaction { realm ->
            val request = realm.createObject(RealmMyTeam::class.java, AndroidDecrypter.generateIv())
            request.docType = "request"
            request.createdDate = Date().time
            request.teamType = teamType
            request.userId = userId
            request.teamId = teamId
            request.updated = true
            request.teamPlanetCode = userPlanetCode
            request.userPlanetCode = userPlanetCode
        }
    }

    override suspend fun respondToMemberRequest(
        teamId: String,
        userId: String,
        accept: Boolean,
    ): Result<Unit> {
        if (teamId.isBlank() || userId.isBlank()) {
            return Result.failure(IllegalArgumentException("teamId and userId cannot be blank"))
        }

        return runCatching {
            executeTransaction { realm ->
                val request = realm.where(RealmMyTeam::class.java)
                    .equalTo("teamId", teamId)
                    .equalTo("userId", userId)
                    .equalTo("docType", "request")
                    .findFirst()
                    ?: throw IllegalStateException("Request not found for user $userId")

                if (accept) {
                    request.docType = "membership"
                    request.updated = true
                } else {
                    request.deleteFromRealm()
                }
            }
        }
    }

    override suspend fun leaveTeam(teamId: String, userId: String?) {
        if (teamId.isBlank() || userId.isNullOrBlank()) return
        executeTransaction { realm ->
            val memberships = realm.where(RealmMyTeam::class.java)
                .equalTo("userId", userId)
                .equalTo("teamId", teamId)
                .equalTo("docType", "membership")
                .findAll()
            memberships.forEach { member ->
                member?.deleteFromRealm()
            }
        }
    }

    override suspend fun removeMember(teamId: String, userId: String) {
        if (teamId.isBlank() || userId.isBlank()) return
        executeTransaction { realm ->
            realm.where(RealmMyTeam::class.java)
                .equalTo("teamId", teamId)
                .equalTo("userId", userId)
                .equalTo("docType", "membership")
                .findAll()
                .deleteAllFromRealm()
        }
    }

    override suspend fun addResourceLinks(
        teamId: String,
        resources: List<RealmMyLibrary>,
        user: RealmUserModel?,
    ) {
        if (teamId.isBlank() || resources.isEmpty() || user == null) return
        executeTransaction { realm ->
            resources.forEach { resource ->
                val teamResource = realm.createObject(RealmMyTeam::class.java, UUID.randomUUID().toString())
                teamResource.teamId = teamId
                teamResource.title = resource.title
                teamResource.status = user.parentCode
                teamResource.resourceId = resource._id
                teamResource.docType = "resourceLink"
                teamResource.updated = true
                teamResource.teamType = "local"
                teamResource.teamPlanetCode = user.planetCode
                teamResource.userPlanetCode = user.planetCode
            }
        }
    }

    override suspend fun removeResourceLink(teamId: String, resourceId: String) {
        if (teamId.isBlank() || resourceId.isBlank()) return
        executeTransaction { realm ->
            realm.where(RealmMyTeam::class.java)
                .equalTo("teamId", teamId)
                .equalTo("resourceId", resourceId)
                .equalTo("docType", "resourceLink")
                .findFirst()
                ?.let { teamResource ->
                    teamResource.resourceId = ""
                    teamResource.updated = true
                }
        }
    }

    override suspend fun getPendingTasksForUser(
        userId: String,
        start: Long,
        end: Long,
    ): List<RealmTeamTask> {
        if (userId.isBlank() || start > end) return emptyList()
        return queryList(RealmTeamTask::class.java) {
            equalTo("completed", false)
            equalTo("assignee", userId)
            equalTo("isNotified", false)
            between("deadline", start, end)
        }
    }

    override suspend fun markTasksNotified(taskIds: Collection<String>) {
        if (taskIds.isEmpty()) return
        val validIds = taskIds.mapNotNull { it.takeIf(String::isNotBlank) }.distinct()
        if (validIds.isEmpty()) return
        executeTransaction { realm ->
            val tasks = realm.where(RealmTeamTask::class.java)
                .`in`("id", validIds.toTypedArray())
                .findAll()
            tasks.forEach { task ->
                task.isNotified = true
            }
        }
    }

    override suspend fun getTasksByTeamId(teamId: String): Flow<List<RealmTeamTask>> {
        return queryListFlow(RealmTeamTask::class.java) {
            equalTo("teamId", teamId)
            notEqualTo("status", "archived")
        }
    }

    override suspend fun deleteTask(taskId: String) {
        delete(RealmTeamTask::class.java, "id", taskId)
    }

    override suspend fun upsertTask(task: RealmTeamTask) {
        if (task.link.isNullOrBlank()) {
            val linkObj = JsonObject().apply { addProperty("teams", task.teamId) }
            task.link = gson.toJson(linkObj)
        }
        if (task.sync.isNullOrBlank()) {
            val syncObj = JsonObject().apply {
                addProperty("type", "local")
                addProperty("planetCode", userProfileDbHandler.userModel?.planetCode)
            }
            task.sync = gson.toJson(syncObj)
        }
        save(task)
    }

    override suspend fun assignTask(taskId: String, assigneeId: String?) {
        update(RealmTeamTask::class.java, "id", taskId) { task ->
            task.assignee = assigneeId
            task.isUpdated = true
        }
    }

    override suspend fun setTaskCompletion(taskId: String, completed: Boolean) {
        update(RealmTeamTask::class.java, "id", taskId) { task ->
            task.completed = completed
            task.completedTime = if (completed) Date().time else 0
            task.isUpdated = true
        }
    }

    override suspend fun logTeamVisit(
        teamId: String,
        userName: String?,
        userPlanetCode: String?,
        userParentCode: String?,
        teamType: String?,
    ) {
        if (teamId.isBlank() || userName.isNullOrBlank()) return
        executeTransaction { realm ->
            val log = realm.createObject(RealmTeamLog::class.java, UUID.randomUUID().toString())
            log.teamId = teamId
            log.user = userName
            log.createdOn = userPlanetCode
            log.type = "teamVisit"
            log.teamType = teamType
            log.parentCode = userParentCode
            log.time = Date().time
        }
    }

    override suspend fun createTeam(
        category: String?,
        name: String,
        description: String,
        services: String,
        rules: String,
        teamType: String?,
        isPublic: Boolean,
        user: RealmUserModel,
    ): Result<String> {
        return runCatching {
            val teamId = AndroidDecrypter.generateIv()
            executeTransaction { realm ->
                val team = realm.createObject(RealmMyTeam::class.java, teamId)
                team.status = "active"
                team.createdDate = Date().time
                if (category == "enterprise") {
                    team.type = "enterprise"
                    team.services = services
                    team.rules = rules
                } else {
                    team.type = "team"
                    team.teamType = teamType
                }
                team.name = name
                team.description = description
                team.createdBy = user._id
                team.teamId = ""
                team.isPublic = isPublic
                team.userId = user.id
                team.parentCode = user.parentCode
                team.teamPlanetCode = user.planetCode
                team.updated = true

                val membershipId = AndroidDecrypter.generateIv()
                val membership = realm.createObject(RealmMyTeam::class.java, membershipId)
                membership.userId = user._id
                membership.teamId = teamId
                membership.teamPlanetCode = user.planetCode
                membership.userPlanetCode = user.planetCode
                membership.docType = "membership"
                membership.isLeader = true
                membership.teamType = teamType
                membership.updated = true
            }
            teamId
        }
    }

    override suspend fun updateTeam(
        teamId: String,
        name: String,
        description: String,
        services: String,
        rules: String,
        updatedBy: String?,
    ): Result<Boolean> {
        return runCatching {
            var updated = false
            executeTransaction { realm ->
                val teamToUpdate = realm.where(RealmMyTeam::class.java)
                    .equalTo("_id", teamId)
                    .findFirst()
                    ?: realm.where(RealmMyTeam::class.java)
                        .equalTo("teamId", teamId)
                        .findFirst()
                teamToUpdate?.let { team ->
                    team.name = name
                    team.services = services
                    team.rules = rules
                    team.description = description
                    updatedBy?.let { team.createdBy = it }
                    team.limit = 12
                    team.updated = true
                    updated = true
                }
            }
            updated
        }
    }

    override suspend fun updateTeamDetails(
        teamId: String,
        name: String,
        description: String,
        services: String,
        rules: String,
        teamType: String,
        isPublic: Boolean,
        createdBy: String,
    ): Boolean {
        if (teamId.isBlank()) return false
        val updated = AtomicBoolean(false)
        val applyUpdates: (RealmMyTeam) -> Unit = { team ->
            team.name = name
            team.description = description
            team.services = services
            team.rules = rules
            team.teamType = teamType
            team.isPublic = isPublic
            team.createdBy = createdBy.takeIf { it.isNotBlank() } ?: team.createdBy
            team.updated = true
            updated.set(true)
        }

        update(RealmMyTeam::class.java, "_id", teamId, applyUpdates)
        if (!updated.get()) {
            update(RealmMyTeam::class.java, "teamId", teamId, applyUpdates)
        }

        return updated.get()
    }

    override suspend fun syncTeamActivities() {
        val updateUrl = preferences.getString("serverURL", "") ?: ""
        val mapping = serverUrlMapper.processUrl(updateUrl)

        val primaryAvailable = MainApplication.isServerReachable(mapping.primaryUrl)
        val alternativeAvailable =
            mapping.alternativeUrl?.let { MainApplication.isServerReachable(it) } == true

        if (!primaryAvailable && alternativeAvailable) {
            mapping.alternativeUrl?.let { alternativeUrl ->
                val uri = updateUrl.toUri()
                val editor = preferences.edit()
                serverUrlMapper.updateUrlPreferences(editor, uri, alternativeUrl, mapping.primaryUrl, preferences)
            }
        }

        uploadTeamActivities()
    }

    private suspend fun uploadTeamActivities() {
        try {
            val apiInterface = client?.create(ApiInterface::class.java)
            withContext(Dispatchers.IO) {
                uploadManager.uploadTeams()
                executeTransaction { realm ->
                    uploadManager.uploadTeamActivities(realm, apiInterface)
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private suspend fun getResourceIds(teamId: String): List<String> {
        return queryList(RealmMyTeam::class.java) {
            equalTo("teamId", teamId)
            beginGroup()
                .isNull("docType")
                .or().equalTo("docType", "")
                .or().equalTo("docType", "resourceLink")
                .or().equalTo("docType", "link")
            endGroup()
            isNotNull("resourceId")
            isNotEmpty("resourceId")
        }.mapNotNull { it.resourceId }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/RatingRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import com.google.gson.Gson
import java.util.Date
import java.util.UUID
import javax.inject.Inject
import kotlin.math.roundToInt
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmRating
import org.ole.planet.myplanet.model.RealmUserModel

class RatingRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
    private val gson: Gson,
) : RealmRepository(databaseService), RatingRepository {

    override suspend fun getRatingSummary(
        type: String,
        itemId: String,
        userId: String,
    ): RatingSummary {
        return withRealmAsync { realm ->
            val results =
                realm.where(RealmRating::class.java)
                    .equalTo("type", type)
                    .equalTo("item", itemId)
                    .findAll()

            val totalRatings = results.size
            val averageRating =
                if (totalRatings > 0) {
                    results.average("rate")?.toFloat() ?: 0f
                } else {
                    0f
                }

            val existingRating =
                results.where()
                    .equalTo("userId", userId)
                    .findFirst()

            RatingSummary(
                existingRating = existingRating?.toRatingEntry(),
                averageRating = averageRating,
                totalRatings = totalRatings,
                userRating = existingRating?.rate,
            )
        }
    }

    override suspend fun submitRating(
        type: String,
        itemId: String,
        title: String,
        userId: String,
        rating: Float,
        comment: String,
    ): RatingSummary {
        val resolvedUser = findUserForRating(userId)
        val resolvedUserId = resolvedUser.id?.takeIf { it.isNotBlank() } ?: resolvedUser._id
        require(!resolvedUserId.isNullOrBlank()) { "Resolved user is missing an identifier" }

        val existingRating = queryList(RealmRating::class.java) {
            equalTo("type", type)
            equalTo("userId", resolvedUserId)
            equalTo("item", itemId)
        }.firstOrNull()

        if (existingRating == null || existingRating.id.isNullOrBlank()) {
            val newRating = RealmRating().apply {
                id = UUID.randomUUID().toString()
            }
            setRatingData(newRating, resolvedUser, type, itemId, title, rating, comment)
            save(newRating)
        } else {
            update(RealmRating::class.java, "id", existingRating.id!!) { ratingObject ->
                setRatingData(ratingObject, resolvedUser, type, itemId, title, rating, comment)
            }
        }

        return getRatingSummary(type, itemId, resolvedUserId)
    }

    private fun RealmRating.toRatingEntry(): RatingEntry =
        RatingEntry(
            id = id,
            comment = comment,
            rate = rate,
        )

    private suspend fun findUserForRating(userId: String): RealmUserModel {
        require(userId.isNotBlank()) { "User ID is required to submit a rating" }

        val user = findByField(RealmUserModel::class.java, "id", userId)
            ?: findByField(RealmUserModel::class.java, "_id", userId)

        return requireNotNull(user) { "Unable to locate user with ID '$userId'" }
    }

    private fun setRatingData(
        ratingObject: RealmRating,
        userModel: RealmUserModel?,
        type: String,
        itemId: String,
        title: String,
        rating: Float,
        comment: String,
    ) {
        val resolvedUser = requireNotNull(userModel) { "User data is required to save a rating" }
        val resolvedUserId =
            resolvedUser.id?.takeIf { it.isNotBlank() } ?: resolvedUser._id
        require(!resolvedUserId.isNullOrBlank()) { "User data is missing a valid identifier" }

        ratingObject.apply {
            isUpdated = true
            this.comment = comment
            rate = roundToSupportedRating(rating)
            time = Date().time
            userId = resolvedUserId
            createdOn = resolvedUser.parentCode
            parentCode = resolvedUser.parentCode
            planetCode = resolvedUser.planetCode
            user = gson.toJson(resolvedUser.serialize())
            this.type = type
            item = itemId
            this.title = title
        }
    }

    companion object {
        private const val MIN_RATING = 1
        private const val MAX_RATING = 5

        internal fun roundToSupportedRating(rating: Float): Int {
            return rating.roundToInt().coerceIn(MIN_RATING, MAX_RATING)
        }
    }
}
=======
package org.ole.planet.myplanet.repository


import com.google.gson.Gson
import java.util.Date
import java.util.UUID
import javax.inject.Inject
import kotlin.math.roundToInt
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmRating
import org.ole.planet.myplanet.model.RealmUserModel

class RatingRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
    private val gson: Gson,
) : RealmRepository(databaseService), RatingRepository {

    override suspend fun getRatingSummary(
        type: String,
        itemId: String,
        userId: String,
    ): RatingSummary {
        return withRealmAsync { realm ->
            val results =
                realm.where(RealmRating::class.java)
                    .equalTo("type", type)
                    .equalTo("item", itemId)
                    .findAll()

            val totalRatings = results.size
            val averageRating =
                if (totalRatings > 0) {
                    results.average("rate")?.toFloat() ?: 0f
                } else {
                    0f
                }

            val existingRating =
                results.where()
                    .equalTo("userId", userId)
                    .findFirst()

            RatingSummary(
                existingRating = existingRating?.toRatingEntry(),
                averageRating = averageRating,
                totalRatings = totalRatings,
                userRating = existingRating?.rate,
            )
        }
    }

    override suspend fun submitRating(
        type: String,
        itemId: String,
        title: String,
        userId: String,
        rating: Float,
        comment: String,
    ): RatingSummary {
        val resolvedUser = findUserForRating(userId)
        val resolvedUserId = resolvedUser.id?.takeIf { it.isNotBlank() } ?: resolvedUser._id
        require(!resolvedUserId.isNullOrBlank()) { "Resolved user is missing an identifier" }

        val existingRating = queryList(RealmRating::class.java) {
            equalTo("type", type)
            equalTo("userId", resolvedUserId)
            equalTo("item", itemId)
        }.firstOrNull()

        if (existingRating == null || existingRating.id.isNullOrBlank()) {
            val newRating = RealmRating().apply {
                id = UUID.randomUUID().toString()
            }
            setRatingData(newRating, resolvedUser, type, itemId, title, rating, comment)
            save(newRating)
        } else {
            update(RealmRating::class.java, "id", existingRating.id!!) { ratingObject ->
                setRatingData(ratingObject, resolvedUser, type, itemId, title, rating, comment)
            }
        }

        return getRatingSummary(type, itemId, resolvedUserId)
    }

    private fun RealmRating.toRatingEntry(): RatingEntry =
        RatingEntry(
            id = id,
            comment = comment,
            rate = rate,
        )

    private suspend fun findUserForRating(userId: String): RealmUserModel {
        require(userId.isNotBlank()) { "User ID is required to submit a rating" }

        val user = findByField(RealmUserModel::class.java, "id", userId)
            ?: findByField(RealmUserModel::class.java, "_id", userId)

        return requireNotNull(user) { "Unable to locate user with ID '$userId'" }
    }

    private fun setRatingData(
        ratingObject: RealmRating,
        userModel: RealmUserModel?,
        type: String,
        itemId: String,
        title: String,
        rating: Float,
        comment: String,
    ) {
        val resolvedUser = requireNotNull(userModel) { "User data is required to save a rating" }
        val resolvedUserId =
            resolvedUser.id?.takeIf { it.isNotBlank() } ?: resolvedUser._id
        require(!resolvedUserId.isNullOrBlank()) { "User data is missing a valid identifier" }

        ratingObject.apply {
            isUpdated = true
            this.comment = comment
            rate = roundToSupportedRating(rating)
            time = Date().time
            userId = resolvedUserId
            createdOn = resolvedUser.parentCode
            parentCode = resolvedUser.parentCode
            planetCode = resolvedUser.planetCode
            user = gson.toJson(resolvedUser.serialize())
            this.type = type
            item = itemId
            this.title = title
        }
    }

    companion object {
        private const val MIN_RATING = 1
        private const val MAX_RATING = 5

        internal fun roundToSupportedRating(rating: Float): Int {
            return rating.roundToInt().coerceIn(MIN_RATING, MAX_RATING)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/SubmissionRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import io.realm.Case
import io.realm.Sort
import java.util.Date
import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmission.Companion.createSubmission

class SubmissionRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), SubmissionRepository {

    private fun RealmSubmission.examIdFromParentId(): String? {
        return parentId?.substringBefore("@")
    }

    override suspend fun getPendingSurveys(userId: String?): List<RealmSubmission> {
        if (userId == null) return emptyList()

        return queryList(RealmSubmission::class.java) {
            equalTo("userId", userId)
            equalTo("status", "pending")
            equalTo("type", "survey")
        }
    }

    override suspend fun getUniquePendingSurveys(userId: String?): List<RealmSubmission> {
        if (userId == null) return emptyList()

        val pendingSurveys = getPendingSurveys(userId)
        if (pendingSurveys.isEmpty()) return emptyList()

        val examIds = pendingSurveys.mapNotNull { it.examIdFromParentId() }.distinct()

        if (examIds.isEmpty()) return emptyList()

        val exams = queryList(RealmStepExam::class.java) {
            `in`("id", examIds.toTypedArray())
        }
        val validExamIds = exams.mapNotNull { it.id }.toSet()

        val uniqueSurveys = linkedMapOf<String, RealmSubmission>()
        pendingSurveys.forEach { submission ->
            val examId = submission.examIdFromParentId()
            if (examId != null && validExamIds.contains(examId) && !uniqueSurveys.containsKey(examId)) {
                uniqueSurveys[examId] = submission
            }
        }

        return uniqueSurveys.values.toList()
    }

    override suspend fun getSurveyTitlesFromSubmissions(
        submissions: List<RealmSubmission>
    ): List<String> {
        val examIds = submissions.mapNotNull { it.examIdFromParentId() }
        if (examIds.isEmpty()) {
            return emptyList()
        }

        val exams = queryList(RealmStepExam::class.java) {
            `in`("id", examIds.toTypedArray())
        }
        val examMap = exams.associate { it.id to (it.name ?: "") }

        return submissions.map { submission ->
            val examId = submission.examIdFromParentId()
            examMap[examId] ?: ""
        }
    }

    override suspend fun getExamMapForSubmissions(
        submissions: List<RealmSubmission>
    ): Map<String?, RealmStepExam> {
        val examIds = submissions.mapNotNull { it.examIdFromParentId() }.distinct()

        if (examIds.isEmpty()) {
            return emptyMap()
        }

        val examMap = queryList(RealmStepExam::class.java) {
            `in`("id", examIds.toTypedArray())
        }.associateBy { it.id }

        return submissions.mapNotNull { sub ->
            val parentId = sub.parentId
            val examId = sub.examIdFromParentId()
            examMap[examId]?.let { parentId to it }
        }.toMap()
    }

    override suspend fun getExamQuestionCount(stepId: String): Int {
        return findByField(RealmStepExam::class.java, "stepId", stepId)?.noOfQuestions ?: 0
    }

    override suspend fun getSubmissionById(id: String): RealmSubmission? {
        return findByField(RealmSubmission::class.java, "id", id)
    }

    override suspend fun getSubmissionsByIds(ids: List<String>): List<RealmSubmission> {
        if (ids.isEmpty()) return emptyList()

        return queryList(RealmSubmission::class.java) {
            `in`("id", ids.toTypedArray())
        }
    }

    override suspend fun getSubmissionsByUserId(userId: String): List<RealmSubmission> {
        return queryList(RealmSubmission::class.java) {
            equalTo("userId", userId)
        }
    }

    override suspend fun hasSubmission(
        stepExamId: String?,
        courseId: String?,
        userId: String?,
        type: String,
    ): Boolean {
        if (stepExamId.isNullOrBlank() || courseId.isNullOrBlank() || userId.isNullOrBlank()) {
            return false
        }

        val questions = queryList(RealmExamQuestion::class.java) {
            equalTo("examId", stepExamId)
        }
        if (questions.isEmpty()) {
            return false
        }

        val examId = questions.firstOrNull()?.examId
        if (examId.isNullOrBlank()) {
            return false
        }

        val parentId = "$examId@$courseId"
        return count(RealmSubmission::class.java) {
            equalTo("userId", userId)
            equalTo("parentId", parentId)
            equalTo("type", type)
        } > 0
    }

    override suspend fun hasPendingOfflineSubmissions(): Boolean {
        return count(RealmSubmission::class.java) {
            beginGroup()
            equalTo("isUpdated", true)
            or()
            isEmpty("_id")
            endGroup()
        } > 0
    }

    override suspend fun hasPendingExamResults(): Boolean {
        return count(RealmSubmission::class.java) {
            equalTo("status", "pending", Case.INSENSITIVE)
            isNotEmpty("answers")
        } > 0
    }

    override suspend fun createSurveySubmission(examId: String, userId: String?) {
        executeTransaction { realm ->
            val courseId = realm.where(RealmStepExam::class.java).equalTo("id", examId).findFirst()?.courseId
            val parentId = if (!courseId.isNullOrEmpty()) {
                examId + "@" + courseId
            } else {
                examId
            }
            var sub = realm.where(RealmSubmission::class.java)
                .equalTo("userId", userId)
                .equalTo(
                    "parentId",
                    parentId,
                )
                .sort("lastUpdateTime", Sort.DESCENDING)
                .equalTo("status", "pending")
                .findFirst()
            sub = createSubmission(sub, realm)
            sub.parentId = parentId
            sub.userId = userId
            sub.type = "survey"
            sub.status = "pending"
            sub.startTime = Date().time
        }
    }

    override suspend fun saveSubmission(submission: RealmSubmission) {
        try {
            save(submission)
        } catch (e: Exception) {
            throw e
        }
    }

}
=======
package org.ole.planet.myplanet.repository


import io.realm.Case
import io.realm.Sort
import java.util.Date
import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmExamQuestion
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmission.Companion.createSubmission

class SubmissionRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), SubmissionRepository {

    private fun RealmSubmission.examIdFromParentId(): String? {
        return parentId?.substringBefore("@")
    }

    override suspend fun getPendingSurveys(userId: String?): List<RealmSubmission> {
        if (userId == null) return emptyList()

        return queryList(RealmSubmission::class.java) {
            equalTo("userId", userId)
            equalTo("status", "pending")
            equalTo("type", "survey")
        }
    }

    override suspend fun getUniquePendingSurveys(userId: String?): List<RealmSubmission> {
        if (userId == null) return emptyList()

        val pendingSurveys = getPendingSurveys(userId)
        if (pendingSurveys.isEmpty()) return emptyList()

        val examIds = pendingSurveys.mapNotNull { it.examIdFromParentId() }.distinct()

        if (examIds.isEmpty()) return emptyList()

        val exams = queryList(RealmStepExam::class.java) {
            `in`("id", examIds.toTypedArray())
        }
        val validExamIds = exams.mapNotNull { it.id }.toSet()

        val uniqueSurveys = linkedMapOf<String, RealmSubmission>()
        pendingSurveys.forEach { submission ->
            val examId = submission.examIdFromParentId()
            if (examId != null && validExamIds.contains(examId) && !uniqueSurveys.containsKey(examId)) {
                uniqueSurveys[examId] = submission
            }
        }

        return uniqueSurveys.values.toList()
    }

    override suspend fun getSurveyTitlesFromSubmissions(
        submissions: List<RealmSubmission>
    ): List<String> {
        val examIds = submissions.mapNotNull { it.examIdFromParentId() }
        if (examIds.isEmpty()) {
            return emptyList()
        }

        val exams = queryList(RealmStepExam::class.java) {
            `in`("id", examIds.toTypedArray())
        }
        val examMap = exams.associate { it.id to (it.name ?: "") }

        return submissions.map { submission ->
            val examId = submission.examIdFromParentId()
            examMap[examId] ?: ""
        }
    }

    override suspend fun getExamMapForSubmissions(
        submissions: List<RealmSubmission>
    ): Map<String?, RealmStepExam> {
        val examIds = submissions.mapNotNull { it.examIdFromParentId() }.distinct()

        if (examIds.isEmpty()) {
            return emptyMap()
        }

        val examMap = queryList(RealmStepExam::class.java) {
            `in`("id", examIds.toTypedArray())
        }.associateBy { it.id }

        return submissions.mapNotNull { sub ->
            val parentId = sub.parentId
            val examId = sub.examIdFromParentId()
            examMap[examId]?.let { parentId to it }
        }.toMap()
    }

    override suspend fun getExamQuestionCount(stepId: String): Int {
        return findByField(RealmStepExam::class.java, "stepId", stepId)?.noOfQuestions ?: 0
    }

    override suspend fun getSubmissionById(id: String): RealmSubmission? {
        return findByField(RealmSubmission::class.java, "id", id)
    }

    override suspend fun getSubmissionsByIds(ids: List<String>): List<RealmSubmission> {
        if (ids.isEmpty()) return emptyList()

        return queryList(RealmSubmission::class.java) {
            `in`("id", ids.toTypedArray())
        }
    }

    override suspend fun getSubmissionsByUserId(userId: String): List<RealmSubmission> {
        return queryList(RealmSubmission::class.java) {
            equalTo("userId", userId)
        }
    }

    override suspend fun hasSubmission(
        stepExamId: String?,
        courseId: String?,
        userId: String?,
        type: String,
    ): Boolean {
        if (stepExamId.isNullOrBlank() || courseId.isNullOrBlank() || userId.isNullOrBlank()) {
            return false
        }

        val questions = queryList(RealmExamQuestion::class.java) {
            equalTo("examId", stepExamId)
        }
        if (questions.isEmpty()) {
            return false
        }

        val examId = questions.firstOrNull()?.examId
        if (examId.isNullOrBlank()) {
            return false
        }

        val parentId = "$examId@$courseId"
        return count(RealmSubmission::class.java) {
            equalTo("userId", userId)
            equalTo("parentId", parentId)
            equalTo("type", type)
        } > 0
    }

    override suspend fun hasPendingOfflineSubmissions(): Boolean {
        return count(RealmSubmission::class.java) {
            beginGroup()
            equalTo("isUpdated", true)
            or()
            isEmpty("_id")
            endGroup()
        } > 0
    }

    override suspend fun hasPendingExamResults(): Boolean {
        return count(RealmSubmission::class.java) {
            equalTo("status", "pending", Case.INSENSITIVE)
            isNotEmpty("answers")
        } > 0
    }

    override suspend fun createSurveySubmission(examId: String, userId: String?) {
        executeTransaction { realm ->
            val courseId = realm.where(RealmStepExam::class.java).equalTo("id", examId).findFirst()?.courseId
            val parentId = if (!courseId.isNullOrEmpty()) {
                examId + "@" + courseId
            } else {
                examId
            }
            var sub = realm.where(RealmSubmission::class.java)
                .equalTo("userId", userId)
                .equalTo(
                    "parentId",
                    parentId,
                )
                .sort("lastUpdateTime", Sort.DESCENDING)
                .equalTo("status", "pending")
                .findFirst()
            sub = createSubmission(sub, realm)
            sub.parentId = parentId
            sub.userId = userId
            sub.type = "survey"
            sub.status = "pending"
            sub.startTime = Date().time
        }
    }

    override suspend fun saveSubmission(submission: RealmSubmission) {
        try {
            save(submission)
        } catch (e: Exception) {
            throw e
        }
    }

}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/RealmRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import io.realm.Realm
import io.realm.RealmChangeListener
import io.realm.RealmObject
import io.realm.RealmQuery
import io.realm.RealmResults
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.ProducerScope
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.applyEqualTo
import org.ole.planet.myplanet.datamanager.findCopyByField
import org.ole.planet.myplanet.datamanager.queryList

open class RealmRepository(protected val databaseService: DatabaseService) {
    protected suspend fun <T : RealmObject> queryList(
        clazz: Class<T>,
        builder: RealmQuery<T>.() -> Unit = {},
    ): List<T> = queryList(clazz, false, builder)

    protected suspend fun <T : RealmObject> queryList(
        clazz: Class<T>,
        ensureLatest: Boolean,
        builder: RealmQuery<T>.() -> Unit = {},
    ): List<T> =
        withRealm(ensureLatest) { realm ->
            realm.queryList(clazz, builder)
        }

    protected suspend fun <T : RealmObject> count(
        clazz: Class<T>,
        builder: RealmQuery<T>.() -> Unit = {},
    ): Long = count(clazz, false, builder)

    protected suspend fun <T : RealmObject> count(
        clazz: Class<T>,
        ensureLatest: Boolean,
        builder: RealmQuery<T>.() -> Unit = {},
    ): Long =
        withRealm(ensureLatest) { realm ->
            realm.where(clazz).apply(builder).count()
        }

    protected suspend fun <T : RealmObject> queryListFlow(
        clazz: Class<T>,
        builder: RealmQuery<T>.() -> Unit = {},
    ): Flow<List<T>> = withContext(Dispatchers.Main) {
        withRealmFlow { realm, scope ->
            val results = realm.where(clazz).apply(builder).findAllAsync()
            val listener =
                RealmChangeListener<RealmResults<T>> { updatedResults ->
                    if (updatedResults.isLoaded && updatedResults.isValid) {
                        scope.trySend(realm.copyFromRealm(updatedResults))
                    }
                }
            results.addChangeListener(listener)
            if (results.isLoaded && results.isValid) {
                scope.trySend(realm.copyFromRealm(results))
            }
            return@withRealmFlow { results.removeChangeListener(listener) }
        }
    }

    protected suspend fun <T : RealmObject, V : Any> findByField(
        clazz: Class<T>,
        fieldName: String,
        value: V,
    ): T? = findByField(clazz, fieldName, value, false)

    protected suspend fun <T : RealmObject, V : Any> findByField(
        clazz: Class<T>,
        fieldName: String,
        value: V,
        ensureLatest: Boolean,
    ): T? =
        withRealm(ensureLatest) { realm ->
            realm.findCopyByField(clazz, fieldName, value)
        }

    protected suspend fun <T : RealmObject> save(item: T) {
        executeTransaction { realm ->
            realm.copyToRealmOrUpdate(item)
        }
    }

    protected suspend fun <T : RealmObject, V : Any> update(
        clazz: Class<T>,
        fieldName: String,
        value: V,
        updater: (T) -> Unit,
    ) {
        executeTransaction { realm ->
            realm.where(clazz)
                .applyEqualTo(fieldName, value)
                .findFirst()?.let { updater(it) }
        }
    }

    protected suspend fun <T : RealmObject, V : Any> delete(
        clazz: Class<T>,
        fieldName: String,
        value: V,
    ) {
        executeTransaction { realm ->
            realm.where(clazz)
                .applyEqualTo(fieldName, value)
                .findFirst()?.deleteFromRealm()
        }
    }

    protected suspend fun <T> withRealm(
        ensureLatest: Boolean = false,
        operation: (Realm) -> T,
    ): T {
        return databaseService.withRealmAsync { realm ->
            if (ensureLatest) {
                realm.refresh()
            }
            operation(realm)
        }
    }

    protected suspend fun <T> withRealmAsync(operation: (Realm) -> T): T {
        return withRealm(false, operation)
    }

    protected fun <T> withRealmFlow(
        block: suspend (Realm, ProducerScope<T>) -> (() -> Unit),
    ): Flow<T> =
        callbackFlow {
            val realm = Realm.getDefaultInstance()
            val cleanup = try {
                block(realm, this)
            } catch (throwable: Throwable) {
                realm.close()
                throw throwable
            }
            awaitClose {
                cleanup()
                if (!realm.isClosed) {
                    realm.close()
                }
            }
        }

    protected suspend fun executeTransaction(transaction: (Realm) -> Unit) {
        databaseService.executeTransactionAsync(transaction)
    }
}
=======
package org.ole.planet.myplanet.repository


import io.realm.Realm
import io.realm.RealmChangeListener
import io.realm.RealmObject
import io.realm.RealmQuery
import io.realm.RealmResults
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.ProducerScope
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.applyEqualTo
import org.ole.planet.myplanet.datamanager.findCopyByField
import org.ole.planet.myplanet.datamanager.queryList

open class RealmRepository(protected val databaseService: DatabaseService) {
    protected suspend fun <T : RealmObject> queryList(
        clazz: Class<T>,
        builder: RealmQuery<T>.() -> Unit = {},
    ): List<T> = queryList(clazz, false, builder)

    protected suspend fun <T : RealmObject> queryList(
        clazz: Class<T>,
        ensureLatest: Boolean,
        builder: RealmQuery<T>.() -> Unit = {},
    ): List<T> =
        withRealm(ensureLatest) { realm ->
            realm.queryList(clazz, builder)
        }

    protected suspend fun <T : RealmObject> count(
        clazz: Class<T>,
        builder: RealmQuery<T>.() -> Unit = {},
    ): Long = count(clazz, false, builder)

    protected suspend fun <T : RealmObject> count(
        clazz: Class<T>,
        ensureLatest: Boolean,
        builder: RealmQuery<T>.() -> Unit = {},
    ): Long =
        withRealm(ensureLatest) { realm ->
            realm.where(clazz).apply(builder).count()
        }

    protected suspend fun <T : RealmObject> queryListFlow(
        clazz: Class<T>,
        builder: RealmQuery<T>.() -> Unit = {},
    ): Flow<List<T>> = withContext(Dispatchers.Main) {
        withRealmFlow { realm, scope ->
            val results = realm.where(clazz).apply(builder).findAllAsync()
            val listener =
                RealmChangeListener<RealmResults<T>> { updatedResults ->
                    if (updatedResults.isLoaded && updatedResults.isValid) {
                        scope.trySend(realm.copyFromRealm(updatedResults))
                    }
                }
            results.addChangeListener(listener)
            if (results.isLoaded && results.isValid) {
                scope.trySend(realm.copyFromRealm(results))
            }
            return@withRealmFlow { results.removeChangeListener(listener) }
        }
    }

    protected suspend fun <T : RealmObject, V : Any> findByField(
        clazz: Class<T>,
        fieldName: String,
        value: V,
    ): T? = findByField(clazz, fieldName, value, false)

    protected suspend fun <T : RealmObject, V : Any> findByField(
        clazz: Class<T>,
        fieldName: String,
        value: V,
        ensureLatest: Boolean,
    ): T? =
        withRealm(ensureLatest) { realm ->
            realm.findCopyByField(clazz, fieldName, value)
        }

    protected suspend fun <T : RealmObject> save(item: T) {
        executeTransaction { realm ->
            realm.copyToRealmOrUpdate(item)
        }
    }

    protected suspend fun <T : RealmObject, V : Any> update(
        clazz: Class<T>,
        fieldName: String,
        value: V,
        updater: (T) -> Unit,
    ) {
        executeTransaction { realm ->
            realm.where(clazz)
                .applyEqualTo(fieldName, value)
                .findFirst()?.let { updater(it) }
        }
    }

    protected suspend fun <T : RealmObject, V : Any> delete(
        clazz: Class<T>,
        fieldName: String,
        value: V,
    ) {
        executeTransaction { realm ->
            realm.where(clazz)
                .applyEqualTo(fieldName, value)
                .findFirst()?.deleteFromRealm()
        }
    }

    protected suspend fun <T> withRealm(
        ensureLatest: Boolean = false,
        operation: (Realm) -> T,
    ): T {
        return databaseService.withRealmAsync { realm ->
            if (ensureLatest) {
                realm.refresh()
            }
            operation(realm)
        }
    }

    protected suspend fun <T> withRealmAsync(operation: (Realm) -> T): T {
        return withRealm(false, operation)
    }

    protected fun <T> withRealmFlow(
        block: suspend (Realm, ProducerScope<T>) -> (() -> Unit),
    ): Flow<T> =
        callbackFlow {
            val realm = Realm.getDefaultInstance()
            val cleanup = try {
                block(realm, this)
            } catch (throwable: Throwable) {
                realm.close()
                throw throwable
            }
            awaitClose {
                cleanup()
                if (!realm.isClosed) {
                    realm.close()
                }
            }
        }

    protected suspend fun executeTransaction(transaction: (Realm) -> Unit) {
        databaseService.executeTransactionAsync(transaction)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/ChatRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import io.realm.Case
import io.realm.Sort
import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmChatHistory
import org.ole.planet.myplanet.model.RealmNews

class ChatRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
) : RealmRepository(databaseService), ChatRepository {

    override suspend fun getChatHistoryForUser(userName: String?): List<RealmChatHistory> {
        if (userName.isNullOrEmpty()) {
            return emptyList()
        }
        return queryList(RealmChatHistory::class.java) {
            equalTo("user", userName)
            sort("id", Sort.DESCENDING)
        }
    }

    override suspend fun getPlanetNewsMessages(planetCode: String?): List<RealmNews> {
        if (planetCode.isNullOrEmpty()) {
            return emptyList()
        }
        return queryList(RealmNews::class.java) {
            equalTo("docType", "message", Case.INSENSITIVE)
            equalTo("createdOn", planetCode, Case.INSENSITIVE)
        }
    }
}
=======
package org.ole.planet.myplanet.repository


import io.realm.Case
import io.realm.Sort
import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmChatHistory
import org.ole.planet.myplanet.model.RealmNews

class ChatRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
) : RealmRepository(databaseService), ChatRepository {

    override suspend fun getChatHistoryForUser(userName: String?): List<RealmChatHistory> {
        if (userName.isNullOrEmpty()) {
            return emptyList()
        }
        return queryList(RealmChatHistory::class.java) {
            equalTo("user", userName)
            sort("id", Sort.DESCENDING)
        }
    }

    override suspend fun getPlanetNewsMessages(planetCode: String?): List<RealmNews> {
        if (planetCode.isNullOrEmpty()) {
            return emptyList()
        }
        return queryList(RealmNews::class.java) {
            equalTo("docType", "message", Case.INSENSITIVE)
            equalTo("createdOn", planetCode, Case.INSENSITIVE)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/SurveyRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import android.content.Context
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import org.json.JSONException
import org.json.JSONObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.ui.survey.SurveyInfo
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDateWithTime

class SurveyRepositoryImpl @Inject constructor(
    @ApplicationContext private val context: Context,
    databaseService: DatabaseService
) : RealmRepository(databaseService), SurveyRepository {

    override suspend fun getTeamOwnedSurveys(teamId: String?): List<RealmStepExam> {
        if (teamId.isNullOrEmpty()) return emptyList()

        val teamSubmissionIds = getTeamSubmissionExamIds(teamId)
        return queryList(RealmStepExam::class.java) {
            equalTo("type", "surveys")

            beginGroup()
            equalTo("teamId", teamId)
            if (teamSubmissionIds.isNotEmpty()) {
                or()
                `in`("id", teamSubmissionIds.toTypedArray())
            }
            endGroup()
        }
    }

    override suspend fun getAdoptableTeamSurveys(teamId: String?): List<RealmStepExam> {
        if (teamId.isNullOrEmpty()) return emptyList()

        val teamSubmissionIds = getTeamSubmissionExamIds(teamId)

        return queryList(RealmStepExam::class.java) {
            equalTo("type", "surveys")

            if (teamSubmissionIds.isNotEmpty()) {
                beginGroup()
                equalTo("isTeamShareAllowed", true)
                and()
                not()
                `in`("id", teamSubmissionIds.toTypedArray())
                endGroup()
            } else {
                equalTo("isTeamShareAllowed", true)
            }
        }
    }

    override suspend fun getIndividualSurveys(): List<RealmStepExam> {
        return queryList(RealmStepExam::class.java) {
            equalTo("type", "surveys")
            equalTo("isTeamShareAllowed", false)
        }
    }

    private suspend fun getTeamSubmissionExamIds(teamId: String): Set<String> {
        val submissions = queryList(RealmSubmission::class.java) {
            isNotNull("membershipDoc")
            equalTo("membershipDoc.teamId", teamId)
        }

        return submissions
            .mapNotNull { parseParentExamId(it.parent) }
            .toSet()
    }

    private fun parseParentExamId(parent: String?): String? {
        if (parent.isNullOrEmpty()) {
            return null
        }
        return try {
            JSONObject(parent).optString("_id").takeIf { it.isNotEmpty() }
        } catch (error: JSONException) {
            null
        }
    }

    override suspend fun getSurveyInfos(
        isTeam: Boolean,
        teamId: String?,
        userId: String?,
        surveys: List<RealmStepExam>
    ): Map<String, SurveyInfo> {
        val surveyIds = surveys.map { it.id }
        val submissions = queryList(RealmSubmission::class.java) {
            `in`("parentId", surveyIds.toTypedArray())
        }
        val surveyInfos = mutableMapOf<String, SurveyInfo>()
        for (survey in surveys) {
            val surveyId = survey.id ?: continue
            val submissionCount = if (isTeam) {
                submissions.count { it.parentId == surveyId && it.membershipDoc?.teamId == teamId }.toString()
            } else {
                submissions.count { it.parentId == surveyId && it.userId == userId }.toString()
            }
            val lastSubmissionDate = if (isTeam) {
                submissions.filter { it.parentId == surveyId && it.membershipDoc?.teamId == teamId }
                    .maxByOrNull { it.startTime }?.startTime?.let { getFormattedDateWithTime(it) } ?: ""
            } else {
                submissions.filter { it.parentId == surveyId && it.userId == userId }
                    .maxByOrNull { it.startTime }?.startTime?.let { getFormattedDateWithTime(it) } ?: ""
            }
            val creationDate = survey.createdDate.let { formatDate(it, "MMM dd, yyyy") } ?: ""
            surveyInfos[surveyId] = SurveyInfo(
                surveyId = surveyId,
                submissionCount = context.resources.getQuantityString(
                    R.plurals.survey_taken_count,
                    submissionCount.toInt(),
                    submissionCount.toInt()
                ),
                lastSubmissionDate = lastSubmissionDate,
                creationDate = creationDate
            )
        }
        return surveyInfos
    }
}
=======
package org.ole.planet.myplanet.repository


import android.content.Context
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import org.json.JSONException
import org.json.JSONObject
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.ui.survey.SurveyInfo
import org.ole.planet.myplanet.utilities.TimeUtils.formatDate
import org.ole.planet.myplanet.utilities.TimeUtils.getFormattedDateWithTime

class SurveyRepositoryImpl @Inject constructor(
    @ApplicationContext private val context: Context,
    databaseService: DatabaseService
) : RealmRepository(databaseService), SurveyRepository {

    override suspend fun getTeamOwnedSurveys(teamId: String?): List<RealmStepExam> {
        if (teamId.isNullOrEmpty()) return emptyList()

        val teamSubmissionIds = getTeamSubmissionExamIds(teamId)
        return queryList(RealmStepExam::class.java) {
            equalTo("type", "surveys")

            beginGroup()
            equalTo("teamId", teamId)
            if (teamSubmissionIds.isNotEmpty()) {
                or()
                `in`("id", teamSubmissionIds.toTypedArray())
            }
            endGroup()
        }
    }

    override suspend fun getAdoptableTeamSurveys(teamId: String?): List<RealmStepExam> {
        if (teamId.isNullOrEmpty()) return emptyList()

        val teamSubmissionIds = getTeamSubmissionExamIds(teamId)

        return queryList(RealmStepExam::class.java) {
            equalTo("type", "surveys")

            if (teamSubmissionIds.isNotEmpty()) {
                beginGroup()
                equalTo("isTeamShareAllowed", true)
                and()
                not()
                `in`("id", teamSubmissionIds.toTypedArray())
                endGroup()
            } else {
                equalTo("isTeamShareAllowed", true)
            }
        }
    }

    override suspend fun getIndividualSurveys(): List<RealmStepExam> {
        return queryList(RealmStepExam::class.java) {
            equalTo("type", "surveys")
            equalTo("isTeamShareAllowed", false)
        }
    }

    private suspend fun getTeamSubmissionExamIds(teamId: String): Set<String> {
        val submissions = queryList(RealmSubmission::class.java) {
            isNotNull("membershipDoc")
            equalTo("membershipDoc.teamId", teamId)
        }

        return submissions
            .mapNotNull { parseParentExamId(it.parent) }
            .toSet()
    }

    private fun parseParentExamId(parent: String?): String? {
        if (parent.isNullOrEmpty()) {
            return null
        }
        return try {
            JSONObject(parent).optString("_id").takeIf { it.isNotEmpty() }
        } catch (error: JSONException) {
            null
        }
    }

    override suspend fun getSurveyInfos(
        isTeam: Boolean,
        teamId: String?,
        userId: String?,
        surveys: List<RealmStepExam>
    ): Map<String, SurveyInfo> {
        val surveyIds = surveys.map { it.id }
        val submissions = queryList(RealmSubmission::class.java) {
            `in`("parentId", surveyIds.toTypedArray())
        }
        val surveyInfos = mutableMapOf<String, SurveyInfo>()
        for (survey in surveys) {
            val surveyId = survey.id ?: continue
            val submissionCount = if (isTeam) {
                submissions.count { it.parentId == surveyId && it.membershipDoc?.teamId == teamId }.toString()
            } else {
                submissions.count { it.parentId == surveyId && it.userId == userId }.toString()
            }
            val lastSubmissionDate = if (isTeam) {
                submissions.filter { it.parentId == surveyId && it.membershipDoc?.teamId == teamId }
                    .maxByOrNull { it.startTime }?.startTime?.let { getFormattedDateWithTime(it) } ?: ""
            } else {
                submissions.filter { it.parentId == surveyId && it.userId == userId }
                    .maxByOrNull { it.startTime }?.startTime?.let { getFormattedDateWithTime(it) } ?: ""
            }
            val creationDate = survey.createdDate.let { formatDate(it, "MMM dd, yyyy") } ?: ""
            surveyInfos[surveyId] = SurveyInfo(
                surveyId = surveyId,
                submissionCount = context.resources.getQuantityString(
                    R.plurals.survey_taken_count,
                    submissionCount.toInt(),
                    submissionCount.toInt()
                ),
                lastSubmissionDate = lastSubmissionDate,
                creationDate = creationDate
            )
        }
        return surveyInfos
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/ChatRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import org.ole.planet.myplanet.model.RealmChatHistory
import org.ole.planet.myplanet.model.RealmNews

interface ChatRepository {
    suspend fun getChatHistoryForUser(userName: String?): List<RealmChatHistory>
    suspend fun getPlanetNewsMessages(planetCode: String?): List<RealmNews>
}
=======
package org.ole.planet.myplanet.repository


import org.ole.planet.myplanet.model.RealmChatHistory
import org.ole.planet.myplanet.model.RealmNews

interface ChatRepository {
    suspend fun getChatHistoryForUser(userName: String?): List<RealmChatHistory>
    suspend fun getPlanetNewsMessages(planetCode: String?): List<RealmNews>
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/NewsRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import com.google.gson.Gson
import com.google.gson.JsonArray
import io.realm.Case
import io.realm.Sort
import java.util.HashMap
import javax.inject.Inject
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.findCopyByField
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmNews.Companion.createNews
import org.ole.planet.myplanet.model.RealmUserModel

class NewsRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
    private val gson: Gson,
) : RealmRepository(databaseService), NewsRepository {

    override suspend fun getNewsWithReplies(newsId: String): Pair<RealmNews?, List<RealmNews>> {
        return withRealm(ensureLatest = true) { realm ->
            val news = realm.findCopyByField(RealmNews::class.java, "id", newsId)
            val replies = realm.where(RealmNews::class.java)
                .equalTo("replyTo", newsId, Case.INSENSITIVE)
                .sort("time", Sort.DESCENDING)
                .findAll()
                .let { realm.copyFromRealm(it) }
            news to replies
        }
    }

    override suspend fun getCommunityVisibleNews(userIdentifier: String): List<RealmNews> {
        val allNews = queryList(RealmNews::class.java) {
            isEmpty("replyTo")
            equalTo("docType", "message", Case.INSENSITIVE)
            sort("time", Sort.DESCENDING)
        }
        if (allNews.isEmpty()) {
            return emptyList()
        }

        return allNews.filter { news ->
            isVisibleToUser(news, userIdentifier)
        }
    }

    override suspend fun createNews(map: HashMap<String?, String>, user: RealmUserModel?): RealmNews {
        return withRealmAsync { realm ->
            val managedNews = createNews(map, realm, user, null)
            realm.copyFromRealm(managedNews)
        }
    }

    private fun isVisibleToUser(news: RealmNews, userIdentifier: String): Boolean {
        if (news.viewableBy.equals("community", ignoreCase = true)) {
            return true
        }

        val viewIn = news.viewIn ?: return false
        if (viewIn.isEmpty()) {
            return false
        }

        return try {
            val array = gson.fromJson(viewIn, JsonArray::class.java)
            array?.any { element ->
                element != null && element.isJsonObject &&
                    element.asJsonObject.has("_id") &&
                    element.asJsonObject.get("_id").asString.equals(userIdentifier, ignoreCase = true)
            } == true
        } catch (throwable: Throwable) {
            false
        }
    }
    override suspend fun getCommunityNews(userIdentifier: String): Flow<List<RealmNews>> {
        val allNewsFlow = queryListFlow(RealmNews::class.java) {
            isEmpty("replyTo")
            equalTo("docType", "message", Case.INSENSITIVE)
            sort("time", Sort.DESCENDING)
        }
        return allNewsFlow.map { allNews ->
            allNews.filter { news ->
                isVisibleToUser(news, userIdentifier)
            }
        }
    }
}
=======
package org.ole.planet.myplanet.repository


import com.google.gson.Gson
import com.google.gson.JsonArray
import io.realm.Case
import io.realm.Sort
import java.util.HashMap
import javax.inject.Inject
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.findCopyByField
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmNews.Companion.createNews
import org.ole.planet.myplanet.model.RealmUserModel

class NewsRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
    private val gson: Gson,
) : RealmRepository(databaseService), NewsRepository {

    override suspend fun getNewsWithReplies(newsId: String): Pair<RealmNews?, List<RealmNews>> {
        return withRealm(ensureLatest = true) { realm ->
            val news = realm.findCopyByField(RealmNews::class.java, "id", newsId)
            val replies = realm.where(RealmNews::class.java)
                .equalTo("replyTo", newsId, Case.INSENSITIVE)
                .sort("time", Sort.DESCENDING)
                .findAll()
                .let { realm.copyFromRealm(it) }
            news to replies
        }
    }

    override suspend fun getCommunityVisibleNews(userIdentifier: String): List<RealmNews> {
        val allNews = queryList(RealmNews::class.java) {
            isEmpty("replyTo")
            equalTo("docType", "message", Case.INSENSITIVE)
            sort("time", Sort.DESCENDING)
        }
        if (allNews.isEmpty()) {
            return emptyList()
        }

        return allNews.filter { news ->
            isVisibleToUser(news, userIdentifier)
        }
    }

    override suspend fun createNews(map: HashMap<String?, String>, user: RealmUserModel?): RealmNews {
        return withRealmAsync { realm ->
            val managedNews = createNews(map, realm, user, null)
            realm.copyFromRealm(managedNews)
        }
    }

    private fun isVisibleToUser(news: RealmNews, userIdentifier: String): Boolean {
        if (news.viewableBy.equals("community", ignoreCase = true)) {
            return true
        }

        val viewIn = news.viewIn ?: return false
        if (viewIn.isEmpty()) {
            return false
        }

        return try {
            val array = gson.fromJson(viewIn, JsonArray::class.java)
            array?.any { element ->
                element != null && element.isJsonObject &&
                    element.asJsonObject.has("_id") &&
                    element.asJsonObject.get("_id").asString.equals(userIdentifier, ignoreCase = true)
            } == true
        } catch (throwable: Throwable) {
            false
        }
    }
    override suspend fun getCommunityNews(userIdentifier: String): Flow<List<RealmNews>> {
        val allNewsFlow = queryListFlow(RealmNews::class.java) {
            isEmpty("replyTo")
            equalTo("docType", "message", Case.INSENSITIVE)
            sort("time", Sort.DESCENDING)
        }
        return allNewsFlow.map { allNews ->
            allNews.filter { news ->
                isVisibleToUser(news, userIdentifier)
            }
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/MeetupRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmUserModel

class MeetupRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
) : RealmRepository(databaseService), MeetupRepository {

    override suspend fun getMeetupsForTeam(teamId: String): List<RealmMeetup> {
        return queryList(RealmMeetup::class.java) {
            equalTo("teamId", teamId)
        }
    }

    override suspend fun getMeetupById(meetupId: String): RealmMeetup? {
        if (meetupId.isBlank()) {
            return null
        }
        return findByField(RealmMeetup::class.java, "meetupId", meetupId)
    }

    override suspend fun getJoinedMembers(meetupId: String): List<RealmUserModel> {
        if (meetupId.isBlank()) {
            return emptyList()
        }
        return withRealmAsync { realm ->
            val meetupMembers = realm.where(RealmMeetup::class.java)
                .equalTo("meetupId", meetupId)
                .isNotEmpty("userId")
                .findAll()
            val memberIds = meetupMembers.mapNotNull { member ->
                member.userId?.takeUnless { it.isBlank() }
            }.distinct()
            if (memberIds.isEmpty()) {
                emptyList()
            } else {
                val users = realm.where(RealmUserModel::class.java)
                    .`in`("id", memberIds.toTypedArray())
                    .findAll()
                realm.copyFromRealm(users)
            }
        }
    }

    override suspend fun toggleAttendance(meetupId: String, currentUserId: String?): RealmMeetup? {
        if (meetupId.isBlank()) {
            return null
        }
        var updatedMeetup: RealmMeetup? = null
        executeTransaction { realm ->
            val meetup = realm.where(RealmMeetup::class.java)
                .equalTo("meetupId", meetupId)
                .findFirst()
                ?: return@executeTransaction

            val isJoined = !meetup.userId.isNullOrEmpty()
            if (!isJoined && currentUserId.isNullOrEmpty()) {
                return@executeTransaction
            }

            meetup.userId = if (isJoined) "" else currentUserId
            updatedMeetup = realm.copyFromRealm(meetup)
        }
        return updatedMeetup ?: getMeetupById(meetupId)
    }
}
=======
package org.ole.planet.myplanet.repository


import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmUserModel

class MeetupRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
) : RealmRepository(databaseService), MeetupRepository {

    override suspend fun getMeetupsForTeam(teamId: String): List<RealmMeetup> {
        return queryList(RealmMeetup::class.java) {
            equalTo("teamId", teamId)
        }
    }

    override suspend fun getMeetupById(meetupId: String): RealmMeetup? {
        if (meetupId.isBlank()) {
            return null
        }
        return findByField(RealmMeetup::class.java, "meetupId", meetupId)
    }

    override suspend fun getJoinedMembers(meetupId: String): List<RealmUserModel> {
        if (meetupId.isBlank()) {
            return emptyList()
        }
        return withRealmAsync { realm ->
            val meetupMembers = realm.where(RealmMeetup::class.java)
                .equalTo("meetupId", meetupId)
                .isNotEmpty("userId")
                .findAll()
            val memberIds = meetupMembers.mapNotNull { member ->
                member.userId?.takeUnless { it.isBlank() }
            }.distinct()
            if (memberIds.isEmpty()) {
                emptyList()
            } else {
                val users = realm.where(RealmUserModel::class.java)
                    .`in`("id", memberIds.toTypedArray())
                    .findAll()
                realm.copyFromRealm(users)
            }
        }
    }

    override suspend fun toggleAttendance(meetupId: String, currentUserId: String?): RealmMeetup? {
        if (meetupId.isBlank()) {
            return null
        }
        var updatedMeetup: RealmMeetup? = null
        executeTransaction { realm ->
            val meetup = realm.where(RealmMeetup::class.java)
                .equalTo("meetupId", meetupId)
                .findFirst()
                ?: return@executeTransaction

            val isJoined = !meetup.userId.isNullOrEmpty()
            if (!isJoined && currentUserId.isNullOrEmpty()) {
                return@executeTransaction
            }

            meetup.userId = if (isJoined) "" else currentUserId
            updatedMeetup = realm.copyFromRealm(meetup)
        }
        return updatedMeetup ?: getMeetupById(meetupId)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/SubmissionRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission

interface SubmissionRepository {
    suspend fun getPendingSurveys(userId: String?): List<RealmSubmission>
    suspend fun getUniquePendingSurveys(userId: String?): List<RealmSubmission>
    suspend fun getSurveyTitlesFromSubmissions(submissions: List<RealmSubmission>): List<String>
    suspend fun getSubmissionById(id: String): RealmSubmission?
    suspend fun getSubmissionsByIds(ids: List<String>): List<RealmSubmission>
    suspend fun getSubmissionsByUserId(userId: String): List<RealmSubmission>
    suspend fun getExamMapForSubmissions(submissions: List<RealmSubmission>): Map<String?, RealmStepExam>
    suspend fun getExamQuestionCount(stepId: String): Int
    suspend fun hasSubmission(
        stepExamId: String?,
        courseId: String?,
        userId: String?,
        type: String,
    ): Boolean
    suspend fun hasPendingOfflineSubmissions(): Boolean
    suspend fun hasPendingExamResults(): Boolean
    suspend fun createSurveySubmission(examId: String, userId: String?)
    suspend fun saveSubmission(submission: RealmSubmission)
}
=======
package org.ole.planet.myplanet.repository


import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission

interface SubmissionRepository {
    suspend fun getPendingSurveys(userId: String?): List<RealmSubmission>
    suspend fun getUniquePendingSurveys(userId: String?): List<RealmSubmission>
    suspend fun getSurveyTitlesFromSubmissions(submissions: List<RealmSubmission>): List<String>
    suspend fun getSubmissionById(id: String): RealmSubmission?
    suspend fun getSubmissionsByIds(ids: List<String>): List<RealmSubmission>
    suspend fun getSubmissionsByUserId(userId: String): List<RealmSubmission>
    suspend fun getExamMapForSubmissions(submissions: List<RealmSubmission>): Map<String?, RealmStepExam>
    suspend fun getExamQuestionCount(stepId: String): Int
    suspend fun hasSubmission(
        stepExamId: String?,
        courseId: String?,
        userId: String?,
        type: String,
    ): Boolean
    suspend fun hasPendingOfflineSubmissions(): Boolean
    suspend fun hasPendingExamResults(): Boolean
    suspend fun createSurveySubmission(examId: String, userId: String?)
    suspend fun saveSubmission(submission: RealmSubmission)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/UserRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import org.ole.planet.myplanet.model.RealmUserModel

interface UserRepository {
    suspend fun getUserById(userId: String): RealmUserModel?
    suspend fun getUserByAnyId(id: String): RealmUserModel?
    suspend fun getAllUsers(): List<RealmUserModel>
    suspend fun getMonthlyLoginCounts(
        userId: String,
        startMillis: Long,
        endMillis: Long,
    ): Map<Int, Int>
    suspend fun updateSecurityData(
        name: String,
        userId: String?,
        rev: String?,
        derivedKey: String?,
        salt: String?,
        passwordScheme: String?,
        iterations: String?,
    )
}
=======
package org.ole.planet.myplanet.repository


import org.ole.planet.myplanet.model.RealmUserModel

interface UserRepository {
    suspend fun getUserById(userId: String): RealmUserModel?
    suspend fun getUserByAnyId(id: String): RealmUserModel?
    suspend fun getAllUsers(): List<RealmUserModel>
    suspend fun getMonthlyLoginCounts(
        userId: String,
        startMillis: Long,
        endMillis: Long,
    ): Map<Int, Int>
    suspend fun updateSecurityData(
        name: String,
        userId: String?,
        rev: String?,
        derivedKey: String?,
        salt: String?,
        passwordScheme: String?,
        iterations: String?,
    )
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/LibraryRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmRemovedLog
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.onAdd
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.onRemove

class LibraryRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), LibraryRepository {

    override suspend fun getAllLibraryItems(): List<RealmMyLibrary> {
        return queryList(RealmMyLibrary::class.java)
    }

    override suspend fun getLibraryItemById(id: String): RealmMyLibrary? {
        return findByField(RealmMyLibrary::class.java, "id", id)
    }

    override suspend fun getLibraryItemByResourceId(resourceId: String): RealmMyLibrary? {
        return findByField(RealmMyLibrary::class.java, "resourceId", resourceId)
            ?: findByField(RealmMyLibrary::class.java, "_id", resourceId)
    }

    override suspend fun getLibraryItemsByIds(ids: Collection<String>): List<RealmMyLibrary> {
        if (ids.isEmpty()) return emptyList()

        return queryList(RealmMyLibrary::class.java) {
            this.`in`("_id", ids.toTypedArray())
        }
    }

    override suspend fun getLibraryItemsByLocalAddress(localAddress: String): List<RealmMyLibrary> {
        return queryList(RealmMyLibrary::class.java) {
            equalTo("resourceLocalAddress", localAddress)
        }
    }

    override suspend fun getLibraryListForUser(userId: String?): List<RealmMyLibrary> {
        if (userId == null) return emptyList()

        val results = queryList(RealmMyLibrary::class.java) {
            equalTo("isPrivate", false)
        }
        return filterLibrariesNeedingUpdate(results)
            .filter { it.userId?.contains(userId) == true }
    }

    override suspend fun getStepResources(stepId: String?, resourceOffline: Boolean): List<RealmMyLibrary> {
        if (stepId == null) return emptyList()

        return queryList(RealmMyLibrary::class.java) {
            equalTo("stepId", stepId)
            equalTo("resourceOffline", resourceOffline)
            isNotNull("resourceLocalAddress")
        }
    }

    override suspend fun countLibrariesNeedingUpdate(userId: String?): Int {
        if (userId == null) return 0

        val results = queryList(RealmMyLibrary::class.java) {
            equalTo("isPrivate", false)
        }
        return filterLibrariesNeedingUpdate(results)
            .count { it.userId?.contains(userId) == true }
    }

    override suspend fun saveLibraryItem(item: RealmMyLibrary) {
        save(item)
    }

    override suspend fun markResourceAdded(userId: String?, resourceId: String) {
        withRealmAsync { realm ->
            RealmRemovedLog.onAdd(realm, "resources", userId, resourceId)
        }
    }

    override suspend fun updateUserLibrary(
        resourceId: String,
        userId: String,
        isAdd: Boolean,
    ): RealmMyLibrary? {
        executeTransaction { realm ->
            realm.where(RealmMyLibrary::class.java)
                .equalTo("resourceId", resourceId)
                .findFirst()?.let { library ->
                    if (isAdd) {
                        library.setUserId(userId)
                    } else {
                        library.removeUserId(userId)
                    }
                }
        }
        withRealmAsync { realm ->
            if (isAdd) {
                onAdd(realm, "resources", userId, resourceId)
            } else {
                onRemove(realm, "resources", userId, resourceId)
            }
        }
        return getLibraryItemByResourceId(resourceId)
            ?: getLibraryItemById(resourceId)
    }

    override suspend fun updateLibraryItem(id: String, updater: (RealmMyLibrary) -> Unit) {
        update(RealmMyLibrary::class.java, "id", id, updater)
    }

    override suspend fun markResourceOfflineByLocalAddress(localAddress: String) {
        executeTransaction { realm ->
            realm.where(RealmMyLibrary::class.java)
                .equalTo("resourceLocalAddress", localAddress)
                .findAll()
                ?.forEach { library ->
                    library.resourceOffline = true
                    library.downloadedRev = library._rev
                }
        }
    }

    private fun filterLibrariesNeedingUpdate(results: Collection<RealmMyLibrary>): List<RealmMyLibrary> {
        return results.filter { it.needToUpdate() }
    }
}
=======
package org.ole.planet.myplanet.repository


import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmRemovedLog
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.onAdd
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.onRemove

class LibraryRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), LibraryRepository {

    override suspend fun getAllLibraryItems(): List<RealmMyLibrary> {
        return queryList(RealmMyLibrary::class.java)
    }

    override suspend fun getLibraryItemById(id: String): RealmMyLibrary? {
        return findByField(RealmMyLibrary::class.java, "id", id)
    }

    override suspend fun getLibraryItemByResourceId(resourceId: String): RealmMyLibrary? {
        return findByField(RealmMyLibrary::class.java, "resourceId", resourceId)
            ?: findByField(RealmMyLibrary::class.java, "_id", resourceId)
    }

    override suspend fun getLibraryItemsByIds(ids: Collection<String>): List<RealmMyLibrary> {
        if (ids.isEmpty()) return emptyList()

        return queryList(RealmMyLibrary::class.java) {
            this.`in`("_id", ids.toTypedArray())
        }
    }

    override suspend fun getLibraryItemsByLocalAddress(localAddress: String): List<RealmMyLibrary> {
        return queryList(RealmMyLibrary::class.java) {
            equalTo("resourceLocalAddress", localAddress)
        }
    }

    override suspend fun getLibraryListForUser(userId: String?): List<RealmMyLibrary> {
        if (userId == null) return emptyList()

        val results = queryList(RealmMyLibrary::class.java) {
            equalTo("isPrivate", false)
        }
        return filterLibrariesNeedingUpdate(results)
            .filter { it.userId?.contains(userId) == true }
    }

    override suspend fun getStepResources(stepId: String?, resourceOffline: Boolean): List<RealmMyLibrary> {
        if (stepId == null) return emptyList()

        return queryList(RealmMyLibrary::class.java) {
            equalTo("stepId", stepId)
            equalTo("resourceOffline", resourceOffline)
            isNotNull("resourceLocalAddress")
        }
    }

    override suspend fun countLibrariesNeedingUpdate(userId: String?): Int {
        if (userId == null) return 0

        val results = queryList(RealmMyLibrary::class.java) {
            equalTo("isPrivate", false)
        }
        return filterLibrariesNeedingUpdate(results)
            .count { it.userId?.contains(userId) == true }
    }

    override suspend fun saveLibraryItem(item: RealmMyLibrary) {
        save(item)
    }

    override suspend fun markResourceAdded(userId: String?, resourceId: String) {
        withRealmAsync { realm ->
            RealmRemovedLog.onAdd(realm, "resources", userId, resourceId)
        }
    }

    override suspend fun updateUserLibrary(
        resourceId: String,
        userId: String,
        isAdd: Boolean,
    ): RealmMyLibrary? {
        executeTransaction { realm ->
            realm.where(RealmMyLibrary::class.java)
                .equalTo("resourceId", resourceId)
                .findFirst()?.let { library ->
                    if (isAdd) {
                        library.setUserId(userId)
                    } else {
                        library.removeUserId(userId)
                    }
                }
        }
        withRealmAsync { realm ->
            if (isAdd) {
                onAdd(realm, "resources", userId, resourceId)
            } else {
                onRemove(realm, "resources", userId, resourceId)
            }
        }
        return getLibraryItemByResourceId(resourceId)
            ?: getLibraryItemById(resourceId)
    }

    override suspend fun updateLibraryItem(id: String, updater: (RealmMyLibrary) -> Unit) {
        update(RealmMyLibrary::class.java, "id", id, updater)
    }

    override suspend fun markResourceOfflineByLocalAddress(localAddress: String) {
        executeTransaction { realm ->
            realm.where(RealmMyLibrary::class.java)
                .equalTo("resourceLocalAddress", localAddress)
                .findAll()
                ?.forEach { library ->
                    library.resourceOffline = true
                    library.downloadedRev = library._rev
                }
        }
    }

    private fun filterLibrariesNeedingUpdate(results: Collection<RealmMyLibrary>): List<RealmMyLibrary> {
        return results.filter { it.needToUpdate() }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/CourseRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary

interface CourseRepository {
    suspend fun getCourseByCourseId(courseId: String?): RealmMyCourse?
    suspend fun getCourseOnlineResources(courseId: String?): List<RealmMyLibrary>
    suspend fun getCourseOfflineResources(courseId: String?): List<RealmMyLibrary>
    suspend fun getCourseExamCount(courseId: String?): Int
    suspend fun getCourseSteps(courseId: String?): List<RealmCourseStep>
    suspend fun markCourseAdded(courseId: String, userId: String?): Boolean
}
=======
package org.ole.planet.myplanet.repository


import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary

interface CourseRepository {
    suspend fun getCourseByCourseId(courseId: String?): RealmMyCourse?
    suspend fun getCourseOnlineResources(courseId: String?): List<RealmMyLibrary>
    suspend fun getCourseOfflineResources(courseId: String?): List<RealmMyLibrary>
    suspend fun getCourseExamCount(courseId: String?): Int
    suspend fun getCourseSteps(courseId: String?): List<RealmCourseStep>
    suspend fun markCourseAdded(courseId: String, userId: String?): Boolean
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/NewsRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import java.util.HashMap
import kotlinx.coroutines.flow.Flow
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel

interface NewsRepository {
    suspend fun getCommunityNews(userIdentifier: String): Flow<List<RealmNews>>
    suspend fun getNewsWithReplies(newsId: String): Pair<RealmNews?, List<RealmNews>>
    suspend fun getCommunityVisibleNews(userIdentifier: String): List<RealmNews>
    suspend fun createNews(map: HashMap<String?, String>, user: RealmUserModel?): RealmNews
}
=======
package org.ole.planet.myplanet.repository


import java.util.HashMap
import kotlinx.coroutines.flow.Flow
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel

interface NewsRepository {
    suspend fun getCommunityNews(userIdentifier: String): Flow<List<RealmNews>>
    suspend fun getNewsWithReplies(newsId: String): Pair<RealmNews?, List<RealmNews>>
    suspend fun getCommunityVisibleNews(userIdentifier: String): List<RealmNews>
    suspend fun createNews(map: HashMap<String?, String>, user: RealmUserModel?): RealmNews
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/MyPersonalRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import kotlinx.coroutines.flow.Flow
import org.ole.planet.myplanet.model.RealmMyPersonal

interface MyPersonalRepository {
    suspend fun savePersonalResource(
        title: String,
        userId: String?,
        userName: String?,
        path: String?,
        description: String?
    )

    suspend fun getPersonalResources(userId: String?): Flow<List<RealmMyPersonal>>

    suspend fun deletePersonalResource(id: String)

    suspend fun updatePersonalResource(id: String, updater: (RealmMyPersonal) -> Unit)
}
=======
package org.ole.planet.myplanet.repository


import kotlinx.coroutines.flow.Flow
import org.ole.planet.myplanet.model.RealmMyPersonal

interface MyPersonalRepository {
    suspend fun savePersonalResource(
        title: String,
        userId: String?,
        userName: String?,
        path: String?,
        description: String?
    )

    suspend fun getPersonalResources(userId: String?): Flow<List<RealmMyPersonal>>

    suspend fun deletePersonalResource(id: String)

    suspend fun updatePersonalResource(id: String, updater: (RealmMyPersonal) -> Unit)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/LibraryRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import org.ole.planet.myplanet.model.RealmMyLibrary

interface LibraryRepository {
    suspend fun getAllLibraryItems(): List<RealmMyLibrary>
    suspend fun getLibraryItemById(id: String): RealmMyLibrary?
    suspend fun getLibraryItemByResourceId(resourceId: String): RealmMyLibrary?
    suspend fun getLibraryItemsByIds(ids: Collection<String>): List<RealmMyLibrary>
    suspend fun getLibraryItemsByLocalAddress(localAddress: String): List<RealmMyLibrary>
    suspend fun getLibraryListForUser(userId: String?): List<RealmMyLibrary>
    suspend fun getStepResources(stepId: String?, resourceOffline: Boolean): List<RealmMyLibrary>
    suspend fun countLibrariesNeedingUpdate(userId: String?): Int
    suspend fun saveLibraryItem(item: RealmMyLibrary)
    suspend fun markResourceAdded(userId: String?, resourceId: String)
    suspend fun updateUserLibrary(resourceId: String, userId: String, isAdd: Boolean): RealmMyLibrary?
    suspend fun updateLibraryItem(id: String, updater: (RealmMyLibrary) -> Unit)
    suspend fun markResourceOfflineByLocalAddress(localAddress: String)
}
=======
package org.ole.planet.myplanet.repository


import org.ole.planet.myplanet.model.RealmMyLibrary

interface LibraryRepository {
    suspend fun getAllLibraryItems(): List<RealmMyLibrary>
    suspend fun getLibraryItemById(id: String): RealmMyLibrary?
    suspend fun getLibraryItemByResourceId(resourceId: String): RealmMyLibrary?
    suspend fun getLibraryItemsByIds(ids: Collection<String>): List<RealmMyLibrary>
    suspend fun getLibraryItemsByLocalAddress(localAddress: String): List<RealmMyLibrary>
    suspend fun getLibraryListForUser(userId: String?): List<RealmMyLibrary>
    suspend fun getStepResources(stepId: String?, resourceOffline: Boolean): List<RealmMyLibrary>
    suspend fun countLibrariesNeedingUpdate(userId: String?): Int
    suspend fun saveLibraryItem(item: RealmMyLibrary)
    suspend fun markResourceAdded(userId: String?, resourceId: String)
    suspend fun updateUserLibrary(resourceId: String, userId: String, isAdd: Boolean): RealmMyLibrary?
    suspend fun updateLibraryItem(id: String, updater: (RealmMyLibrary) -> Unit)
    suspend fun markResourceOfflineByLocalAddress(localAddress: String)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/CourseRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmRemovedLog
import org.ole.planet.myplanet.model.RealmStepExam

class CourseRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), CourseRepository {

    override suspend fun getCourseByCourseId(courseId: String?): RealmMyCourse? {
        if (courseId.isNullOrBlank()) {
            return null
        }
        return findByField(RealmMyCourse::class.java, "courseId", courseId)
    }

    override suspend fun getCourseOnlineResources(courseId: String?): List<RealmMyLibrary> {
        return getCourseResources(courseId, isOffline = false)
    }

    override suspend fun getCourseOfflineResources(courseId: String?): List<RealmMyLibrary> {
        return getCourseResources(courseId, isOffline = true)
    }

    override suspend fun getCourseExamCount(courseId: String?): Int {
        if (courseId.isNullOrEmpty()) {
            return 0
        }
        return count(RealmStepExam::class.java) {
            equalTo("courseId", courseId)
        }.toInt()
    }

    override suspend fun getCourseSteps(courseId: String?): List<RealmCourseStep> {
        if (courseId.isNullOrEmpty()) {
            return emptyList()
        }
        return queryList(RealmCourseStep::class.java) {
            equalTo("courseId", courseId)
        }
    }

    override suspend fun markCourseAdded(courseId: String, userId: String?): Boolean {
        if (courseId.isBlank()) {
            return false
        }

        var courseFound = false
        executeTransaction { realm ->
            realm.where(RealmMyCourse::class.java)
                .equalTo("courseId", courseId)
                .findFirst()
                ?.let { course ->
                    course.setUserId(userId)
                    if (!userId.isNullOrBlank()) {
                        realm.where(RealmRemovedLog::class.java)
                            .equalTo("type", "courses")
                            .equalTo("userId", userId)
                            .equalTo("docId", course.courseId)
                            .findAll()
                            .deleteAllFromRealm()
                    }
                    courseFound = true
                }
        }

        return courseFound
    }

    private suspend fun getCourseResources(courseId: String?, isOffline: Boolean): List<RealmMyLibrary> {
        if (courseId.isNullOrEmpty()) {
            return emptyList()
        }
        return queryList(RealmMyLibrary::class.java) {
            equalTo("courseId", courseId)
            equalTo("resourceOffline", isOffline)
            isNotNull("resourceLocalAddress")
        }
    }
}
=======
package org.ole.planet.myplanet.repository


import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmCourseStep
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmRemovedLog
import org.ole.planet.myplanet.model.RealmStepExam

class CourseRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), CourseRepository {

    override suspend fun getCourseByCourseId(courseId: String?): RealmMyCourse? {
        if (courseId.isNullOrBlank()) {
            return null
        }
        return findByField(RealmMyCourse::class.java, "courseId", courseId)
    }

    override suspend fun getCourseOnlineResources(courseId: String?): List<RealmMyLibrary> {
        return getCourseResources(courseId, isOffline = false)
    }

    override suspend fun getCourseOfflineResources(courseId: String?): List<RealmMyLibrary> {
        return getCourseResources(courseId, isOffline = true)
    }

    override suspend fun getCourseExamCount(courseId: String?): Int {
        if (courseId.isNullOrEmpty()) {
            return 0
        }
        return count(RealmStepExam::class.java) {
            equalTo("courseId", courseId)
        }.toInt()
    }

    override suspend fun getCourseSteps(courseId: String?): List<RealmCourseStep> {
        if (courseId.isNullOrEmpty()) {
            return emptyList()
        }
        return queryList(RealmCourseStep::class.java) {
            equalTo("courseId", courseId)
        }
    }

    override suspend fun markCourseAdded(courseId: String, userId: String?): Boolean {
        if (courseId.isBlank()) {
            return false
        }

        var courseFound = false
        executeTransaction { realm ->
            realm.where(RealmMyCourse::class.java)
                .equalTo("courseId", courseId)
                .findFirst()
                ?.let { course ->
                    course.setUserId(userId)
                    if (!userId.isNullOrBlank()) {
                        realm.where(RealmRemovedLog::class.java)
                            .equalTo("type", "courses")
                            .equalTo("userId", userId)
                            .equalTo("docId", course.courseId)
                            .findAll()
                            .deleteAllFromRealm()
                    }
                    courseFound = true
                }
        }

        return courseFound
    }

    private suspend fun getCourseResources(courseId: String?, isOffline: Boolean): List<RealmMyLibrary> {
        if (courseId.isNullOrEmpty()) {
            return emptyList()
        }
        return queryList(RealmMyLibrary::class.java) {
            equalTo("courseId", courseId)
            equalTo("resourceOffline", isOffline)
            isNotNull("resourceLocalAddress")
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/MeetupRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmUserModel

interface MeetupRepository {
    suspend fun getMeetupsForTeam(teamId: String): List<RealmMeetup>
    suspend fun getMeetupById(meetupId: String): RealmMeetup?
    suspend fun getJoinedMembers(meetupId: String): List<RealmUserModel>
    suspend fun toggleAttendance(meetupId: String, currentUserId: String?): RealmMeetup?
}
=======
package org.ole.planet.myplanet.repository


import org.ole.planet.myplanet.model.RealmMeetup
import org.ole.planet.myplanet.model.RealmUserModel

interface MeetupRepository {
    suspend fun getMeetupsForTeam(teamId: String): List<RealmMeetup>
    suspend fun getMeetupById(meetupId: String): RealmMeetup?
    suspend fun getJoinedMembers(meetupId: String): List<RealmUserModel>
    suspend fun toggleAttendance(meetupId: String, currentUserId: String?): RealmMeetup?
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/MyPersonalRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import java.util.Date
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flowOf
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyPersonal

class MyPersonalRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), MyPersonalRepository {

    override suspend fun savePersonalResource(
        title: String,
        userId: String?,
        userName: String?,
        path: String?,
        description: String?
    ) {
        val personal = RealmMyPersonal().apply {
            id = UUID.randomUUID().toString()
            _id = id
            this.title = title
            this.userId = userId
            this.userName = userName
            this.path = path
            this.date = Date().time
            this.description = description
        }
        save(personal)
    }

    override suspend fun getPersonalResources(userId: String?): Flow<List<RealmMyPersonal>> {
        if (userId.isNullOrBlank()) {
            return flowOf(emptyList())
        }

        return queryListFlow(RealmMyPersonal::class.java) {
            equalTo("userId", userId)
        }
    }

    override suspend fun deletePersonalResource(id: String) {
        delete(RealmMyPersonal::class.java, "_id", id)
        delete(RealmMyPersonal::class.java, "id", id)
    }

    override suspend fun updatePersonalResource(id: String, updater: (RealmMyPersonal) -> Unit) {
        update(RealmMyPersonal::class.java, "_id", id, updater)
        update(RealmMyPersonal::class.java, "id", id, updater)
    }
}
=======
package org.ole.planet.myplanet.repository


import java.util.Date
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flowOf
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmMyPersonal

class MyPersonalRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), MyPersonalRepository {

    override suspend fun savePersonalResource(
        title: String,
        userId: String?,
        userName: String?,
        path: String?,
        description: String?
    ) {
        val personal = RealmMyPersonal().apply {
            id = UUID.randomUUID().toString()
            _id = id
            this.title = title
            this.userId = userId
            this.userName = userName
            this.path = path
            this.date = Date().time
            this.description = description
        }
        save(personal)
    }

    override suspend fun getPersonalResources(userId: String?): Flow<List<RealmMyPersonal>> {
        if (userId.isNullOrBlank()) {
            return flowOf(emptyList())
        }

        return queryListFlow(RealmMyPersonal::class.java) {
            equalTo("userId", userId)
        }
    }

    override suspend fun deletePersonalResource(id: String) {
        delete(RealmMyPersonal::class.java, "_id", id)
        delete(RealmMyPersonal::class.java, "id", id)
    }

    override suspend fun updatePersonalResource(id: String, updater: (RealmMyPersonal) -> Unit) {
        update(RealmMyPersonal::class.java, "_id", id, updater)
        update(RealmMyPersonal::class.java, "id", id, updater)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/SurveyRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.ui.survey.SurveyInfo

interface SurveyRepository {
    suspend fun getTeamOwnedSurveys(teamId: String?): List<RealmStepExam>
    suspend fun getAdoptableTeamSurveys(teamId: String?): List<RealmStepExam>
    suspend fun getIndividualSurveys(): List<RealmStepExam>
    suspend fun getSurveyInfos(
        isTeam: Boolean,
        teamId: String?,
        userId: String?,
        surveys: List<RealmStepExam>
    ): Map<String, SurveyInfo>
}
=======
package org.ole.planet.myplanet.repository


import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.ui.survey.SurveyInfo

interface SurveyRepository {
    suspend fun getTeamOwnedSurveys(teamId: String?): List<RealmStepExam>
    suspend fun getAdoptableTeamSurveys(teamId: String?): List<RealmStepExam>
    suspend fun getIndividualSurveys(): List<RealmStepExam>
    suspend fun getSurveyInfos(
        isTeam: Boolean,
        teamId: String?,
        userId: String?,
        surveys: List<RealmStepExam>
    ): Map<String, SurveyInfo>
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/UserRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import java.util.Calendar
import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmOfflineActivity
import org.ole.planet.myplanet.model.RealmUserModel

class UserRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), UserRepository {
    override suspend fun getUserById(userId: String): RealmUserModel? {
        return findByField(RealmUserModel::class.java, "id", userId)
    }

    override suspend fun getUserByAnyId(id: String): RealmUserModel? {
        return findByField(RealmUserModel::class.java, "_id", id)
            ?: findByField(RealmUserModel::class.java, "id", id)
    }

    override suspend fun getAllUsers(): List<RealmUserModel> {
        return queryList(RealmUserModel::class.java)
    }

    override suspend fun getMonthlyLoginCounts(
        userId: String,
        startMillis: Long,
        endMillis: Long,
    ): Map<Int, Int> {
        if (startMillis > endMillis) {
            return emptyMap()
        }

        val activities = queryList(RealmOfflineActivity::class.java) {
            equalTo("userId", userId)
            between("loginTime", startMillis, endMillis)
        }

        if (activities.isEmpty()) {
            return emptyMap()
        }

        val calendar = Calendar.getInstance()
        return activities.mapNotNull { it.loginTime }
            .map { loginTime ->
                calendar.timeInMillis = loginTime
                calendar.get(Calendar.MONTH)
            }
            .groupingBy { it }
            .eachCount()
            .toSortedMap()
    }

    override suspend fun updateSecurityData(
        name: String,
        userId: String?,
        rev: String?,
        derivedKey: String?,
        salt: String?,
        passwordScheme: String?,
        iterations: String?,
    ) {
        update(RealmUserModel::class.java, "name", name) { user ->
            user._id = userId
            user._rev = rev
            user.derived_key = derivedKey
            user.salt = salt
            user.password_scheme = passwordScheme
            user.iterations = iterations
            user.isUpdated = false
        }
    }
}
=======
package org.ole.planet.myplanet.repository


import java.util.Calendar
import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmOfflineActivity
import org.ole.planet.myplanet.model.RealmUserModel

class UserRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), UserRepository {
    override suspend fun getUserById(userId: String): RealmUserModel? {
        return findByField(RealmUserModel::class.java, "id", userId)
    }

    override suspend fun getUserByAnyId(id: String): RealmUserModel? {
        return findByField(RealmUserModel::class.java, "_id", id)
            ?: findByField(RealmUserModel::class.java, "id", id)
    }

    override suspend fun getAllUsers(): List<RealmUserModel> {
        return queryList(RealmUserModel::class.java)
    }

    override suspend fun getMonthlyLoginCounts(
        userId: String,
        startMillis: Long,
        endMillis: Long,
    ): Map<Int, Int> {
        if (startMillis > endMillis) {
            return emptyMap()
        }

        val activities = queryList(RealmOfflineActivity::class.java) {
            equalTo("userId", userId)
            between("loginTime", startMillis, endMillis)
        }

        if (activities.isEmpty()) {
            return emptyMap()
        }

        val calendar = Calendar.getInstance()
        return activities.mapNotNull { it.loginTime }
            .map { loginTime ->
                calendar.timeInMillis = loginTime
                calendar.get(Calendar.MONTH)
            }
            .groupingBy { it }
            .eachCount()
            .toSortedMap()
    }

    override suspend fun updateSecurityData(
        name: String,
        userId: String?,
        rev: String?,
        derivedKey: String?,
        salt: String?,
        passwordScheme: String?,
        iterations: String?,
    ) {
        update(RealmUserModel::class.java, "name", name) { user ->
            user._id = userId
            user._rev = rev
            user.derived_key = derivedKey
            user.salt = salt
            user.password_scheme = passwordScheme
            user.iterations = iterations
            user.isUpdated = false
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/FeedbackRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Sort
import java.util.Date
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.flow.Flow
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.model.RealmUserModel

class FeedbackRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
    private val gson: Gson
) : RealmRepository(databaseService), FeedbackRepository {

    override fun createFeedback(
        user: String?,
        urgent: String,
        type: String,
        message: String,
        item: String?,
        state: String?,
    ): RealmFeedback {
        val feedback = RealmFeedback()
        feedback.id = UUID.randomUUID().toString()
        if (state != null) {
            feedback.title = "Question regarding /$state"
            feedback.url = "/$state"
            feedback.state = state
            feedback.item = item
        } else {
            feedback.title = "Question regarding /"
            feedback.url = "/"
        }
        val timestamp = Date().time
        feedback.openTime = timestamp
        feedback.owner = user
        feedback.source = user
        feedback.status = "Open"
        feedback.priority = urgent
        feedback.type = type
        feedback.parentCode = "dev"
        val obj = JsonObject().apply {
            addProperty("message", message)
            addProperty("time", timestamp.toString())
            addProperty("user", user.orEmpty())
        }
        val msgArray = JsonArray().apply { add(obj) }
        feedback.setMessages(msgArray)
        return feedback
    }

    override suspend fun getFeedback(userModel: RealmUserModel?): Flow<List<RealmFeedback>> =
        queryListFlow(RealmFeedback::class.java) {
            if (userModel?.isManager() == true) {
                sort("openTime", Sort.DESCENDING)
            } else {
                equalTo("owner", userModel?.name)
                sort("openTime", Sort.DESCENDING)
            }
        }

    override suspend fun getFeedbackById(id: String?): RealmFeedback? {
        return id?.let { findByField(RealmFeedback::class.java, "id", it) }
    }

    override suspend fun closeFeedback(id: String?) {
        id?.let {
            update(RealmFeedback::class.java, "id", it) { feedback ->
                feedback.status = "Closed"
            }
        }
    }

    override suspend fun addReply(id: String?, obj: JsonObject) {
        id?.let {
            update(RealmFeedback::class.java, "id", it) { feedback ->
                val msgArray = gson.fromJson(feedback.messages, JsonArray::class.java)
                msgArray.add(obj)
                feedback.setMessages(msgArray)
            }
        }
    }

    override suspend fun saveFeedback(feedback: RealmFeedback) {
        save(feedback)
    }
}
=======
package org.ole.planet.myplanet.repository


import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import io.realm.Sort
import java.util.Date
import java.util.UUID
import javax.inject.Inject
import kotlinx.coroutines.flow.Flow
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.model.RealmUserModel

class FeedbackRepositoryImpl @Inject constructor(
    databaseService: DatabaseService,
    private val gson: Gson
) : RealmRepository(databaseService), FeedbackRepository {

    override fun createFeedback(
        user: String?,
        urgent: String,
        type: String,
        message: String,
        item: String?,
        state: String?,
    ): RealmFeedback {
        val feedback = RealmFeedback()
        feedback.id = UUID.randomUUID().toString()
        if (state != null) {
            feedback.title = "Question regarding /$state"
            feedback.url = "/$state"
            feedback.state = state
            feedback.item = item
        } else {
            feedback.title = "Question regarding /"
            feedback.url = "/"
        }
        val timestamp = Date().time
        feedback.openTime = timestamp
        feedback.owner = user
        feedback.source = user
        feedback.status = "Open"
        feedback.priority = urgent
        feedback.type = type
        feedback.parentCode = "dev"
        val obj = JsonObject().apply {
            addProperty("message", message)
            addProperty("time", timestamp.toString())
            addProperty("user", user.orEmpty())
        }
        val msgArray = JsonArray().apply { add(obj) }
        feedback.setMessages(msgArray)
        return feedback
    }

    override suspend fun getFeedback(userModel: RealmUserModel?): Flow<List<RealmFeedback>> =
        queryListFlow(RealmFeedback::class.java) {
            if (userModel?.isManager() == true) {
                sort("openTime", Sort.DESCENDING)
            } else {
                equalTo("owner", userModel?.name)
                sort("openTime", Sort.DESCENDING)
            }
        }

    override suspend fun getFeedbackById(id: String?): RealmFeedback? {
        return id?.let { findByField(RealmFeedback::class.java, "id", it) }
    }

    override suspend fun closeFeedback(id: String?) {
        id?.let {
            update(RealmFeedback::class.java, "id", it) { feedback ->
                feedback.status = "Closed"
            }
        }
    }

    override suspend fun addReply(id: String?, obj: JsonObject) {
        id?.let {
            update(RealmFeedback::class.java, "id", it) { feedback ->
                val msgArray = gson.fromJson(feedback.messages, JsonArray::class.java)
                msgArray.add(obj)
                feedback.setMessages(msgArray)
            }
        }
    }

    override suspend fun saveFeedback(feedback: RealmFeedback) {
        save(feedback)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/TagRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import org.ole.planet.myplanet.model.RealmTag

interface TagRepository {
    suspend fun getTags(dbType: String?): List<RealmTag>
    suspend fun buildChildMap(): HashMap<String, List<RealmTag>>
    suspend fun getTagsForResource(resourceId: String): List<RealmTag>
    suspend fun getTagsForCourse(courseId: String): List<RealmTag>
}
=======
package org.ole.planet.myplanet.repository


import org.ole.planet.myplanet.model.RealmTag

interface TagRepository {
    suspend fun getTags(dbType: String?): List<RealmTag>
    suspend fun buildChildMap(): HashMap<String, List<RealmTag>>
    suspend fun getTagsForResource(resourceId: String): List<RealmTag>
    suspend fun getTagsForCourse(courseId: String): List<RealmTag>
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/NotificationRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import java.util.Date
import java.util.UUID
import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmNotification

class NotificationRepositoryImpl @Inject constructor(
        databaseService: DatabaseService,
    ) : RealmRepository(databaseService), NotificationRepository {

    override suspend fun createNotificationIfMissing(
        type: String,
        message: String,
        relatedId: String?,
        userId: String?,
    ) {
        val actualUserId = userId ?: ""
        executeTransaction { realm ->
            val query = realm.where(RealmNotification::class.java)
                .equalTo("userId", actualUserId)
                .equalTo("type", type)

            val existingNotification =
                if (relatedId != null) {
                    query.equalTo("relatedId", relatedId).findFirst()
                } else {
                    query.isNull("relatedId").findFirst()
                }

            if (existingNotification == null) {
                realm.createObject(RealmNotification::class.java, UUID.randomUUID().toString()).apply {
                    this.userId = actualUserId
                    this.type = type
                    this.message = message
                    this.relatedId = relatedId
                    this.createdAt = Date()
                }
            }
        }
    }

    override suspend fun getUnreadCount(userId: String?): Int {
        if (userId == null) return 0

        return count(RealmNotification::class.java) {
            equalTo("userId", userId)
            equalTo("isRead", false)
        }.toInt()
    }

    override suspend fun updateResourceNotification(userId: String?, resourceCount: Int) {
        userId ?: return

        val notificationId = "$userId:resource:count"
        val existingNotification = findByField(RealmNotification::class.java, "id", notificationId)

        if (resourceCount > 0) {
            val previousCount = existingNotification?.message?.toIntOrNull() ?: 0
            val countChanged = previousCount != resourceCount

            val notification = existingNotification?.apply {
                message = "$resourceCount"
                relatedId = "$resourceCount"
                if (countChanged) {
                    this.isRead = false
                    this.createdAt = Date()
                }
            } ?: RealmNotification().apply {
                this.id = notificationId
                this.userId = userId
                this.type = "resource"
                this.message = "$resourceCount"
                this.relatedId = "$resourceCount"
                this.createdAt = Date()
            }
            save(notification)
        } else {
            existingNotification?.let { delete(RealmNotification::class.java, "id", it.id) }
        }
    }

    override suspend fun markNotificationsAsRead(notificationIds: Set<String>): Set<String> {
        if (notificationIds.isEmpty()) return emptySet()

        val updatedIds = mutableSetOf<String>()
        executeTransaction { realm ->
            realm.where(RealmNotification::class.java)
                .`in`("id", notificationIds.toTypedArray())
                .findAll()
                ?.forEach { notification ->
                    notification.isRead = true
                    notification.createdAt = Date()
                    updatedIds.add(notification.id)
                }
        }
        return updatedIds
    }

    override suspend fun markAllUnreadAsRead(userId: String?): Set<String> {
        val actualUserId = userId ?: return emptySet()
        val updatedIds = mutableSetOf<String>()
        val now = Date()
        executeTransaction { realm ->
            realm.where(RealmNotification::class.java)
                .equalTo("userId", actualUserId)
                .equalTo("isRead", false)
                .findAll()
                ?.forEach { notification ->
                    notification.isRead = true
                    notification.createdAt = now
                    updatedIds.add(notification.id)
                }
        }
        return updatedIds
    }

    override suspend fun getNotifications(userId: String, filter: String): List<RealmNotification> {
        return queryList(RealmNotification::class.java) {
            equalTo("userId", userId)
            notEqualTo("message", "INVALID")
            isNotEmpty("message")
            when (filter) {
                "read" -> equalTo("isRead", true)
                "unread" -> equalTo("isRead", false)
            }
            sort("isRead", io.realm.Sort.ASCENDING, "createdAt", io.realm.Sort.DESCENDING)
        }
    }
}
=======
package org.ole.planet.myplanet.repository


import java.util.Date
import java.util.UUID
import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmNotification

class NotificationRepositoryImpl @Inject constructor(
        databaseService: DatabaseService,
    ) : RealmRepository(databaseService), NotificationRepository {

    override suspend fun createNotificationIfMissing(
        type: String,
        message: String,
        relatedId: String?,
        userId: String?,
    ) {
        val actualUserId = userId ?: ""
        executeTransaction { realm ->
            val query = realm.where(RealmNotification::class.java)
                .equalTo("userId", actualUserId)
                .equalTo("type", type)

            val existingNotification =
                if (relatedId != null) {
                    query.equalTo("relatedId", relatedId).findFirst()
                } else {
                    query.isNull("relatedId").findFirst()
                }

            if (existingNotification == null) {
                realm.createObject(RealmNotification::class.java, UUID.randomUUID().toString()).apply {
                    this.userId = actualUserId
                    this.type = type
                    this.message = message
                    this.relatedId = relatedId
                    this.createdAt = Date()
                }
            }
        }
    }

    override suspend fun getUnreadCount(userId: String?): Int {
        if (userId == null) return 0

        return count(RealmNotification::class.java) {
            equalTo("userId", userId)
            equalTo("isRead", false)
        }.toInt()
    }

    override suspend fun updateResourceNotification(userId: String?, resourceCount: Int) {
        userId ?: return

        val notificationId = "$userId:resource:count"
        val existingNotification = findByField(RealmNotification::class.java, "id", notificationId)

        if (resourceCount > 0) {
            val previousCount = existingNotification?.message?.toIntOrNull() ?: 0
            val countChanged = previousCount != resourceCount

            val notification = existingNotification?.apply {
                message = "$resourceCount"
                relatedId = "$resourceCount"
                if (countChanged) {
                    this.isRead = false
                    this.createdAt = Date()
                }
            } ?: RealmNotification().apply {
                this.id = notificationId
                this.userId = userId
                this.type = "resource"
                this.message = "$resourceCount"
                this.relatedId = "$resourceCount"
                this.createdAt = Date()
            }
            save(notification)
        } else {
            existingNotification?.let { delete(RealmNotification::class.java, "id", it.id) }
        }
    }

    override suspend fun markNotificationsAsRead(notificationIds: Set<String>): Set<String> {
        if (notificationIds.isEmpty()) return emptySet()

        val updatedIds = mutableSetOf<String>()
        executeTransaction { realm ->
            realm.where(RealmNotification::class.java)
                .`in`("id", notificationIds.toTypedArray())
                .findAll()
                ?.forEach { notification ->
                    notification.isRead = true
                    notification.createdAt = Date()
                    updatedIds.add(notification.id)
                }
        }
        return updatedIds
    }

    override suspend fun markAllUnreadAsRead(userId: String?): Set<String> {
        val actualUserId = userId ?: return emptySet()
        val updatedIds = mutableSetOf<String>()
        val now = Date()
        executeTransaction { realm ->
            realm.where(RealmNotification::class.java)
                .equalTo("userId", actualUserId)
                .equalTo("isRead", false)
                .findAll()
                ?.forEach { notification ->
                    notification.isRead = true
                    notification.createdAt = now
                    updatedIds.add(notification.id)
                }
        }
        return updatedIds
    }

    override suspend fun getNotifications(userId: String, filter: String): List<RealmNotification> {
        return queryList(RealmNotification::class.java) {
            equalTo("userId", userId)
            notEqualTo("message", "INVALID")
            isNotEmpty("message")
            when (filter) {
                "read" -> equalTo("isRead", true)
                "unread" -> equalTo("isRead", false)
            }
            sort("isRead", io.realm.Sort.ASCENDING, "createdAt", io.realm.Sort.DESCENDING)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/TagRepositoryImpl.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmTag

class TagRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), TagRepository {

    override suspend fun getTags(dbType: String?): List<RealmTag> {
        return queryList(RealmTag::class.java) {
            dbType?.let { equalTo("db", it) }
            isNotEmpty("name")
            equalTo("isAttached", false)
        }
    }

    override suspend fun buildChildMap(): HashMap<String, List<RealmTag>> {
        val allTags = queryList(RealmTag::class.java)
        val childMap = HashMap<String, List<RealmTag>>()
        allTags.forEach { t ->
            t.attachedTo?.forEach { parent ->
                val list = childMap[parent]?.toMutableList() ?: mutableListOf()
                if (!list.contains(t)) {
                    list.add(t)
                }
                childMap[parent] = list
            }
        }
        return childMap
    }

    override suspend fun getTagsForResource(resourceId: String): List<RealmTag> {
        return getLinkedTags("resources", resourceId)
    }

    override suspend fun getTagsForCourse(courseId: String): List<RealmTag> {
        return getLinkedTags("courses", courseId)
    }

    private suspend fun getLinkedTags(db: String, linkId: String): List<RealmTag> {
        val links = queryList(RealmTag::class.java) {
            equalTo("db", db)
            equalTo("linkId", linkId)
        }
        if (links.isEmpty()) {
            return emptyList()
        }
        val tagIds = links.mapNotNull { it.tagId }.distinct()
        if (tagIds.isEmpty()) {
            return emptyList()
        }

        val parents = queryList(RealmTag::class.java) {
            `in`("id", tagIds.toTypedArray())
        }
        if (parents.isEmpty()) {
            return emptyList()
        }

        val parentsById = parents.associateBy { it.id }
        return tagIds.mapNotNull { parentsById[it] }
    }
}
=======
package org.ole.planet.myplanet.repository


import javax.inject.Inject
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmTag

class TagRepositoryImpl @Inject constructor(
    databaseService: DatabaseService
) : RealmRepository(databaseService), TagRepository {

    override suspend fun getTags(dbType: String?): List<RealmTag> {
        return queryList(RealmTag::class.java) {
            dbType?.let { equalTo("db", it) }
            isNotEmpty("name")
            equalTo("isAttached", false)
        }
    }

    override suspend fun buildChildMap(): HashMap<String, List<RealmTag>> {
        val allTags = queryList(RealmTag::class.java)
        val childMap = HashMap<String, List<RealmTag>>()
        allTags.forEach { t ->
            t.attachedTo?.forEach { parent ->
                val list = childMap[parent]?.toMutableList() ?: mutableListOf()
                if (!list.contains(t)) {
                    list.add(t)
                }
                childMap[parent] = list
            }
        }
        return childMap
    }

    override suspend fun getTagsForResource(resourceId: String): List<RealmTag> {
        return getLinkedTags("resources", resourceId)
    }

    override suspend fun getTagsForCourse(courseId: String): List<RealmTag> {
        return getLinkedTags("courses", courseId)
    }

    private suspend fun getLinkedTags(db: String, linkId: String): List<RealmTag> {
        val links = queryList(RealmTag::class.java) {
            equalTo("db", db)
            equalTo("linkId", linkId)
        }
        if (links.isEmpty()) {
            return emptyList()
        }
        val tagIds = links.mapNotNull { it.tagId }.distinct()
        if (tagIds.isEmpty()) {
            return emptyList()
        }

        val parents = queryList(RealmTag::class.java) {
            `in`("id", tagIds.toTypedArray())
        }
        if (parents.isEmpty()) {
            return emptyList()
        }

        val parentsById = parents.associateBy { it.id }
        return tagIds.mapNotNull { parentsById[it] }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/TeamRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import com.google.gson.JsonObject
import kotlinx.coroutines.flow.Flow
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel

data class TeamMemberStatus(
    val isMember: Boolean,
    val isLeader: Boolean,
    val hasPendingRequest: Boolean
)

interface TeamRepository {
    suspend fun getShareableTeams(): List<RealmMyTeam>
    suspend fun getShareableEnterprises(): List<RealmMyTeam>
    suspend fun getTeamResources(teamId: String): List<RealmMyLibrary>
    suspend fun getTeamByDocumentIdOrTeamId(id: String): RealmMyTeam?
    suspend fun getTeamLinks(): List<RealmMyTeam>
    suspend fun getTeamById(teamId: String): RealmMyTeam?
    suspend fun getTaskTeamInfo(taskId: String): Triple<String, String, String>?
    suspend fun getJoinRequestTeamId(requestId: String): String?
    suspend fun isMember(userId: String?, teamId: String): Boolean
    suspend fun isTeamLeader(teamId: String, userId: String?): Boolean
    suspend fun hasPendingRequest(teamId: String, userId: String?): Boolean
    suspend fun getTeamMemberStatuses(userId: String?, teamIds: Collection<String>): Map<String, TeamMemberStatus>
    suspend fun getRecentVisitCounts(teamIds: Collection<String>): Map<String, Long>
    suspend fun requestToJoin(teamId: String, userId: String?, userPlanetCode: String?, teamType: String?)
    suspend fun leaveTeam(teamId: String, userId: String?)
    suspend fun removeMember(teamId: String, userId: String)
    suspend fun addResourceLinks(teamId: String, resources: List<RealmMyLibrary>, user: RealmUserModel?)
    suspend fun removeResourceLink(teamId: String, resourceId: String)
    suspend fun deleteTask(taskId: String)
    suspend fun upsertTask(task: RealmTeamTask)
    suspend fun assignTask(taskId: String, assigneeId: String?)
    suspend fun setTaskCompletion(taskId: String, completed: Boolean)
    suspend fun getPendingTasksForUser(userId: String, start: Long, end: Long): List<RealmTeamTask>
    suspend fun markTasksNotified(taskIds: Collection<String>)
    suspend fun getTasksByTeamId(teamId: String): Flow<List<RealmTeamTask>>
    suspend fun addReport(report: JsonObject)
    suspend fun updateReport(reportId: String, payload: JsonObject)
    suspend fun archiveReport(reportId: String)
    suspend fun logTeamVisit(
        teamId: String,
        userName: String?,
        userPlanetCode: String?,
        userParentCode: String?,
        teamType: String?,
    )
    suspend fun createTeam(
        category: String?,
        name: String,
        description: String,
        services: String,
        rules: String,
        teamType: String?,
        isPublic: Boolean,
        user: RealmUserModel,
    ): Result<String>
    suspend fun updateTeam(
        teamId: String,
        name: String,
        description: String,
        services: String,
        rules: String,
        updatedBy: String?,
    ): Result<Boolean>
    suspend fun updateTeamDetails(
        teamId: String,
        name: String,
        description: String,
        services: String,
        rules: String,
        teamType: String,
        isPublic: Boolean,
        createdBy: String,
    ): Boolean
    suspend fun syncTeamActivities()
    suspend fun getTeamTransactions(
        teamId: String,
        startDate: Long? = null,
        endDate: Long? = null,
        sortAscending: Boolean = false,
    ): Flow<List<RealmMyTeam>>
    suspend fun createTransaction(
        teamId: String,
        type: String,
        note: String,
        amount: Int,
        date: Long,
        parentCode: String?,
        planetCode: String?,
    ): Result<Unit>
    suspend fun respondToMemberRequest(teamId: String, userId: String, accept: Boolean): Result<Unit>
}
=======
package org.ole.planet.myplanet.repository


import com.google.gson.JsonObject
import kotlinx.coroutines.flow.Flow
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyTeam
import org.ole.planet.myplanet.model.RealmTeamTask
import org.ole.planet.myplanet.model.RealmUserModel

data class TeamMemberStatus(
    val isMember: Boolean,
    val isLeader: Boolean,
    val hasPendingRequest: Boolean
)

interface TeamRepository {
    suspend fun getShareableTeams(): List<RealmMyTeam>
    suspend fun getShareableEnterprises(): List<RealmMyTeam>
    suspend fun getTeamResources(teamId: String): List<RealmMyLibrary>
    suspend fun getTeamByDocumentIdOrTeamId(id: String): RealmMyTeam?
    suspend fun getTeamLinks(): List<RealmMyTeam>
    suspend fun getTeamById(teamId: String): RealmMyTeam?
    suspend fun getTaskTeamInfo(taskId: String): Triple<String, String, String>?
    suspend fun getJoinRequestTeamId(requestId: String): String?
    suspend fun isMember(userId: String?, teamId: String): Boolean
    suspend fun isTeamLeader(teamId: String, userId: String?): Boolean
    suspend fun hasPendingRequest(teamId: String, userId: String?): Boolean
    suspend fun getTeamMemberStatuses(userId: String?, teamIds: Collection<String>): Map<String, TeamMemberStatus>
    suspend fun getRecentVisitCounts(teamIds: Collection<String>): Map<String, Long>
    suspend fun requestToJoin(teamId: String, userId: String?, userPlanetCode: String?, teamType: String?)
    suspend fun leaveTeam(teamId: String, userId: String?)
    suspend fun removeMember(teamId: String, userId: String)
    suspend fun addResourceLinks(teamId: String, resources: List<RealmMyLibrary>, user: RealmUserModel?)
    suspend fun removeResourceLink(teamId: String, resourceId: String)
    suspend fun deleteTask(taskId: String)
    suspend fun upsertTask(task: RealmTeamTask)
    suspend fun assignTask(taskId: String, assigneeId: String?)
    suspend fun setTaskCompletion(taskId: String, completed: Boolean)
    suspend fun getPendingTasksForUser(userId: String, start: Long, end: Long): List<RealmTeamTask>
    suspend fun markTasksNotified(taskIds: Collection<String>)
    suspend fun getTasksByTeamId(teamId: String): Flow<List<RealmTeamTask>>
    suspend fun addReport(report: JsonObject)
    suspend fun updateReport(reportId: String, payload: JsonObject)
    suspend fun archiveReport(reportId: String)
    suspend fun logTeamVisit(
        teamId: String,
        userName: String?,
        userPlanetCode: String?,
        userParentCode: String?,
        teamType: String?,
    )
    suspend fun createTeam(
        category: String?,
        name: String,
        description: String,
        services: String,
        rules: String,
        teamType: String?,
        isPublic: Boolean,
        user: RealmUserModel,
    ): Result<String>
    suspend fun updateTeam(
        teamId: String,
        name: String,
        description: String,
        services: String,
        rules: String,
        updatedBy: String?,
    ): Result<Boolean>
    suspend fun updateTeamDetails(
        teamId: String,
        name: String,
        description: String,
        services: String,
        rules: String,
        teamType: String,
        isPublic: Boolean,
        createdBy: String,
    ): Boolean
    suspend fun syncTeamActivities()
    suspend fun getTeamTransactions(
        teamId: String,
        startDate: Long? = null,
        endDate: Long? = null,
        sortAscending: Boolean = false,
    ): Flow<List<RealmMyTeam>>
    suspend fun createTransaction(
        teamId: String,
        type: String,
        note: String,
        amount: Int,
        date: Long,
        parentCode: String?,
        planetCode: String?,
    ): Result<Unit>
    suspend fun respondToMemberRequest(teamId: String, userId: String, accept: Boolean): Result<Unit>
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/repository/FeedbackRepository.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.repository

import com.google.gson.JsonObject
import kotlinx.coroutines.flow.Flow
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.model.RealmUserModel

interface FeedbackRepository {
    fun createFeedback(
        user: String?,
        urgent: String,
        type: String,
        message: String,
        item: String? = null,
        state: String? = null,
    ): RealmFeedback
    suspend fun getFeedback(userModel: RealmUserModel?): Flow<List<RealmFeedback>>
    suspend fun getFeedbackById(id: String?): RealmFeedback?
    suspend fun closeFeedback(id: String?)
    suspend fun addReply(id: String?, obj: JsonObject)
    suspend fun saveFeedback(feedback: RealmFeedback)
}
=======
package org.ole.planet.myplanet.repository


import com.google.gson.JsonObject
import kotlinx.coroutines.flow.Flow
import org.ole.planet.myplanet.model.RealmFeedback
import org.ole.planet.myplanet.model.RealmUserModel

interface FeedbackRepository {
    fun createFeedback(
        user: String?,
        urgent: String,
        type: String,
        message: String,
        item: String? = null,
        state: String? = null,
    ): RealmFeedback
    suspend fun getFeedback(userModel: RealmUserModel?): Flow<List<RealmFeedback>>
    suspend fun getFeedbackById(id: String?): RealmFeedback?
    suspend fun closeFeedback(id: String?)
    suspend fun addReply(id: String?, obj: JsonObject)
    suspend fun saveFeedback(feedback: RealmFeedback)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/datamanager/ConfigurationManager.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.datamanager

import android.app.AlertDialog
import android.content.Context
import android.content.DialogInterface
import android.content.SharedPreferences
import androidx.core.content.edit
import androidx.core.net.toUri
import com.google.gson.Gson
import com.google.gson.JsonObject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.ui.sync.SyncActivity
import org.ole.planet.myplanet.utilities.DialogUtils.CustomProgressDialog
import org.ole.planet.myplanet.utilities.IntentUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.NetworkUtils.extractProtocol
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.UrlUtils

class ConfigurationManager(
    private val context: Context,
    private val preferences: SharedPreferences,
    private val retrofitInterface: ApiInterface?
) {

    fun getMinApk(
        listener: Service.ConfigurationIdListener?,
        url: String,
        pin: String,
        activity: SyncActivity,
        callerActivity: String
    ) {
        val serverUrlMapper = ServerUrlMapper()
        val mapping = serverUrlMapper.processUrl(url)
        val urlsToTry = mutableListOf(url).apply { mapping.alternativeUrl?.let { add(it) } }

        MainApplication.applicationScope.launch {
            val customProgressDialog = withContext(Dispatchers.Main) {
                CustomProgressDialog(context).apply {
                    setText(context.getString(R.string.check_apk_version))
                    show()
                }
            }

            try {
                val deferreds = urlsToTry.map { currentUrl ->
                    async { checkConfigurationUrl(currentUrl, pin, customProgressDialog) }
                }

                val result = try {
                    val allResults = deferreds.awaitAll()
                    allResults.firstOrNull { it is UrlCheckResult.Success }
                        ?: allResults.firstOrNull()
                        ?: UrlCheckResult.Failure(url)
                } catch (e: Exception) {
                    e.printStackTrace()
                    UrlCheckResult.Failure(url)
                }

                when (result) {
                    is UrlCheckResult.Success -> {
                        val isAlternativeUrl = result.url != url
                        listener?.onConfigurationIdReceived(result.id, result.code, result.url, url, isAlternativeUrl, callerActivity)
                        activity.syncFailed = false
                    }
                    is UrlCheckResult.Failure -> {
                        activity.syncFailed = true
                        val errorMessage = when (extractProtocol(url)) {
                            context.getString(R.string.http_protocol) -> context.getString(R.string.device_couldn_t_reach_local_server)
                            context.getString(R.string.https_protocol) -> context.getString(R.string.device_couldn_t_reach_nation_server)
                            else -> context.getString(R.string.device_couldn_t_reach_local_server)
                        }
                        showAlertDialog(errorMessage, false)
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
                activity.syncFailed = true
                withContext(Dispatchers.Main) {
                    showAlertDialog(context.getString(R.string.device_couldn_t_reach_local_server), false)
                }
            } finally {
                customProgressDialog.dismiss()
            }
        }
    }

    private suspend fun checkConfigurationUrl(currentUrl: String, pin: String, customProgressDialog: CustomProgressDialog): UrlCheckResult {
        return try {
            val versionsResponse = retrofitInterface?.getConfiguration("$currentUrl/versions")?.execute()

            if (versionsResponse?.isSuccessful == true) {
                val jsonObject = versionsResponse.body()
                val minApkVersion = jsonObject?.get("minapk")?.asString
                val currentVersion = context.getString(R.string.app_version)

                if (minApkVersion != null && isVersionAllowed(currentVersion, minApkVersion)) {
                    val couchdbURL = buildCouchdbUrl(currentUrl, pin)

                    withContext(Dispatchers.Main) {
                        customProgressDialog.setText(context.getString(R.string.checking_server))
                    }

                    fetchConfiguration(couchdbURL)?.let { (id, code) ->
                        return UrlCheckResult.Success(id, code, currentUrl)
                    }
                }
            }

            UrlCheckResult.Failure(currentUrl)
        } catch (e: Exception) {
            e.printStackTrace()
            UrlCheckResult.Failure(currentUrl)
        }
    }

    private suspend fun fetchConfiguration(couchdbURL: String): Pair<String, String>? {
        val configResponse = retrofitInterface
            ?.getConfiguration("${getUrl(couchdbURL)}/configurations/_all_docs?include_docs=true")
            ?.execute()

        if (configResponse?.isSuccessful == true) {
            val rows = configResponse.body()?.getAsJsonArray("rows")
            if (rows != null && rows.size() > 0) {
                val firstRow = rows[0].asJsonObject
                val id = firstRow.getAsJsonPrimitive("id").asString
                val doc = firstRow.getAsJsonObject("doc")
                val code = doc.getAsJsonPrimitive("code").asString
                processConfigurationDoc(doc)
                return Pair(id, code)
            }
        }
        return null
    }

    private suspend fun processConfigurationDoc(doc: JsonObject) {
        val parentCode = doc.getAsJsonPrimitive("parentCode").asString

        withContext(Dispatchers.IO) {
            preferences.edit { putString("parentCode", parentCode) }
        }

        if (doc.has("preferredLang")) {
            val preferredLang = doc.getAsJsonPrimitive("preferredLang").asString
            val languageCode = getLanguageCodeFromName(preferredLang)
            if (languageCode != null) {
                withContext(Dispatchers.IO) {
                    LocaleHelper.setLocale(context, languageCode)
                    preferences.edit { putString("pendingLanguageChange", languageCode) }
                }
            }
        }

        if (doc.has("models")) {
            val modelsMap = doc.getAsJsonObject("models").entrySet()
                .associate { it.key to it.value.asString }

            withContext(Dispatchers.IO) {
                preferences.edit { putString("ai_models", Gson().toJson(modelsMap)) }
            }
        }

        if (doc.has("planetType")) {
            val planetType = doc.getAsJsonPrimitive("planetType").asString
            withContext(Dispatchers.IO) {
                preferences.edit { putString("planetType", planetType) }
            }
        }
    }

    private fun buildCouchdbUrl(currentUrl: String, pin: String): String {
        val uri = currentUrl.toUri()
        return if (currentUrl.contains("@")) {
            currentUrl
        } else {
            val urlUser = "satellite"
            "${uri.scheme}://$urlUser:$pin@${uri.host}:${if (uri.port == -1) if (uri.scheme == "http") 80 else 443 else uri.port}"
        }
    }

    sealed class UrlCheckResult {
        data class Success(val id: String, val code: String, val url: String) : UrlCheckResult()
        data class Failure(val url: String) : UrlCheckResult()
    }

    private fun isVersionAllowed(currentVersion: String, minApkVersion: String): Boolean {
        return compareVersions(currentVersion, minApkVersion) >= 0
    }

    private fun compareVersions(version1: String, version2: String): Int {
        val parts1 = version1.removeSuffix("-lite").removePrefix("v").split(".").map { it.toInt() }
        val parts2 = version2.removePrefix("v").split(".").map { it.toInt() }

        for (i in 0 until kotlin.math.min(parts1.size, parts2.size)) {
            if (parts1[i] != parts2[i]) {
                return parts1[i].compareTo(parts2[i])
            }
        }
        return parts1.size.compareTo(parts2.size)
    }

    private fun getLanguageCodeFromName(languageName: String): String? {
        return when (languageName.lowercase()) {
            "english" -> "en"
            "spanish", "espaol" -> "es"
            "somali" -> "so"
            "nepali" -> "ne"
            "arabic", "" -> "ar"
            "french", "franais" -> "fr"
            else -> null
        }
    }

    fun showAlertDialog(message: String?, playStoreRedirect: Boolean) {
        MainApplication.applicationScope.launch(Dispatchers.Main) {
            val builder = AlertDialog.Builder(context, R.style.CustomAlertDialog)
            builder.setMessage(message)
            builder.setCancelable(true)
            builder.setNegativeButton(R.string.okay) { dialog: DialogInterface, _: Int ->
                if (playStoreRedirect) {
                    IntentUtils.openPlayStore(context)
                }
                dialog.cancel()
            }
            val alert = builder.create()
            alert.show()
        }
    }

    private fun getUrl(couchdbURL: String): String {
        return UrlUtils.dbUrl(couchdbURL)
    }
}
=======
package org.ole.planet.myplanet.datamanager


import android.app.AlertDialog
import android.content.Context
import android.content.DialogInterface
import android.content.SharedPreferences
import androidx.core.content.edit
import androidx.core.net.toUri
import com.google.gson.Gson
import com.google.gson.JsonObject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.ui.sync.SyncActivity
import org.ole.planet.myplanet.utilities.DialogUtils.CustomProgressDialog
import org.ole.planet.myplanet.utilities.IntentUtils
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.NetworkUtils.extractProtocol
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.UrlUtils

class ConfigurationManager(
    private val context: Context,
    private val preferences: SharedPreferences,
    private val retrofitInterface: ApiInterface?
) {

    fun getMinApk(
        listener: Service.ConfigurationIdListener?,
        url: String,
        pin: String,
        activity: SyncActivity,
        callerActivity: String
    ) {
        val serverUrlMapper = ServerUrlMapper()
        val mapping = serverUrlMapper.processUrl(url)
        val urlsToTry = mutableListOf(url).apply { mapping.alternativeUrl?.let { add(it) } }

        MainApplication.applicationScope.launch {
            val customProgressDialog = withContext(Dispatchers.Main) {
                CustomProgressDialog(context).apply {
                    setText(context.getString(R.string.check_apk_version))
                    show()
                }
            }

            try {
                val deferreds = urlsToTry.map { currentUrl ->
                    async { checkConfigurationUrl(currentUrl, pin, customProgressDialog) }
                }

                val result = try {
                    val allResults = deferreds.awaitAll()
                    allResults.firstOrNull { it is UrlCheckResult.Success }
                        ?: allResults.firstOrNull()
                        ?: UrlCheckResult.Failure(url)
                } catch (e: Exception) {
                    e.printStackTrace()
                    UrlCheckResult.Failure(url)
                }

                when (result) {
                    is UrlCheckResult.Success -> {
                        val isAlternativeUrl = result.url != url
                        listener?.onConfigurationIdReceived(result.id, result.code, result.url, url, isAlternativeUrl, callerActivity)
                        activity.syncFailed = false
                    }
                    is UrlCheckResult.Failure -> {
                        activity.syncFailed = true
                        val errorMessage = when (extractProtocol(url)) {
                            context.getString(R.string.http_protocol) -> context.getString(R.string.device_couldn_t_reach_local_server)
                            context.getString(R.string.https_protocol) -> context.getString(R.string.device_couldn_t_reach_nation_server)
                            else -> context.getString(R.string.device_couldn_t_reach_local_server)
                        }
                        showAlertDialog(errorMessage, false)
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
                activity.syncFailed = true
                withContext(Dispatchers.Main) {
                    showAlertDialog(context.getString(R.string.device_couldn_t_reach_local_server), false)
                }
            } finally {
                customProgressDialog.dismiss()
            }
        }
    }

    private suspend fun checkConfigurationUrl(currentUrl: String, pin: String, customProgressDialog: CustomProgressDialog): UrlCheckResult {
        return try {
            val versionsResponse = retrofitInterface?.getConfiguration("$currentUrl/versions")?.execute()

            if (versionsResponse?.isSuccessful == true) {
                val jsonObject = versionsResponse.body()
                val minApkVersion = jsonObject?.get("minapk")?.asString
                val currentVersion = context.getString(R.string.app_version)

                if (minApkVersion != null && isVersionAllowed(currentVersion, minApkVersion)) {
                    val couchdbURL = buildCouchdbUrl(currentUrl, pin)

                    withContext(Dispatchers.Main) {
                        customProgressDialog.setText(context.getString(R.string.checking_server))
                    }

                    fetchConfiguration(couchdbURL)?.let { (id, code) ->
                        return UrlCheckResult.Success(id, code, currentUrl)
                    }
                }
            }

            UrlCheckResult.Failure(currentUrl)
        } catch (e: Exception) {
            e.printStackTrace()
            UrlCheckResult.Failure(currentUrl)
        }
    }

    private suspend fun fetchConfiguration(couchdbURL: String): Pair<String, String>? {
        val configResponse = retrofitInterface
            ?.getConfiguration("${getUrl(couchdbURL)}/configurations/_all_docs?include_docs=true")
            ?.execute()

        if (configResponse?.isSuccessful == true) {
            val rows = configResponse.body()?.getAsJsonArray("rows")
            if (rows != null && rows.size() > 0) {
                val firstRow = rows[0].asJsonObject
                val id = firstRow.getAsJsonPrimitive("id").asString
                val doc = firstRow.getAsJsonObject("doc")
                val code = doc.getAsJsonPrimitive("code").asString
                processConfigurationDoc(doc)
                return Pair(id, code)
            }
        }
        return null
    }

    private suspend fun processConfigurationDoc(doc: JsonObject) {
        val parentCode = doc.getAsJsonPrimitive("parentCode").asString

        withContext(Dispatchers.IO) {
            preferences.edit { putString("parentCode", parentCode) }
        }

        if (doc.has("preferredLang")) {
            val preferredLang = doc.getAsJsonPrimitive("preferredLang").asString
            val languageCode = getLanguageCodeFromName(preferredLang)
            if (languageCode != null) {
                withContext(Dispatchers.IO) {
                    LocaleHelper.setLocale(context, languageCode)
                    preferences.edit { putString("pendingLanguageChange", languageCode) }
                }
            }
        }

        if (doc.has("models")) {
            val modelsMap = doc.getAsJsonObject("models").entrySet()
                .associate { it.key to it.value.asString }

            withContext(Dispatchers.IO) {
                preferences.edit { putString("ai_models", Gson().toJson(modelsMap)) }
            }
        }

        if (doc.has("planetType")) {
            val planetType = doc.getAsJsonPrimitive("planetType").asString
            withContext(Dispatchers.IO) {
                preferences.edit { putString("planetType", planetType) }
            }
        }
    }

    private fun buildCouchdbUrl(currentUrl: String, pin: String): String {
        val uri = currentUrl.toUri()
        return if (currentUrl.contains("@")) {
            currentUrl
        } else {
            val urlUser = "satellite"
            "${uri.scheme}://$urlUser:$pin@${uri.host}:${if (uri.port == -1) if (uri.scheme == "http") 80 else 443 else uri.port}"
        }
    }

    sealed class UrlCheckResult {
        data class Success(val id: String, val code: String, val url: String) : UrlCheckResult()
        data class Failure(val url: String) : UrlCheckResult()
    }

    private fun isVersionAllowed(currentVersion: String, minApkVersion: String): Boolean {
        return compareVersions(currentVersion, minApkVersion) >= 0
    }

    private fun compareVersions(version1: String, version2: String): Int {
        val parts1 = version1.removeSuffix("-lite").removePrefix("v").split(".").map { it.toInt() }
        val parts2 = version2.removePrefix("v").split(".").map { it.toInt() }

        for (i in 0 until kotlin.math.min(parts1.size, parts2.size)) {
            if (parts1[i] != parts2[i]) {
                return parts1[i].compareTo(parts2[i])
            }
        }
        return parts1.size.compareTo(parts2.size)
    }

    private fun getLanguageCodeFromName(languageName: String): String? {
        return when (languageName.lowercase()) {
            "english" -> "en"
            "spanish", "espaol" -> "es"
            "somali" -> "so"
            "nepali" -> "ne"
            "arabic", "" -> "ar"
            "french", "franais" -> "fr"
            else -> null
        }
    }

    fun showAlertDialog(message: String?, playStoreRedirect: Boolean) {
        MainApplication.applicationScope.launch(Dispatchers.Main) {
            val builder = AlertDialog.Builder(context, R.style.CustomAlertDialog)
            builder.setMessage(message)
            builder.setCancelable(true)
            builder.setNegativeButton(R.string.okay) { dialog: DialogInterface, _: Int ->
                if (playStoreRedirect) {
                    IntentUtils.openPlayStore(context)
                }
                dialog.cancel()
            }
            val alert = builder.create()
            alert.show()
        }
    }

    private fun getUrl(couchdbURL: String): String {
        return UrlUtils.dbUrl(couchdbURL)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/datamanager/DownloadWorker.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.datamanager

import android.app.NotificationManager
import android.content.Context
import android.content.Intent
import androidx.work.CoroutineWorker
import androidx.work.ForegroundInfo
import androidx.work.WorkerParameters
import dagger.hilt.android.EntryPointAccessors
import java.io.File
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.ResponseBody
import okio.Buffer
import okio.buffer
import okio.sink
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.di.ApiInterfaceEntryPoint
import org.ole.planet.myplanet.model.Download
import org.ole.planet.myplanet.service.getBroadcastService
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.FileUtils.getFileNameFromUrl
import org.ole.planet.myplanet.utilities.UrlUtils

class DownloadWorker(val context: Context, workerParams: WorkerParameters) : CoroutineWorker(context, workerParams) {
    private val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    private val preferences = context.getSharedPreferences(MyDownloadService.PREFS_NAME, Context.MODE_PRIVATE)
    private val apiInterface: ApiInterface by lazy {
        EntryPointAccessors.fromApplication(
            context.applicationContext,
            ApiInterfaceEntryPoint::class.java
        ).apiInterface()
    }

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            val urlsKey = inputData.getString("urls_key") ?: "url_list_key"
            val fromSync = inputData.getBoolean("fromSync", false)
            val urlSet = preferences.getStringSet(urlsKey, emptySet()) ?: emptySet()

            if (urlSet.isEmpty()) {
                return@withContext Result.failure()
            }

            val urls = urlSet.toTypedArray()
            DownloadUtils.createChannels(context)

            showProgressNotification(0, urls.size, context.getString(R.string.starting_downloads))

            var completedCount = 0
            val results = mutableListOf<Boolean>()

            urls.forEachIndexed { index, url ->
                try {
                    val success = downloadFile(url, index, urls.size)
                    results.add(success)
                    completedCount++

                    showProgressNotification(completedCount, urls.size, context.getString(R.string.downloaded_files, "$completedCount", "${urls.size}"))
                    sendDownloadUpdate(url, success, completedCount >= urls.size, fromSync)
                } catch (e: Exception) {
                    e.printStackTrace()
                    results.add(false)
                    completedCount++
                }
            }

            showCompletionNotification(completedCount, urls.size, results.any { !it })
            Result.success()
        } catch (e: Exception) {
            e.printStackTrace()
            Result.failure()
        }
    }

    private suspend fun downloadFile(url: String, index: Int, total: Int): Boolean {
        return try {
            val response = apiInterface.downloadFile(UrlUtils.header, url)
            if (response.isSuccessful) {
                response.body()?.let {
                    downloadFileBody(it, url, index, total)
                    true
                } ?: false
            } else {
                false
            }
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    private suspend fun downloadFileBody(body: ResponseBody, url: String, index: Int, total: Int) {
        val fileSize = body.contentLength()
        val outputFile: File = FileUtils.getSDPathFromUrl(context, url)
        var totalBytes: Long = 0

        outputFile.sink().buffer().use { sink ->
            body.source().use { source ->
                val buffer = Buffer()
                while (true) {
                    val read = source.read(buffer, 8_192)
                    if (read == -1L) break
                    sink.write(buffer, read)
                    totalBytes += read

                    if (totalBytes % (1024 * 100) == 0L) {
                        val progress = if (fileSize > 0) {
                            (totalBytes * 100 / fileSize).toInt()
                        } else 0
                        showProgressNotification(index, total, "Downloading ${getFileNameFromUrl(url)} ($progress%)")
                    }
                }
                sink.flush()
            }
        }
        DownloadUtils.updateResourceOfflineStatus(url)
    }

    private suspend fun showProgressNotification(current: Int, total: Int, text: String) {
        val notification = DownloadUtils.buildProgressNotification(
            context,
            current,
            total,
            text,
            forWorker = true
        )
        setForeground(ForegroundInfo(WORKER_NOTIFICATION_ID, notification))
    }

    private fun showCompletionNotification(completed: Int, total: Int, hadErrors: Boolean) {
        val notification = DownloadUtils.buildCompletionNotification(
            context,
            completed,
            total,
            hadErrors,
            forWorker = true
        )

        notificationManager.notify(COMPLETION_NOTIFICATION_ID, notification)
    }

    private suspend fun sendDownloadUpdate(url: String, success: Boolean, isComplete: Boolean, fromSync: Boolean) {
        val download = Download().apply {
            fileName = getFileNameFromUrl(url)
            fileUrl = url
            progress = if (success) 100 else 0
            failed = !success
            completeAll = isComplete
            if (!success) {
                message = context.getString(R.string.download_failed)
            }
        }

        val intent = Intent(MyDownloadService.MESSAGE_PROGRESS).apply {
            putExtra("download", download)
            putExtra("fromSync", fromSync)
        }
        val broadcastService = getBroadcastService(applicationContext)
        broadcastService.sendBroadcast(intent)
    }


    companion object {
        const val WORKER_NOTIFICATION_ID = 3
        const val COMPLETION_NOTIFICATION_ID = 4
    }
}
=======
package org.ole.planet.myplanet.datamanager


import android.app.NotificationManager
import android.content.Context
import android.content.Intent
import androidx.work.CoroutineWorker
import androidx.work.ForegroundInfo
import androidx.work.WorkerParameters
import dagger.hilt.android.EntryPointAccessors
import java.io.File
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.ResponseBody
import okio.Buffer
import okio.buffer
import okio.sink
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.di.ApiInterfaceEntryPoint
import org.ole.planet.myplanet.model.Download
import org.ole.planet.myplanet.service.getBroadcastService
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.FileUtils.getFileNameFromUrl
import org.ole.planet.myplanet.utilities.UrlUtils

class DownloadWorker(val context: Context, workerParams: WorkerParameters) : CoroutineWorker(context, workerParams) {
    private val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    private val preferences = context.getSharedPreferences(MyDownloadService.PREFS_NAME, Context.MODE_PRIVATE)
    private val apiInterface: ApiInterface by lazy {
        EntryPointAccessors.fromApplication(
            context.applicationContext,
            ApiInterfaceEntryPoint::class.java
        ).apiInterface()
    }

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            val urlsKey = inputData.getString("urls_key") ?: "url_list_key"
            val fromSync = inputData.getBoolean("fromSync", false)
            val urlSet = preferences.getStringSet(urlsKey, emptySet()) ?: emptySet()

            if (urlSet.isEmpty()) {
                return@withContext Result.failure()
            }

            val urls = urlSet.toTypedArray()
            DownloadUtils.createChannels(context)

            showProgressNotification(0, urls.size, context.getString(R.string.starting_downloads))

            var completedCount = 0
            val results = mutableListOf<Boolean>()

            urls.forEachIndexed { index, url ->
                try {
                    val success = downloadFile(url, index, urls.size)
                    results.add(success)
                    completedCount++

                    showProgressNotification(completedCount, urls.size, context.getString(R.string.downloaded_files, "$completedCount", "${urls.size}"))
                    sendDownloadUpdate(url, success, completedCount >= urls.size, fromSync)
                } catch (e: Exception) {
                    e.printStackTrace()
                    results.add(false)
                    completedCount++
                }
            }

            showCompletionNotification(completedCount, urls.size, results.any { !it })
            Result.success()
        } catch (e: Exception) {
            e.printStackTrace()
            Result.failure()
        }
    }

    private suspend fun downloadFile(url: String, index: Int, total: Int): Boolean {
        return try {
            val response = apiInterface.downloadFile(UrlUtils.header, url)
            if (response.isSuccessful) {
                response.body()?.let {
                    downloadFileBody(it, url, index, total)
                    true
                } ?: false
            } else {
                false
            }
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    private suspend fun downloadFileBody(body: ResponseBody, url: String, index: Int, total: Int) {
        val fileSize = body.contentLength()
        val outputFile: File = FileUtils.getSDPathFromUrl(context, url)
        var totalBytes: Long = 0

        outputFile.sink().buffer().use { sink ->
            body.source().use { source ->
                val buffer = Buffer()
                while (true) {
                    val read = source.read(buffer, 8_192)
                    if (read == -1L) break
                    sink.write(buffer, read)
                    totalBytes += read

                    if (totalBytes % (1024 * 100) == 0L) {
                        val progress = if (fileSize > 0) {
                            (totalBytes * 100 / fileSize).toInt()
                        } else 0
                        showProgressNotification(index, total, "Downloading ${getFileNameFromUrl(url)} ($progress%)")
                    }
                }
                sink.flush()
            }
        }
        DownloadUtils.updateResourceOfflineStatus(url)
    }

    private suspend fun showProgressNotification(current: Int, total: Int, text: String) {
        val notification = DownloadUtils.buildProgressNotification(
            context,
            current,
            total,
            text,
            forWorker = true
        )
        setForeground(ForegroundInfo(WORKER_NOTIFICATION_ID, notification))
    }

    private fun showCompletionNotification(completed: Int, total: Int, hadErrors: Boolean) {
        val notification = DownloadUtils.buildCompletionNotification(
            context,
            completed,
            total,
            hadErrors,
            forWorker = true
        )

        notificationManager.notify(COMPLETION_NOTIFICATION_ID, notification)
    }

    private suspend fun sendDownloadUpdate(url: String, success: Boolean, isComplete: Boolean, fromSync: Boolean) {
        val download = Download().apply {
            fileName = getFileNameFromUrl(url)
            fileUrl = url
            progress = if (success) 100 else 0
            failed = !success
            completeAll = isComplete
            if (!success) {
                message = context.getString(R.string.download_failed)
            }
        }

        val intent = Intent(MyDownloadService.MESSAGE_PROGRESS).apply {
            putExtra("download", download)
            putExtra("fromSync", fromSync)
        }
        val broadcastService = getBroadcastService(applicationContext)
        broadcastService.sendBroadcast(intent)
    }


    companion object {
        const val WORKER_NOTIFICATION_ID = 3
        const val COMPLETION_NOTIFICATION_ID = 4
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/datamanager/ManagerSync.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.datamanager

import android.content.Context
import android.content.SharedPreferences
import android.util.Base64
import androidx.core.content.edit
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.Realm
import java.util.Locale
import kotlin.LazyThreadSafetyMode
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmUserModel.Companion.populateUsersTable
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.androidDecrypter
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.UrlUtils
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

class ManagerSync private constructor(
    private val context: Context,
    private val dbService: DatabaseService
) {
    private val settings: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

    fun login(userName: String?, password: String?, listener: SyncListener) {
        try {
            if (userName.isNullOrBlank() || password.isNullOrBlank()) {
                listener.onSyncFailed("Username and password are required.")
                return
            }

            listener.onSyncStarted()

            val apiInterface = ApiClient.client.create(ApiInterface::class.java)
            if (apiInterface == null) {
                listener.onSyncFailed("Network client not available.")
                return
            }

            val authHeader = try {
                "Basic " + Base64.encodeToString("$userName:$password".toByteArray(), Base64.NO_WRAP)
            } catch (e: Exception) {
                e.printStackTrace()
                listener.onSyncFailed("Authentication encoding failed.")
                return
            }

            val userUrl = try {
                String.format("%s/_users/%s", UrlUtils.getUrl(), "org.couchdb.user:$userName")
            } catch (e: Exception) {
                e.printStackTrace()
                listener.onSyncFailed("Invalid server URL.")
                return
            }

            apiInterface.getJsonObject(authHeader, userUrl).enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    try {
                        when {
                            !response.isSuccessful -> {
                                val errorMsg = when (response.code()) {
                                    401 -> "Name or password is incorrect."
                                    404 -> "User not found."
                                    500 -> "Server error. Please try again later."
                                    else -> "Login failed. Error code: ${response.code()}"
                                }
                                listener.onSyncFailed(errorMsg)
                                return
                            }

                            response.body() == null -> {
                                listener.onSyncFailed("Empty response from server.")
                                return
                            }
                        }

                        val jsonDoc = response.body()
                        if (jsonDoc?.has("derived_key") == true && jsonDoc.has("salt")) {
                            try {
                                val derivedKey = jsonDoc["derived_key"].asString
                                val salt = jsonDoc["salt"].asString

                                if (androidDecrypter(userName, password, derivedKey, salt)) {
                                    dbService.withRealm { realm ->
                                        checkManagerAndInsert(jsonDoc, realm, listener)
                                    }
                                } else {
                                    listener.onSyncFailed("Authentication failed. Invalid credentials.")
                                }
                            } catch (e: Exception) {
                                e.printStackTrace()
                                listener.onSyncFailed("Authentication processing failed.")
                            }
                        } else {
                            listener.onSyncFailed("Server response missing authentication data.")
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                        listener.onSyncFailed("Login processing failed.")
                    }
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    try {
                        t.printStackTrace()
                        val errorMsg = when (t) {
                            is java.net.UnknownHostException -> "Server not reachable. Check your internet connection."
                            is java.net.SocketTimeoutException -> "Connection timeout. Please try again."
                            is java.net.ConnectException -> "Unable to connect to server."
                            else -> "Network error: ${t.message ?: "Unknown error"}"
                        }
                        listener.onSyncFailed(errorMsg)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        listener.onSyncFailed("Network error occurred.")
                    }
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
            listener.onSyncFailed("Login initialization failed.")
        }
    }

    fun syncAdmin() {
        try {
            val `object` = JsonObject()
            val selector = JsonObject()
            selector.addProperty("isUserAdmin", true)
            `object`.add("selector", selector)

            val apiInterface = ApiClient.client.create(ApiInterface::class.java)
            if (apiInterface == null) {
                return
            }

            val header = UrlUtils.header
            if (header.isBlank()) {
                return
            }

            val url = try {
                UrlUtils.getUrl() + "/_users/_find"
            } catch (e: Exception) {
                e.printStackTrace()
                return
            }

            apiInterface.findDocs(header, "application/json", url, `object`).enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    try {
                        if (response.isSuccessful && response.body() != null) {
                            val responseBody = response.body()
                            settings.edit { putString("communityLeaders", "$responseBody") }

                            val array = JsonUtils.getJsonArray("docs", responseBody)
                            if (array != null && array.size() > 0) {
                                try {
                                    settings.edit { putString("user_admin", Gson().toJson(array[0])) }
                                } catch (e: Exception) {
                                    e.printStackTrace()
                                }
                            }
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    try {
                        t.printStackTrace()
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun checkManagerAndInsert(jsonDoc: JsonObject?, realm: Realm, listener: SyncListener) {
        if (isManager(jsonDoc)) {
            populateUsersTable(jsonDoc, realm, settings)
            listener.onSyncComplete()
        } else {
            listener.onSyncFailed(MainApplication.context.getString(R.string.user_verification_in_progress))
        }
    }

    private fun isManager(jsonDoc: JsonObject?): Boolean {
        val roles = jsonDoc?.get("roles")?.asJsonArray
        val isManager = roles.toString().lowercase(Locale.getDefault()).contains("manager")
        return jsonDoc?.get("isUserAdmin")?.asBoolean == true || isManager
    }

    companion object {
        @JvmStatic
        val instance: ManagerSync by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
            ManagerSync(MainApplication.context, MainApplication.service)
        }
    }
}
=======
package org.ole.planet.myplanet.datamanager


import android.content.Context
import android.content.SharedPreferences
import android.util.Base64
import androidx.core.content.edit
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.Realm
import java.util.Locale
import kotlin.LazyThreadSafetyMode
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.SyncListener
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.model.RealmUserModel.Companion.populateUsersTable
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.androidDecrypter
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.UrlUtils
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

class ManagerSync private constructor(
    private val context: Context,
    private val dbService: DatabaseService
) {
    private val settings: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

    fun login(userName: String?, password: String?, listener: SyncListener) {
        try {
            if (userName.isNullOrBlank() || password.isNullOrBlank()) {
                listener.onSyncFailed("Username and password are required.")
                return
            }

            listener.onSyncStarted()

            val apiInterface = ApiClient.client.create(ApiInterface::class.java)
            if (apiInterface == null) {
                listener.onSyncFailed("Network client not available.")
                return
            }

            val authHeader = try {
                "Basic " + Base64.encodeToString("$userName:$password".toByteArray(), Base64.NO_WRAP)
            } catch (e: Exception) {
                e.printStackTrace()
                listener.onSyncFailed("Authentication encoding failed.")
                return
            }

            val userUrl = try {
                String.format("%s/_users/%s", UrlUtils.getUrl(), "org.couchdb.user:$userName")
            } catch (e: Exception) {
                e.printStackTrace()
                listener.onSyncFailed("Invalid server URL.")
                return
            }

            apiInterface.getJsonObject(authHeader, userUrl).enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    try {
                        when {
                            !response.isSuccessful -> {
                                val errorMsg = when (response.code()) {
                                    401 -> "Name or password is incorrect."
                                    404 -> "User not found."
                                    500 -> "Server error. Please try again later."
                                    else -> "Login failed. Error code: ${response.code()}"
                                }
                                listener.onSyncFailed(errorMsg)
                                return
                            }

                            response.body() == null -> {
                                listener.onSyncFailed("Empty response from server.")
                                return
                            }
                        }

                        val jsonDoc = response.body()
                        if (jsonDoc?.has("derived_key") == true && jsonDoc.has("salt")) {
                            try {
                                val derivedKey = jsonDoc["derived_key"].asString
                                val salt = jsonDoc["salt"].asString

                                if (androidDecrypter(userName, password, derivedKey, salt)) {
                                    dbService.withRealm { realm ->
                                        checkManagerAndInsert(jsonDoc, realm, listener)
                                    }
                                } else {
                                    listener.onSyncFailed("Authentication failed. Invalid credentials.")
                                }
                            } catch (e: Exception) {
                                e.printStackTrace()
                                listener.onSyncFailed("Authentication processing failed.")
                            }
                        } else {
                            listener.onSyncFailed("Server response missing authentication data.")
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                        listener.onSyncFailed("Login processing failed.")
                    }
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    try {
                        t.printStackTrace()
                        val errorMsg = when (t) {
                            is java.net.UnknownHostException -> "Server not reachable. Check your internet connection."
                            is java.net.SocketTimeoutException -> "Connection timeout. Please try again."
                            is java.net.ConnectException -> "Unable to connect to server."
                            else -> "Network error: ${t.message ?: "Unknown error"}"
                        }
                        listener.onSyncFailed(errorMsg)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        listener.onSyncFailed("Network error occurred.")
                    }
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
            listener.onSyncFailed("Login initialization failed.")
        }
    }

    fun syncAdmin() {
        try {
            val `object` = JsonObject()
            val selector = JsonObject()
            selector.addProperty("isUserAdmin", true)
            `object`.add("selector", selector)

            val apiInterface = ApiClient.client.create(ApiInterface::class.java)
            if (apiInterface == null) {
                return
            }

            val header = UrlUtils.header
            if (header.isBlank()) {
                return
            }

            val url = try {
                UrlUtils.getUrl() + "/_users/_find"
            } catch (e: Exception) {
                e.printStackTrace()
                return
            }

            apiInterface.findDocs(header, "application/json", url, `object`).enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    try {
                        if (response.isSuccessful && response.body() != null) {
                            val responseBody = response.body()
                            settings.edit { putString("communityLeaders", "$responseBody") }

                            val array = JsonUtils.getJsonArray("docs", responseBody)
                            if (array != null && array.size() > 0) {
                                try {
                                    settings.edit { putString("user_admin", Gson().toJson(array[0])) }
                                } catch (e: Exception) {
                                    e.printStackTrace()
                                }
                            }
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    try {
                        t.printStackTrace()
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun checkManagerAndInsert(jsonDoc: JsonObject?, realm: Realm, listener: SyncListener) {
        if (isManager(jsonDoc)) {
            populateUsersTable(jsonDoc, realm, settings)
            listener.onSyncComplete()
        } else {
            listener.onSyncFailed(MainApplication.context.getString(R.string.user_verification_in_progress))
        }
    }

    private fun isManager(jsonDoc: JsonObject?): Boolean {
        val roles = jsonDoc?.get("roles")?.asJsonArray
        val isManager = roles.toString().lowercase(Locale.getDefault()).contains("manager")
        return jsonDoc?.get("isUserAdmin")?.asBoolean == true || isManager
    }

    companion object {
        @JvmStatic
        val instance: ManagerSync by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
            ManagerSync(MainApplication.context, MainApplication.service)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/datamanager/ApiClient.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.datamanager

import java.io.IOException
import java.net.SocketTimeoutException
import kotlinx.coroutines.delay
import org.ole.planet.myplanet.utilities.RetryUtils
import retrofit2.Response
import retrofit2.Retrofit

object ApiClient {
    lateinit var client: Retrofit

    suspend fun <T> executeWithRetryAndWrap(operation: suspend () -> Response<T>?): Response<T>? {
        return RetryUtils.retry(
            maxAttempts = 3,
            delayMs = 2000L,
            shouldRetry = { resp -> resp == null || !resp.isSuccessful },
            block = { operation() },
        )
    }

    suspend fun <T> executeWithResult(operation: suspend () -> Response<T>?): NetworkResult<T> {
        var retryCount = 0
        var lastException: Exception? = null

        while (retryCount < 3) {
            try {
                val response = operation()
                if (response != null) {
                    if (response.isSuccessful) {
                        val body = response.body()
                        if (body != null) {
                            return NetworkResult.Success(body)
                        }
                        return NetworkResult.Error(response.code(), null)
                    } else if (retryCount < 2) {
                        retryCount++
                        delay(2000L * (retryCount + 1))
                        continue
                    } else {
                        val errorBody = try { response.errorBody()?.string() } catch (_: Exception) { null }
                        return NetworkResult.Error(response.code(), errorBody)
                    }
                }
            } catch (e: SocketTimeoutException) {
                lastException = e
            } catch (e: IOException) {
                lastException = e
            } catch (e: Exception) {
                lastException = e
            }

            if (retryCount < 2) {
                retryCount++
                delay(2000L * (retryCount + 1))
            } else {
                break
            }
        }
        return NetworkResult.Exception(lastException ?: Exception("Unknown error"))
    }
}
=======
package org.ole.planet.myplanet.datamanager


import java.io.IOException
import java.net.SocketTimeoutException
import kotlinx.coroutines.delay
import org.ole.planet.myplanet.utilities.RetryUtils
import retrofit2.Response
import retrofit2.Retrofit

object ApiClient {
    lateinit var client: Retrofit

    suspend fun <T> executeWithRetryAndWrap(operation: suspend () -> Response<T>?): Response<T>? {
        return RetryUtils.retry(
            maxAttempts = 3,
            delayMs = 2000L,
            shouldRetry = { resp -> resp == null || !resp.isSuccessful },
            block = { operation() },
        )
    }

    suspend fun <T> executeWithResult(operation: suspend () -> Response<T>?): NetworkResult<T> {
        var retryCount = 0
        var lastException: Exception? = null

        while (retryCount < 3) {
            try {
                val response = operation()
                if (response != null) {
                    if (response.isSuccessful) {
                        val body = response.body()
                        if (body != null) {
                            return NetworkResult.Success(body)
                        }
                        return NetworkResult.Error(response.code(), null)
                    } else if (retryCount < 2) {
                        retryCount++
                        delay(2000L * (retryCount + 1))
                        continue
                    } else {
                        val errorBody = try { response.errorBody()?.string() } catch (_: Exception) { null }
                        return NetworkResult.Error(response.code(), errorBody)
                    }
                }
            } catch (e: SocketTimeoutException) {
                lastException = e
            } catch (e: IOException) {
                lastException = e
            } catch (e: Exception) {
                lastException = e
            }

            if (retryCount < 2) {
                retryCount++
                delay(2000L * (retryCount + 1))
            } else {
                break
            }
        }
        return NetworkResult.Exception(lastException ?: Exception("Unknown error"))
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/datamanager/MyDownloadService.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.datamanager

import android.app.Activity
import android.app.ActivityManager
import android.app.NotificationManager
import android.app.Service
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Build
import android.os.IBinder
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.workDataOf
import java.io.BufferedInputStream
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import kotlin.math.roundToInt
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import okhttp3.ResponseBody
import org.ole.planet.myplanet.MainApplication.Companion.createLog
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.Download
import org.ole.planet.myplanet.service.getBroadcastService
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.FileUtils.availableExternalMemorySize
import org.ole.planet.myplanet.utilities.FileUtils.externalMemoryAvailable
import org.ole.planet.myplanet.utilities.FileUtils.getFileNameFromUrl
import org.ole.planet.myplanet.utilities.UrlUtils.header

class MyDownloadService : Service() {
    private var data = ByteArray(1024 * 4)
    private var outputFile: File? = null
    private var notificationBuilder: NotificationCompat.Builder? = null
    private var notificationManager: NotificationManager? = null
    private var totalFileSize = 0
    private lateinit var preferences: SharedPreferences
    private lateinit var urls: Array<String>
    private var currentIndex = 0
    private var fromSync = false

    private var totalDownloadsCount = 0
    private var completedDownloadsCount = 0

    private val downloadJob = SupervisorJob()
    private val downloadScope = CoroutineScope(downloadJob + Dispatchers.IO)

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        preferences = getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager

        DownloadUtils.createChannels(this)

        val initialNotification = DownloadUtils.buildInitialNotification(this)
        startForeground(ONGOING_NOTIFICATION_ID, initialNotification)

        val urlsKey = intent?.getStringExtra("urls_key") ?: "url_list_key"
        val urlSet = preferences.getStringSet(urlsKey, emptySet()) ?: emptySet()

        if (urlSet.isEmpty()) {
            stopSelf()
            return START_NOT_STICKY
        }

        urls = urlSet.toTypedArray()
        totalDownloadsCount = urls.size
        fromSync = intent?.getBooleanExtra("fromSync", false) == true

        updateNotificationForBatchDownload()

        downloadScope.launch {
            urls.forEachIndexed { index, url ->
                currentIndex = index
                initDownload(url, fromSync)
            }
        }

        return START_STICKY
    }

    private fun updateNotificationForBatchDownload() {
        DownloadUtils.createChannels(this)
        notificationBuilder = NotificationCompat.Builder(this, "DownloadChannel")
            .setContentTitle(getString(R.string.downloading_files))
            .setContentText("Starting downloads (0/$totalDownloadsCount)")
            .setSmallIcon(R.drawable.ic_download)
            .setProgress(totalDownloadsCount, 0, false)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setOngoing(true)
            .setSilent(true)

        notificationManager?.notify(ONGOING_NOTIFICATION_ID, notificationBuilder?.build())
    }

    private suspend fun initDownload(url: String, fromSync: Boolean) {
        try {
            if (url.isBlank()) {
                downloadFailed("Invalid URL - empty or blank", fromSync)
                return
            }

            val retrofitInterface = ApiClient.client.create(ApiInterface::class.java)
            if (retrofitInterface == null) {
                downloadFailed("Network client not available", fromSync)
                return
            }

            val authHeader = header
            if (authHeader.isBlank()) {
                downloadFailed("Authentication header not available", fromSync)
                return
            }
            val response = try {
                retrofitInterface.downloadFile(authHeader, url)
            } catch (e: java.net.UnknownHostException) {
                downloadFailed("Server not reachable. Check internet connection.", fromSync)
                return
            } catch (e: java.net.SocketTimeoutException) {
                downloadFailed("Connection timeout. Please try again.", fromSync)
                return
            } catch (e: java.net.ConnectException) {
                downloadFailed("Unable to connect to server", fromSync)
                return
            } catch (e: IOException) {
                downloadFailed("Network error: ${e.localizedMessage ?: "Unknown IO error"}", fromSync)
                return
            } catch (e: Exception) {
                downloadFailed("Network error: ${e.localizedMessage ?: "Unknown error"}", fromSync)
                return
            }

            if (response.isSuccessful) {
                    val responseBody = response.body()
                    if (responseBody == null) {
                        downloadFailed("Empty response body", fromSync)
                        return
                    }

                    try {
                        val contentLength = responseBody.contentLength()
                        if (contentLength > 0 && !checkStorage(contentLength)) {
                            downloadFile(responseBody, url)
                        } else if (contentLength == -1L) {
                            downloadFile(responseBody, url)
                        } else if (contentLength == 0L) {
                            downloadFailed("Empty file: Content-Length=$contentLength", fromSync)
                        }
                    } catch (e: Exception) {
                        downloadFailed("Storage check failed: ${e.localizedMessage ?: "Unknown error"}", fromSync)
                    }
            } else {
                val errorMessage = when (response.code()) {
                        401 -> "Unauthorized access"
                        403 -> "Forbidden - Access denied"
                        404 -> "File not found"
                        408 -> "Request timeout"
                        500 -> "Server error"
                        502 -> "Bad gateway"
                        503 -> "Service unavailable"
                        504 -> "Gateway timeout"
                        else -> "Connection failed (${response.code()})"
                }
                downloadFailed(errorMessage, fromSync)

                if (response.code() == 404) {
                    try {
                        val responseString = response.toString()
                        val regex = Regex("url=([^}]*)")
                        val matchResult = regex.find(responseString)
                        val extractedUrl = matchResult?.groupValues?.get(1)
                        createLog("File Not Found", "$extractedUrl")
                    } catch (e: Exception) {
                        createLog("File Not Found", url)
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
            downloadFailed("Download initialization failed: ${e.localizedMessage ?: "Unknown error"}", fromSync)
        }
    }

    private fun downloadFailed(message: String, fromSync: Boolean) {
        notificationBuilder?.apply {
            setContentText("Error: $message (${currentIndex + 1}/$totalDownloadsCount)")
            notificationManager?.notify(ONGOING_NOTIFICATION_ID, build())
        }

        val download = Download().apply {
            failed = true
            this.message = message
        }
        sendIntent(download, fromSync)
        completedDownloadsCount++

        if (completedDownloadsCount >= totalDownloadsCount) {
            showCompletionNotification(true)
            stopSelf()
        }

        if (!fromSync) {
            if (message == "File Not Found") {
                val intent = Intent(RESOURCE_NOT_FOUND_ACTION)
                downloadScope.launch {
                    val broadcastService = getBroadcastService(this@MyDownloadService)
                    broadcastService.sendBroadcast(intent)
                }
            }
        }
    }

    @Throws(IOException::class)
    private fun downloadFile(body: ResponseBody, url: String) {
        val fileSize = body.contentLength()
        outputFile = FileUtils.getSDPathFromUrl(this@MyDownloadService, url)
        var total: Long = 0
        val startTime = System.currentTimeMillis()
        var timeCount = 1

        BufferedInputStream(body.byteStream(), 1024 * 8).use { bis ->
            FileOutputStream(outputFile).use { output ->
                while (true) {
                    val readCount = bis.read(data)
                    if (readCount == -1) break

                    if (readCount > 0) {
                        total += readCount
                        val current = (total / 1024.0).roundToInt().toDouble()
                        val currentTime = System.currentTimeMillis() - startTime

                        val download = Download().apply {
                            fileName = getFileNameFromUrl(url)
                        }

                        if (fileSize > 0) {
                            totalFileSize = (fileSize / 1024.0).toInt()
                            val progress = (total * 100 / fileSize).toInt()
                            this@MyDownloadService.totalFileSize = totalFileSize
                            download.totalFileSize = totalFileSize
                            download.progress = progress
                        } else {
                            download.totalFileSize = 0
                            download.progress = -1
                        }

                        if (currentTime > 1000 * timeCount) {
                            download.currentFileSize = current.toInt()
                            sendNotification(download)
                            timeCount++
                        }
                        output.write(data, 0, readCount)
                    }
                }
            }
        }

        onDownloadComplete(url)
    }

    private fun checkStorage(fileSize: Long): Boolean {
        return when {
            !externalMemoryAvailable() -> {
                downloadFailed("Download Failed: SD card not available", fromSync)
                true
            }
            fileSize > availableExternalMemorySize -> {
                downloadFailed("Download Failed: Not enough storage in SD card", fromSync)
                true
            }
            else -> false
        }
    }

    private fun sendNotification(download: Download) {
        val url = urls.getOrNull(currentIndex) ?: run {
            return
        }

        download.fileName = "Downloading: ${getFileNameFromUrl(url)}"
        sendIntent(download, fromSync)

        if (NotificationManagerCompat.from(this).areNotificationsEnabled()) {
            notificationBuilder?.apply {
                setProgress(totalDownloadsCount, completedDownloadsCount, false)
                setContentText("Downloading ${currentIndex + 1}/$totalDownloadsCount: ${getFileNameFromUrl(url)}")
                notificationManager?.notify(ONGOING_NOTIFICATION_ID, build())
            }
        }
    }

    private fun sendIntent(download: Download, fromSync: Boolean) {
        val intent = Intent(MESSAGE_PROGRESS).apply {
            putExtra("download", download)
            putExtra("fromSync", fromSync)
        }
        downloadScope.launch {
            val broadcastService = getBroadcastService(this@MyDownloadService)
            broadcastService.sendBroadcast(intent)
        }
    }

    private fun onDownloadComplete(url: String) {
        if ((outputFile?.length() ?: 0) > 0) {
            DownloadUtils.updateResourceOfflineStatus(url)
        }
        completedDownloadsCount++

        val download = Download().apply {
            fileName = getFileNameFromUrl(url)
            fileUrl = url
            progress = 100
            completeAll = (completedDownloadsCount >= totalDownloadsCount)
        }

        sendIntent(download, fromSync)
        notificationBuilder?.apply {
            setProgress(totalDownloadsCount, completedDownloadsCount, false)
            setContentText("Downloaded ${completedDownloadsCount}/${totalDownloadsCount} files")
            notificationManager?.notify(ONGOING_NOTIFICATION_ID, build())
        }

        if (completedDownloadsCount >= totalDownloadsCount) {
            showCompletionNotification(false)
            stopSelf()
        }
    }

    private fun showCompletionNotification(hadErrors: Boolean) {
        val notification = DownloadUtils.buildCompletionNotification(
            this,
            completedDownloadsCount,
            totalDownloadsCount,
            hadErrors,
            forWorker = false
        )

        notificationManager?.notify(COMPLETION_NOTIFICATION_ID, notification)
    }

    override fun onDestroy() {
        try {
            stopForeground(true)
        } catch (_: Exception) {
        }
        downloadJob.cancel()
        notificationManager?.cancel(ONGOING_NOTIFICATION_ID)
        super.onDestroy()
    }

    companion object {
        const val PREFS_NAME = "MyPrefsFile"
        const val MESSAGE_PROGRESS = "message_progress"
        const val RESOURCE_NOT_FOUND_ACTION = "resource_not_found_action"
        const val ONGOING_NOTIFICATION_ID = 1
        const val COMPLETION_NOTIFICATION_ID = 2

        fun startService(context: Context, urlsKey: String, fromSync: Boolean) {
            val intent = Intent(context, MyDownloadService::class.java).apply {
                putExtra("urls_key", urlsKey)
                putExtra("fromSync", fromSync)
            }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                val canStart = when {
                    context is Activity -> true
                    Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE -> {
                        hasValidForegroundServiceContext(context)
                    }
                    else -> true
                }

                if (canStart) {
                    try {
                        ContextCompat.startForegroundService(context, intent)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        handleForegroundServiceError(context, urlsKey, fromSync)
                    }
                } else {
                    startDownloadWork(context, urlsKey, fromSync)
                }
            } else {
                try {
                    ContextCompat.startForegroundService(context, intent)
                } catch (e: Exception) {
                    e.printStackTrace()
                    handleForegroundServiceError(context, urlsKey, fromSync)
                }
            }
        }

        @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
        private fun hasValidForegroundServiceContext(context: Context): Boolean {
            val activityManager = context.getSystemService(ACTIVITY_SERVICE) as ActivityManager
            return activityManager.isBackgroundRestricted.not()
        }

        private fun handleForegroundServiceError(context: Context, urlsKey: String, fromSync: Boolean) {
            try {
                val intent = Intent(context, MyDownloadService::class.java).apply {
                    putExtra("urls_key", urlsKey)
                    putExtra("fromSync", fromSync)
                }
                context.startService(intent)
            } catch (e: Exception) {
                e.printStackTrace()
                startDownloadWork(context, urlsKey, fromSync)
            }
        }

        private fun startDownloadWork(context: Context, urlsKey: String, fromSync: Boolean) {
            val workRequest = OneTimeWorkRequestBuilder<DownloadWorker>()
                .setInputData(workDataOf(
                    "urls_key" to urlsKey,
                    "fromSync" to fromSync
                ))
                .build()

            WorkManager.getInstance(context).enqueue(workRequest)
        }
    }
}
=======
package org.ole.planet.myplanet.datamanager


import android.app.Activity
import android.app.ActivityManager
import android.app.NotificationManager
import android.app.Service
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Build
import android.os.IBinder
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.workDataOf
import java.io.BufferedInputStream
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import kotlin.math.roundToInt
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import okhttp3.ResponseBody
import org.ole.planet.myplanet.MainApplication.Companion.createLog
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.model.Download
import org.ole.planet.myplanet.service.getBroadcastService
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.FileUtils.availableExternalMemorySize
import org.ole.planet.myplanet.utilities.FileUtils.externalMemoryAvailable
import org.ole.planet.myplanet.utilities.FileUtils.getFileNameFromUrl
import org.ole.planet.myplanet.utilities.UrlUtils.header

class MyDownloadService : Service() {
    private var data = ByteArray(1024 * 4)
    private var outputFile: File? = null
    private var notificationBuilder: NotificationCompat.Builder? = null
    private var notificationManager: NotificationManager? = null
    private var totalFileSize = 0
    private lateinit var preferences: SharedPreferences
    private lateinit var urls: Array<String>
    private var currentIndex = 0
    private var fromSync = false

    private var totalDownloadsCount = 0
    private var completedDownloadsCount = 0

    private val downloadJob = SupervisorJob()
    private val downloadScope = CoroutineScope(downloadJob + Dispatchers.IO)

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        preferences = getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager

        DownloadUtils.createChannels(this)

        val initialNotification = DownloadUtils.buildInitialNotification(this)
        startForeground(ONGOING_NOTIFICATION_ID, initialNotification)

        val urlsKey = intent?.getStringExtra("urls_key") ?: "url_list_key"
        val urlSet = preferences.getStringSet(urlsKey, emptySet()) ?: emptySet()

        if (urlSet.isEmpty()) {
            stopSelf()
            return START_NOT_STICKY
        }

        urls = urlSet.toTypedArray()
        totalDownloadsCount = urls.size
        fromSync = intent?.getBooleanExtra("fromSync", false) == true

        updateNotificationForBatchDownload()

        downloadScope.launch {
            urls.forEachIndexed { index, url ->
                currentIndex = index
                initDownload(url, fromSync)
            }
        }

        return START_STICKY
    }

    private fun updateNotificationForBatchDownload() {
        DownloadUtils.createChannels(this)
        notificationBuilder = NotificationCompat.Builder(this, "DownloadChannel")
            .setContentTitle(getString(R.string.downloading_files))
            .setContentText("Starting downloads (0/$totalDownloadsCount)")
            .setSmallIcon(R.drawable.ic_download)
            .setProgress(totalDownloadsCount, 0, false)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setOngoing(true)
            .setSilent(true)

        notificationManager?.notify(ONGOING_NOTIFICATION_ID, notificationBuilder?.build())
    }

    private suspend fun initDownload(url: String, fromSync: Boolean) {
        try {
            if (url.isBlank()) {
                downloadFailed("Invalid URL - empty or blank", fromSync)
                return
            }

            val retrofitInterface = ApiClient.client.create(ApiInterface::class.java)
            if (retrofitInterface == null) {
                downloadFailed("Network client not available", fromSync)
                return
            }

            val authHeader = header
            if (authHeader.isBlank()) {
                downloadFailed("Authentication header not available", fromSync)
                return
            }
            val response = try {
                retrofitInterface.downloadFile(authHeader, url)
            } catch (e: java.net.UnknownHostException) {
                downloadFailed("Server not reachable. Check internet connection.", fromSync)
                return
            } catch (e: java.net.SocketTimeoutException) {
                downloadFailed("Connection timeout. Please try again.", fromSync)
                return
            } catch (e: java.net.ConnectException) {
                downloadFailed("Unable to connect to server", fromSync)
                return
            } catch (e: IOException) {
                downloadFailed("Network error: ${e.localizedMessage ?: "Unknown IO error"}", fromSync)
                return
            } catch (e: Exception) {
                downloadFailed("Network error: ${e.localizedMessage ?: "Unknown error"}", fromSync)
                return
            }

            if (response.isSuccessful) {
                    val responseBody = response.body()
                    if (responseBody == null) {
                        downloadFailed("Empty response body", fromSync)
                        return
                    }

                    try {
                        val contentLength = responseBody.contentLength()
                        if (contentLength > 0 && !checkStorage(contentLength)) {
                            downloadFile(responseBody, url)
                        } else if (contentLength == -1L) {
                            downloadFile(responseBody, url)
                        } else if (contentLength == 0L) {
                            downloadFailed("Empty file: Content-Length=$contentLength", fromSync)
                        }
                    } catch (e: Exception) {
                        downloadFailed("Storage check failed: ${e.localizedMessage ?: "Unknown error"}", fromSync)
                    }
            } else {
                val errorMessage = when (response.code()) {
                        401 -> "Unauthorized access"
                        403 -> "Forbidden - Access denied"
                        404 -> "File not found"
                        408 -> "Request timeout"
                        500 -> "Server error"
                        502 -> "Bad gateway"
                        503 -> "Service unavailable"
                        504 -> "Gateway timeout"
                        else -> "Connection failed (${response.code()})"
                }
                downloadFailed(errorMessage, fromSync)

                if (response.code() == 404) {
                    try {
                        val responseString = response.toString()
                        val regex = Regex("url=([^}]*)")
                        val matchResult = regex.find(responseString)
                        val extractedUrl = matchResult?.groupValues?.get(1)
                        createLog("File Not Found", "$extractedUrl")
                    } catch (e: Exception) {
                        createLog("File Not Found", url)
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
            downloadFailed("Download initialization failed: ${e.localizedMessage ?: "Unknown error"}", fromSync)
        }
    }

    private fun downloadFailed(message: String, fromSync: Boolean) {
        notificationBuilder?.apply {
            setContentText("Error: $message (${currentIndex + 1}/$totalDownloadsCount)")
            notificationManager?.notify(ONGOING_NOTIFICATION_ID, build())
        }

        val download = Download().apply {
            failed = true
            this.message = message
        }
        sendIntent(download, fromSync)
        completedDownloadsCount++

        if (completedDownloadsCount >= totalDownloadsCount) {
            showCompletionNotification(true)
            stopSelf()
        }

        if (!fromSync) {
            if (message == "File Not Found") {
                val intent = Intent(RESOURCE_NOT_FOUND_ACTION)
                downloadScope.launch {
                    val broadcastService = getBroadcastService(this@MyDownloadService)
                    broadcastService.sendBroadcast(intent)
                }
            }
        }
    }

    @Throws(IOException::class)
    private fun downloadFile(body: ResponseBody, url: String) {
        val fileSize = body.contentLength()
        outputFile = FileUtils.getSDPathFromUrl(this@MyDownloadService, url)
        var total: Long = 0
        val startTime = System.currentTimeMillis()
        var timeCount = 1

        BufferedInputStream(body.byteStream(), 1024 * 8).use { bis ->
            FileOutputStream(outputFile).use { output ->
                while (true) {
                    val readCount = bis.read(data)
                    if (readCount == -1) break

                    if (readCount > 0) {
                        total += readCount
                        val current = (total / 1024.0).roundToInt().toDouble()
                        val currentTime = System.currentTimeMillis() - startTime

                        val download = Download().apply {
                            fileName = getFileNameFromUrl(url)
                        }

                        if (fileSize > 0) {
                            totalFileSize = (fileSize / 1024.0).toInt()
                            val progress = (total * 100 / fileSize).toInt()
                            this@MyDownloadService.totalFileSize = totalFileSize
                            download.totalFileSize = totalFileSize
                            download.progress = progress
                        } else {
                            download.totalFileSize = 0
                            download.progress = -1
                        }

                        if (currentTime > 1000 * timeCount) {
                            download.currentFileSize = current.toInt()
                            sendNotification(download)
                            timeCount++
                        }
                        output.write(data, 0, readCount)
                    }
                }
            }
        }

        onDownloadComplete(url)
    }

    private fun checkStorage(fileSize: Long): Boolean {
        return when {
            !externalMemoryAvailable() -> {
                downloadFailed("Download Failed: SD card not available", fromSync)
                true
            }
            fileSize > availableExternalMemorySize -> {
                downloadFailed("Download Failed: Not enough storage in SD card", fromSync)
                true
            }
            else -> false
        }
    }

    private fun sendNotification(download: Download) {
        val url = urls.getOrNull(currentIndex) ?: run {
            return
        }

        download.fileName = "Downloading: ${getFileNameFromUrl(url)}"
        sendIntent(download, fromSync)

        if (NotificationManagerCompat.from(this).areNotificationsEnabled()) {
            notificationBuilder?.apply {
                setProgress(totalDownloadsCount, completedDownloadsCount, false)
                setContentText("Downloading ${currentIndex + 1}/$totalDownloadsCount: ${getFileNameFromUrl(url)}")
                notificationManager?.notify(ONGOING_NOTIFICATION_ID, build())
            }
        }
    }

    private fun sendIntent(download: Download, fromSync: Boolean) {
        val intent = Intent(MESSAGE_PROGRESS).apply {
            putExtra("download", download)
            putExtra("fromSync", fromSync)
        }
        downloadScope.launch {
            val broadcastService = getBroadcastService(this@MyDownloadService)
            broadcastService.sendBroadcast(intent)
        }
    }

    private fun onDownloadComplete(url: String) {
        if ((outputFile?.length() ?: 0) > 0) {
            DownloadUtils.updateResourceOfflineStatus(url)
        }
        completedDownloadsCount++

        val download = Download().apply {
            fileName = getFileNameFromUrl(url)
            fileUrl = url
            progress = 100
            completeAll = (completedDownloadsCount >= totalDownloadsCount)
        }

        sendIntent(download, fromSync)
        notificationBuilder?.apply {
            setProgress(totalDownloadsCount, completedDownloadsCount, false)
            setContentText("Downloaded ${completedDownloadsCount}/${totalDownloadsCount} files")
            notificationManager?.notify(ONGOING_NOTIFICATION_ID, build())
        }

        if (completedDownloadsCount >= totalDownloadsCount) {
            showCompletionNotification(false)
            stopSelf()
        }
    }

    private fun showCompletionNotification(hadErrors: Boolean) {
        val notification = DownloadUtils.buildCompletionNotification(
            this,
            completedDownloadsCount,
            totalDownloadsCount,
            hadErrors,
            forWorker = false
        )

        notificationManager?.notify(COMPLETION_NOTIFICATION_ID, notification)
    }

    override fun onDestroy() {
        try {
            stopForeground(true)
        } catch (_: Exception) {
        }
        downloadJob.cancel()
        notificationManager?.cancel(ONGOING_NOTIFICATION_ID)
        super.onDestroy()
    }

    companion object {
        const val PREFS_NAME = "MyPrefsFile"
        const val MESSAGE_PROGRESS = "message_progress"
        const val RESOURCE_NOT_FOUND_ACTION = "resource_not_found_action"
        const val ONGOING_NOTIFICATION_ID = 1
        const val COMPLETION_NOTIFICATION_ID = 2

        fun startService(context: Context, urlsKey: String, fromSync: Boolean) {
            val intent = Intent(context, MyDownloadService::class.java).apply {
                putExtra("urls_key", urlsKey)
                putExtra("fromSync", fromSync)
            }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                val canStart = when {
                    context is Activity -> true
                    Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE -> {
                        hasValidForegroundServiceContext(context)
                    }
                    else -> true
                }

                if (canStart) {
                    try {
                        ContextCompat.startForegroundService(context, intent)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        handleForegroundServiceError(context, urlsKey, fromSync)
                    }
                } else {
                    startDownloadWork(context, urlsKey, fromSync)
                }
            } else {
                try {
                    ContextCompat.startForegroundService(context, intent)
                } catch (e: Exception) {
                    e.printStackTrace()
                    handleForegroundServiceError(context, urlsKey, fromSync)
                }
            }
        }

        @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
        private fun hasValidForegroundServiceContext(context: Context): Boolean {
            val activityManager = context.getSystemService(ACTIVITY_SERVICE) as ActivityManager
            return activityManager.isBackgroundRestricted.not()
        }

        private fun handleForegroundServiceError(context: Context, urlsKey: String, fromSync: Boolean) {
            try {
                val intent = Intent(context, MyDownloadService::class.java).apply {
                    putExtra("urls_key", urlsKey)
                    putExtra("fromSync", fromSync)
                }
                context.startService(intent)
            } catch (e: Exception) {
                e.printStackTrace()
                startDownloadWork(context, urlsKey, fromSync)
            }
        }

        private fun startDownloadWork(context: Context, urlsKey: String, fromSync: Boolean) {
            val workRequest = OneTimeWorkRequestBuilder<DownloadWorker>()
                .setInputData(workDataOf(
                    "urls_key" to urlsKey,
                    "fromSync" to fromSync
                ))
                .build()

            WorkManager.getInstance(context).enqueue(workRequest)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/datamanager/Service.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.datamanager

import android.content.Context
import android.content.SharedPreferences
import android.text.TextUtils
import androidx.core.content.edit
import androidx.core.net.toUri
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.EntryPointAccessors
import io.realm.Realm
import java.io.IOException
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.Executors
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.ResponseBody
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.SecurityDataCallback
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.di.ApiInterfaceEntryPoint
import org.ole.planet.myplanet.di.ApplicationScope
import org.ole.planet.myplanet.di.ApplicationScopeEntryPoint
import org.ole.planet.myplanet.di.AutoSyncEntryPoint
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.model.RealmCommunity
import org.ole.planet.myplanet.model.RealmUserModel.Companion.isUserExists
import org.ole.planet.myplanet.model.RealmUserModel.Companion.populateUsersTable
import org.ole.planet.myplanet.service.UploadToShelfService
import org.ole.planet.myplanet.ui.sync.ProcessUserDataActivity
import org.ole.planet.myplanet.ui.sync.SyncActivity
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateIv
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateKey
import org.ole.planet.myplanet.utilities.Constants.KEY_UPGRADE_MAX
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.Constants.showBetaFeature
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.Sha256Utils
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities
import org.ole.planet.myplanet.utilities.VersionUtils
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

class Service @Inject constructor(
    private val context: Context,
    private val retrofitInterface: ApiInterface,
    @ApplicationScope private val serviceScope: CoroutineScope,
) {
    constructor(context: Context) : this(
        context,
        EntryPointAccessors.fromApplication(
            context.applicationContext,
            ApiInterfaceEntryPoint::class.java
        ).apiInterface(),
        EntryPointAccessors.fromApplication(
            context.applicationContext,
            ApplicationScopeEntryPoint::class.java
        ).applicationScope(),
    )

    private val preferences: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    private val serverAvailabilityCache = ConcurrentHashMap<String, Pair<Boolean, Long>>()
    private val configurationManager =
        ConfigurationManager(context, preferences, retrofitInterface)
    private fun getUploadToShelfService(): UploadToShelfService {
        val entryPoint = EntryPointAccessors.fromApplication(
            context.applicationContext,
            AutoSyncEntryPoint::class.java
        )
        return entryPoint.uploadToShelfService()
    }

    fun healthAccess(listener: SuccessListener) {
        try {
            val healthUrl = UrlUtils.getHealthAccessUrl(preferences)
            if (healthUrl.isBlank()) {
                listener.onSuccess("")
                return
            }

            retrofitInterface.healthAccess(healthUrl).enqueue(object : Callback<ResponseBody> {
                override fun onResponse(call: Call<ResponseBody>, response: Response<ResponseBody>) {
                    try {
                        when (response.code()) {
                            200 -> listener.onSuccess(context.getString(R.string.server_sync_successfully))
                            401 -> listener.onSuccess("Unauthorized - Invalid credentials")
                            404 -> listener.onSuccess("Server endpoint not found")
                            500 -> listener.onSuccess("Server internal error")
                            502 -> listener.onSuccess("Bad gateway - Server unavailable")
                            503 -> listener.onSuccess("Service temporarily unavailable")
                            504 -> listener.onSuccess("Gateway timeout")
                            else -> listener.onSuccess("Server error: ${response.code()}")
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                        listener.onSuccess("")
                    }
                }

                override fun onFailure(call: Call<ResponseBody>, t: Throwable) {
                    try {
                        t.printStackTrace()
                        val errorMsg = when (t) {
                            is java.net.UnknownHostException -> "Server not reachable"
                            is java.net.SocketTimeoutException -> "Connection timeout"
                            is java.net.ConnectException -> "Unable to connect to server"
                            is java.io.IOException -> "Network connection error"
                            else -> "Network error: ${t.localizedMessage ?: "Unknown error"}"
                        }
                        listener.onSuccess(errorMsg)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        listener.onSuccess("Health check failed")
                    }
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
            listener.onSuccess("Health access initialization failed")
        }
    }

    fun checkCheckSum(callback: ChecksumCallback, path: String?) {
        retrofitInterface.getChecksum(UrlUtils.getChecksumUrl(preferences)).enqueue(object : Callback<ResponseBody> {
            override fun onResponse(call: Call<ResponseBody>, response: Response<ResponseBody>) {
                if (response.code() == 200) {
                    try {
                        val checksum = response.body()?.string()
                        if (TextUtils.isEmpty(checksum)) {
                            val f = FileUtils.getSDPathFromUrl(context, path)
                            if (f.exists()) {
                                val sha256 = Sha256Utils().getCheckSumFromFile(f)
                                if (checksum?.contains(sha256) == true) {
                                    callback.onMatch()
                                    return
                                }
                            }
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
                }
                callback.onFail()
            }

            override fun onFailure(call: Call<ResponseBody>, t: Throwable) {
                callback.onFail()
            }
        })
    }

    fun checkVersion(callback: CheckVersionCallback, settings: SharedPreferences) {
        if (shouldPromptForSettings(settings)) return

        serviceScope.launch {
            withContext(Dispatchers.Main) {
                callback.onCheckingVersion()
            }
            try {
                val planetInfo = fetchVersionInfo(settings)
                if (planetInfo == null) {
                    withContext(Dispatchers.Main) {
                        callback.onError(context.getString(R.string.version_not_found), true)
                    }
                    return@launch
                }

                preferences.edit {
                    putLong("last_version_check_timestamp", System.currentTimeMillis())
                    putInt("LastWifiID", NetworkUtils.getCurrentNetworkId(context))
                    putString("versionDetail", Gson().toJson(planetInfo))
                }

                val rawApkVersion = fetchApkVersionString(settings)
                val versionStr = Gson().fromJson(rawApkVersion, String::class.java)
                if (versionStr.isNullOrEmpty()) {
                    withContext(Dispatchers.Main) {
                        callback.onError(context.getString(R.string.planet_is_up_to_date), false)
                    }
                    return@launch
                }

                val apkVersion = parseApkVersionString(versionStr)
                    ?: run {
                        withContext(Dispatchers.Main) {
                            callback.onError(
                                context.getString(R.string.new_apk_version_required_but_not_found_on_server),
                                false
                            )
                        }
                        return@launch
                    }

                handleVersionEvaluation(planetInfo, apkVersion, callback)
            } catch (e: Exception) {
                e.printStackTrace()
                withContext(Dispatchers.Main) {
                    callback.onError(context.getString(R.string.connection_failed), true)
                }
            }
        }
    }

    fun isPlanetAvailable(callback: PlanetAvailableListener?) {
        val updateUrl = "${preferences.getString("serverURL", "")}"
        serverAvailabilityCache[updateUrl]?.let { (available, timestamp) ->
            if (System.currentTimeMillis() - timestamp < 30000) {
                if (available) {
                    callback?.isAvailable()
                } else {
                    callback?.notAvailable()
                }
                return
            }
        }

        val serverUrlMapper = ServerUrlMapper()
        val mapping = serverUrlMapper.processUrl(updateUrl)

        serviceScope.launch {
            withContext(Dispatchers.IO) {
                val primaryReachable = isServerReachable(mapping.primaryUrl)
                val alternativeReachable = mapping.alternativeUrl?.let { isServerReachable(it) } == true

                if (!primaryReachable && alternativeReachable) {
                    mapping.alternativeUrl?.let { alternativeUrl ->
                        val uri = updateUrl.toUri()
                        val editor = preferences.edit()

                        serverUrlMapper.updateUrlPreferences(
                            editor,
                            uri,
                            alternativeUrl,
                            mapping.primaryUrl,
                            preferences
                        )
                    }
                }
            }

            retrofitInterface.isPlanetAvailable(UrlUtils.getUpdateUrl(preferences)).enqueue(object : Callback<ResponseBody?> {
                override fun onResponse(call: Call<ResponseBody?>, response: Response<ResponseBody?>) {
                    val isAvailable = callback != null && response.code() == 200
                    serverAvailabilityCache[updateUrl] = Pair(isAvailable, System.currentTimeMillis())
                    serviceScope.launch {
                        withContext(Dispatchers.Main) {
                            if (isAvailable) {
                                callback.isAvailable()
                            } else {
                                callback?.notAvailable()
                            }
                        }
                    }
                }

                override fun onFailure(call: Call<ResponseBody?>, t: Throwable) {
                    serverAvailabilityCache[updateUrl] = Pair(false, System.currentTimeMillis())
                    serviceScope.launch {
                        withContext(Dispatchers.Main) {
                            callback?.notAvailable()
                        }
                    }
                }
            })
        }
    }

    fun becomeMember(realm: Realm, obj: JsonObject, callback: CreateUserCallback, securityCallback: SecurityDataCallback? = null) {
        isPlanetAvailable(object : PlanetAvailableListener {
            override fun isAvailable() {
                retrofitInterface.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/_users/org.couchdb.user:${obj["name"].asString}").enqueue(object : Callback<JsonObject> {
                     override fun onResponse(call: Call<JsonObject>, response: Response<JsonObject>) {
                         if (response.body() != null && response.body()?.has("_id") == true) {
                             callback.onSuccess(context.getString(R.string.unable_to_create_user_user_already_exists))
                         } else {
                             retrofitInterface.putDoc(null, "application/json", "${UrlUtils.getUrl()}/_users/org.couchdb.user:${obj["name"].asString}", obj).enqueue(object : Callback<JsonObject> {
                                 override fun onResponse(call: Call<JsonObject>, response: Response<JsonObject>) {
                                     if (response.body() != null && response.body()?.has("id") == true) {
                                         uploadToShelf(obj)
                                         saveUserToDb(realm, "${response.body()?.get("id")?.asString}", obj, callback, securityCallback)
                                     } else {
                                         callback.onSuccess(context.getString(R.string.unable_to_create_user_user_already_exists))
                                     }
                                 }

                                 override fun onFailure(call: Call<JsonObject>, t: Throwable) {
                                     callback.onSuccess(context.getString(R.string.unable_to_create_user_user_already_exists))
                                 }
                             })
                         }
                     }

                    override fun onFailure(call: Call<JsonObject>, t: Throwable) {
                        callback.onSuccess(context.getString(R.string.unable_to_create_user_user_already_exists))
                    }
                })
            }

            override fun notAvailable() {
                val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
                if (isUserExists(realm, obj["name"].asString)) {
                    callback.onSuccess(context.getString(R.string.unable_to_create_user_user_already_exists))
                    return
                }
                realm.beginTransaction()
                val model = populateUsersTable(obj, realm, settings)
                val keyString = generateKey()
                val iv = generateIv()
                if (model != null) {
                    model.key = keyString
                    model.iv = iv
                }
                realm.commitTransaction()
                Utilities.toast(MainApplication.context, context.getString(R.string.not_connect_to_planet_created_user_offline))
                callback.onSuccess(context.getString(R.string.not_connect_to_planet_created_user_offline))
                securityCallback?.onSecurityDataUpdated()
            }
        })
    }

    private fun uploadToShelf(obj: JsonObject) {
        retrofitInterface.putDoc(null, "application/json", UrlUtils.getUrl() + "/shelf/org.couchdb.user:" + obj["name"].asString, JsonObject()).enqueue(object : Callback<JsonObject?> {
            override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {}
            override fun onFailure(call: Call<JsonObject?>, t: Throwable) {}
        })
    }

    private fun saveUserToDb(realm: Realm, id: String, obj: JsonObject, callback: CreateUserCallback, securityCallback: SecurityDataCallback? = null) {
        val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        realm.executeTransactionAsync({ realm1: Realm? ->
            try {
                val res = retrofitInterface.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/_users/$id").execute()
                if (res.body() != null) {
                    val model = populateUsersTable(res.body(), realm1, settings)
                    if (model != null) {
                        getUploadToShelfService().saveKeyIv(retrofitInterface, model, obj)
                    }
                }
            } catch (e: IOException) {
                e.printStackTrace()
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }, {
            callback.onSuccess(context.getString(R.string.user_created_successfully))
            if (context is ProcessUserDataActivity) {
                context.runOnUiThread {
                    val userName = "${obj["name"].asString}"
                    context.startUpload("becomeMember", userName, securityCallback)
                }
            }
        }) { error: Throwable ->
            error.printStackTrace()
            callback.onSuccess(context.getString(R.string.unable_to_save_user_please_sync))
            securityCallback?.onSecurityDataUpdated()
        }
    }

    fun syncPlanetServers(callback: SuccessListener) {
        retrofitInterface.getJsonObject("", "https://planet.earth.ole.org/db/communityregistrationrequests/_all_docs?include_docs=true")
            .enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    if (response.body() != null) {
                        val arr = JsonUtils.getJsonArray("rows", response.body())

                        val executor = Executors.newSingleThreadExecutor()
                        try {
                            executor.execute {
                                MainApplication.service.withRealm { backgroundRealm ->
                                    try {
                                        backgroundRealm.executeTransaction { realm1 ->
                                            realm1.delete(RealmCommunity::class.java)
                                            for (j in arr) {
                                                var jsonDoc = j.asJsonObject
                                                jsonDoc = JsonUtils.getJsonObject("doc", jsonDoc)
                                                val id = JsonUtils.getString("_id", jsonDoc)
                                                val community = realm1.createObject(RealmCommunity::class.java, id)
                                                if (JsonUtils.getString("name", jsonDoc) == "learning") {
                                                    community.weight = 0
                                                }
                                                community.localDomain = JsonUtils.getString("localDomain", jsonDoc)
                                                community.name = JsonUtils.getString("name", jsonDoc)
                                                community.parentDomain = JsonUtils.getString("parentDomain", jsonDoc)
                                                community.registrationRequest = JsonUtils.getString("registrationRequest", jsonDoc)
                                            }
                                        }
                                    } catch (e: Exception) {
                                        e.printStackTrace()
                                    }
                                }
                            }
                        } finally {
                            executor.shutdown()
                        }
                    }
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    callback.onSuccess(context.getString(R.string.server_sync_has_failed))
                }
            })
    }

    fun getMinApk(listener: ConfigurationIdListener?, url: String, pin: String, activity: SyncActivity, callerActivity: String) {
        configurationManager.getMinApk(listener, url, pin, activity, callerActivity)
    }

    private fun shouldPromptForSettings(settings: SharedPreferences): Boolean {
        if (!settings.getBoolean("isAlternativeUrl", false)) {
            if (settings.getString("couchdbURL", "").isNullOrEmpty()) {
                (context as? SyncActivity)?.settingDialog()
                return true
            }
        }
        return false
    }

    private suspend fun fetchVersionInfo(settings: SharedPreferences): MyPlanet? =
        withContext(Dispatchers.IO) {
            val result = ApiClient.executeWithResult {
                retrofitInterface.checkVersion(UrlUtils.getUpdateUrl(settings))
            }
            when (result) {
                is NetworkResult.Success -> result.data
                else -> null
            }
        }

    private suspend fun fetchApkVersionString(settings: SharedPreferences): String? =
        withContext(Dispatchers.IO) {
            val result = ApiClient.executeWithResult {
                retrofitInterface.getApkVersion(UrlUtils.getApkVersionUrl(settings))
            }
            when (result) {
                is NetworkResult.Success -> result.data.string()
                else -> null
            }
        }

    private fun parseApkVersionString(raw: String?): Int? {
        if (raw.isNullOrEmpty()) return null
        var vsn = raw.replace("v".toRegex(), "")
        vsn = vsn.replace("\\.".toRegex(), "")
        val cleaned = if (vsn.startsWith("0")) vsn.replaceFirst("0", "") else vsn
        return cleaned.toIntOrNull()
    }

    private fun handleVersionEvaluation(info: MyPlanet, apkVersion: Int, callback: CheckVersionCallback) {
        val currentVersion = VersionUtils.getVersionCode(context)
        if (showBetaFeature(KEY_UPGRADE_MAX, context) && info.latestapkcode > currentVersion) {
            serviceScope.launch {
                withContext(Dispatchers.Main) {
                    callback.onUpdateAvailable(info, false)
                }
            }
            return
        }
        if (apkVersion > currentVersion) {
            serviceScope.launch {
                withContext(Dispatchers.Main) {
                    callback.onUpdateAvailable(info, currentVersion >= info.minapkcode)
                }
            }
            return
        }
        if (currentVersion < info.minapkcode && apkVersion < info.minapkcode) {
            serviceScope.launch {
                withContext(Dispatchers.Main) {
                    callback.onUpdateAvailable(info, true)
                }
            }
        } else {
            serviceScope.launch {
                withContext(Dispatchers.Main) {
                    callback.onError(context.getString(R.string.planet_is_up_to_date), false)
                }
            }
        }
    }

    interface CheckVersionCallback {
        fun onUpdateAvailable(info: MyPlanet?, cancelable: Boolean)
        fun onCheckingVersion()
        fun onError(msg: String, blockSync: Boolean)
    }

    interface CreateUserCallback {
        fun onSuccess(message: String)
    }

    interface ChecksumCallback {
        fun onMatch()
        fun onFail()
    }

    interface PlanetAvailableListener {
        fun isAvailable()
        fun notAvailable()
    }

    interface ConfigurationIdListener {
        fun onConfigurationIdReceived(id: String, code: String, url: String, defaultUrl: String, isAlternativeUrl: Boolean, callerActivity: String)
    }
}
=======
package org.ole.planet.myplanet.datamanager


import android.content.Context
import android.content.SharedPreferences
import android.text.TextUtils
import androidx.core.content.edit
import androidx.core.net.toUri
import com.google.gson.Gson
import com.google.gson.JsonObject
import dagger.hilt.android.EntryPointAccessors
import io.realm.Realm
import java.io.IOException
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.Executors
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.ResponseBody
import org.ole.planet.myplanet.MainApplication
import org.ole.planet.myplanet.MainApplication.Companion.isServerReachable
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.SecurityDataCallback
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.di.ApiInterfaceEntryPoint
import org.ole.planet.myplanet.di.ApplicationScope
import org.ole.planet.myplanet.di.ApplicationScopeEntryPoint
import org.ole.planet.myplanet.di.AutoSyncEntryPoint
import org.ole.planet.myplanet.model.MyPlanet
import org.ole.planet.myplanet.model.RealmCommunity
import org.ole.planet.myplanet.model.RealmUserModel.Companion.isUserExists
import org.ole.planet.myplanet.model.RealmUserModel.Companion.populateUsersTable
import org.ole.planet.myplanet.service.UploadToShelfService
import org.ole.planet.myplanet.ui.sync.ProcessUserDataActivity
import org.ole.planet.myplanet.ui.sync.SyncActivity
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateIv
import org.ole.planet.myplanet.utilities.AndroidDecrypter.Companion.generateKey
import org.ole.planet.myplanet.utilities.Constants.KEY_UPGRADE_MAX
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.Constants.showBetaFeature
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.NetworkUtils
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.Sha256Utils
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities
import org.ole.planet.myplanet.utilities.VersionUtils
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

class Service @Inject constructor(
    private val context: Context,
    private val retrofitInterface: ApiInterface,
    @ApplicationScope private val serviceScope: CoroutineScope,
) {
    constructor(context: Context) : this(
        context,
        EntryPointAccessors.fromApplication(
            context.applicationContext,
            ApiInterfaceEntryPoint::class.java
        ).apiInterface(),
        EntryPointAccessors.fromApplication(
            context.applicationContext,
            ApplicationScopeEntryPoint::class.java
        ).applicationScope(),
    )

    private val preferences: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    private val serverAvailabilityCache = ConcurrentHashMap<String, Pair<Boolean, Long>>()
    private val configurationManager =
        ConfigurationManager(context, preferences, retrofitInterface)
    private fun getUploadToShelfService(): UploadToShelfService {
        val entryPoint = EntryPointAccessors.fromApplication(
            context.applicationContext,
            AutoSyncEntryPoint::class.java
        )
        return entryPoint.uploadToShelfService()
    }

    fun healthAccess(listener: SuccessListener) {
        try {
            val healthUrl = UrlUtils.getHealthAccessUrl(preferences)
            if (healthUrl.isBlank()) {
                listener.onSuccess("")
                return
            }

            retrofitInterface.healthAccess(healthUrl).enqueue(object : Callback<ResponseBody> {
                override fun onResponse(call: Call<ResponseBody>, response: Response<ResponseBody>) {
                    try {
                        when (response.code()) {
                            200 -> listener.onSuccess(context.getString(R.string.server_sync_successfully))
                            401 -> listener.onSuccess("Unauthorized - Invalid credentials")
                            404 -> listener.onSuccess("Server endpoint not found")
                            500 -> listener.onSuccess("Server internal error")
                            502 -> listener.onSuccess("Bad gateway - Server unavailable")
                            503 -> listener.onSuccess("Service temporarily unavailable")
                            504 -> listener.onSuccess("Gateway timeout")
                            else -> listener.onSuccess("Server error: ${response.code()}")
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                        listener.onSuccess("")
                    }
                }

                override fun onFailure(call: Call<ResponseBody>, t: Throwable) {
                    try {
                        t.printStackTrace()
                        val errorMsg = when (t) {
                            is java.net.UnknownHostException -> "Server not reachable"
                            is java.net.SocketTimeoutException -> "Connection timeout"
                            is java.net.ConnectException -> "Unable to connect to server"
                            is java.io.IOException -> "Network connection error"
                            else -> "Network error: ${t.localizedMessage ?: "Unknown error"}"
                        }
                        listener.onSuccess(errorMsg)
                    } catch (e: Exception) {
                        e.printStackTrace()
                        listener.onSuccess("Health check failed")
                    }
                }
            })
        } catch (e: Exception) {
            e.printStackTrace()
            listener.onSuccess("Health access initialization failed")
        }
    }

    fun checkCheckSum(callback: ChecksumCallback, path: String?) {
        retrofitInterface.getChecksum(UrlUtils.getChecksumUrl(preferences)).enqueue(object : Callback<ResponseBody> {
            override fun onResponse(call: Call<ResponseBody>, response: Response<ResponseBody>) {
                if (response.code() == 200) {
                    try {
                        val checksum = response.body()?.string()
                        if (TextUtils.isEmpty(checksum)) {
                            val f = FileUtils.getSDPathFromUrl(context, path)
                            if (f.exists()) {
                                val sha256 = Sha256Utils().getCheckSumFromFile(f)
                                if (checksum?.contains(sha256) == true) {
                                    callback.onMatch()
                                    return
                                }
                            }
                        }
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
                }
                callback.onFail()
            }

            override fun onFailure(call: Call<ResponseBody>, t: Throwable) {
                callback.onFail()
            }
        })
    }

    fun checkVersion(callback: CheckVersionCallback, settings: SharedPreferences) {
        if (shouldPromptForSettings(settings)) return

        serviceScope.launch {
            withContext(Dispatchers.Main) {
                callback.onCheckingVersion()
            }
            try {
                val planetInfo = fetchVersionInfo(settings)
                if (planetInfo == null) {
                    withContext(Dispatchers.Main) {
                        callback.onError(context.getString(R.string.version_not_found), true)
                    }
                    return@launch
                }

                preferences.edit {
                    putLong("last_version_check_timestamp", System.currentTimeMillis())
                    putInt("LastWifiID", NetworkUtils.getCurrentNetworkId(context))
                    putString("versionDetail", Gson().toJson(planetInfo))
                }

                val rawApkVersion = fetchApkVersionString(settings)
                val versionStr = Gson().fromJson(rawApkVersion, String::class.java)
                if (versionStr.isNullOrEmpty()) {
                    withContext(Dispatchers.Main) {
                        callback.onError(context.getString(R.string.planet_is_up_to_date), false)
                    }
                    return@launch
                }

                val apkVersion = parseApkVersionString(versionStr)
                    ?: run {
                        withContext(Dispatchers.Main) {
                            callback.onError(
                                context.getString(R.string.new_apk_version_required_but_not_found_on_server),
                                false
                            )
                        }
                        return@launch
                    }

                handleVersionEvaluation(planetInfo, apkVersion, callback)
            } catch (e: Exception) {
                e.printStackTrace()
                withContext(Dispatchers.Main) {
                    callback.onError(context.getString(R.string.connection_failed), true)
                }
            }
        }
    }

    fun isPlanetAvailable(callback: PlanetAvailableListener?) {
        val updateUrl = "${preferences.getString("serverURL", "")}"
        serverAvailabilityCache[updateUrl]?.let { (available, timestamp) ->
            if (System.currentTimeMillis() - timestamp < 30000) {
                if (available) {
                    callback?.isAvailable()
                } else {
                    callback?.notAvailable()
                }
                return
            }
        }

        val serverUrlMapper = ServerUrlMapper()
        val mapping = serverUrlMapper.processUrl(updateUrl)

        serviceScope.launch {
            withContext(Dispatchers.IO) {
                val primaryReachable = isServerReachable(mapping.primaryUrl)
                val alternativeReachable = mapping.alternativeUrl?.let { isServerReachable(it) } == true

                if (!primaryReachable && alternativeReachable) {
                    mapping.alternativeUrl?.let { alternativeUrl ->
                        val uri = updateUrl.toUri()
                        val editor = preferences.edit()

                        serverUrlMapper.updateUrlPreferences(
                            editor,
                            uri,
                            alternativeUrl,
                            mapping.primaryUrl,
                            preferences
                        )
                    }
                }
            }

            retrofitInterface.isPlanetAvailable(UrlUtils.getUpdateUrl(preferences)).enqueue(object : Callback<ResponseBody?> {
                override fun onResponse(call: Call<ResponseBody?>, response: Response<ResponseBody?>) {
                    val isAvailable = callback != null && response.code() == 200
                    serverAvailabilityCache[updateUrl] = Pair(isAvailable, System.currentTimeMillis())
                    serviceScope.launch {
                        withContext(Dispatchers.Main) {
                            if (isAvailable) {
                                callback.isAvailable()
                            } else {
                                callback?.notAvailable()
                            }
                        }
                    }
                }

                override fun onFailure(call: Call<ResponseBody?>, t: Throwable) {
                    serverAvailabilityCache[updateUrl] = Pair(false, System.currentTimeMillis())
                    serviceScope.launch {
                        withContext(Dispatchers.Main) {
                            callback?.notAvailable()
                        }
                    }
                }
            })
        }
    }

    fun becomeMember(realm: Realm, obj: JsonObject, callback: CreateUserCallback, securityCallback: SecurityDataCallback? = null) {
        isPlanetAvailable(object : PlanetAvailableListener {
            override fun isAvailable() {
                retrofitInterface.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/_users/org.couchdb.user:${obj["name"].asString}").enqueue(object : Callback<JsonObject> {
                     override fun onResponse(call: Call<JsonObject>, response: Response<JsonObject>) {
                         if (response.body() != null && response.body()?.has("_id") == true) {
                             callback.onSuccess(context.getString(R.string.unable_to_create_user_user_already_exists))
                         } else {
                             retrofitInterface.putDoc(null, "application/json", "${UrlUtils.getUrl()}/_users/org.couchdb.user:${obj["name"].asString}", obj).enqueue(object : Callback<JsonObject> {
                                 override fun onResponse(call: Call<JsonObject>, response: Response<JsonObject>) {
                                     if (response.body() != null && response.body()?.has("id") == true) {
                                         uploadToShelf(obj)
                                         saveUserToDb(realm, "${response.body()?.get("id")?.asString}", obj, callback, securityCallback)
                                     } else {
                                         callback.onSuccess(context.getString(R.string.unable_to_create_user_user_already_exists))
                                     }
                                 }

                                 override fun onFailure(call: Call<JsonObject>, t: Throwable) {
                                     callback.onSuccess(context.getString(R.string.unable_to_create_user_user_already_exists))
                                 }
                             })
                         }
                     }

                    override fun onFailure(call: Call<JsonObject>, t: Throwable) {
                        callback.onSuccess(context.getString(R.string.unable_to_create_user_user_already_exists))
                    }
                })
            }

            override fun notAvailable() {
                val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
                if (isUserExists(realm, obj["name"].asString)) {
                    callback.onSuccess(context.getString(R.string.unable_to_create_user_user_already_exists))
                    return
                }
                realm.beginTransaction()
                val model = populateUsersTable(obj, realm, settings)
                val keyString = generateKey()
                val iv = generateIv()
                if (model != null) {
                    model.key = keyString
                    model.iv = iv
                }
                realm.commitTransaction()
                Utilities.toast(MainApplication.context, context.getString(R.string.not_connect_to_planet_created_user_offline))
                callback.onSuccess(context.getString(R.string.not_connect_to_planet_created_user_offline))
                securityCallback?.onSecurityDataUpdated()
            }
        })
    }

    private fun uploadToShelf(obj: JsonObject) {
        retrofitInterface.putDoc(null, "application/json", UrlUtils.getUrl() + "/shelf/org.couchdb.user:" + obj["name"].asString, JsonObject()).enqueue(object : Callback<JsonObject?> {
            override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {}
            override fun onFailure(call: Call<JsonObject?>, t: Throwable) {}
        })
    }

    private fun saveUserToDb(realm: Realm, id: String, obj: JsonObject, callback: CreateUserCallback, securityCallback: SecurityDataCallback? = null) {
        val settings = MainApplication.context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        realm.executeTransactionAsync({ realm1: Realm? ->
            try {
                val res = retrofitInterface.getJsonObject(UrlUtils.header, "${UrlUtils.getUrl()}/_users/$id").execute()
                if (res.body() != null) {
                    val model = populateUsersTable(res.body(), realm1, settings)
                    if (model != null) {
                        getUploadToShelfService().saveKeyIv(retrofitInterface, model, obj)
                    }
                }
            } catch (e: IOException) {
                e.printStackTrace()
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }, {
            callback.onSuccess(context.getString(R.string.user_created_successfully))
            if (context is ProcessUserDataActivity) {
                context.runOnUiThread {
                    val userName = "${obj["name"].asString}"
                    context.startUpload("becomeMember", userName, securityCallback)
                }
            }
        }) { error: Throwable ->
            error.printStackTrace()
            callback.onSuccess(context.getString(R.string.unable_to_save_user_please_sync))
            securityCallback?.onSecurityDataUpdated()
        }
    }

    fun syncPlanetServers(callback: SuccessListener) {
        retrofitInterface.getJsonObject("", "https://planet.earth.ole.org/db/communityregistrationrequests/_all_docs?include_docs=true")
            .enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    if (response.body() != null) {
                        val arr = JsonUtils.getJsonArray("rows", response.body())

                        val executor = Executors.newSingleThreadExecutor()
                        try {
                            executor.execute {
                                MainApplication.service.withRealm { backgroundRealm ->
                                    try {
                                        backgroundRealm.executeTransaction { realm1 ->
                                            realm1.delete(RealmCommunity::class.java)
                                            for (j in arr) {
                                                var jsonDoc = j.asJsonObject
                                                jsonDoc = JsonUtils.getJsonObject("doc", jsonDoc)
                                                val id = JsonUtils.getString("_id", jsonDoc)
                                                val community = realm1.createObject(RealmCommunity::class.java, id)
                                                if (JsonUtils.getString("name", jsonDoc) == "learning") {
                                                    community.weight = 0
                                                }
                                                community.localDomain = JsonUtils.getString("localDomain", jsonDoc)
                                                community.name = JsonUtils.getString("name", jsonDoc)
                                                community.parentDomain = JsonUtils.getString("parentDomain", jsonDoc)
                                                community.registrationRequest = JsonUtils.getString("registrationRequest", jsonDoc)
                                            }
                                        }
                                    } catch (e: Exception) {
                                        e.printStackTrace()
                                    }
                                }
                            }
                        } finally {
                            executor.shutdown()
                        }
                    }
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    callback.onSuccess(context.getString(R.string.server_sync_has_failed))
                }
            })
    }

    fun getMinApk(listener: ConfigurationIdListener?, url: String, pin: String, activity: SyncActivity, callerActivity: String) {
        configurationManager.getMinApk(listener, url, pin, activity, callerActivity)
    }

    private fun shouldPromptForSettings(settings: SharedPreferences): Boolean {
        if (!settings.getBoolean("isAlternativeUrl", false)) {
            if (settings.getString("couchdbURL", "").isNullOrEmpty()) {
                (context as? SyncActivity)?.settingDialog()
                return true
            }
        }
        return false
    }

    private suspend fun fetchVersionInfo(settings: SharedPreferences): MyPlanet? =
        withContext(Dispatchers.IO) {
            val result = ApiClient.executeWithResult {
                retrofitInterface.checkVersion(UrlUtils.getUpdateUrl(settings))
            }
            when (result) {
                is NetworkResult.Success -> result.data
                else -> null
            }
        }

    private suspend fun fetchApkVersionString(settings: SharedPreferences): String? =
        withContext(Dispatchers.IO) {
            val result = ApiClient.executeWithResult {
                retrofitInterface.getApkVersion(UrlUtils.getApkVersionUrl(settings))
            }
            when (result) {
                is NetworkResult.Success -> result.data.string()
                else -> null
            }
        }

    private fun parseApkVersionString(raw: String?): Int? {
        if (raw.isNullOrEmpty()) return null
        var vsn = raw.replace("v".toRegex(), "")
        vsn = vsn.replace("\\.".toRegex(), "")
        val cleaned = if (vsn.startsWith("0")) vsn.replaceFirst("0", "") else vsn
        return cleaned.toIntOrNull()
    }

    private fun handleVersionEvaluation(info: MyPlanet, apkVersion: Int, callback: CheckVersionCallback) {
        val currentVersion = VersionUtils.getVersionCode(context)
        if (showBetaFeature(KEY_UPGRADE_MAX, context) && info.latestapkcode > currentVersion) {
            serviceScope.launch {
                withContext(Dispatchers.Main) {
                    callback.onUpdateAvailable(info, false)
                }
            }
            return
        }
        if (apkVersion > currentVersion) {
            serviceScope.launch {
                withContext(Dispatchers.Main) {
                    callback.onUpdateAvailable(info, currentVersion >= info.minapkcode)
                }
            }
            return
        }
        if (currentVersion < info.minapkcode && apkVersion < info.minapkcode) {
            serviceScope.launch {
                withContext(Dispatchers.Main) {
                    callback.onUpdateAvailable(info, true)
                }
            }
        } else {
            serviceScope.launch {
                withContext(Dispatchers.Main) {
                    callback.onError(context.getString(R.string.planet_is_up_to_date), false)
                }
            }
        }
    }

    interface CheckVersionCallback {
        fun onUpdateAvailable(info: MyPlanet?, cancelable: Boolean)
        fun onCheckingVersion()
        fun onError(msg: String, blockSync: Boolean)
    }

    interface CreateUserCallback {
        fun onSuccess(message: String)
    }

    interface ChecksumCallback {
        fun onMatch()
        fun onFail()
    }

    interface PlanetAvailableListener {
        fun isAvailable()
        fun notAvailable()
    }

    interface ConfigurationIdListener {
        fun onConfigurationIdReceived(id: String, code: String, url: String, defaultUrl: String, isAlternativeUrl: Boolean, callerActivity: String)
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/datamanager/ApiInterface.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.datamanager

import com.google.gson.JsonObject
import okhttp3.RequestBody
import okhttp3.ResponseBody
import org.ole.planet.myplanet.model.ChatModel
import org.ole.planet.myplanet.model.DocumentResponse
import org.ole.planet.myplanet.model.MyPlanet
import retrofit2.Call
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.GET
import retrofit2.http.Header
import retrofit2.http.HeaderMap
import retrofit2.http.POST
import retrofit2.http.PUT
import retrofit2.http.Streaming
import retrofit2.http.Url

interface ApiInterface {
    @Streaming
    @GET
    suspend fun downloadFile(@Header("Authorization") header: String?, @Url fileUrl: String?): Response<ResponseBody>

    @GET
    fun getDocuments(@Header("Authorization") header: String?, @Url url: String?): Call<DocumentResponse>

    @GET
    fun getJsonObject(@Header("Authorization") header: String?, @Url url: String?): Call<JsonObject>

    @POST
    fun findDocs(@Header("Authorization") header: String?, @Header("Content-Type") c: String?, @Url url: String?, @Body s: JsonObject?): Call<JsonObject>

    @POST
    fun postDoc(@Header("Authorization") header: String?, @Header("Content-Type") c: String?, @Url url: String?, @Body s: JsonObject?): Call<JsonObject>

    @PUT
    fun uploadResource(@HeaderMap headerMap: Map<String, String>, @Url url: String?, @Body body: RequestBody?): Call<JsonObject>

    @PUT
    fun putDoc(@Header("Authorization") header: String?, @Header("Content-Type") c: String?, @Url url: String?, @Body s: JsonObject?): Call<JsonObject>

    @GET
    suspend fun checkVersion(@Url serverUrl: String?): Response<MyPlanet>

    @GET
    suspend fun getApkVersion(@Url url: String?): Response<ResponseBody>

    @GET
    fun healthAccess(@Url url: String?): Call<ResponseBody>

    @GET
    fun getChecksum(@Url url: String?): Call<ResponseBody>

    @GET
    fun isPlanetAvailable(@Url serverUrl: String?): Call<ResponseBody>

    @POST
    fun chatGpt(@Url url: String?, @Body requestBody: RequestBody?): Call<ChatModel>

    @GET
    fun checkAiProviders(@Url url: String?): Call<ResponseBody>

    @GET
    fun getConfiguration(@Url url: String?): Call<JsonObject>
}
=======
package org.ole.planet.myplanet.datamanager


import com.google.gson.JsonObject
import okhttp3.RequestBody
import okhttp3.ResponseBody
import org.ole.planet.myplanet.model.ChatModel
import org.ole.planet.myplanet.model.DocumentResponse
import org.ole.planet.myplanet.model.MyPlanet
import retrofit2.Call
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.GET
import retrofit2.http.Header
import retrofit2.http.HeaderMap
import retrofit2.http.POST
import retrofit2.http.PUT
import retrofit2.http.Streaming
import retrofit2.http.Url

interface ApiInterface {
    @Streaming
    @GET
    suspend fun downloadFile(@Header("Authorization") header: String?, @Url fileUrl: String?): Response<ResponseBody>

    @GET
    fun getDocuments(@Header("Authorization") header: String?, @Url url: String?): Call<DocumentResponse>

    @GET
    fun getJsonObject(@Header("Authorization") header: String?, @Url url: String?): Call<JsonObject>

    @POST
    fun findDocs(@Header("Authorization") header: String?, @Header("Content-Type") c: String?, @Url url: String?, @Body s: JsonObject?): Call<JsonObject>

    @POST
    fun postDoc(@Header("Authorization") header: String?, @Header("Content-Type") c: String?, @Url url: String?, @Body s: JsonObject?): Call<JsonObject>

    @PUT
    fun uploadResource(@HeaderMap headerMap: Map<String, String>, @Url url: String?, @Body body: RequestBody?): Call<JsonObject>

    @PUT
    fun putDoc(@Header("Authorization") header: String?, @Header("Content-Type") c: String?, @Url url: String?, @Body s: JsonObject?): Call<JsonObject>

    @GET
    suspend fun checkVersion(@Url serverUrl: String?): Response<MyPlanet>

    @GET
    suspend fun getApkVersion(@Url url: String?): Response<ResponseBody>

    @GET
    fun healthAccess(@Url url: String?): Call<ResponseBody>

    @GET
    fun getChecksum(@Url url: String?): Call<ResponseBody>

    @GET
    fun isPlanetAvailable(@Url serverUrl: String?): Call<ResponseBody>

    @POST
    fun chatGpt(@Url url: String?, @Body requestBody: RequestBody?): Call<ChatModel>

    @GET
    fun checkAiProviders(@Url url: String?): Call<ResponseBody>

    @GET
    fun getConfiguration(@Url url: String?): Call<JsonObject>
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/datamanager/auth/AuthSessionUpdater.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.datamanager.auth

import android.content.SharedPreferences
import dagger.assisted.Assisted
import dagger.assisted.AssistedFactory
import dagger.assisted.AssistedInject
import java.io.DataOutputStream
import java.net.HttpURLConnection
import java.net.URL
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONObject
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.di.ApplicationScope
import org.ole.planet.myplanet.utilities.UrlUtils

class AuthSessionUpdater @AssistedInject constructor(
    @Assisted private val callback: AuthCallback,
    @AppPreferences private val settings: SharedPreferences,
    @ApplicationScope private val scope: CoroutineScope
) {

    interface AuthCallback {
        fun setAuthSession(responseHeader: Map<String, List<String>>)
        fun onError(s: String)
    }

    @AssistedFactory
    interface Factory {
        fun create(callback: AuthCallback): AuthSessionUpdater
    }

    private var job: Job? = null

    init {
        start()
    }

    fun start() {
        job?.cancel()
        job = scope.launch {
            while (isActive) {
                sendPost(settings)
                delay(15 * 60 * 1000L)
            }
        }
    }

    fun stop() {
        job?.cancel()
    }

    // sendPost() - Meant to get New AuthSession Token for viewing Online resources such as Video, and basically any file.
    // It creates a session of about 20 mins after which a new AuthSession Token will be needed.
    // During these 20 mins items.getResourceRemoteAddress() will work in obtaining the files necessary.
    private suspend fun sendPost(settings: SharedPreferences) {
        try {
            withContext(Dispatchers.IO) {
                val conn = getSessionUrl()?.openConnection() as HttpURLConnection
                conn.requestMethod = "GET"
                conn.setRequestProperty("Content-Type", "application/json")
                conn.setRequestProperty("Accept", "application/json")
                conn.doOutput = true
                conn.doInput = true

                val os = DataOutputStream(conn.outputStream)
                os.writeBytes(getJsonObject(settings).toString())

                os.flush()
                os.close()

                callback.setAuthSession(conn.headerFields)
                conn.disconnect()
            }
        } catch (e: Exception) {
            callback.onError(e.message.orEmpty())
            e.printStackTrace()
        }
    }

    private fun getJsonObject(settings: SharedPreferences): JSONObject? {
        return try {
            val jsonParam = JSONObject()
            jsonParam.put("name", settings.getString("url_user", ""))
            jsonParam.put("password", settings.getString("url_pwd", ""))
            jsonParam
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private fun getSessionUrl(): URL? {
        return try {
            val pref = UrlUtils.getUrl()
            val urlString = "$pref/_session"
            val serverUrl = URL(urlString)
            serverUrl
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }
}
=======
package org.ole.planet.myplanet.datamanager.auth


import android.content.SharedPreferences
import dagger.assisted.Assisted
import dagger.assisted.AssistedFactory
import dagger.assisted.AssistedInject
import java.io.DataOutputStream
import java.net.HttpURLConnection
import java.net.URL
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONObject
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.di.ApplicationScope
import org.ole.planet.myplanet.utilities.UrlUtils

class AuthSessionUpdater @AssistedInject constructor(
    @Assisted private val callback: AuthCallback,
    @AppPreferences private val settings: SharedPreferences,
    @ApplicationScope private val scope: CoroutineScope
) {

    interface AuthCallback {
        fun setAuthSession(responseHeader: Map<String, List<String>>)
        fun onError(s: String)
    }

    @AssistedFactory
    interface Factory {
        fun create(callback: AuthCallback): AuthSessionUpdater
    }

    private var job: Job? = null

    init {
        start()
    }

    fun start() {
        job?.cancel()
        job = scope.launch {
            while (isActive) {
                sendPost(settings)
                delay(15 * 60 * 1000L)
            }
        }
    }

    fun stop() {
        job?.cancel()
    }

    // sendPost() - Meant to get New AuthSession Token for viewing Online resources such as Video, and basically any file.
    // It creates a session of about 20 mins after which a new AuthSession Token will be needed.
    // During these 20 mins items.getResourceRemoteAddress() will work in obtaining the files necessary.
    private suspend fun sendPost(settings: SharedPreferences) {
        try {
            withContext(Dispatchers.IO) {
                val conn = getSessionUrl()?.openConnection() as HttpURLConnection
                conn.requestMethod = "GET"
                conn.setRequestProperty("Content-Type", "application/json")
                conn.setRequestProperty("Accept", "application/json")
                conn.doOutput = true
                conn.doInput = true

                val os = DataOutputStream(conn.outputStream)
                os.writeBytes(getJsonObject(settings).toString())

                os.flush()
                os.close()

                callback.setAuthSession(conn.headerFields)
                conn.disconnect()
            }
        } catch (e: Exception) {
            callback.onError(e.message.orEmpty())
            e.printStackTrace()
        }
    }

    private fun getJsonObject(settings: SharedPreferences): JSONObject? {
        return try {
            val jsonParam = JSONObject()
            jsonParam.put("name", settings.getString("url_user", ""))
            jsonParam.put("password", settings.getString("url_pwd", ""))
            jsonParam
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private fun getSessionUrl(): URL? {
        return try {
            val pref = UrlUtils.getUrl()
            val urlString = "$pref/_session"
            val serverUrl = URL(urlString)
            serverUrl
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/datamanager/FileUploadService.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.datamanager

import com.google.gson.JsonObject
import java.io.File
import java.io.IOException
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyPersonal
import org.ole.planet.myplanet.model.RealmSubmitPhotos
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.UrlUtils
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

open class FileUploadService {
    fun uploadAttachment(id: String, rev: String, personal: RealmMyPersonal, listener: SuccessListener) {
        val f = personal.path?.let { File(it) }
        val name = FileUtils.getFileNameFromUrl(personal.path)
        if (f != null) {
            uploadDoc(id, rev, "%s/resources/%s/%s", f, name, listener)
        }
    }

    fun uploadAttachment(id: String, rev: String, personal: RealmMyLibrary, listener: SuccessListener) {
        val f = personal.resourceLocalAddress?.let { File(it) }
        val name = FileUtils.getFileNameFromLocalAddress(personal.resourceLocalAddress)
        if (f != null) {
            uploadDoc(id, rev, "%s/resources/%s/%s", f, name, listener)
        }
    }

    fun uploadAttachment(id: String, rev: String, personal: RealmSubmitPhotos, listener: SuccessListener) {
        val f = personal.photoLocation?.let { File(it) }
        val name = FileUtils.getFileNameFromUrl(personal.photoLocation)
        if (f != null) {
            uploadDoc(id, rev, "%s/submissions/%s/%s", f, name, listener)
        }
    }

    private fun uploadDoc(id: String, rev: String, format: String, f: File, name: String, listener: SuccessListener) {
        val apiInterface = ApiClient.client?.create(ApiInterface::class.java)
        try {
            val connection = f.toURI().toURL().openConnection()
            val mimeType = connection.contentType
            val body = FileUtils.fullyReadFileToBytes(f)
                .toRequestBody("application/octet-stream".toMediaTypeOrNull())
            val url = String.format(format, UrlUtils.getUrl(), id, name)
            apiInterface?.uploadResource(getHeaderMap(mimeType, rev), url, body)?.enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    onDataReceived(response.body(), listener)
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    listener.onSuccess("Unable to upload resource")
                }
            })
        } catch (e: IOException) {
            e.printStackTrace()
            listener.onSuccess("Unable to upload resource")
        }
    }

    private fun onDataReceived(`object`: JsonObject?, listener: SuccessListener) {
        if (`object` != null) {
            if (JsonUtils.getBoolean("ok", `object`)) {
                listener.onSuccess("Uploaded successfully")
                return
            }
        }
        listener.onSuccess("Unable to upload resource")
    }

    companion object {
        @JvmStatic
        fun getHeaderMap(mimeType: String, rev: String): Map<String, String> {
            val hashMap: MutableMap<String, String> = HashMap()
            hashMap["Authorization"] = UrlUtils.header
            hashMap["Content-Type"] = mimeType
            hashMap["If-Match"] = rev
            return hashMap
        }
    }
}
=======
package org.ole.planet.myplanet.datamanager


import com.google.gson.JsonObject
import java.io.File
import java.io.IOException
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.ole.planet.myplanet.callback.SuccessListener
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyPersonal
import org.ole.planet.myplanet.model.RealmSubmitPhotos
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.JsonUtils
import org.ole.planet.myplanet.utilities.UrlUtils
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

open class FileUploadService {
    fun uploadAttachment(id: String, rev: String, personal: RealmMyPersonal, listener: SuccessListener) {
        val f = personal.path?.let { File(it) }
        val name = FileUtils.getFileNameFromUrl(personal.path)
        if (f != null) {
            uploadDoc(id, rev, "%s/resources/%s/%s", f, name, listener)
        }
    }

    fun uploadAttachment(id: String, rev: String, personal: RealmMyLibrary, listener: SuccessListener) {
        val f = personal.resourceLocalAddress?.let { File(it) }
        val name = FileUtils.getFileNameFromLocalAddress(personal.resourceLocalAddress)
        if (f != null) {
            uploadDoc(id, rev, "%s/resources/%s/%s", f, name, listener)
        }
    }

    fun uploadAttachment(id: String, rev: String, personal: RealmSubmitPhotos, listener: SuccessListener) {
        val f = personal.photoLocation?.let { File(it) }
        val name = FileUtils.getFileNameFromUrl(personal.photoLocation)
        if (f != null) {
            uploadDoc(id, rev, "%s/submissions/%s/%s", f, name, listener)
        }
    }

    private fun uploadDoc(id: String, rev: String, format: String, f: File, name: String, listener: SuccessListener) {
        val apiInterface = ApiClient.client?.create(ApiInterface::class.java)
        try {
            val connection = f.toURI().toURL().openConnection()
            val mimeType = connection.contentType
            val body = FileUtils.fullyReadFileToBytes(f)
                .toRequestBody("application/octet-stream".toMediaTypeOrNull())
            val url = String.format(format, UrlUtils.getUrl(), id, name)
            apiInterface?.uploadResource(getHeaderMap(mimeType, rev), url, body)?.enqueue(object : Callback<JsonObject?> {
                override fun onResponse(call: Call<JsonObject?>, response: Response<JsonObject?>) {
                    onDataReceived(response.body(), listener)
                }

                override fun onFailure(call: Call<JsonObject?>, t: Throwable) {
                    listener.onSuccess("Unable to upload resource")
                }
            })
        } catch (e: IOException) {
            e.printStackTrace()
            listener.onSuccess("Unable to upload resource")
        }
    }

    private fun onDataReceived(`object`: JsonObject?, listener: SuccessListener) {
        if (`object` != null) {
            if (JsonUtils.getBoolean("ok", `object`)) {
                listener.onSuccess("Uploaded successfully")
                return
            }
        }
        listener.onSuccess("Unable to upload resource")
    }

    companion object {
        @JvmStatic
        fun getHeaderMap(mimeType: String, rev: String): Map<String, String> {
            val hashMap: MutableMap<String, String> = HashMap()
            hashMap["Authorization"] = UrlUtils.header
            hashMap["Content-Type"] = mimeType
            hashMap["If-Match"] = rev
            return hashMap
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/datamanager/DatabaseService.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.datamanager

import android.content.Context
import io.realm.Realm
import io.realm.RealmConfiguration
import io.realm.RealmModel
import io.realm.RealmQuery
import io.realm.log.LogLevel
import io.realm.log.RealmLog
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.BuildConfig

class DatabaseService(context: Context) {
    init {
        Realm.init(context)
        val targetLogLevel = if (BuildConfig.DEBUG) LogLevel.DEBUG else LogLevel.ERROR
        if (RealmLog.getLevel() != targetLogLevel) {
            RealmLog.setLevel(targetLogLevel)
        }
        val config = RealmConfiguration.Builder()
            .name(Realm.DEFAULT_REALM_NAME)
            .deleteRealmIfMigrationNeeded()
            .schemaVersion(4)
            .build()
        Realm.setDefaultConfiguration(config)
    }

    @Deprecated("Use withRealm/withRealmAsync instead")
    val realmInstance: Realm
        get() = Realm.getDefaultInstance()

    private inline fun <T> withRealmInstance(block: (Realm) -> T): T {
        val realm = Realm.getDefaultInstance()
        return try {
            block(realm)
        } finally {
            if (!realm.isClosed) {
                realm.close()
            }
        }
    }

    fun <T> withRealm(operation: (Realm) -> T): T {
        return withRealmInstance(operation)
    }

    suspend fun <T> withRealmAsync(operation: (Realm) -> T): T {
        return withContext(Dispatchers.IO) {
            withRealmInstance(operation)
        }
    }

    suspend fun executeTransactionAsync(transaction: (Realm) -> Unit) {
        withContext(Dispatchers.IO) {
            Realm.getDefaultInstance().use { realm ->
                realm.executeTransaction { transactionRealm ->
                    transaction(transactionRealm)
                }
            }
        }
    }

}

fun <T : RealmModel> Realm.queryList(
    clazz: Class<T>,
    builder: RealmQuery<T>.() -> Unit = {}
): List<T> {
    return where(clazz).apply(builder).findAll().let { copyFromRealm(it) }
}

fun <T : RealmModel, V : Any> Realm.findCopyByField(
    clazz: Class<T>,
    fieldName: String,
    value: V,
): T? {
    return where(clazz)
        .applyEqualTo(fieldName, value)
        .findFirst()
        ?.let { copyFromRealm(it) }
}

fun <T : RealmModel> RealmQuery<T>.applyEqualTo(field: String, value: Any): RealmQuery<T> {
    return when (value) {
        is String -> equalTo(field, value)
        is Boolean -> equalTo(field, value)
        is Int -> equalTo(field, value)
        is Long -> equalTo(field, value)
        is Float -> equalTo(field, value)
        is Double -> equalTo(field, value)
        else -> throw IllegalArgumentException("Unsupported value type")
    }
}
=======
package org.ole.planet.myplanet.datamanager


import android.content.Context
import io.realm.Realm
import io.realm.RealmConfiguration
import io.realm.RealmModel
import io.realm.RealmQuery
import io.realm.log.LogLevel
import io.realm.log.RealmLog
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.BuildConfig

class DatabaseService(context: Context) {
    init {
        Realm.init(context)
        val targetLogLevel = if (BuildConfig.DEBUG) LogLevel.DEBUG else LogLevel.ERROR
        if (RealmLog.getLevel() != targetLogLevel) {
            RealmLog.setLevel(targetLogLevel)
        }
        val config = RealmConfiguration.Builder()
            .name(Realm.DEFAULT_REALM_NAME)
            .deleteRealmIfMigrationNeeded()
            .schemaVersion(4)
            .build()
        Realm.setDefaultConfiguration(config)
    }

    @Deprecated("Use withRealm/withRealmAsync instead")
    val realmInstance: Realm
        get() = Realm.getDefaultInstance()

    private inline fun <T> withRealmInstance(block: (Realm) -> T): T {
        val realm = Realm.getDefaultInstance()
        return try {
            block(realm)
        } finally {
            if (!realm.isClosed) {
                realm.close()
            }
        }
    }

    fun <T> withRealm(operation: (Realm) -> T): T {
        return withRealmInstance(operation)
    }

    suspend fun <T> withRealmAsync(operation: (Realm) -> T): T {
        return withContext(Dispatchers.IO) {
            withRealmInstance(operation)
        }
    }

    suspend fun executeTransactionAsync(transaction: (Realm) -> Unit) {
        withContext(Dispatchers.IO) {
            Realm.getDefaultInstance().use { realm ->
                realm.executeTransaction { transactionRealm ->
                    transaction(transactionRealm)
                }
            }
        }
    }

}

fun <T : RealmModel> Realm.queryList(
    clazz: Class<T>,
    builder: RealmQuery<T>.() -> Unit = {}
): List<T> {
    return where(clazz).apply(builder).findAll().let { copyFromRealm(it) }
}

fun <T : RealmModel, V : Any> Realm.findCopyByField(
    clazz: Class<T>,
    fieldName: String,
    value: V,
): T? {
    return where(clazz)
        .applyEqualTo(fieldName, value)
        .findFirst()
        ?.let { copyFromRealm(it) }
}

fun <T : RealmModel> RealmQuery<T>.applyEqualTo(field: String, value: Any): RealmQuery<T> {
    return when (value) {
        is String -> equalTo(field, value)
        is Boolean -> equalTo(field, value)
        is Int -> equalTo(field, value)
        is Long -> equalTo(field, value)
        is Float -> equalTo(field, value)
        is Double -> equalTo(field, value)
        else -> throw IllegalArgumentException("Unsupported value type")
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/base/BaseNewsFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.base

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.res.Configuration
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.activity.result.ActivityResult
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.RequiresApi
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.RealmList
import java.io.File
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.ImageThumbBinding
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.news.AdapterNews
import org.ole.planet.myplanet.ui.news.AdapterNews.OnNewsItemClickListener
import org.ole.planet.myplanet.ui.news.NewsActions
import org.ole.planet.myplanet.ui.news.ReplyActivity
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.FileUtils.getFileNameFromUrl
import org.ole.planet.myplanet.utilities.FileUtils.getRealPathFromURI

@RequiresApi(api = Build.VERSION_CODES.O)
abstract class BaseNewsFragment : BaseContainerFragment(), OnNewsItemClickListener {
    lateinit var imageList: RealmList<String>
    @JvmField
    protected var llImage: ViewGroup? = null
    @JvmField
    protected var adapterNews: AdapterNews? = null
    lateinit var openFolderLauncher: ActivityResultLauncher<Intent>
    private lateinit var replyActivityLauncher: ActivityResultLauncher<Intent>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        imageList = RealmList()
        openFolderLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result: ActivityResult ->
            if (result.resultCode == Activity.RESULT_OK) {
                val data = result.data
                val clipData = data?.clipData
                if (clipData != null) {
                    for (i in 0 until clipData.itemCount) {
                        val uri = clipData.getItemAt(i).uri
                        processImageUri(uri, result.resultCode)
                    }
                } else {
                    val uri = data?.data
                    processImageUri(uri, result.resultCode)
                }
            }
        }
        replyActivityLauncher = registerForActivityResult(
            ActivityResultContracts.StartActivityForResult()) { result: ActivityResult ->
            if (result.resultCode == Activity.RESULT_OK) {
                val newsId = result.data?.getStringExtra("newsId")
                newsId.let { adapterNews?.updateReplyBadge(it) }
                adapterNews?.refreshCurrentItems()
            }
        }
    }

    override fun onDataChanged() {
        adapterNews?.refreshCurrentItems()
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) homeItemClickListener = context
    }

    override fun showReply(news: RealmNews?, fromLogin: Boolean, nonTeamMember: Boolean) {
        if (news != null) {
            val intent = Intent(activity, ReplyActivity::class.java).putExtra("id", news.id)
                .putExtra("fromLogin", fromLogin)
                .putExtra("nonTeamMember", nonTeamMember)
            replyActivityLauncher.launch(intent)
        }
    }

    override fun onMemberSelected(userModel: RealmUserModel?) {
        if (!isAdded) return
        val handler = profileDbHandler
        val fragment = NewsActions.showMemberDetails(userModel, handler) ?: return
        NavigationHelper.replaceFragment(
            requireActivity().supportFragmentManager,
            R.id.fragment_container,
            fragment,
            addToBackStack = true
        )
    }

    abstract fun setData(list: List<RealmNews?>?)
    fun showNoData(v: View?, count: Int?, source: String) {
        count?.let { BaseRecyclerFragment.showNoData(v, it, source) }
    }


    fun changeLayoutManager(orientation: Int, recyclerView: RecyclerView) {
        activity?.let { act ->
            if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
                recyclerView.layoutManager = GridLayoutManager(act, 2)
            } else {
                recyclerView.layoutManager = LinearLayoutManager(act)
            }
        }
    }

    override fun addImage(llImage: ViewGroup?) {
        this.llImage = llImage
        val openFolderIntent = FileUtils.openOleFolder(requireContext())
        openFolderLauncher.launch(openFolderIntent)
    }

    override fun getCurrentImageList(): RealmList<String>? {
        return if (::imageList.isInitialized) imageList else null
    }

    private fun processImageUri(uri: Uri?, resultCode: Int) {
        if (uri == null) return

        var path: String? = getRealPathFromURI(requireActivity(), uri)
        if (TextUtils.isEmpty(path)) {
            path = FileUtils.getPathFromURI(requireActivity(), uri)
        }

        if (path.isNullOrEmpty()) return

        val `object` = JsonObject()
        `object`.addProperty("imageUrl", path)
        `object`.addProperty("fileName", getFileNameFromUrl(path))
        imageList.add(Gson().toJson(`object`))

        try {
            llImage?.visibility = View.VISIBLE
            val imageBinding = ImageThumbBinding.inflate(LayoutInflater.from(activity), llImage, false)
            Glide.with(requireActivity())
                .load(File(path))
                .into(imageBinding.thumb)
            llImage?.addView(imageBinding.root)
            if (resultCode == 102) adapterNews?.setImageList(imageList)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}
=======
package org.ole.planet.myplanet.base


import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.res.Configuration
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.activity.result.ActivityResult
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.RequiresApi
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.google.gson.Gson
import com.google.gson.JsonObject
import io.realm.RealmList
import java.io.File
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.databinding.ImageThumbBinding
import org.ole.planet.myplanet.model.RealmNews
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.news.AdapterNews
import org.ole.planet.myplanet.ui.news.AdapterNews.OnNewsItemClickListener
import org.ole.planet.myplanet.ui.news.NewsActions
import org.ole.planet.myplanet.ui.news.ReplyActivity
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.FileUtils.getFileNameFromUrl
import org.ole.planet.myplanet.utilities.FileUtils.getRealPathFromURI

@RequiresApi(api = Build.VERSION_CODES.O)
abstract class BaseNewsFragment : BaseContainerFragment(), OnNewsItemClickListener {
    lateinit var imageList: RealmList<String>
    @JvmField
    protected var llImage: ViewGroup? = null
    @JvmField
    protected var adapterNews: AdapterNews? = null
    lateinit var openFolderLauncher: ActivityResultLauncher<Intent>
    private lateinit var replyActivityLauncher: ActivityResultLauncher<Intent>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        imageList = RealmList()
        openFolderLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result: ActivityResult ->
            if (result.resultCode == Activity.RESULT_OK) {
                val data = result.data
                val clipData = data?.clipData
                if (clipData != null) {
                    for (i in 0 until clipData.itemCount) {
                        val uri = clipData.getItemAt(i).uri
                        processImageUri(uri, result.resultCode)
                    }
                } else {
                    val uri = data?.data
                    processImageUri(uri, result.resultCode)
                }
            }
        }
        replyActivityLauncher = registerForActivityResult(
            ActivityResultContracts.StartActivityForResult()) { result: ActivityResult ->
            if (result.resultCode == Activity.RESULT_OK) {
                val newsId = result.data?.getStringExtra("newsId")
                newsId.let { adapterNews?.updateReplyBadge(it) }
                adapterNews?.refreshCurrentItems()
            }
        }
    }

    override fun onDataChanged() {
        adapterNews?.refreshCurrentItems()
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) homeItemClickListener = context
    }

    override fun showReply(news: RealmNews?, fromLogin: Boolean, nonTeamMember: Boolean) {
        if (news != null) {
            val intent = Intent(activity, ReplyActivity::class.java).putExtra("id", news.id)
                .putExtra("fromLogin", fromLogin)
                .putExtra("nonTeamMember", nonTeamMember)
            replyActivityLauncher.launch(intent)
        }
    }

    override fun onMemberSelected(userModel: RealmUserModel?) {
        if (!isAdded) return
        val handler = profileDbHandler
        val fragment = NewsActions.showMemberDetails(userModel, handler) ?: return
        NavigationHelper.replaceFragment(
            requireActivity().supportFragmentManager,
            R.id.fragment_container,
            fragment,
            addToBackStack = true
        )
    }

    abstract fun setData(list: List<RealmNews?>?)
    fun showNoData(v: View?, count: Int?, source: String) {
        count?.let { BaseRecyclerFragment.showNoData(v, it, source) }
    }


    fun changeLayoutManager(orientation: Int, recyclerView: RecyclerView) {
        activity?.let { act ->
            if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
                recyclerView.layoutManager = GridLayoutManager(act, 2)
            } else {
                recyclerView.layoutManager = LinearLayoutManager(act)
            }
        }
    }

    override fun addImage(llImage: ViewGroup?) {
        this.llImage = llImage
        val openFolderIntent = FileUtils.openOleFolder(requireContext())
        openFolderLauncher.launch(openFolderIntent)
    }

    override fun getCurrentImageList(): RealmList<String>? {
        return if (::imageList.isInitialized) imageList else null
    }

    private fun processImageUri(uri: Uri?, resultCode: Int) {
        if (uri == null) return

        var path: String? = getRealPathFromURI(requireActivity(), uri)
        if (TextUtils.isEmpty(path)) {
            path = FileUtils.getPathFromURI(requireActivity(), uri)
        }

        if (path.isNullOrEmpty()) return

        val `object` = JsonObject()
        `object`.addProperty("imageUrl", path)
        `object`.addProperty("fileName", getFileNameFromUrl(path))
        imageList.add(Gson().toJson(`object`))

        try {
            llImage?.visibility = View.VISIBLE
            val imageBinding = ImageThumbBinding.inflate(LayoutInflater.from(activity), llImage, false)
            Glide.with(requireActivity())
                .load(File(path))
                .into(imageBinding.thumb)
            llImage?.addView(imageBinding.root)
            if (resultCode == 102) adapterNews?.setImageList(imageList)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/base/BaseActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.base

import android.content.Context
import android.content.pm.PackageManager
import android.content.res.Configuration
import android.os.Bundle
import android.view.MenuItem
import java.util.Locale
import org.ole.planet.myplanet.ui.sync.SyncActivity
import org.ole.planet.myplanet.utilities.LocaleHelper

abstract class BaseActivity : SyncActivity() {
    override fun attachBaseContext(newBase: Context) {
        val localeUpdatedContext = LocaleHelper.onAttach(newBase)
        super.attachBaseContext(localeUpdatedContext)
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        resetTitle()
        updateConfigurationIfNeeded()
    }

    override fun onResume() {
        super.onResume()
        updateConfigurationIfNeeded()
    }

    private fun resetTitle() {
        try {
            val label = packageManager.getActivityInfo(componentName, PackageManager.GET_META_DATA).labelRes
            if (label != 0) {
                setTitle(label)
            }
        } catch (e: PackageManager.NameNotFoundException) {
            e.printStackTrace()
        }
    }

    private fun updateConfigurationIfNeeded() {
        val currentLanguage = LocaleHelper.getLanguage(this)
        val newConfig = resources.configuration
        val newLocale = Locale(currentLanguage)

        if (newConfig.locale != newLocale) {
            Locale.setDefault(newLocale)
            newConfig.setLocale(newLocale)
            newConfig.setLayoutDirection(newLocale)
            resources.updateConfiguration(newConfig, resources.displayMetrics)
            supportActionBar?.title = title
        }
    }

    override fun applyOverrideConfiguration(overrideConfiguration: Configuration?) {
        if (overrideConfiguration != null) {
            val uiMode = overrideConfiguration.uiMode
            overrideConfiguration.setTo(baseContext.resources.configuration)
            overrideConfiguration.uiMode = uiMode
        }
        super.applyOverrideConfiguration(overrideConfiguration)
    }

    fun initActionBar() {
        supportActionBar?.setHomeButtonEnabled(true)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return if (item.itemId == android.R.id.home) {
            finish()
            true
        } else {
            super.onOptionsItemSelected(item)
        }
    }
}
=======
package org.ole.planet.myplanet.base


import android.content.Context
import android.content.pm.PackageManager
import android.content.res.Configuration
import android.os.Bundle
import android.view.MenuItem
import java.util.Locale
import org.ole.planet.myplanet.ui.sync.SyncActivity
import org.ole.planet.myplanet.utilities.LocaleHelper

abstract class BaseActivity : SyncActivity() {
    override fun attachBaseContext(newBase: Context) {
        val localeUpdatedContext = LocaleHelper.onAttach(newBase)
        super.attachBaseContext(localeUpdatedContext)
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        resetTitle()
        updateConfigurationIfNeeded()
    }

    override fun onResume() {
        super.onResume()
        updateConfigurationIfNeeded()
    }

    private fun resetTitle() {
        try {
            val label = packageManager.getActivityInfo(componentName, PackageManager.GET_META_DATA).labelRes
            if (label != 0) {
                setTitle(label)
            }
        } catch (e: PackageManager.NameNotFoundException) {
            e.printStackTrace()
        }
    }

    private fun updateConfigurationIfNeeded() {
        val currentLanguage = LocaleHelper.getLanguage(this)
        val newConfig = resources.configuration
        val newLocale = Locale(currentLanguage)

        if (newConfig.locale != newLocale) {
            Locale.setDefault(newLocale)
            newConfig.setLocale(newLocale)
            newConfig.setLayoutDirection(newLocale)
            resources.updateConfiguration(newConfig, resources.displayMetrics)
            supportActionBar?.title = title
        }
    }

    override fun applyOverrideConfiguration(overrideConfiguration: Configuration?) {
        if (overrideConfiguration != null) {
            val uiMode = overrideConfiguration.uiMode
            overrideConfiguration.setTo(baseContext.resources.configuration)
            overrideConfiguration.uiMode = uiMode
        }
        super.applyOverrideConfiguration(overrideConfiguration)
    }

    fun initActionBar() {
        supportActionBar?.setHomeButtonEnabled(true)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return if (item.itemId == android.R.id.home) {
            finish()
            true
        } else {
            super.onOptionsItemSelected(item)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/base/BaseRecyclerParentFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.base

import com.google.gson.JsonArray
import io.realm.RealmModel
import io.realm.Sort
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmStepExam

abstract class BaseRecyclerParentFragment<LI> : BaseResourceFragment() {
    var isMyCourseLib: Boolean = false

    @Suppress("UNCHECKED_CAST")
    fun getList(c: Class<*>): List<LI> {
        return when {
            c == RealmStepExam::class.java -> {
                mRealm.where(c).equalTo("type", "surveys").findAll().toList() as List<LI>
            }
            isMyCourseLib -> {
                getMyLibItems(c as Class<out RealmModel>)
            }
            c == RealmMyLibrary::class.java -> {
                RealmMyLibrary.getOurLibrary(model?.id, mRealm.where(c).equalTo("isPrivate", false).findAll().toList()) as List<LI>
            }
            else -> {
                val myLibItems = getMyLibItems(c as Class<out RealmModel>)
                val results: List<RealmMyCourse> = mRealm.where(RealmMyCourse::class.java)
                    .isNotEmpty("courseTitle")
                    .findAll()
                    .toList()
                val ourCourseItems = RealmMyCourse.getOurCourse(model?.id, results)

                when (c) {
                    RealmMyCourse::class.java -> {
                        val combinedList = mutableListOf<RealmMyCourse>()
                        (myLibItems as List<RealmMyCourse>).forEach { course ->
                            course.isMyCourse = true
                            combinedList.add(course)
                        }
                        ourCourseItems.forEach { course ->
                            if (!combinedList.any { it.id == course.id }) {
                                course.isMyCourse = false
                                combinedList.add(course)
                            }
                        }
                        combinedList as List<LI>
                    }
                    else -> {
                        throw IllegalArgumentException("Unsupported class: ${c.simpleName}")
                    }
                }
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    fun getList(c: Class<*>, orderBy: String? = null, sort: Sort = Sort.ASCENDING): List<LI> {
        return when {
            c == RealmStepExam::class.java -> {
                mRealm.where(c).equalTo("type", "surveys").sort(orderBy ?: "", sort).findAll().toList() as List<LI>
            }
            isMyCourseLib -> {
                getMyLibItems(c as Class<out RealmModel>, orderBy)
            }
            c == RealmMyLibrary::class.java -> {
                RealmMyLibrary.getOurLibrary(model?.id, mRealm.where(c).equalTo("isPrivate", false).sort(orderBy ?: "", sort).findAll().toList()) as List<LI>
            }
            else -> {
                val results = mRealm.where(RealmMyCourse::class.java).sort(orderBy ?: "", sort).findAll().toList() as List<RealmMyCourse>
                RealmMyCourse.getOurCourse(model?.id, results) as List<LI>
            }
        }
    }
    @Suppress("UNCHECKED_CAST")
    private fun <T : RealmModel> getMyLibItems(c: Class<T>, orderBy: String? = null): List<LI> {
        val query = mRealm.where(c)
        val realmResults = if (orderBy != null) {
            query.sort(orderBy).findAll()
        } else {
            query.findAll()
        }
        val results: List<T> = realmResults.toList()
        return when (c) {
            RealmMyLibrary::class.java -> {
                RealmMyLibrary.getMyLibraryByUserId(model?.id, results as? List<RealmMyLibrary> ?: emptyList()) as List<LI>
            }
            RealmMyCourse::class.java -> {
                RealmMyCourse.getMyCourseByUserId(model?.id, results as? List<RealmMyCourse> ?: emptyList()) as List<LI>
            }
            else -> throw IllegalArgumentException("Unsupported class: ${c.simpleName}")
        }
    }

    fun getJsonArrayFromList(list: Set<String>): JsonArray {
        val array = JsonArray()
        list.forEach { array.add(it) }
        return array
    }

    companion object {
        var isSurvey: Boolean = false
    }
}
=======
package org.ole.planet.myplanet.base


import com.google.gson.JsonArray
import io.realm.RealmModel
import io.realm.Sort
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmStepExam

abstract class BaseRecyclerParentFragment<LI> : BaseResourceFragment() {
    var isMyCourseLib: Boolean = false

    @Suppress("UNCHECKED_CAST")
    fun getList(c: Class<*>): List<LI> {
        return when {
            c == RealmStepExam::class.java -> {
                mRealm.where(c).equalTo("type", "surveys").findAll().toList() as List<LI>
            }
            isMyCourseLib -> {
                getMyLibItems(c as Class<out RealmModel>)
            }
            c == RealmMyLibrary::class.java -> {
                RealmMyLibrary.getOurLibrary(model?.id, mRealm.where(c).equalTo("isPrivate", false).findAll().toList()) as List<LI>
            }
            else -> {
                val myLibItems = getMyLibItems(c as Class<out RealmModel>)
                val results: List<RealmMyCourse> = mRealm.where(RealmMyCourse::class.java)
                    .isNotEmpty("courseTitle")
                    .findAll()
                    .toList()
                val ourCourseItems = RealmMyCourse.getOurCourse(model?.id, results)

                when (c) {
                    RealmMyCourse::class.java -> {
                        val combinedList = mutableListOf<RealmMyCourse>()
                        (myLibItems as List<RealmMyCourse>).forEach { course ->
                            course.isMyCourse = true
                            combinedList.add(course)
                        }
                        ourCourseItems.forEach { course ->
                            if (!combinedList.any { it.id == course.id }) {
                                course.isMyCourse = false
                                combinedList.add(course)
                            }
                        }
                        combinedList as List<LI>
                    }
                    else -> {
                        throw IllegalArgumentException("Unsupported class: ${c.simpleName}")
                    }
                }
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    fun getList(c: Class<*>, orderBy: String? = null, sort: Sort = Sort.ASCENDING): List<LI> {
        return when {
            c == RealmStepExam::class.java -> {
                mRealm.where(c).equalTo("type", "surveys").sort(orderBy ?: "", sort).findAll().toList() as List<LI>
            }
            isMyCourseLib -> {
                getMyLibItems(c as Class<out RealmModel>, orderBy)
            }
            c == RealmMyLibrary::class.java -> {
                RealmMyLibrary.getOurLibrary(model?.id, mRealm.where(c).equalTo("isPrivate", false).sort(orderBy ?: "", sort).findAll().toList()) as List<LI>
            }
            else -> {
                val results = mRealm.where(RealmMyCourse::class.java).sort(orderBy ?: "", sort).findAll().toList() as List<RealmMyCourse>
                RealmMyCourse.getOurCourse(model?.id, results) as List<LI>
            }
        }
    }
    @Suppress("UNCHECKED_CAST")
    private fun <T : RealmModel> getMyLibItems(c: Class<T>, orderBy: String? = null): List<LI> {
        val query = mRealm.where(c)
        val realmResults = if (orderBy != null) {
            query.sort(orderBy).findAll()
        } else {
            query.findAll()
        }
        val results: List<T> = realmResults.toList()
        return when (c) {
            RealmMyLibrary::class.java -> {
                RealmMyLibrary.getMyLibraryByUserId(model?.id, results as? List<RealmMyLibrary> ?: emptyList()) as List<LI>
            }
            RealmMyCourse::class.java -> {
                RealmMyCourse.getMyCourseByUserId(model?.id, results as? List<RealmMyCourse> ?: emptyList()) as List<LI>
            }
            else -> throw IllegalArgumentException("Unsupported class: ${c.simpleName}")
        }
    }

    fun getJsonArrayFromList(list: Set<String>): JsonArray {
        val array = JsonArray()
        list.forEach { array.add(it) }
        return array
    }

    companion object {
        var isSurvey: Boolean = false
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/base/BaseDialogFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.base

import android.os.Bundle
import androidx.fragment.app.DialogFragment
import org.ole.planet.myplanet.R

abstract class BaseDialogFragment : DialogFragment() {
    @JvmField
    var id: String? = null
    var teamId: String? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NO_TITLE, R.style.AppTheme_Dialog_NoActionBar_MinWidth)
        if (arguments != null) {
            id = requireArguments().getString(key)
            teamId = requireArguments().getString("teamId")
        }
    }

    protected abstract val key: String?
}
=======
package org.ole.planet.myplanet.base


import android.os.Bundle
import androidx.fragment.app.DialogFragment
import org.ole.planet.myplanet.R

abstract class BaseDialogFragment : DialogFragment() {
    @JvmField
    var id: String? = null
    var teamId: String? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NO_TITLE, R.style.AppTheme_Dialog_NoActionBar_MinWidth)
        if (arguments != null) {
            id = requireArguments().getString(key)
            teamId = requireArguments().getString("teamId")
        }
    }

    protected abstract val key: String?
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/base/PermissionActivity.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.base

import android.Manifest
import android.app.AppOpsManager
import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Process
import android.provider.Settings
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.utilities.Utilities

abstract class PermissionActivity : AppCompatActivity() {
    fun checkPermission(strPermission: String?): Boolean {
        val result = strPermission?.let { ContextCompat.checkSelfPermission(this, it) }
        return result == PackageManager.PERMISSION_GRANTED
    }

    fun checkUsagesPermission() {
        if (!getUsagesPermission(this)) {
            Utilities.toast(this, getString(R.string.please_allow_usages_permission_to_myplanet_app))
            startActivity(Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS))
        }
    }

    fun getUsagesPermission(context: Context): Boolean {
        val appOps = context.getSystemService(APP_OPS_SERVICE) as AppOpsManager
        var mode = -1
        try {
            val method = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                AppOpsManager::class.java.getMethod("unsafeCheckOpNoThrow", String::class.java, Int::class.javaPrimitiveType, String::class.java)
            } else {
                AppOpsManager::class.java.getMethod("checkOpNoThrow", String::class.java, Int::class.javaPrimitiveType, String::class.java)
            }
            mode = method.invoke(appOps, AppOpsManager.OPSTR_GET_USAGE_STATS, Process.myUid(), context.packageName) as Int
        } catch (e: Exception) {
            e.printStackTrace()
        }

        return if (mode == AppOpsManager.MODE_DEFAULT) {
            context.checkCallingOrSelfPermission(Manifest.permission.PACKAGE_USAGE_STATS) == PackageManager.PERMISSION_GRANTED
        } else {
            mode == AppOpsManager.MODE_ALLOWED
        }
    }

    fun requestAllPermissions() {
        val permissions = ArrayList<String>()
        if (!checkPermission(Manifest.permission.RECORD_AUDIO)) {
            permissions.add(Manifest.permission.RECORD_AUDIO)
        }
        if (!checkPermission(Manifest.permission.CAMERA)) {
            permissions.add(Manifest.permission.CAMERA)
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (isPermissionDeclaredInManifest(Manifest.permission.READ_MEDIA_IMAGES) &&
                !checkPermission(Manifest.permission.READ_MEDIA_IMAGES)) {
                permissions.add(Manifest.permission.READ_MEDIA_IMAGES)
            }
            if (isPermissionDeclaredInManifest(Manifest.permission.READ_MEDIA_VIDEO) &&
                !checkPermission(Manifest.permission.READ_MEDIA_VIDEO)) {
                permissions.add(Manifest.permission.READ_MEDIA_VIDEO)
            }
            if (isPermissionDeclaredInManifest(Manifest.permission.READ_MEDIA_AUDIO) &&
                !checkPermission(Manifest.permission.READ_MEDIA_AUDIO)) {
                permissions.add(Manifest.permission.READ_MEDIA_AUDIO)
            }
        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            if (isPermissionDeclaredInManifest(Manifest.permission.READ_EXTERNAL_STORAGE) &&
                !checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        } else {
            if (isPermissionDeclaredInManifest(Manifest.permission.WRITE_EXTERNAL_STORAGE) &&
                !checkPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.WRITE_EXTERNAL_STORAGE)
            }
            if (isPermissionDeclaredInManifest(Manifest.permission.READ_EXTERNAL_STORAGE) &&
                !checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (isPermissionDeclaredInManifest(Manifest.permission.POST_NOTIFICATIONS) &&
                !checkPermission(Manifest.permission.POST_NOTIFICATIONS)) {
                permissions.add(Manifest.permission.POST_NOTIFICATIONS)
            }
        }

        if (permissions.isNotEmpty()) {
            ActivityCompat.requestPermissions(this, permissions.toTypedArray(), PERMISSION_REQUEST_CODE_FILE)
        } else {
            onAllPermissionsGranted()
        }
    }

    private fun isPermissionDeclaredInManifest(permission: String): Boolean {
        return try {
            val packageInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS)
            packageInfo.requestedPermissions?.contains(permission) == true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    fun requestMediaPermissions() {
        val permissions = ArrayList<String>()

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (!checkPermission(Manifest.permission.READ_MEDIA_IMAGES)) {
                permissions.add(Manifest.permission.READ_MEDIA_IMAGES)
            }
            if (!checkPermission(Manifest.permission.READ_MEDIA_VIDEO)) {
                permissions.add(Manifest.permission.READ_MEDIA_VIDEO)
            }
            if (!checkPermission(Manifest.permission.READ_MEDIA_AUDIO)) {
                permissions.add(Manifest.permission.READ_MEDIA_AUDIO)
            }
        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            if (!checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        } else {
            if (!checkPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.WRITE_EXTERNAL_STORAGE)
            }
            if (!checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        }

        if (permissions.isNotEmpty()) {
            ActivityCompat.requestPermissions(this, permissions.toTypedArray(), PERMISSION_REQUEST_CODE_MEDIA)
        } else {
            onMediaPermissionsGranted()
        }
    }

    fun requestNotificationPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (!checkPermission(Manifest.permission.POST_NOTIFICATIONS)) {
                if (shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS)) {
                    showNotificationPermissionRationale()
                } else {
                    ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.POST_NOTIFICATIONS), PERMISSION_REQUEST_CODE_NOTIFICATION)
                }
            }
        }
    }

    fun areNotificationsEnabled(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            checkPermission(Manifest.permission.POST_NOTIFICATIONS) &&
                    NotificationManagerCompat.from(this).areNotificationsEnabled()
        } else {
            NotificationManagerCompat.from(this).areNotificationsEnabled()
        }
    }

    fun getNotificationPermissionStatus(): NotificationPermissionStatus {
        return when {
            Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU -> {
                if (NotificationManagerCompat.from(this).areNotificationsEnabled()) {
                    NotificationPermissionStatus.GRANTED
                } else {
                    NotificationPermissionStatus.DISABLED_IN_SETTINGS
                }
            }
            checkPermission(Manifest.permission.POST_NOTIFICATIONS) -> {
                if (NotificationManagerCompat.from(this).areNotificationsEnabled()) {
                    NotificationPermissionStatus.GRANTED
                } else {
                    NotificationPermissionStatus.DISABLED_IN_SETTINGS
                }
            }
            shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS) -> {
                NotificationPermissionStatus.SHOULD_SHOW_RATIONALE
            }
            else -> {
                NotificationPermissionStatus.DENIED
            }
        }
    }

    enum class NotificationPermissionStatus {
        GRANTED,
        DENIED,
        SHOULD_SHOW_RATIONALE,
        DISABLED_IN_SETTINGS
    }

    private fun showNotificationPermissionRationale() {
        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle("Enable Notifications")
            .setMessage("Notifications help you stay updated with:\n\n" +
                    " New surveys and assignments\n" +
                    " Task deadlines and reminders\n" +
                    " Team join requests\n" +
                    " System updates and storage warnings\n\n" +
                    "You can always disable them later in Settings.")
            .setPositiveButton("Allow") { _, _ ->
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    ActivityCompat.requestPermissions(
                        this,
                        arrayOf(Manifest.permission.POST_NOTIFICATIONS),
                        PERMISSION_REQUEST_CODE_NOTIFICATION
                    )
                }
            }
            .setNegativeButton("Not Now") { dialog, _ ->
                dialog.dismiss()
                onNotificationPermissionDenied()
            }
            .setCancelable(false)
            .show()
    }

    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)

        when (requestCode) {
            PERMISSION_REQUEST_CODE_FILE -> {
                handleFilePermissionsResult(permissions, grantResults)
            }
            PERMISSION_REQUEST_CODE_NOTIFICATION -> {
                handleNotificationPermissionResult(permissions, grantResults)
            }
            PERMISSION_REQUEST_CODE_MEDIA -> {
                handleMediaPermissionsResult(permissions, grantResults)
            }
        }
    }

    private fun handleFilePermissionsResult(permissions: Array<out String>, grantResults: IntArray) {
        val deniedPermissions = mutableListOf<String>()
        val grantedPermissions = mutableListOf<String>()

        for (i in permissions.indices) {
            if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {
                deniedPermissions.add(permissions[i])
            } else {
                grantedPermissions.add(permissions[i])
            }
        }

        if (deniedPermissions.isNotEmpty()) {
            val mediaPermissions = listOf(
                Manifest.permission.READ_MEDIA_IMAGES,
                Manifest.permission.READ_MEDIA_VIDEO,
                Manifest.permission.READ_MEDIA_AUDIO,
                Manifest.permission.READ_EXTERNAL_STORAGE,
                Manifest.permission.WRITE_EXTERNAL_STORAGE
            )

            val onlyMediaDenied = deniedPermissions.all { it in mediaPermissions }

            if (onlyMediaDenied) {
                showMediaPermissionsDeniedDialog(deniedPermissions)
            } else {
                onPermissionsDenied(deniedPermissions)
            }
        } else {
            onAllPermissionsGranted()
        }
    }

    private fun handleMediaPermissionsResult(permissions: Array<out String>, grantResults: IntArray) {
        val deniedPermissions = mutableListOf<String>()

        for (i in permissions.indices) {
            if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {
                deniedPermissions.add(permissions[i])
            }
        }

        if (deniedPermissions.isNotEmpty()) {
            onMediaPermissionsDenied(deniedPermissions)
        } else {
            onMediaPermissionsGranted()
        }
    }

    private fun handleNotificationPermissionResult(permissions: Array<out String>, grantResults: IntArray) {
        val notificationPermissionIndex = permissions.indexOf(Manifest.permission.POST_NOTIFICATIONS)

        if (notificationPermissionIndex >= 0) {
            if (grantResults[notificationPermissionIndex] == PackageManager.PERMISSION_GRANTED) {
                onNotificationPermissionGranted()
            } else {
                onNotificationPermissionDenied()
            }
        }
    }

    private fun showMediaPermissionsDeniedDialog(deniedPermissions: List<String>) {
        val permissionNames = deniedPermissions.map { permission ->
            getPermissionDisplayName(permission)
        }.distinct().joinToString(", ")

        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle("Media Access")
            .setMessage("$permissionNames access was denied. You can:\n\n" +
                    " Continue using the app with limited functionality\n" +
                    " Grant permissions later in Settings\n" +
                    " Try again now\n\n" +
                    "Note: Some features may not work without these permissions.")
            .setPositiveButton("Try Again") { _, _ ->
                requestMediaPermissions()
            }
            .setNegativeButton("Continue") { dialog, _ ->
                dialog.dismiss()
                onMediaPermissionsDenied(deniedPermissions)
            }
            .setNeutralButton("Settings") { _, _ ->
                openAppSettings()
            }
            .show()
    }

    fun openNotificationSettings() {
        try {
            val intent = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                Intent(Settings.ACTION_APP_NOTIFICATION_SETTINGS).apply {
                    putExtra(Settings.EXTRA_APP_PACKAGE, packageName)
                }
            } else {
                Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                    data = Uri.fromParts("package", packageName, null)
                }
            }
            startActivity(intent)
        } catch (e: ActivityNotFoundException) {
            startActivity(Intent(Settings.ACTION_SETTINGS))
            e.printStackTrace()
        }
    }

    fun openAppSettings() {
        try {
            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                data = Uri.fromParts("package", packageName, null)
            }
            startActivity(intent)
        } catch (e: ActivityNotFoundException) {
            startActivity(Intent(Settings.ACTION_SETTINGS))
            e.printStackTrace()
        }
    }

    fun showNotificationSettingsDialog() {
        val status = getNotificationPermissionStatus()
        val (title, message, positiveText) = when (status) {
            NotificationPermissionStatus.DISABLED_IN_SETTINGS -> Triple(
                "Notifications Disabled",
                "Notifications are disabled in your device settings. To receive important updates about surveys, tasks, and team activities, please enable notifications for this app.",
                "Open Settings"
            )
            NotificationPermissionStatus.DENIED -> Triple(
                "Enable Notifications",
                "Stay informed about new surveys, task assignments, team requests, and important updates. Notifications help you never miss important activities.",
                "Enable"
            )
            NotificationPermissionStatus.SHOULD_SHOW_RATIONALE -> Triple(
                "Why Enable Notifications?",
                "Notifications are essential for:\n\n" +
                        " New surveys and forms\n" +
                        " Task assignments and deadlines\n" +
                        " Team join requests\n" +
                        " Storage and system alerts\n" +
                        " Course and library updates\n\n" +
                        "You can customize notification types in Settings later.",
                "Allow Notifications"
            )
            else -> return
        }

        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(positiveText) { _, _ ->
                when (status) {
                    NotificationPermissionStatus.DISABLED_IN_SETTINGS -> openNotificationSettings()
                    else -> requestNotificationPermission()
                }
            }
            .setNegativeButton("Skip") { dialog, _ ->
                dialog.dismiss()
                onNotificationPermissionDenied()
            }
            .setCancelable(false)
            .show()
    }

    fun ensureNotificationPermission(showRationale: Boolean = true) {
        val status = getNotificationPermissionStatus()

        when (status) {
            NotificationPermissionStatus.GRANTED -> {
                onNotificationPermissionGranted()
            }
            NotificationPermissionStatus.DENIED -> {
                if (showRationale) {
                    showNotificationSettingsDialog()
                } else {
                    requestNotificationPermission()
                }
            }
            NotificationPermissionStatus.SHOULD_SHOW_RATIONALE -> {
                showNotificationSettingsDialog()
            }
            NotificationPermissionStatus.DISABLED_IN_SETTINGS -> {
                if (showRationale) {
                    showNotificationSettingsDialog()
                } else {
                    openNotificationSettings()
                }
            }
        }
    }

    fun checkNotificationPermissionStatus() {
        val prefs = getSharedPreferences("app_prefs", Context.MODE_PRIVATE)
        val lastCheck = prefs.getLong("last_notification_check", 0)
        val currentTime = System.currentTimeMillis()

        if (currentTime - lastCheck > 24 * 60 * 60 * 1000) {
            if (!areNotificationsEnabled()) {
                onNotificationPermissionChanged(false)
            }
            prefs.edit { putLong("last_notification_check", currentTime) }
        }
    }

    open fun onAllPermissionsGranted() {}

    open fun onPermissionsDenied(deniedPermissions: List<String>) {}

    open fun onMediaPermissionsGranted() {}

    open fun onMediaPermissionsDenied(deniedPermissions: List<String>) {}

    private fun getPermissionDisplayName(permission: String): String {
        return when (permission) {
            Manifest.permission.CAMERA -> "Camera"
            Manifest.permission.RECORD_AUDIO -> "Microphone"
            Manifest.permission.POST_NOTIFICATIONS -> "Notifications"
            else -> {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    when (permission) {
                        Manifest.permission.READ_MEDIA_IMAGES -> "Photos"
                        Manifest.permission.READ_MEDIA_VIDEO -> "Videos"
                        Manifest.permission.READ_MEDIA_AUDIO -> "Audio"
                        else -> "Required permission"
                    }
                } else {
                    when (permission) {
                        Manifest.permission.WRITE_EXTERNAL_STORAGE -> "Storage"
                        Manifest.permission.READ_EXTERNAL_STORAGE -> "Storage"
                        else -> "Required permission"
                    }
                }
            }
        }
    }

    open fun onNotificationPermissionGranted() {
        Utilities.toast(this, "Notifications enabled! You'll receive important updates.")
    }

    open fun onNotificationPermissionDenied() {
        Utilities.toast(this, "You can enable notifications later in Settings to receive important updates.")
    }

    open fun onNotificationPermissionChanged(isEnabled: Boolean) {
        if (!isEnabled) {
            Utilities.toast(this, "Notifications are disabled. You can enable them in Settings to receive important updates.")
        }
    }

    companion object {
        const val PERMISSION_REQUEST_CODE_FILE = 111
        const val PERMISSION_REQUEST_CODE_NOTIFICATION = 112
        const val PERMISSION_REQUEST_CODE_MEDIA = 113

        @JvmStatic
        fun hasInstallPermission(context: Context): Boolean {
            return !BuildConfig.LITE && context.packageManager.canRequestPackageInstalls()
        }
    }
}
=======
package org.ole.planet.myplanet.base


import android.Manifest
import android.app.AppOpsManager
import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Process
import android.provider.Settings
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import androidx.core.content.edit
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.utilities.Utilities

abstract class PermissionActivity : AppCompatActivity() {
    fun checkPermission(strPermission: String?): Boolean {
        val result = strPermission?.let { ContextCompat.checkSelfPermission(this, it) }
        return result == PackageManager.PERMISSION_GRANTED
    }

    fun checkUsagesPermission() {
        if (!getUsagesPermission(this)) {
            Utilities.toast(this, getString(R.string.please_allow_usages_permission_to_myplanet_app))
            startActivity(Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS))
        }
    }

    fun getUsagesPermission(context: Context): Boolean {
        val appOps = context.getSystemService(APP_OPS_SERVICE) as AppOpsManager
        var mode = -1
        try {
            val method = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                AppOpsManager::class.java.getMethod("unsafeCheckOpNoThrow", String::class.java, Int::class.javaPrimitiveType, String::class.java)
            } else {
                AppOpsManager::class.java.getMethod("checkOpNoThrow", String::class.java, Int::class.javaPrimitiveType, String::class.java)
            }
            mode = method.invoke(appOps, AppOpsManager.OPSTR_GET_USAGE_STATS, Process.myUid(), context.packageName) as Int
        } catch (e: Exception) {
            e.printStackTrace()
        }

        return if (mode == AppOpsManager.MODE_DEFAULT) {
            context.checkCallingOrSelfPermission(Manifest.permission.PACKAGE_USAGE_STATS) == PackageManager.PERMISSION_GRANTED
        } else {
            mode == AppOpsManager.MODE_ALLOWED
        }
    }

    fun requestAllPermissions() {
        val permissions = ArrayList<String>()
        if (!checkPermission(Manifest.permission.RECORD_AUDIO)) {
            permissions.add(Manifest.permission.RECORD_AUDIO)
        }
        if (!checkPermission(Manifest.permission.CAMERA)) {
            permissions.add(Manifest.permission.CAMERA)
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (isPermissionDeclaredInManifest(Manifest.permission.READ_MEDIA_IMAGES) &&
                !checkPermission(Manifest.permission.READ_MEDIA_IMAGES)) {
                permissions.add(Manifest.permission.READ_MEDIA_IMAGES)
            }
            if (isPermissionDeclaredInManifest(Manifest.permission.READ_MEDIA_VIDEO) &&
                !checkPermission(Manifest.permission.READ_MEDIA_VIDEO)) {
                permissions.add(Manifest.permission.READ_MEDIA_VIDEO)
            }
            if (isPermissionDeclaredInManifest(Manifest.permission.READ_MEDIA_AUDIO) &&
                !checkPermission(Manifest.permission.READ_MEDIA_AUDIO)) {
                permissions.add(Manifest.permission.READ_MEDIA_AUDIO)
            }
        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            if (isPermissionDeclaredInManifest(Manifest.permission.READ_EXTERNAL_STORAGE) &&
                !checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        } else {
            if (isPermissionDeclaredInManifest(Manifest.permission.WRITE_EXTERNAL_STORAGE) &&
                !checkPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.WRITE_EXTERNAL_STORAGE)
            }
            if (isPermissionDeclaredInManifest(Manifest.permission.READ_EXTERNAL_STORAGE) &&
                !checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (isPermissionDeclaredInManifest(Manifest.permission.POST_NOTIFICATIONS) &&
                !checkPermission(Manifest.permission.POST_NOTIFICATIONS)) {
                permissions.add(Manifest.permission.POST_NOTIFICATIONS)
            }
        }

        if (permissions.isNotEmpty()) {
            ActivityCompat.requestPermissions(this, permissions.toTypedArray(), PERMISSION_REQUEST_CODE_FILE)
        } else {
            onAllPermissionsGranted()
        }
    }

    private fun isPermissionDeclaredInManifest(permission: String): Boolean {
        return try {
            val packageInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS)
            packageInfo.requestedPermissions?.contains(permission) == true
        } catch (e: Exception) {
            e.printStackTrace()
            false
        }
    }

    fun requestMediaPermissions() {
        val permissions = ArrayList<String>()

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (!checkPermission(Manifest.permission.READ_MEDIA_IMAGES)) {
                permissions.add(Manifest.permission.READ_MEDIA_IMAGES)
            }
            if (!checkPermission(Manifest.permission.READ_MEDIA_VIDEO)) {
                permissions.add(Manifest.permission.READ_MEDIA_VIDEO)
            }
            if (!checkPermission(Manifest.permission.READ_MEDIA_AUDIO)) {
                permissions.add(Manifest.permission.READ_MEDIA_AUDIO)
            }
        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            if (!checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        } else {
            if (!checkPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.WRITE_EXTERNAL_STORAGE)
            }
            if (!checkPermission(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        }

        if (permissions.isNotEmpty()) {
            ActivityCompat.requestPermissions(this, permissions.toTypedArray(), PERMISSION_REQUEST_CODE_MEDIA)
        } else {
            onMediaPermissionsGranted()
        }
    }

    fun requestNotificationPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (!checkPermission(Manifest.permission.POST_NOTIFICATIONS)) {
                if (shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS)) {
                    showNotificationPermissionRationale()
                } else {
                    ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.POST_NOTIFICATIONS), PERMISSION_REQUEST_CODE_NOTIFICATION)
                }
            }
        }
    }

    fun areNotificationsEnabled(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            checkPermission(Manifest.permission.POST_NOTIFICATIONS) &&
                    NotificationManagerCompat.from(this).areNotificationsEnabled()
        } else {
            NotificationManagerCompat.from(this).areNotificationsEnabled()
        }
    }

    fun getNotificationPermissionStatus(): NotificationPermissionStatus {
        return when {
            Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU -> {
                if (NotificationManagerCompat.from(this).areNotificationsEnabled()) {
                    NotificationPermissionStatus.GRANTED
                } else {
                    NotificationPermissionStatus.DISABLED_IN_SETTINGS
                }
            }
            checkPermission(Manifest.permission.POST_NOTIFICATIONS) -> {
                if (NotificationManagerCompat.from(this).areNotificationsEnabled()) {
                    NotificationPermissionStatus.GRANTED
                } else {
                    NotificationPermissionStatus.DISABLED_IN_SETTINGS
                }
            }
            shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS) -> {
                NotificationPermissionStatus.SHOULD_SHOW_RATIONALE
            }
            else -> {
                NotificationPermissionStatus.DENIED
            }
        }
    }

    enum class NotificationPermissionStatus {
        GRANTED,
        DENIED,
        SHOULD_SHOW_RATIONALE,
        DISABLED_IN_SETTINGS
    }

    private fun showNotificationPermissionRationale() {
        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle("Enable Notifications")
            .setMessage("Notifications help you stay updated with:\n\n" +
                    " New surveys and assignments\n" +
                    " Task deadlines and reminders\n" +
                    " Team join requests\n" +
                    " System updates and storage warnings\n\n" +
                    "You can always disable them later in Settings.")
            .setPositiveButton("Allow") { _, _ ->
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    ActivityCompat.requestPermissions(
                        this,
                        arrayOf(Manifest.permission.POST_NOTIFICATIONS),
                        PERMISSION_REQUEST_CODE_NOTIFICATION
                    )
                }
            }
            .setNegativeButton("Not Now") { dialog, _ ->
                dialog.dismiss()
                onNotificationPermissionDenied()
            }
            .setCancelable(false)
            .show()
    }

    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)

        when (requestCode) {
            PERMISSION_REQUEST_CODE_FILE -> {
                handleFilePermissionsResult(permissions, grantResults)
            }
            PERMISSION_REQUEST_CODE_NOTIFICATION -> {
                handleNotificationPermissionResult(permissions, grantResults)
            }
            PERMISSION_REQUEST_CODE_MEDIA -> {
                handleMediaPermissionsResult(permissions, grantResults)
            }
        }
    }

    private fun handleFilePermissionsResult(permissions: Array<out String>, grantResults: IntArray) {
        val deniedPermissions = mutableListOf<String>()
        val grantedPermissions = mutableListOf<String>()

        for (i in permissions.indices) {
            if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {
                deniedPermissions.add(permissions[i])
            } else {
                grantedPermissions.add(permissions[i])
            }
        }

        if (deniedPermissions.isNotEmpty()) {
            val mediaPermissions = listOf(
                Manifest.permission.READ_MEDIA_IMAGES,
                Manifest.permission.READ_MEDIA_VIDEO,
                Manifest.permission.READ_MEDIA_AUDIO,
                Manifest.permission.READ_EXTERNAL_STORAGE,
                Manifest.permission.WRITE_EXTERNAL_STORAGE
            )

            val onlyMediaDenied = deniedPermissions.all { it in mediaPermissions }

            if (onlyMediaDenied) {
                showMediaPermissionsDeniedDialog(deniedPermissions)
            } else {
                onPermissionsDenied(deniedPermissions)
            }
        } else {
            onAllPermissionsGranted()
        }
    }

    private fun handleMediaPermissionsResult(permissions: Array<out String>, grantResults: IntArray) {
        val deniedPermissions = mutableListOf<String>()

        for (i in permissions.indices) {
            if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {
                deniedPermissions.add(permissions[i])
            }
        }

        if (deniedPermissions.isNotEmpty()) {
            onMediaPermissionsDenied(deniedPermissions)
        } else {
            onMediaPermissionsGranted()
        }
    }

    private fun handleNotificationPermissionResult(permissions: Array<out String>, grantResults: IntArray) {
        val notificationPermissionIndex = permissions.indexOf(Manifest.permission.POST_NOTIFICATIONS)

        if (notificationPermissionIndex >= 0) {
            if (grantResults[notificationPermissionIndex] == PackageManager.PERMISSION_GRANTED) {
                onNotificationPermissionGranted()
            } else {
                onNotificationPermissionDenied()
            }
        }
    }

    private fun showMediaPermissionsDeniedDialog(deniedPermissions: List<String>) {
        val permissionNames = deniedPermissions.map { permission ->
            getPermissionDisplayName(permission)
        }.distinct().joinToString(", ")

        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle("Media Access")
            .setMessage("$permissionNames access was denied. You can:\n\n" +
                    " Continue using the app with limited functionality\n" +
                    " Grant permissions later in Settings\n" +
                    " Try again now\n\n" +
                    "Note: Some features may not work without these permissions.")
            .setPositiveButton("Try Again") { _, _ ->
                requestMediaPermissions()
            }
            .setNegativeButton("Continue") { dialog, _ ->
                dialog.dismiss()
                onMediaPermissionsDenied(deniedPermissions)
            }
            .setNeutralButton("Settings") { _, _ ->
                openAppSettings()
            }
            .show()
    }

    fun openNotificationSettings() {
        try {
            val intent = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                Intent(Settings.ACTION_APP_NOTIFICATION_SETTINGS).apply {
                    putExtra(Settings.EXTRA_APP_PACKAGE, packageName)
                }
            } else {
                Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                    data = Uri.fromParts("package", packageName, null)
                }
            }
            startActivity(intent)
        } catch (e: ActivityNotFoundException) {
            startActivity(Intent(Settings.ACTION_SETTINGS))
            e.printStackTrace()
        }
    }

    fun openAppSettings() {
        try {
            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                data = Uri.fromParts("package", packageName, null)
            }
            startActivity(intent)
        } catch (e: ActivityNotFoundException) {
            startActivity(Intent(Settings.ACTION_SETTINGS))
            e.printStackTrace()
        }
    }

    fun showNotificationSettingsDialog() {
        val status = getNotificationPermissionStatus()
        val (title, message, positiveText) = when (status) {
            NotificationPermissionStatus.DISABLED_IN_SETTINGS -> Triple(
                "Notifications Disabled",
                "Notifications are disabled in your device settings. To receive important updates about surveys, tasks, and team activities, please enable notifications for this app.",
                "Open Settings"
            )
            NotificationPermissionStatus.DENIED -> Triple(
                "Enable Notifications",
                "Stay informed about new surveys, task assignments, team requests, and important updates. Notifications help you never miss important activities.",
                "Enable"
            )
            NotificationPermissionStatus.SHOULD_SHOW_RATIONALE -> Triple(
                "Why Enable Notifications?",
                "Notifications are essential for:\n\n" +
                        " New surveys and forms\n" +
                        " Task assignments and deadlines\n" +
                        " Team join requests\n" +
                        " Storage and system alerts\n" +
                        " Course and library updates\n\n" +
                        "You can customize notification types in Settings later.",
                "Allow Notifications"
            )
            else -> return
        }

        AlertDialog.Builder(this, R.style.AlertDialogTheme)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(positiveText) { _, _ ->
                when (status) {
                    NotificationPermissionStatus.DISABLED_IN_SETTINGS -> openNotificationSettings()
                    else -> requestNotificationPermission()
                }
            }
            .setNegativeButton("Skip") { dialog, _ ->
                dialog.dismiss()
                onNotificationPermissionDenied()
            }
            .setCancelable(false)
            .show()
    }

    fun ensureNotificationPermission(showRationale: Boolean = true) {
        val status = getNotificationPermissionStatus()

        when (status) {
            NotificationPermissionStatus.GRANTED -> {
                onNotificationPermissionGranted()
            }
            NotificationPermissionStatus.DENIED -> {
                if (showRationale) {
                    showNotificationSettingsDialog()
                } else {
                    requestNotificationPermission()
                }
            }
            NotificationPermissionStatus.SHOULD_SHOW_RATIONALE -> {
                showNotificationSettingsDialog()
            }
            NotificationPermissionStatus.DISABLED_IN_SETTINGS -> {
                if (showRationale) {
                    showNotificationSettingsDialog()
                } else {
                    openNotificationSettings()
                }
            }
        }
    }

    fun checkNotificationPermissionStatus() {
        val prefs = getSharedPreferences("app_prefs", Context.MODE_PRIVATE)
        val lastCheck = prefs.getLong("last_notification_check", 0)
        val currentTime = System.currentTimeMillis()

        if (currentTime - lastCheck > 24 * 60 * 60 * 1000) {
            if (!areNotificationsEnabled()) {
                onNotificationPermissionChanged(false)
            }
            prefs.edit { putLong("last_notification_check", currentTime) }
        }
    }

    open fun onAllPermissionsGranted() {}

    open fun onPermissionsDenied(deniedPermissions: List<String>) {}

    open fun onMediaPermissionsGranted() {}

    open fun onMediaPermissionsDenied(deniedPermissions: List<String>) {}

    private fun getPermissionDisplayName(permission: String): String {
        return when (permission) {
            Manifest.permission.CAMERA -> "Camera"
            Manifest.permission.RECORD_AUDIO -> "Microphone"
            Manifest.permission.POST_NOTIFICATIONS -> "Notifications"
            else -> {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    when (permission) {
                        Manifest.permission.READ_MEDIA_IMAGES -> "Photos"
                        Manifest.permission.READ_MEDIA_VIDEO -> "Videos"
                        Manifest.permission.READ_MEDIA_AUDIO -> "Audio"
                        else -> "Required permission"
                    }
                } else {
                    when (permission) {
                        Manifest.permission.WRITE_EXTERNAL_STORAGE -> "Storage"
                        Manifest.permission.READ_EXTERNAL_STORAGE -> "Storage"
                        else -> "Required permission"
                    }
                }
            }
        }
    }

    open fun onNotificationPermissionGranted() {
        Utilities.toast(this, "Notifications enabled! You'll receive important updates.")
    }

    open fun onNotificationPermissionDenied() {
        Utilities.toast(this, "You can enable notifications later in Settings to receive important updates.")
    }

    open fun onNotificationPermissionChanged(isEnabled: Boolean) {
        if (!isEnabled) {
            Utilities.toast(this, "Notifications are disabled. You can enable them in Settings to receive important updates.")
        }
    }

    companion object {
        const val PERMISSION_REQUEST_CODE_FILE = 111
        const val PERMISSION_REQUEST_CODE_NOTIFICATION = 112
        const val PERMISSION_REQUEST_CODE_MEDIA = 113

        @JvmStatic
        fun hasInstallPermission(context: Context): Boolean {
            return !BuildConfig.LITE && context.packageManager.canRequestPackageInstalls()
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/base/BaseResourceFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.base

import android.content.BroadcastReceiver
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.content.IntentFilter
import android.content.SharedPreferences
import android.net.wifi.WifiManager
import android.os.Build
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ListView
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmObject
import io.realm.RealmResults
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.MyDownloadService
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.datamanager.Service.PlanetAvailableListener
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.Download
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmRemovedLog
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.onRemove
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmission.Companion.getExamMap
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.CourseRepository
import org.ole.planet.myplanet.repository.LibraryRepository
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission
import org.ole.planet.myplanet.utilities.CheckboxListView
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.DialogUtils.getProgressDialog
import org.ole.planet.myplanet.utilities.DialogUtils.showError
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.DownloadUtils.downloadAllFiles
import org.ole.planet.myplanet.utilities.DownloadUtils.downloadFiles
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
abstract class BaseResourceFragment : Fragment() {
    var homeItemClickListener: OnHomeItemClickListener? = null
    var model: RealmUserModel? = null
    protected lateinit var mRealm: Realm
    var editor: SharedPreferences.Editor? = null
    var lv: CheckboxListView? = null
    var convertView: View? = null
    internal lateinit var prgDialog: DialogUtils.CustomProgressDialog
    @Inject
    lateinit var userRepository: UserRepository
    @Inject
    lateinit var libraryRepository: LibraryRepository
    @Inject
    lateinit var courseRepository: CourseRepository
    @Inject
    lateinit var submissionRepository: SubmissionRepository
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var profileDbHandler: UserProfileDbHandler
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    @Inject
    lateinit var broadcastService: org.ole.planet.myplanet.service.BroadcastService
    private var resourceNotFoundDialog: AlertDialog? = null
    private var downloadSuggestionDialog: AlertDialog? = null
    private var pendingSurveyDialog: AlertDialog? = null
    private var stayOnlineDialog: AlertDialog? = null

    protected fun isRealmInitialized(): Boolean {
        return ::mRealm.isInitialized && !mRealm.isClosed
    }

    private fun isFragmentActive(): Boolean {
        return isAdded && activity != null &&
            !requireActivity().isFinishing && !requireActivity().isDestroyed
    }

    private fun showProgressDialog() {
        viewLifecycleOwner.lifecycleScope.launch {
            if (isFragmentActive()) {
                prgDialog.show()
            }
        }
    }

    private fun showNotConnectedToast() {
        if (isFragmentActive()) {
            Utilities.toast(requireActivity(),
                getString(R.string.device_not_connected_to_planet))
        }
    }

    private var receiver: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            this@BaseResourceFragment.lifecycleScope.launch {
                val list = libraryRepository.getLibraryListForUser(
                    settings.getString("userId", "--")
                )
                showDownloadDialog(list)
            }
        }
    }

    private var stateReceiver: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            stayOnlineDialog?.dismiss()
            stayOnlineDialog = AlertDialog.Builder(requireContext()).setMessage(R.string.do_you_want_to_stay_online)
                .setPositiveButton(R.string.yes, null)
                .setNegativeButton(R.string.no) { _: DialogInterface?, _: Int ->
                    val wifi = requireContext().applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
                    wifi.setWifiEnabled(false)
                }.create()
            stayOnlineDialog?.setOnDismissListener {
                stayOnlineDialog = null
            }
            stayOnlineDialog?.show()
        }
    }
    private val broadcastReceiver: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (intent.action == DashboardActivity.MESSAGE_PROGRESS) {
                val download: Download? = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    intent.getParcelableExtra("download", Download::class.java)
                } else {
                    @Suppress("DEPRECATION")
                    intent.getParcelableExtra("download")
                }
                if (download?.failed == false) {
                    setProgress(download)
                } else {
                    prgDialog.dismiss()
                    download?.message?.let { showError(prgDialog, it) }
                }
            }
        }
    }

    protected fun showDownloadDialog(dbMyLibrary: List<RealmMyLibrary?>) {
        if (!isAdded) return
        Service(requireContext()).isPlanetAvailable(object : PlanetAvailableListener {
            override fun isAvailable() {
                if (!isAdded) return
                val userId = profileDbHandler.userModel?.id
                val librariesForDialog = if (userId.isNullOrBlank()) {
                    dbMyLibrary
                } else {
                    val userLibraries = dbMyLibrary.filter { it?.userId?.contains(userId) == true }
                    if (userLibraries.isEmpty()) dbMyLibrary else userLibraries
                }

                if (librariesForDialog.isEmpty()) {
                    return
                }

                activity?.let { fragmentActivity ->
                    val inflater = fragmentActivity.layoutInflater
                    val rootView = fragmentActivity.findViewById<ViewGroup>(android.R.id.content)
                    convertView = inflater.inflate(R.layout.my_library_alertdialog, rootView, false)

                    val alertDialogBuilder = AlertDialog.Builder(fragmentActivity, R.style.AlertDialogTheme)
                    alertDialogBuilder.setView(convertView)
                        .setTitle(R.string.download_suggestion)
                        .setPositiveButton(R.string.download_selected) { _: DialogInterface?, _: Int ->
                            lv?.selectedItemsList?.let {
                                addToLibrary(librariesForDialog, it)
                                downloadFiles(librariesForDialog, it)
                            }?.let { startDownload(it) }
                        }.setNeutralButton(R.string.download_all) { _: DialogInterface?, _: Int ->
                            lv?.selectedItemsList?.let {
                                addAllToLibrary(librariesForDialog)
                            }
                            startDownload(downloadAllFiles(librariesForDialog))
                        }.setNegativeButton(R.string.txt_cancel, null)
                    downloadSuggestionDialog?.dismiss()
                    downloadSuggestionDialog = alertDialogBuilder.create()
                    downloadSuggestionDialog?.let { dialog ->
                        createListView(librariesForDialog, dialog)
                        dialog.setOnDismissListener {
                            downloadSuggestionDialog = null
                        }
                        dialog.show()
                        dialog.getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = (lv?.selectedItemsList?.size
                            ?: 0) > 0
                    }
                }
            }

            override fun notAvailable() {
                if (!isAdded) return
                activity?.let {
                    Utilities.toast(it, getString(R.string.planet_not_available))
                }
            }
        })
    }

    fun showPendingSurveyDialog() {
        model = profileDbHandler.userModel
        viewLifecycleOwner.lifecycleScope.launch {
            val list = submissionRepository.getPendingSurveys(model?.id)
            if (list.isEmpty()) return@launch
            val exams = getExamMap(mRealm, list)
            val arrayAdapter = createSurveyAdapter(list, exams)
            pendingSurveyDialog?.dismiss()
            pendingSurveyDialog = AlertDialog.Builder(requireActivity()).setTitle("Pending Surveys")
                .setAdapter(arrayAdapter) { _: DialogInterface?, i: Int ->
                    AdapterMySubmission.openSurvey(homeItemClickListener, list[i].id, true, false, "")
                }.setPositiveButton(R.string.dismiss, null).create()
            pendingSurveyDialog?.setOnDismissListener {
                pendingSurveyDialog = null
            }
            pendingSurveyDialog?.show()
        }
    }

    private fun createSurveyAdapter(
        list: List<RealmSubmission>,
        exams: HashMap<String?, RealmStepExam>
    ): ArrayAdapter<RealmSubmission> {
        return object : ArrayAdapter<RealmSubmission>(requireActivity(), android.R.layout.simple_list_item_1, list) {
            override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
                val view = convertView ?: LayoutInflater.from(activity)
                    .inflate(android.R.layout.simple_list_item_1, parent, false)
                val text = exams[list[position].parentId]?.name ?: getString(R.string.n_a)
                (view as TextView).text = text
                return view
            }
        }
    }

    private val resourceNotFoundReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            showResourceNotFoundDialog()
        }
    }

    private fun showResourceNotFoundDialog() {
        if (isAdded) {
            if (prgDialog.isShowing()) {
                prgDialog.dismiss()
            }

            if (resourceNotFoundDialog?.isShowing == true) {
                return
            }

            resourceNotFoundDialog = AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
                .setTitle(R.string.resource_not_found)
                .setMessage(R.string.resource_not_found_message)
                .setNegativeButton(R.string.close) { dialog, _ ->
                    dialog.dismiss()
                }
                .create()
            resourceNotFoundDialog?.setOnDismissListener {
                resourceNotFoundDialog = null
            }

            resourceNotFoundDialog?.show()
        }
    }

    fun startDownload(urls: ArrayList<String>) {
        if (!isFragmentActive()) return
        Service(requireActivity()).isPlanetAvailable(object : PlanetAvailableListener {
            override fun isAvailable() {
                if (!isFragmentActive()) return
                if (urls.isNotEmpty()) {
                    try {
                        showProgressDialog()
                        DownloadUtils.openDownloadService(activity, urls, false)
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }

            override fun notAvailable() {
                showNotConnectedToast()
            }
        })
    }

    fun setProgress(download: Download) {
        prgDialog.setProgress(download.progress)
        if (!TextUtils.isEmpty(download.fileName)) {
            prgDialog.setTitle(download.fileName)
        }
        if (download.completeAll) {
            showError(prgDialog, getString(R.string.all_files_downloaded_successfully))
            onDownloadComplete()
        }
    }

    open fun onDownloadComplete() {
        prgDialog.setPositiveButton("Finish", isVisible = true){
            prgDialog.dismiss()
        }
        prgDialog.setNegativeButton("disabling", isVisible = false){ prgDialog.dismiss() }

        if (settings.getBoolean("isAlternativeUrl", false)) {
            editor?.putString("alternativeUrl", "")
            editor?.putString("processedAlternativeUrl", "")
            editor?.putBoolean("isAlternativeUrl", false)
            editor?.apply()
        }
    }

    fun createListView(dbMyLibrary: List<RealmMyLibrary?>, alertDialog: AlertDialog) {
        lv = convertView?.findViewById(R.id.alertDialog_listView)
        val names = dbMyLibrary.map { it?.title }
        val adapter = ArrayAdapter(requireActivity().baseContext, R.layout.rowlayout, R.id.checkBoxRowLayout, names)
        lv?.choiceMode = ListView.CHOICE_MODE_MULTIPLE
        lv?.setCheckChangeListener {
            alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = (lv?.selectedItemsList?.size ?: 0) > 0
        }
        lv?.adapter = adapter
    }

    private fun registerReceiver() {
        lifecycleScope.launch {
            broadcastService.events.collect { intent ->
                when (intent.action) {
                    DashboardActivity.MESSAGE_PROGRESS -> broadcastReceiver.onReceive(requireContext(), intent)
                    "ACTION_NETWORK_CHANGED" -> receiver.onReceive(requireContext(), intent)
                    "SHOW_WIFI_ALERT" -> stateReceiver.onReceive(requireContext(), intent)
                    MyDownloadService.RESOURCE_NOT_FOUND_ACTION -> resourceNotFoundReceiver.onReceive(requireContext(), intent)
                }
            }
        }
    }

    suspend fun getLibraryList(mRealm: Realm): List<RealmMyLibrary> {
        return libraryRepository.getLibraryListForUser(
            settings.getString("userId", "--")
        )
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        mRealm = databaseService.realmInstance
        prgDialog = getProgressDialog(requireActivity())
        editor = settings.edit()
    }

    override fun onPause() {
        super.onPause()
    }

    override fun onDetach() {
        super.onDetach()
        homeItemClickListener = null
    }

    fun removeFromShelf(`object`: RealmObject) {
        if (`object` is RealmMyLibrary) {
            val myObject = mRealm.where(RealmMyLibrary::class.java).equalTo("resourceId", `object`.resourceId).findFirst()
            myObject?.removeUserId(model?.id)
            model?.id?.let { `object`.resourceId?.let { it1 ->
                onRemove(mRealm, "resources", it, it1)
            } }
            Utilities.toast(activity, getString(R.string.removed_from_mylibrary))
        } else {
            val myObject = getMyCourse(mRealm, (`object` as RealmMyCourse).courseId)
            myObject?.removeUserId(model?.id)
            model?.id?.let { `object`.courseId?.let { it1 -> onRemove(mRealm, "courses", it, it1) } }
            Utilities.toast(activity, getString(R.string.removed_from_mycourse))
        }
    }

    override fun onResume() {
        super.onResume()
        registerReceiver()
    }

    fun showTagText(list: List<RealmTag>, tvSelected: TextView?) {
        val selected = list.joinToString(separator = ",", prefix = getString(R.string.selected)) { it.name.orEmpty() }
        tvSelected?.text = selected
    }

    fun addToLibrary(libraryItems: List<RealmMyLibrary?>, selectedItems: ArrayList<Int>) {
        if (!isRealmInitialized()) return

        val userId = profileDbHandler.userModel?.id ?: return

        try {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }

            selectedItems.forEach { index ->
                val item = libraryItems[index]
                if (item?.userId?.contains(userId) == false) {
                    item.setUserId(userId)
                    RealmRemovedLog.onAdd(mRealm, "resources", userId, item.resourceId)
                }
            }

            if (mRealm.isInTransaction) {
                mRealm.commitTransaction()
            }
        } catch (e: Exception) {
            if (mRealm.isInTransaction) {
                mRealm.cancelTransaction()
            }
            throw e
        }
        Utilities.toast(activity, getString(R.string.added_to_my_library))
    }

    fun addAllToLibrary(libraryItems: List<RealmMyLibrary?>) {
        if (!isRealmInitialized()) return

        val userId = profileDbHandler.userModel?.id ?: return

        try {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }

            libraryItems.forEach { libraryItem ->
                if (libraryItem?.userId?.contains(userId) == false) {
                    libraryItem.setUserId(userId, mRealm)
                    RealmRemovedLog.onAdd(mRealm, "resources", userId, libraryItem.resourceId)
                }
            }

            if (mRealm.isInTransaction) {
                mRealm.commitTransaction()
            }
        } catch (e: Exception) {
            if (mRealm.isInTransaction) {
                mRealm.cancelTransaction()
            }
            throw e
        }
        Utilities.toast(activity, getString(R.string.added_to_my_library))
    }

    override fun onDestroyView() {
        downloadSuggestionDialog?.dismiss()
        downloadSuggestionDialog = null
        pendingSurveyDialog?.dismiss()
        pendingSurveyDialog = null
        stayOnlineDialog?.dismiss()
        stayOnlineDialog = null
        resourceNotFoundDialog?.dismiss()
        resourceNotFoundDialog = null
        convertView = null
        super.onDestroyView()
    }

    override fun onDestroy() {
        cleanupRealm()
        super.onDestroy()
    }

    private fun cleanupRealm() {
        if (isRealmInitialized()) {
            try {
                mRealm.removeAllChangeListeners()
                if (mRealm.isInTransaction) {
                    try {
                        mRealm.commitTransaction()
                    } catch (e: Exception) {
                        mRealm.cancelTransaction()
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                if (!mRealm.isClosed) {
                    mRealm.close()
                }
            }
        }
    }

    companion object {
        var auth = ""

        fun getAllLibraryList(mRealm: Realm): List<RealmMyLibrary> {
            val l = mRealm.where(RealmMyLibrary::class.java).equalTo("resourceOffline", false).findAll()
            val libList: MutableList<RealmMyLibrary> = ArrayList()
            val libraries = getLibraries(l)
            libList.addAll(libraries)
            return libList
        }

        fun backgroundDownload(urls: ArrayList<String>, context: Context) {
            Service(context).isPlanetAvailable(object : PlanetAvailableListener {
                override fun isAvailable() {
                    if (urls.isNotEmpty()) {
                        DownloadUtils.openDownloadService(context, urls, false)
                    }
                }

                override fun notAvailable() {}
            })
        }

        fun getLibraryList(mRealm: Realm, userId: String?): List<RealmMyLibrary> {
            val l = mRealm.where(RealmMyLibrary::class.java).equalTo("isPrivate", false).findAll()
            val libList: MutableList<RealmMyLibrary> = ArrayList()
            val libraries = getLibraries(l)
            for (item in libraries) {
                if (item.userId?.contains(userId) == true) {
                    libList.add(item)
                }
            }
            return libList
        }

        private fun getLibraries(l: RealmResults<RealmMyLibrary>): List<RealmMyLibrary> {
            val libraries: MutableList<RealmMyLibrary> = ArrayList()
            for (lib in l) {
                if (lib.needToUpdate()) {
                    libraries.add(lib)
                }
            }
            return libraries
        }
    }
}
=======
package org.ole.planet.myplanet.base


import android.content.BroadcastReceiver
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.content.IntentFilter
import android.content.SharedPreferences
import android.net.wifi.WifiManager
import android.os.Build
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.ListView
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import io.realm.Realm
import io.realm.RealmObject
import io.realm.RealmResults
import javax.inject.Inject
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.datamanager.MyDownloadService
import org.ole.planet.myplanet.datamanager.Service
import org.ole.planet.myplanet.datamanager.Service.PlanetAvailableListener
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.model.Download
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getMyCourse
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmRemovedLog
import org.ole.planet.myplanet.model.RealmRemovedLog.Companion.onRemove
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmSubmission.Companion.getExamMap
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.repository.CourseRepository
import org.ole.planet.myplanet.repository.LibraryRepository
import org.ole.planet.myplanet.repository.SubmissionRepository
import org.ole.planet.myplanet.repository.UserRepository
import org.ole.planet.myplanet.service.UserProfileDbHandler
import org.ole.planet.myplanet.ui.dashboard.DashboardActivity
import org.ole.planet.myplanet.ui.submission.AdapterMySubmission
import org.ole.planet.myplanet.utilities.CheckboxListView
import org.ole.planet.myplanet.utilities.DialogUtils
import org.ole.planet.myplanet.utilities.DialogUtils.getProgressDialog
import org.ole.planet.myplanet.utilities.DialogUtils.showError
import org.ole.planet.myplanet.utilities.DownloadUtils
import org.ole.planet.myplanet.utilities.DownloadUtils.downloadAllFiles
import org.ole.planet.myplanet.utilities.DownloadUtils.downloadFiles
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
abstract class BaseResourceFragment : Fragment() {
    var homeItemClickListener: OnHomeItemClickListener? = null
    var model: RealmUserModel? = null
    protected lateinit var mRealm: Realm
    var editor: SharedPreferences.Editor? = null
    var lv: CheckboxListView? = null
    var convertView: View? = null
    internal lateinit var prgDialog: DialogUtils.CustomProgressDialog
    @Inject
    lateinit var userRepository: UserRepository
    @Inject
    lateinit var libraryRepository: LibraryRepository
    @Inject
    lateinit var courseRepository: CourseRepository
    @Inject
    lateinit var submissionRepository: SubmissionRepository
    @Inject
    lateinit var databaseService: DatabaseService
    @Inject
    lateinit var profileDbHandler: UserProfileDbHandler
    @Inject
    @AppPreferences
    lateinit var settings: SharedPreferences
    @Inject
    lateinit var broadcastService: org.ole.planet.myplanet.service.BroadcastService
    private var resourceNotFoundDialog: AlertDialog? = null
    private var downloadSuggestionDialog: AlertDialog? = null
    private var pendingSurveyDialog: AlertDialog? = null
    private var stayOnlineDialog: AlertDialog? = null

    protected fun isRealmInitialized(): Boolean {
        return ::mRealm.isInitialized && !mRealm.isClosed
    }

    private fun isFragmentActive(): Boolean {
        return isAdded && activity != null &&
            !requireActivity().isFinishing && !requireActivity().isDestroyed
    }

    private fun showProgressDialog() {
        viewLifecycleOwner.lifecycleScope.launch {
            if (isFragmentActive()) {
                prgDialog.show()
            }
        }
    }

    private fun showNotConnectedToast() {
        if (isFragmentActive()) {
            Utilities.toast(requireActivity(),
                getString(R.string.device_not_connected_to_planet))
        }
    }

    private var receiver: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            this@BaseResourceFragment.lifecycleScope.launch {
                val list = libraryRepository.getLibraryListForUser(
                    settings.getString("userId", "--")
                )
                showDownloadDialog(list)
            }
        }
    }

    private var stateReceiver: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            stayOnlineDialog?.dismiss()
            stayOnlineDialog = AlertDialog.Builder(requireContext()).setMessage(R.string.do_you_want_to_stay_online)
                .setPositiveButton(R.string.yes, null)
                .setNegativeButton(R.string.no) { _: DialogInterface?, _: Int ->
                    val wifi = requireContext().applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
                    wifi.setWifiEnabled(false)
                }.create()
            stayOnlineDialog?.setOnDismissListener {
                stayOnlineDialog = null
            }
            stayOnlineDialog?.show()
        }
    }
    private val broadcastReceiver: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (intent.action == DashboardActivity.MESSAGE_PROGRESS) {
                val download: Download? = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    intent.getParcelableExtra("download", Download::class.java)
                } else {
                    @Suppress("DEPRECATION")
                    intent.getParcelableExtra("download")
                }
                if (download?.failed == false) {
                    setProgress(download)
                } else {
                    prgDialog.dismiss()
                    download?.message?.let { showError(prgDialog, it) }
                }
            }
        }
    }

    protected fun showDownloadDialog(dbMyLibrary: List<RealmMyLibrary?>) {
        if (!isAdded) return
        Service(requireContext()).isPlanetAvailable(object : PlanetAvailableListener {
            override fun isAvailable() {
                if (!isAdded) return
                val userId = profileDbHandler.userModel?.id
                val librariesForDialog = if (userId.isNullOrBlank()) {
                    dbMyLibrary
                } else {
                    val userLibraries = dbMyLibrary.filter { it?.userId?.contains(userId) == true }
                    if (userLibraries.isEmpty()) dbMyLibrary else userLibraries
                }

                if (librariesForDialog.isEmpty()) {
                    return
                }

                activity?.let { fragmentActivity ->
                    val inflater = fragmentActivity.layoutInflater
                    val rootView = fragmentActivity.findViewById<ViewGroup>(android.R.id.content)
                    convertView = inflater.inflate(R.layout.my_library_alertdialog, rootView, false)

                    val alertDialogBuilder = AlertDialog.Builder(fragmentActivity, R.style.AlertDialogTheme)
                    alertDialogBuilder.setView(convertView)
                        .setTitle(R.string.download_suggestion)
                        .setPositiveButton(R.string.download_selected) { _: DialogInterface?, _: Int ->
                            lv?.selectedItemsList?.let {
                                addToLibrary(librariesForDialog, it)
                                downloadFiles(librariesForDialog, it)
                            }?.let { startDownload(it) }
                        }.setNeutralButton(R.string.download_all) { _: DialogInterface?, _: Int ->
                            lv?.selectedItemsList?.let {
                                addAllToLibrary(librariesForDialog)
                            }
                            startDownload(downloadAllFiles(librariesForDialog))
                        }.setNegativeButton(R.string.txt_cancel, null)
                    downloadSuggestionDialog?.dismiss()
                    downloadSuggestionDialog = alertDialogBuilder.create()
                    downloadSuggestionDialog?.let { dialog ->
                        createListView(librariesForDialog, dialog)
                        dialog.setOnDismissListener {
                            downloadSuggestionDialog = null
                        }
                        dialog.show()
                        dialog.getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = (lv?.selectedItemsList?.size
                            ?: 0) > 0
                    }
                }
            }

            override fun notAvailable() {
                if (!isAdded) return
                activity?.let {
                    Utilities.toast(it, getString(R.string.planet_not_available))
                }
            }
        })
    }

    fun showPendingSurveyDialog() {
        model = profileDbHandler.userModel
        viewLifecycleOwner.lifecycleScope.launch {
            val list = submissionRepository.getPendingSurveys(model?.id)
            if (list.isEmpty()) return@launch
            val exams = getExamMap(mRealm, list)
            val arrayAdapter = createSurveyAdapter(list, exams)
            pendingSurveyDialog?.dismiss()
            pendingSurveyDialog = AlertDialog.Builder(requireActivity()).setTitle("Pending Surveys")
                .setAdapter(arrayAdapter) { _: DialogInterface?, i: Int ->
                    AdapterMySubmission.openSurvey(homeItemClickListener, list[i].id, true, false, "")
                }.setPositiveButton(R.string.dismiss, null).create()
            pendingSurveyDialog?.setOnDismissListener {
                pendingSurveyDialog = null
            }
            pendingSurveyDialog?.show()
        }
    }

    private fun createSurveyAdapter(
        list: List<RealmSubmission>,
        exams: HashMap<String?, RealmStepExam>
    ): ArrayAdapter<RealmSubmission> {
        return object : ArrayAdapter<RealmSubmission>(requireActivity(), android.R.layout.simple_list_item_1, list) {
            override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
                val view = convertView ?: LayoutInflater.from(activity)
                    .inflate(android.R.layout.simple_list_item_1, parent, false)
                val text = exams[list[position].parentId]?.name ?: getString(R.string.n_a)
                (view as TextView).text = text
                return view
            }
        }
    }

    private val resourceNotFoundReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            showResourceNotFoundDialog()
        }
    }

    private fun showResourceNotFoundDialog() {
        if (isAdded) {
            if (prgDialog.isShowing()) {
                prgDialog.dismiss()
            }

            if (resourceNotFoundDialog?.isShowing == true) {
                return
            }

            resourceNotFoundDialog = AlertDialog.Builder(requireContext(), R.style.AlertDialogTheme)
                .setTitle(R.string.resource_not_found)
                .setMessage(R.string.resource_not_found_message)
                .setNegativeButton(R.string.close) { dialog, _ ->
                    dialog.dismiss()
                }
                .create()
            resourceNotFoundDialog?.setOnDismissListener {
                resourceNotFoundDialog = null
            }

            resourceNotFoundDialog?.show()
        }
    }

    fun startDownload(urls: ArrayList<String>) {
        if (!isFragmentActive()) return
        Service(requireActivity()).isPlanetAvailable(object : PlanetAvailableListener {
            override fun isAvailable() {
                if (!isFragmentActive()) return
                if (urls.isNotEmpty()) {
                    try {
                        showProgressDialog()
                        DownloadUtils.openDownloadService(activity, urls, false)
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }

            override fun notAvailable() {
                showNotConnectedToast()
            }
        })
    }

    fun setProgress(download: Download) {
        prgDialog.setProgress(download.progress)
        if (!TextUtils.isEmpty(download.fileName)) {
            prgDialog.setTitle(download.fileName)
        }
        if (download.completeAll) {
            showError(prgDialog, getString(R.string.all_files_downloaded_successfully))
            onDownloadComplete()
        }
    }

    open fun onDownloadComplete() {
        prgDialog.setPositiveButton("Finish", isVisible = true){
            prgDialog.dismiss()
        }
        prgDialog.setNegativeButton("disabling", isVisible = false){ prgDialog.dismiss() }

        if (settings.getBoolean("isAlternativeUrl", false)) {
            editor?.putString("alternativeUrl", "")
            editor?.putString("processedAlternativeUrl", "")
            editor?.putBoolean("isAlternativeUrl", false)
            editor?.apply()
        }
    }

    fun createListView(dbMyLibrary: List<RealmMyLibrary?>, alertDialog: AlertDialog) {
        lv = convertView?.findViewById(R.id.alertDialog_listView)
        val names = dbMyLibrary.map { it?.title }
        val adapter = ArrayAdapter(requireActivity().baseContext, R.layout.rowlayout, R.id.checkBoxRowLayout, names)
        lv?.choiceMode = ListView.CHOICE_MODE_MULTIPLE
        lv?.setCheckChangeListener {
            alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).isEnabled = (lv?.selectedItemsList?.size ?: 0) > 0
        }
        lv?.adapter = adapter
    }

    private fun registerReceiver() {
        lifecycleScope.launch {
            broadcastService.events.collect { intent ->
                when (intent.action) {
                    DashboardActivity.MESSAGE_PROGRESS -> broadcastReceiver.onReceive(requireContext(), intent)
                    "ACTION_NETWORK_CHANGED" -> receiver.onReceive(requireContext(), intent)
                    "SHOW_WIFI_ALERT" -> stateReceiver.onReceive(requireContext(), intent)
                    MyDownloadService.RESOURCE_NOT_FOUND_ACTION -> resourceNotFoundReceiver.onReceive(requireContext(), intent)
                }
            }
        }
    }

    suspend fun getLibraryList(mRealm: Realm): List<RealmMyLibrary> {
        return libraryRepository.getLibraryListForUser(
            settings.getString("userId", "--")
        )
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        mRealm = databaseService.realmInstance
        prgDialog = getProgressDialog(requireActivity())
        editor = settings.edit()
    }

    override fun onPause() {
        super.onPause()
    }

    override fun onDetach() {
        super.onDetach()
        homeItemClickListener = null
    }

    fun removeFromShelf(`object`: RealmObject) {
        if (`object` is RealmMyLibrary) {
            val myObject = mRealm.where(RealmMyLibrary::class.java).equalTo("resourceId", `object`.resourceId).findFirst()
            myObject?.removeUserId(model?.id)
            model?.id?.let { `object`.resourceId?.let { it1 ->
                onRemove(mRealm, "resources", it, it1)
            } }
            Utilities.toast(activity, getString(R.string.removed_from_mylibrary))
        } else {
            val myObject = getMyCourse(mRealm, (`object` as RealmMyCourse).courseId)
            myObject?.removeUserId(model?.id)
            model?.id?.let { `object`.courseId?.let { it1 -> onRemove(mRealm, "courses", it, it1) } }
            Utilities.toast(activity, getString(R.string.removed_from_mycourse))
        }
    }

    override fun onResume() {
        super.onResume()
        registerReceiver()
    }

    fun showTagText(list: List<RealmTag>, tvSelected: TextView?) {
        val selected = list.joinToString(separator = ",", prefix = getString(R.string.selected)) { it.name.orEmpty() }
        tvSelected?.text = selected
    }

    fun addToLibrary(libraryItems: List<RealmMyLibrary?>, selectedItems: ArrayList<Int>) {
        if (!isRealmInitialized()) return

        val userId = profileDbHandler.userModel?.id ?: return

        try {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }

            selectedItems.forEach { index ->
                val item = libraryItems[index]
                if (item?.userId?.contains(userId) == false) {
                    item.setUserId(userId)
                    RealmRemovedLog.onAdd(mRealm, "resources", userId, item.resourceId)
                }
            }

            if (mRealm.isInTransaction) {
                mRealm.commitTransaction()
            }
        } catch (e: Exception) {
            if (mRealm.isInTransaction) {
                mRealm.cancelTransaction()
            }
            throw e
        }
        Utilities.toast(activity, getString(R.string.added_to_my_library))
    }

    fun addAllToLibrary(libraryItems: List<RealmMyLibrary?>) {
        if (!isRealmInitialized()) return

        val userId = profileDbHandler.userModel?.id ?: return

        try {
            if (!mRealm.isInTransaction) {
                mRealm.beginTransaction()
            }

            libraryItems.forEach { libraryItem ->
                if (libraryItem?.userId?.contains(userId) == false) {
                    libraryItem.setUserId(userId, mRealm)
                    RealmRemovedLog.onAdd(mRealm, "resources", userId, libraryItem.resourceId)
                }
            }

            if (mRealm.isInTransaction) {
                mRealm.commitTransaction()
            }
        } catch (e: Exception) {
            if (mRealm.isInTransaction) {
                mRealm.cancelTransaction()
            }
            throw e
        }
        Utilities.toast(activity, getString(R.string.added_to_my_library))
    }

    override fun onDestroyView() {
        downloadSuggestionDialog?.dismiss()
        downloadSuggestionDialog = null
        pendingSurveyDialog?.dismiss()
        pendingSurveyDialog = null
        stayOnlineDialog?.dismiss()
        stayOnlineDialog = null
        resourceNotFoundDialog?.dismiss()
        resourceNotFoundDialog = null
        convertView = null
        super.onDestroyView()
    }

    override fun onDestroy() {
        cleanupRealm()
        super.onDestroy()
    }

    private fun cleanupRealm() {
        if (isRealmInitialized()) {
            try {
                mRealm.removeAllChangeListeners()
                if (mRealm.isInTransaction) {
                    try {
                        mRealm.commitTransaction()
                    } catch (e: Exception) {
                        mRealm.cancelTransaction()
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                if (!mRealm.isClosed) {
                    mRealm.close()
                }
            }
        }
    }

    companion object {
        var auth = ""

        fun getAllLibraryList(mRealm: Realm): List<RealmMyLibrary> {
            val l = mRealm.where(RealmMyLibrary::class.java).equalTo("resourceOffline", false).findAll()
            val libList: MutableList<RealmMyLibrary> = ArrayList()
            val libraries = getLibraries(l)
            libList.addAll(libraries)
            return libList
        }

        fun backgroundDownload(urls: ArrayList<String>, context: Context) {
            Service(context).isPlanetAvailable(object : PlanetAvailableListener {
                override fun isAvailable() {
                    if (urls.isNotEmpty()) {
                        DownloadUtils.openDownloadService(context, urls, false)
                    }
                }

                override fun notAvailable() {}
            })
        }

        fun getLibraryList(mRealm: Realm, userId: String?): List<RealmMyLibrary> {
            val l = mRealm.where(RealmMyLibrary::class.java).equalTo("isPrivate", false).findAll()
            val libList: MutableList<RealmMyLibrary> = ArrayList()
            val libraries = getLibraries(l)
            for (item in libraries) {
                if (item.userId?.contains(userId) == true) {
                    libList.add(item)
                }
            }
            return libList
        }

        private fun getLibraries(l: RealmResults<RealmMyLibrary>): List<RealmMyLibrary> {
            val libraries: MutableList<RealmMyLibrary> = ArrayList()
            for (lib in l) {
                if (lib.needToUpdate()) {
                    libraries.add(lib)
                }
            }
            return libraries
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/base/BaseRecyclerFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.base

import android.os.Build
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.annotation.RequiresApi
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import io.realm.RealmList
import io.realm.RealmModel
import io.realm.RealmObject
import io.realm.RealmResults
import java.text.Normalizer
import java.util.Locale
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getAllCourses
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getMyCourseByUserId
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getMyLibraryByUserId
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getOurLibrary
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.utilities.Utilities.toast

abstract class BaseRecyclerFragment<LI> : BaseRecyclerParentFragment<Any?>(), OnRatingChangeListener {
    var subjects: MutableSet<String> = mutableSetOf()
    var languages: MutableSet<String> = mutableSetOf()
    var mediums: MutableSet<String> = mutableSetOf()
    var levels: MutableSet<String> = mutableSetOf()
    var selectedItems: MutableList<LI>? = null
    var gradeLevel = ""
    var subjectLevel = ""
    lateinit var recyclerView: RecyclerView
    lateinit var tvMessage: TextView
    lateinit var tvFragmentInfo: TextView
    var tvDelete: TextView? = null
    var list: MutableList<LI>? = null
    var resources: List<RealmMyLibrary>? = null
    var courseLib: String? = null
    private var isAddInProgress = false


    abstract fun getLayout(): Int

    abstract fun getAdapter(): RecyclerView.Adapter<*>

    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            isMyCourseLib = it.getBoolean("isMyCourseLib")
            courseLib = it.getString("courseLib")
            @Suppress("UNCHECKED_CAST")
            resources = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                it.getSerializable("resources", ArrayList::class.java) as? ArrayList<RealmMyLibrary>
            } else {
                it.getSerializable("resources") as? ArrayList<RealmMyLibrary>
            }
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        val v = inflater.inflate(getLayout(), container, false)
        recyclerView = v.findViewById(R.id.recycler)
        recyclerView.layoutManager = LinearLayoutManager(activity)
        if (isMyCourseLib) {
            tvDelete = v.findViewById(R.id.tv_delete)
            initDeleteButton()
            v.findViewById<TextView>(R.id.tv_add)?.visibility = View.GONE
        }
        tvMessage = v.findViewById(R.id.tv_message)
        selectedItems = mutableListOf()
        list = mutableListOf()
        mRealm = databaseService.realmInstance
        model = profileDbHandler.userModel
        val adapter = getAdapter()
        recyclerView.adapter = adapter
        if (isMyCourseLib && adapter.itemCount != 0 && courseLib == "courses") {
            resources?.let { showDownloadDialog(it) }
        } else if (isMyCourseLib && courseLib == null && !isSurvey) {
            viewLifecycleOwner.lifecycleScope.launch {
                showDownloadDialog(getLibraryList(mRealm))
            }
        }
        return v
    }

    private fun initDeleteButton() {
        tvDelete?.let {
            it.visibility = View.VISIBLE
            it.setOnClickListener { deleteSelected(false) }
        }
    }

    override fun onRatingChanged() {
        recyclerView.adapter = getAdapter()
    }

    fun addToMyList() {
        if (!isRealmInitialized() || isAddInProgress) return

        val itemsToAdd = selectedItems?.toList() ?: emptyList()
        if (itemsToAdd.isEmpty()) return

        val resourceIds = mutableSetOf<String>()
        val courseIds = mutableSetOf<String>()

        itemsToAdd.forEach { item ->
            val realmObject = item as? RealmObject ?: return@forEach
            when (realmObject) {
                is RealmMyLibrary -> realmObject.resourceId?.let(resourceIds::add)
                is RealmMyCourse -> realmObject.courseId?.let(courseIds::add)
            }
        }

        if (resourceIds.isEmpty() && courseIds.isEmpty()) {
            return
        }

        isAddInProgress = true
        setJoinInProgress(true)

        val userId = profileDbHandler.userModel?.id

        viewLifecycleOwner.lifecycleScope.launch {
            var libraryAdded = false
            var courseAdded = false
            val result = runCatching {
                resourceIds.forEach { resourceId ->
                    if (!userId.isNullOrBlank()) {
                        libraryRepository.updateUserLibrary(resourceId, userId, isAdd = true)
                        libraryAdded = true
                    }
                }

                courseIds.forEach { courseId ->
                    if (courseId.isNotBlank()) {
                        val added = courseRepository.markCourseAdded(courseId, userId)
                        courseAdded = courseAdded || added
                    }
                }
            }

            isAddInProgress = false
            setJoinInProgress(false)
            recyclerView.adapter = getAdapter()
            showNoData(tvMessage, getAdapter().itemCount, "")

            result.exceptionOrNull()?.let { throw it }

            if (libraryAdded) {
                toast(activity, getString(R.string.added_to_my_library))
            }
            if (courseAdded) {
                toast(activity, getString(R.string.added_to_my_courses))
            }
        }
    }

    private fun setJoinInProgress(inProgress: Boolean) {
        recyclerView.isEnabled = !inProgress
        recyclerView.alpha = if (inProgress) 0.6f else 1f
        view?.findViewById<View>(R.id.tv_add)?.let { addButton ->
            addButton.isEnabled = if (inProgress) {
                false
            } else {
                !(selectedItems.isNullOrEmpty())
            }
            addButton.alpha = if (inProgress) 0.5f else 1f
        }
    }

    fun deleteSelected(deleteProgress: Boolean) {
        selectedItems?.forEach { item ->
            try {
                if (!mRealm.isInTransaction) {
                    mRealm.beginTransaction()
                }
                val `object` = item as RealmObject
                deleteCourseProgress(deleteProgress, `object`)
                removeFromShelf(`object`)
                if (mRealm.isInTransaction) {
                    mRealm.commitTransaction()
                }
            } catch (e: Exception) {
                if (mRealm.isInTransaction) {
                    mRealm.cancelTransaction()
                }
                throw e
            }
        }
        recyclerView.adapter = getAdapter()
        showNoData(tvMessage, getAdapter().itemCount, "")
    }

    fun countSelected(): Int {
        return selectedItems?.size ?: 0
    }

    private fun deleteCourseProgress(deleteProgress: Boolean, `object`: RealmObject) {
        if (deleteProgress && `object` is RealmMyCourse) {
            mRealm.where(RealmCourseProgress::class.java).equalTo("courseId", `object`.courseId).findAll().deleteAllFromRealm()
            val examList: List<RealmStepExam> = mRealm.where(RealmStepExam::class.java).equalTo("courseId", `object`.courseId).findAll()
            for (exam in examList) {
                mRealm.where(RealmSubmission::class.java).equalTo("parentId", exam.id)
                    .notEqualTo("type", "survey").equalTo("uploaded", false).findAll()
                    .deleteAllFromRealm()
            }
        }
    }

    private fun checkAndAddToList(course: RealmMyCourse?, courses: MutableList<RealmMyCourse>, tags: List<RealmTag>) {
        for (tg in tags) {
            val count = mRealm.where(RealmTag::class.java).equalTo("db", "courses").equalTo("tagId", tg.id)
                .equalTo("linkId", course?.courseId).count()
            if (count > 0 && !courses.contains(course)) {
                course?.let { courses.add(it) }
            }
        }
    }

    private fun <LI : RealmModel> getData(s: String, c: Class<LI>): List<LI> {
        if (s.isEmpty()) return mRealm.where(c).findAll()

        val queryParts = s.split(" ").filterNot { it.isEmpty() }
        val data: RealmResults<LI> = mRealm.where(c).findAll()
        val normalizedQuery = normalizeText(s)
        val startsWithQuery = mutableListOf<LI>()
        val containsQuery = mutableListOf<LI>()

        for (item in data) {
            val title = getTitle(item, c)?.let { normalizeText(it) } ?: continue

            if (title.startsWith(normalizedQuery, ignoreCase = true)) {
                startsWithQuery.add(item)
            } else if (queryParts.all { title.contains(normalizeText(it), ignoreCase = true) }) {
                containsQuery.add(item)
            }
        }
        return startsWithQuery + containsQuery
    }

    private fun <LI : RealmModel> getTitle(item: LI, c: Class<LI>): String? {
        return when {
            c.isAssignableFrom(RealmMyLibrary::class.java) -> (item as RealmMyLibrary).title
            else -> (item as RealmMyCourse).courseTitle
        }
    }

    fun filterLibraryByTag(s: String, tags: List<RealmTag>): List<RealmMyLibrary> {
        val normalizedSearchTerm = normalizeText(s)
        var list = getData(s, RealmMyLibrary::class.java)
        list = if (isMyCourseLib) {
            getMyLibraryByUserId(model?.id, list)
        } else {
            getOurLibrary(model?.id, list)
        }

        val libraries = if (tags.isNotEmpty()) {
            val filteredLibraries = mutableListOf<RealmMyLibrary>()
            for (library in list) {
                filter(tags, library, filteredLibraries)
            }
            filteredLibraries
        } else {
            list
        }

        return libraries
    }

    fun normalizeText(str: String): String {
        return Normalizer.normalize(str.lowercase(Locale.getDefault()), Normalizer.Form.NFD)
            .replace(Regex("\\p{InCombiningDiacriticalMarks}+"), "")
    }

    fun filterCourseByTag(s: String, tags: List<RealmTag>): List<RealmMyCourse> {
        if (tags.isEmpty() && s.isEmpty()) {
            return applyCourseFilter(filterRealmMyCourseList(getList(RealmMyCourse::class.java)))
        }
        var list = getData(s, RealmMyCourse::class.java)
        list = if (isMyCourseLib) {
            getMyCourseByUserId(model?.id, list)
        } else {
            getAllCourses(model?.id, list)
        }
        if (tags.isEmpty()) {
            return list
        }
        val courses = RealmList<RealmMyCourse>()
        list.forEach { course ->
            checkAndAddToList(course, courses, tags)
        }
        return applyCourseFilter(courses)
    }

    private fun filterRealmMyCourseList(items: List<Any?>): List<RealmMyCourse> {
        return items.filterIsInstance<RealmMyCourse>()
    }

    private fun filter(tags: List<RealmTag>, library: RealmMyLibrary?, libraries: MutableList<RealmMyLibrary>) {
        for (tg in tags) {
            val count = mRealm.where(RealmTag::class.java).equalTo("db", "resources")
                .equalTo("tagId", tg.id).equalTo("linkId", library?.id).count()
            if (count > 0 && !libraries.contains(library)) {
                library?.let { libraries.add(it) }
            }
        }
    }

    fun applyFilter(libraries: List<RealmMyLibrary>): List<RealmMyLibrary> {
        val newList: MutableList<RealmMyLibrary> = ArrayList()
        for (l in libraries) {
            if (isValidFilter(l)) newList.add(l)
        }
        return newList
    }

    private fun applyCourseFilter(courses: List<RealmMyCourse>): List<RealmMyCourse> {
        if (TextUtils.isEmpty(subjectLevel) && TextUtils.isEmpty(gradeLevel)) return courses
        val newList: MutableList<RealmMyCourse> = ArrayList()
        for (l in courses) {
            if (TextUtils.equals(l.gradeLevel, gradeLevel) || TextUtils.equals(
                    l.subjectLevel, subjectLevel
                )
            ) {
                newList.add(l)
            }
        }
        return newList
    }

    private fun isValidFilter(l: RealmMyLibrary): Boolean {
        val sub = subjects.isEmpty() || subjects.let { l.subject?.containsAll(it) } == true
        val lev = levels.isEmpty() || l.level?.containsAll(levels) == true
        val lan = languages.isEmpty() || languages.contains(l.language)
        val med = mediums.isEmpty() || mediums.contains(l.mediaType)
        return sub && lev && lan && med
    }

    override fun onDestroy() {
        cleanupRealm()
        super.onDestroy()
    }

    private fun cleanupRealm() {
        if (isRealmInitialized()) {
            try {
                mRealm.removeAllChangeListeners()

                if (mRealm.isInTransaction) {
                    try {
                        mRealm.commitTransaction()
                    } catch (e: Exception) {
                        mRealm.cancelTransaction()
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                if (!mRealm.isClosed) {
                    mRealm.close()
                }
            }
        }
    }

    override fun onDetach() {
        super.onDetach()
        cleanupReferences()
    }

    private fun cleanupReferences() {
        selectedItems?.clear()
        list?.clear()
        selectedItems = null
        list = null
        resources = null
    }

    companion object {
        private val noDataMessages = mapOf(
            "courses" to R.string.no_courses,
            "resources" to R.string.no_resources,
            "finances" to R.string.no_finance_record,
            "news" to R.string.no_voices_available,
            "teamCourses" to R.string.no_team_courses,
            "teamResources" to R.string.no_team_resources,
            "tasks" to R.string.no_tasks,
            "members" to R.string.no_join_request_available,
            "discussions" to R.string.no_news,
            "survey" to R.string.no_surveys,
            "survey_submission" to R.string.no_survey_submissions,
            "exam_submission" to R.string.no_exam_submissions,
            "team" to R.string.no_teams,
            "enterprise" to R.string.no_enterprise,
            "chatHistory" to R.string.no_chats,
            "feedback" to R.string.no_feedback,
            "reports" to R.string.no_reports
        )

        fun showNoData(v: View?, count: Int?, source: String) {
            v ?: return
            v.visibility = if (count == 0) View.VISIBLE else View.GONE
            val messageRes = noDataMessages[source]
                ?: R.string.no_data_available_please_check_and_try_again
            (v as TextView).setText(messageRes)
        }

        fun showNoFilter(v: View?, count: Int) {
            v ?: return
            v.visibility = if (count == 0) View.VISIBLE else View.GONE
            (v as TextView).setText(R.string.no_course_matched_filter)
        }
    }
}
=======
package org.ole.planet.myplanet.base


import android.os.Build
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.annotation.RequiresApi
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import io.realm.RealmList
import io.realm.RealmModel
import io.realm.RealmObject
import io.realm.RealmResults
import java.text.Normalizer
import java.util.Locale
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.model.RealmCourseProgress
import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getAllCourses
import org.ole.planet.myplanet.model.RealmMyCourse.Companion.getMyCourseByUserId
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getMyLibraryByUserId
import org.ole.planet.myplanet.model.RealmMyLibrary.Companion.getOurLibrary
import org.ole.planet.myplanet.model.RealmStepExam
import org.ole.planet.myplanet.model.RealmSubmission
import org.ole.planet.myplanet.model.RealmTag
import org.ole.planet.myplanet.utilities.Utilities.toast

abstract class BaseRecyclerFragment<LI> : BaseRecyclerParentFragment<Any?>(), OnRatingChangeListener {
    var subjects: MutableSet<String> = mutableSetOf()
    var languages: MutableSet<String> = mutableSetOf()
    var mediums: MutableSet<String> = mutableSetOf()
    var levels: MutableSet<String> = mutableSetOf()
    var selectedItems: MutableList<LI>? = null
    var gradeLevel = ""
    var subjectLevel = ""
    lateinit var recyclerView: RecyclerView
    lateinit var tvMessage: TextView
    lateinit var tvFragmentInfo: TextView
    var tvDelete: TextView? = null
    var list: MutableList<LI>? = null
    var resources: List<RealmMyLibrary>? = null
    var courseLib: String? = null
    private var isAddInProgress = false


    abstract fun getLayout(): Int

    abstract fun getAdapter(): RecyclerView.Adapter<*>

    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            isMyCourseLib = it.getBoolean("isMyCourseLib")
            courseLib = it.getString("courseLib")
            @Suppress("UNCHECKED_CAST")
            resources = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                it.getSerializable("resources", ArrayList::class.java) as? ArrayList<RealmMyLibrary>
            } else {
                it.getSerializable("resources") as? ArrayList<RealmMyLibrary>
            }
        }
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        val v = inflater.inflate(getLayout(), container, false)
        recyclerView = v.findViewById(R.id.recycler)
        recyclerView.layoutManager = LinearLayoutManager(activity)
        if (isMyCourseLib) {
            tvDelete = v.findViewById(R.id.tv_delete)
            initDeleteButton()
            v.findViewById<TextView>(R.id.tv_add)?.visibility = View.GONE
        }
        tvMessage = v.findViewById(R.id.tv_message)
        selectedItems = mutableListOf()
        list = mutableListOf()
        mRealm = databaseService.realmInstance
        model = profileDbHandler.userModel
        val adapter = getAdapter()
        recyclerView.adapter = adapter
        if (isMyCourseLib && adapter.itemCount != 0 && courseLib == "courses") {
            resources?.let { showDownloadDialog(it) }
        } else if (isMyCourseLib && courseLib == null && !isSurvey) {
            viewLifecycleOwner.lifecycleScope.launch {
                showDownloadDialog(getLibraryList(mRealm))
            }
        }
        return v
    }

    private fun initDeleteButton() {
        tvDelete?.let {
            it.visibility = View.VISIBLE
            it.setOnClickListener { deleteSelected(false) }
        }
    }

    override fun onRatingChanged() {
        recyclerView.adapter = getAdapter()
    }

    fun addToMyList() {
        if (!isRealmInitialized() || isAddInProgress) return

        val itemsToAdd = selectedItems?.toList() ?: emptyList()
        if (itemsToAdd.isEmpty()) return

        val resourceIds = mutableSetOf<String>()
        val courseIds = mutableSetOf<String>()

        itemsToAdd.forEach { item ->
            val realmObject = item as? RealmObject ?: return@forEach
            when (realmObject) {
                is RealmMyLibrary -> realmObject.resourceId?.let(resourceIds::add)
                is RealmMyCourse -> realmObject.courseId?.let(courseIds::add)
            }
        }

        if (resourceIds.isEmpty() && courseIds.isEmpty()) {
            return
        }

        isAddInProgress = true
        setJoinInProgress(true)

        val userId = profileDbHandler.userModel?.id

        viewLifecycleOwner.lifecycleScope.launch {
            var libraryAdded = false
            var courseAdded = false
            val result = runCatching {
                resourceIds.forEach { resourceId ->
                    if (!userId.isNullOrBlank()) {
                        libraryRepository.updateUserLibrary(resourceId, userId, isAdd = true)
                        libraryAdded = true
                    }
                }

                courseIds.forEach { courseId ->
                    if (courseId.isNotBlank()) {
                        val added = courseRepository.markCourseAdded(courseId, userId)
                        courseAdded = courseAdded || added
                    }
                }
            }

            isAddInProgress = false
            setJoinInProgress(false)
            recyclerView.adapter = getAdapter()
            showNoData(tvMessage, getAdapter().itemCount, "")

            result.exceptionOrNull()?.let { throw it }

            if (libraryAdded) {
                toast(activity, getString(R.string.added_to_my_library))
            }
            if (courseAdded) {
                toast(activity, getString(R.string.added_to_my_courses))
            }
        }
    }

    private fun setJoinInProgress(inProgress: Boolean) {
        recyclerView.isEnabled = !inProgress
        recyclerView.alpha = if (inProgress) 0.6f else 1f
        view?.findViewById<View>(R.id.tv_add)?.let { addButton ->
            addButton.isEnabled = if (inProgress) {
                false
            } else {
                !(selectedItems.isNullOrEmpty())
            }
            addButton.alpha = if (inProgress) 0.5f else 1f
        }
    }

    fun deleteSelected(deleteProgress: Boolean) {
        selectedItems?.forEach { item ->
            try {
                if (!mRealm.isInTransaction) {
                    mRealm.beginTransaction()
                }
                val `object` = item as RealmObject
                deleteCourseProgress(deleteProgress, `object`)
                removeFromShelf(`object`)
                if (mRealm.isInTransaction) {
                    mRealm.commitTransaction()
                }
            } catch (e: Exception) {
                if (mRealm.isInTransaction) {
                    mRealm.cancelTransaction()
                }
                throw e
            }
        }
        recyclerView.adapter = getAdapter()
        showNoData(tvMessage, getAdapter().itemCount, "")
    }

    fun countSelected(): Int {
        return selectedItems?.size ?: 0
    }

    private fun deleteCourseProgress(deleteProgress: Boolean, `object`: RealmObject) {
        if (deleteProgress && `object` is RealmMyCourse) {
            mRealm.where(RealmCourseProgress::class.java).equalTo("courseId", `object`.courseId).findAll().deleteAllFromRealm()
            val examList: List<RealmStepExam> = mRealm.where(RealmStepExam::class.java).equalTo("courseId", `object`.courseId).findAll()
            for (exam in examList) {
                mRealm.where(RealmSubmission::class.java).equalTo("parentId", exam.id)
                    .notEqualTo("type", "survey").equalTo("uploaded", false).findAll()
                    .deleteAllFromRealm()
            }
        }
    }

    private fun checkAndAddToList(course: RealmMyCourse?, courses: MutableList<RealmMyCourse>, tags: List<RealmTag>) {
        for (tg in tags) {
            val count = mRealm.where(RealmTag::class.java).equalTo("db", "courses").equalTo("tagId", tg.id)
                .equalTo("linkId", course?.courseId).count()
            if (count > 0 && !courses.contains(course)) {
                course?.let { courses.add(it) }
            }
        }
    }

    private fun <LI : RealmModel> getData(s: String, c: Class<LI>): List<LI> {
        if (s.isEmpty()) return mRealm.where(c).findAll()

        val queryParts = s.split(" ").filterNot { it.isEmpty() }
        val data: RealmResults<LI> = mRealm.where(c).findAll()
        val normalizedQuery = normalizeText(s)
        val startsWithQuery = mutableListOf<LI>()
        val containsQuery = mutableListOf<LI>()

        for (item in data) {
            val title = getTitle(item, c)?.let { normalizeText(it) } ?: continue

            if (title.startsWith(normalizedQuery, ignoreCase = true)) {
                startsWithQuery.add(item)
            } else if (queryParts.all { title.contains(normalizeText(it), ignoreCase = true) }) {
                containsQuery.add(item)
            }
        }
        return startsWithQuery + containsQuery
    }

    private fun <LI : RealmModel> getTitle(item: LI, c: Class<LI>): String? {
        return when {
            c.isAssignableFrom(RealmMyLibrary::class.java) -> (item as RealmMyLibrary).title
            else -> (item as RealmMyCourse).courseTitle
        }
    }

    fun filterLibraryByTag(s: String, tags: List<RealmTag>): List<RealmMyLibrary> {
        val normalizedSearchTerm = normalizeText(s)
        var list = getData(s, RealmMyLibrary::class.java)
        list = if (isMyCourseLib) {
            getMyLibraryByUserId(model?.id, list)
        } else {
            getOurLibrary(model?.id, list)
        }

        val libraries = if (tags.isNotEmpty()) {
            val filteredLibraries = mutableListOf<RealmMyLibrary>()
            for (library in list) {
                filter(tags, library, filteredLibraries)
            }
            filteredLibraries
        } else {
            list
        }

        return libraries
    }

    fun normalizeText(str: String): String {
        return Normalizer.normalize(str.lowercase(Locale.getDefault()), Normalizer.Form.NFD)
            .replace(Regex("\\p{InCombiningDiacriticalMarks}+"), "")
    }

    fun filterCourseByTag(s: String, tags: List<RealmTag>): List<RealmMyCourse> {
        if (tags.isEmpty() && s.isEmpty()) {
            return applyCourseFilter(filterRealmMyCourseList(getList(RealmMyCourse::class.java)))
        }
        var list = getData(s, RealmMyCourse::class.java)
        list = if (isMyCourseLib) {
            getMyCourseByUserId(model?.id, list)
        } else {
            getAllCourses(model?.id, list)
        }
        if (tags.isEmpty()) {
            return list
        }
        val courses = RealmList<RealmMyCourse>()
        list.forEach { course ->
            checkAndAddToList(course, courses, tags)
        }
        return applyCourseFilter(courses)
    }

    private fun filterRealmMyCourseList(items: List<Any?>): List<RealmMyCourse> {
        return items.filterIsInstance<RealmMyCourse>()
    }

    private fun filter(tags: List<RealmTag>, library: RealmMyLibrary?, libraries: MutableList<RealmMyLibrary>) {
        for (tg in tags) {
            val count = mRealm.where(RealmTag::class.java).equalTo("db", "resources")
                .equalTo("tagId", tg.id).equalTo("linkId", library?.id).count()
            if (count > 0 && !libraries.contains(library)) {
                library?.let { libraries.add(it) }
            }
        }
    }

    fun applyFilter(libraries: List<RealmMyLibrary>): List<RealmMyLibrary> {
        val newList: MutableList<RealmMyLibrary> = ArrayList()
        for (l in libraries) {
            if (isValidFilter(l)) newList.add(l)
        }
        return newList
    }

    private fun applyCourseFilter(courses: List<RealmMyCourse>): List<RealmMyCourse> {
        if (TextUtils.isEmpty(subjectLevel) && TextUtils.isEmpty(gradeLevel)) return courses
        val newList: MutableList<RealmMyCourse> = ArrayList()
        for (l in courses) {
            if (TextUtils.equals(l.gradeLevel, gradeLevel) || TextUtils.equals(
                    l.subjectLevel, subjectLevel
                )
            ) {
                newList.add(l)
            }
        }
        return newList
    }

    private fun isValidFilter(l: RealmMyLibrary): Boolean {
        val sub = subjects.isEmpty() || subjects.let { l.subject?.containsAll(it) } == true
        val lev = levels.isEmpty() || l.level?.containsAll(levels) == true
        val lan = languages.isEmpty() || languages.contains(l.language)
        val med = mediums.isEmpty() || mediums.contains(l.mediaType)
        return sub && lev && lan && med
    }

    override fun onDestroy() {
        cleanupRealm()
        super.onDestroy()
    }

    private fun cleanupRealm() {
        if (isRealmInitialized()) {
            try {
                mRealm.removeAllChangeListeners()

                if (mRealm.isInTransaction) {
                    try {
                        mRealm.commitTransaction()
                    } catch (e: Exception) {
                        mRealm.cancelTransaction()
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                if (!mRealm.isClosed) {
                    mRealm.close()
                }
            }
        }
    }

    override fun onDetach() {
        super.onDetach()
        cleanupReferences()
    }

    private fun cleanupReferences() {
        selectedItems?.clear()
        list?.clear()
        selectedItems = null
        list = null
        resources = null
    }

    companion object {
        private val noDataMessages = mapOf(
            "courses" to R.string.no_courses,
            "resources" to R.string.no_resources,
            "finances" to R.string.no_finance_record,
            "news" to R.string.no_voices_available,
            "teamCourses" to R.string.no_team_courses,
            "teamResources" to R.string.no_team_resources,
            "tasks" to R.string.no_tasks,
            "members" to R.string.no_join_request_available,
            "discussions" to R.string.no_news,
            "survey" to R.string.no_surveys,
            "survey_submission" to R.string.no_survey_submissions,
            "exam_submission" to R.string.no_exam_submissions,
            "team" to R.string.no_teams,
            "enterprise" to R.string.no_enterprise,
            "chatHistory" to R.string.no_chats,
            "feedback" to R.string.no_feedback,
            "reports" to R.string.no_reports
        )

        fun showNoData(v: View?, count: Int?, source: String) {
            v ?: return
            v.visibility = if (count == 0) View.VISIBLE else View.GONE
            val messageRes = noDataMessages[source]
                ?: R.string.no_data_available_please_check_and_try_again
            (v as TextView).setText(messageRes)
        }

        fun showNoFilter(v: View?, count: Int) {
            v ?: return
            v.visibility = if (count == 0) View.VISIBLE else View.GONE
            (v as TextView).setText(R.string.no_course_matched_filter)
        }
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/base/BaseMemberFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.base

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.databinding.FragmentMembersBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.team.BaseTeamFragment

abstract class BaseMemberFragment : BaseTeamFragment() {
    abstract val list: List<RealmUserModel?>
    abstract val adapter: RecyclerView.Adapter<*>?
    abstract val layoutManager: RecyclerView.LayoutManager?
    private var _binding: FragmentMembersBinding? = null
    protected val binding get() = _binding!!
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMembersBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.rvMember.layoutManager = layoutManager
        binding.rvMember.adapter = adapter
        showNoData(binding.tvNodata, list.size, "members")
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
=======
package org.ole.planet.myplanet.base


import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.RecyclerView
import org.ole.planet.myplanet.databinding.FragmentMembersBinding
import org.ole.planet.myplanet.model.RealmUserModel
import org.ole.planet.myplanet.ui.team.BaseTeamFragment

abstract class BaseMemberFragment : BaseTeamFragment() {
    abstract val list: List<RealmUserModel?>
    abstract val adapter: RecyclerView.Adapter<*>?
    abstract val layoutManager: RecyclerView.LayoutManager?
    private var _binding: FragmentMembersBinding? = null
    protected val binding get() = _binding!!
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMembersBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.rvMember.layoutManager = layoutManager
        binding.rvMember.adapter = adapter
        showNoData(binding.tvNodata, list.size, "members")
    }

    override fun onDestroyView() {
        _binding = null
        super.onDestroyView()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/base/BaseContainerFragment.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.base

import android.app.Activity
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.os.Bundle
import android.provider.Settings
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.TextView
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.view.ContextThemeWrapper
import androidx.appcompat.widget.AppCompatRatingBar
import androidx.core.content.FileProvider
import androidx.core.net.toUri
import androidx.lifecycle.lifecycleScope
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import java.io.File
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.PermissionActivity.Companion.hasInstallPermission
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.service.UserProfileDbHandler.Companion.KEY_RESOURCE_DOWNLOAD
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.viewer.WebViewActivity
import org.ole.planet.myplanet.utilities.CourseRatingUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.ResourceOpener
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
abstract class BaseContainerFragment : BaseResourceFragment() {
    private var timesRated: TextView? = null
    var rating: TextView? = null
    private var ratingBar: AppCompatRatingBar? = null
    private val installUnknownSourcesRequestCode = 112
    private var hasInstallPermissionValue = false
    private var currentLibrary: RealmMyLibrary? = null
    private var installApkLauncher: ActivityResultLauncher<Intent>? = null
    lateinit var prefData: SharedPrefManager
    private var pendingAutoOpenLibrary: RealmMyLibrary? = null
    private var shouldAutoOpenAfterDownload = false
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        hasInstallPermissionValue = hasInstallPermission(requireContext())
        if (!BuildConfig.LITE) {
            installApkLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
                if (result.resultCode == Activity.RESULT_OK) {
                    currentLibrary?.let {
                        installApk(it)
                        currentLibrary = null
                    }
                }
            }
        }
        prefData = SharedPrefManager(requireContext())
    }

    fun setRatings(`object`: JsonObject?) {
        if (`object` != null) {
            CourseRatingUtils.showRating(requireContext(), `object`, rating, timesRated, ratingBar)
        }
    }
    fun getUrlsAndStartDownload(lib: List<RealmMyLibrary?>, urls: ArrayList<String>) {
        for (library in lib) {
            val url = UrlUtils.getUrl(library)
            if (!FileUtils.checkFileExist(requireContext(), url) && !TextUtils.isEmpty(url)) {
                urls.add(url)
            }
        }
        if (urls.isNotEmpty()) {
            startDownload(urls)
        }
    }
    fun startDownloadWithAutoOpen(urls: ArrayList<String>, libraryToOpen: RealmMyLibrary? = null) {
        if (libraryToOpen != null) {
            pendingAutoOpenLibrary = libraryToOpen
            shouldAutoOpenAfterDownload = true
        }
        startDownload(urls)
    }
    override fun onDownloadComplete() {
        super.onDownloadComplete()
        if (shouldAutoOpenAfterDownload && pendingAutoOpenLibrary != null) {
            pendingAutoOpenLibrary?.let { library ->
                shouldAutoOpenAfterDownload = false
                pendingAutoOpenLibrary = null

                val isDownloaded = if (library.mediaType == "HTML") {
                    val directory = File(context?.getExternalFilesDir(null), "ole/${library.resourceId}")
                    val indexFile = File(directory, "index.html")
                    indexFile.exists()
                } else {
                    library.isResourceOffline() || FileUtils.checkFileExist(requireContext(), UrlUtils.getUrl(library))
                }

                if (isDownloaded) {
                    openResource(library)
                }
            }
        }
    }
    fun initRatingView(type: String?, id: String?, title: String?, listener: OnRatingChangeListener?) {
        timesRated = requireView().findViewById(R.id.times_rated)
        rating = requireView().findViewById(R.id.tv_rating)
        ratingBar = requireView().findViewById(R.id.rating_bar)
        ratingBar?.apply {
            setOnTouchListener { view, e: MotionEvent ->
                if (e.action == MotionEvent.ACTION_UP) {
                    view.performClick()
                }
                true
            }
            val userModel = profileDbHandler.userModel
            if (userModel?.isGuest() == false) {
                setOnClickListener {
                    homeItemClickListener?.showRatingDialog(type, id, title, listener)
                }
            }
        }
    }
    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) {
            homeItemClickListener = context
        }
    }

    private fun dismissProgressDialog() {
        try {
            if (prgDialog.isShowing()) {
                prgDialog.dismiss()
            }
        } catch (e: UninitializedPropertyAccessException) {
            e.printStackTrace()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
    fun openResource(items: RealmMyLibrary) {
        dismissProgressDialog()
        if (items.mediaType == "HTML") {
            openHtmlResource(items)
        } else {
            openNonHtmlResource(items)
        }
    }

    private fun openHtmlResource(items: RealmMyLibrary) {
        val directory = File(context?.getExternalFilesDir(null), "ole/${items.resourceId}")
        val indexFile = File(directory, "index.html")

        if (indexFile.exists()) {
            val intent = Intent(activity, WebViewActivity::class.java)
            intent.putExtra("RESOURCE_ID", items.id)
            intent.putExtra("LOCAL_ADDRESS", items.resourceLocalAddress)
            intent.putExtra("title", items.title)
            startActivity(intent)
            return
        }

        viewLifecycleOwner.lifecycleScope.launch {
            val resource = items.resourceId?.let { libraryRepository.getLibraryItemByResourceId(it) }
            val downloadUrls = resource?.attachments
                ?.mapNotNull { attachment ->
                    attachment.name?.let { name ->
                        createAttachmentDir(items.resourceId, name)
                        UrlUtils.getUrl("${items.resourceId}", name)
                    }
                }
                ?.toCollection(ArrayList()) ?: arrayListOf()

            if (downloadUrls.isNotEmpty()) {
                startDownloadWithAutoOpen(downloadUrls, items)
            } else {
                val errorMessage = when {
                    resource == null -> getString(R.string.resource_not_found_in_database)
                    resource.attachments.isNullOrEmpty() -> getString(R.string.resource_has_no_attachments)
                    else -> getString(R.string.unable_to_download_resource)
                }
                Utilities.toast(activity, errorMessage)
            }
        }
    }

    private fun createAttachmentDir(resourceId: String?, name: String) {
        val baseDir = File(context?.getExternalFilesDir(null), "ole/$resourceId")
        val lastSlashIndex = name.lastIndexOf('/')
        if (lastSlashIndex > 0) {
            val dirPath = name.substring(0, lastSlashIndex)
            File(baseDir, dirPath).mkdirs()
        }
    }

    private fun openNonHtmlResource(items: RealmMyLibrary) {
        viewLifecycleOwner.lifecycleScope.launch {
            val matchingItems = items.resourceLocalAddress?.let {
                libraryRepository.getLibraryItemsByLocalAddress(it)
            } ?: emptyList()

            val offlineItem = matchingItems.firstOrNull { it.isResourceOffline() }
            if (offlineItem != null) {
                ResourceOpener.openFileType(requireActivity(), offlineItem, "offline", profileDbHandler)
                return@launch
            }

            when {
                items.isResourceOffline() -> ResourceOpener.openFileType(
                    requireActivity(), items, "offline", profileDbHandler
                )
                FileUtils.getFileExtension(items.resourceLocalAddress) == "mp4" -> ResourceOpener.openFileType(
                    requireActivity(), items, "online", profileDbHandler
                )
                else -> {
                    val arrayList = arrayListOf(UrlUtils.getUrl(items))
                    startDownloadWithAutoOpen(arrayList, items)
                    profileDbHandler.setResourceOpenCount(items, KEY_RESOURCE_DOWNLOAD)
                }
            }
        }
    }

    private fun installApk(items: RealmMyLibrary) {
        if (BuildConfig.LITE) return
        currentLibrary = items
        val directory = File(requireContext().getExternalFilesDir(null).toString() + "/ole" + "/" + items.id)
        if (!directory.exists()) {
            if (!directory.mkdirs()) {
                throw RuntimeException("Failed to create directory: " + directory.absolutePath)
            }
        }
        val apkFile = items.resourceLocalAddress?.let { File(directory, it) }
        if (apkFile != null) {
            if (!apkFile.exists()) {
                Utilities.toast(activity,"APK file not found")
                return
            }
        }
        val uri = apkFile?.let {
            FileProvider.getUriForFile(requireContext(), "${requireContext().packageName}.fileprovider", it)
        }
        val intent = Intent(Intent.ACTION_VIEW).apply {
            setDataAndType(uri, "application/vnd.android.package-archive")
            flags = Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_ACTIVITY_NEW_TASK
        }
        if (intent.resolveActivity(requireActivity().packageManager) != null) {
            if (hasInstallPermission(requireContext())) {
                startActivity(intent)
            } else {
                requestInstallPermission()
            }
        } else {
            Utilities.toast(activity,"No app to handle the installation")
        }
    }

    private fun requestInstallPermission() {
        if (BuildConfig.LITE) return
        val intent = Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES)
        intent.data = ("package:" + requireContext().packageName).toUri()
        installApkLauncher?.launch(intent)
    }

    private fun openFileType(items: RealmMyLibrary, videoType: String) {
        dismissProgressDialog()
        ResourceOpener.openFileType(requireActivity(), items, videoType, profileDbHandler)
    }

    private fun showResourceList(downloadedResources: List<RealmMyLibrary>) {
        val builderSingle = AlertDialog.Builder(ContextThemeWrapper(requireActivity(), R.style.CustomAlertDialog))
        builderSingle.setTitle(getString(R.string.select_resource_to_open))
        val arrayAdapter: ArrayAdapter<RealmMyLibrary?> = object : ArrayAdapter<RealmMyLibrary?>(
            requireActivity(), android.R.layout.select_dialog_item, downloadedResources
        ) {
            override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
                var view = convertView
                if (view == null) view = LayoutInflater.from(activity)
                    .inflate(android.R.layout.select_dialog_item, parent, false)
                val tv = view as TextView
                val library = getItem(position)
                tv.setCompoundDrawablesWithIntrinsicBounds(0, 0,
                    if (library?.isResourceOffline() == true) {
                        R.drawable.ic_eye
                    } else {
                        R.drawable.ic_download
                    }, 0)
                tv.setTextColor(context.getColor(R.color.daynight_textColor))
                tv.text = library?.title
                return tv
            }
        }
        builderSingle.setAdapter(arrayAdapter) { _: DialogInterface?, i: Int ->
            val library = arrayAdapter.getItem(i)
            library?.let { openResource(it) }
        }
        builderSingle.setNegativeButton(R.string.dismiss, null).show()
    }

    fun setOpenResourceButton(downloadedResources: List<RealmMyLibrary>?, btnOpen: Button) {
        if (downloadedResources.isNullOrEmpty()) {
            btnOpen.visibility = View.GONE
        } else {
            btnOpen.visibility = View.VISIBLE
            btnOpen.setOnClickListener {
                if (downloadedResources.size == 1) {
                    openResource(downloadedResources[0])
                } else {
                    showResourceList(downloadedResources)
                }
            }
        }
    }
    fun setResourceButton(resources: List<RealmMyLibrary>?, btnResources: Button) {
        if (resources.isNullOrEmpty()) {
            btnResources.visibility = View.GONE
        } else {
            btnResources.visibility = View.VISIBLE
            btnResources.text = getString(R.string.resources_size, resources.size)
            btnResources.setOnClickListener {
                if (resources.isNotEmpty()) {
                    showDownloadDialog(resources)
                }
            }
        }
    }

    open fun handleBackPressed() {
        NavigationHelper.popBackStack(parentFragmentManager)
    }

    override fun onPause() {
        super.onPause()
        dismissProgressDialog()
    }

    override fun onDestroy() {
        dismissProgressDialog()
        super.onDestroy()
    }
}
=======
package org.ole.planet.myplanet.base


import android.app.Activity
import android.content.Context
import android.content.DialogInterface
import android.content.Intent
import android.os.Bundle
import android.provider.Settings
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.TextView
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.view.ContextThemeWrapper
import androidx.appcompat.widget.AppCompatRatingBar
import androidx.core.content.FileProvider
import androidx.core.net.toUri
import androidx.lifecycle.lifecycleScope
import com.google.gson.JsonObject
import dagger.hilt.android.AndroidEntryPoint
import java.io.File
import kotlinx.coroutines.launch
import org.ole.planet.myplanet.BuildConfig
import org.ole.planet.myplanet.R
import org.ole.planet.myplanet.base.PermissionActivity.Companion.hasInstallPermission
import org.ole.planet.myplanet.callback.OnHomeItemClickListener
import org.ole.planet.myplanet.callback.OnRatingChangeListener
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.service.UserProfileDbHandler.Companion.KEY_RESOURCE_DOWNLOAD
import org.ole.planet.myplanet.ui.navigation.NavigationHelper
import org.ole.planet.myplanet.ui.viewer.WebViewActivity
import org.ole.planet.myplanet.utilities.CourseRatingUtils
import org.ole.planet.myplanet.utilities.FileUtils
import org.ole.planet.myplanet.utilities.ResourceOpener
import org.ole.planet.myplanet.utilities.SharedPrefManager
import org.ole.planet.myplanet.utilities.UrlUtils
import org.ole.planet.myplanet.utilities.Utilities

@AndroidEntryPoint
abstract class BaseContainerFragment : BaseResourceFragment() {
    private var timesRated: TextView? = null
    var rating: TextView? = null
    private var ratingBar: AppCompatRatingBar? = null
    private val installUnknownSourcesRequestCode = 112
    private var hasInstallPermissionValue = false
    private var currentLibrary: RealmMyLibrary? = null
    private var installApkLauncher: ActivityResultLauncher<Intent>? = null
    lateinit var prefData: SharedPrefManager
    private var pendingAutoOpenLibrary: RealmMyLibrary? = null
    private var shouldAutoOpenAfterDownload = false
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        hasInstallPermissionValue = hasInstallPermission(requireContext())
        if (!BuildConfig.LITE) {
            installApkLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
                if (result.resultCode == Activity.RESULT_OK) {
                    currentLibrary?.let {
                        installApk(it)
                        currentLibrary = null
                    }
                }
            }
        }
        prefData = SharedPrefManager(requireContext())
    }

    fun setRatings(`object`: JsonObject?) {
        if (`object` != null) {
            CourseRatingUtils.showRating(requireContext(), `object`, rating, timesRated, ratingBar)
        }
    }
    fun getUrlsAndStartDownload(lib: List<RealmMyLibrary?>, urls: ArrayList<String>) {
        for (library in lib) {
            val url = UrlUtils.getUrl(library)
            if (!FileUtils.checkFileExist(requireContext(), url) && !TextUtils.isEmpty(url)) {
                urls.add(url)
            }
        }
        if (urls.isNotEmpty()) {
            startDownload(urls)
        }
    }
    fun startDownloadWithAutoOpen(urls: ArrayList<String>, libraryToOpen: RealmMyLibrary? = null) {
        if (libraryToOpen != null) {
            pendingAutoOpenLibrary = libraryToOpen
            shouldAutoOpenAfterDownload = true
        }
        startDownload(urls)
    }
    override fun onDownloadComplete() {
        super.onDownloadComplete()
        if (shouldAutoOpenAfterDownload && pendingAutoOpenLibrary != null) {
            pendingAutoOpenLibrary?.let { library ->
                shouldAutoOpenAfterDownload = false
                pendingAutoOpenLibrary = null

                val isDownloaded = if (library.mediaType == "HTML") {
                    val directory = File(context?.getExternalFilesDir(null), "ole/${library.resourceId}")
                    val indexFile = File(directory, "index.html")
                    indexFile.exists()
                } else {
                    library.isResourceOffline() || FileUtils.checkFileExist(requireContext(), UrlUtils.getUrl(library))
                }

                if (isDownloaded) {
                    openResource(library)
                }
            }
        }
    }
    fun initRatingView(type: String?, id: String?, title: String?, listener: OnRatingChangeListener?) {
        timesRated = requireView().findViewById(R.id.times_rated)
        rating = requireView().findViewById(R.id.tv_rating)
        ratingBar = requireView().findViewById(R.id.rating_bar)
        ratingBar?.apply {
            setOnTouchListener { view, e: MotionEvent ->
                if (e.action == MotionEvent.ACTION_UP) {
                    view.performClick()
                }
                true
            }
            val userModel = profileDbHandler.userModel
            if (userModel?.isGuest() == false) {
                setOnClickListener {
                    homeItemClickListener?.showRatingDialog(type, id, title, listener)
                }
            }
        }
    }
    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnHomeItemClickListener) {
            homeItemClickListener = context
        }
    }

    private fun dismissProgressDialog() {
        try {
            if (prgDialog.isShowing()) {
                prgDialog.dismiss()
            }
        } catch (e: UninitializedPropertyAccessException) {
            e.printStackTrace()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
    fun openResource(items: RealmMyLibrary) {
        dismissProgressDialog()
        if (items.mediaType == "HTML") {
            openHtmlResource(items)
        } else {
            openNonHtmlResource(items)
        }
    }

    private fun openHtmlResource(items: RealmMyLibrary) {
        val directory = File(context?.getExternalFilesDir(null), "ole/${items.resourceId}")
        val indexFile = File(directory, "index.html")

        if (indexFile.exists()) {
            val intent = Intent(activity, WebViewActivity::class.java)
            intent.putExtra("RESOURCE_ID", items.id)
            intent.putExtra("LOCAL_ADDRESS", items.resourceLocalAddress)
            intent.putExtra("title", items.title)
            startActivity(intent)
            return
        }

        viewLifecycleOwner.lifecycleScope.launch {
            val resource = items.resourceId?.let { libraryRepository.getLibraryItemByResourceId(it) }
            val downloadUrls = resource?.attachments
                ?.mapNotNull { attachment ->
                    attachment.name?.let { name ->
                        createAttachmentDir(items.resourceId, name)
                        UrlUtils.getUrl("${items.resourceId}", name)
                    }
                }
                ?.toCollection(ArrayList()) ?: arrayListOf()

            if (downloadUrls.isNotEmpty()) {
                startDownloadWithAutoOpen(downloadUrls, items)
            } else {
                val errorMessage = when {
                    resource == null -> getString(R.string.resource_not_found_in_database)
                    resource.attachments.isNullOrEmpty() -> getString(R.string.resource_has_no_attachments)
                    else -> getString(R.string.unable_to_download_resource)
                }
                Utilities.toast(activity, errorMessage)
            }
        }
    }

    private fun createAttachmentDir(resourceId: String?, name: String) {
        val baseDir = File(context?.getExternalFilesDir(null), "ole/$resourceId")
        val lastSlashIndex = name.lastIndexOf('/')
        if (lastSlashIndex > 0) {
            val dirPath = name.substring(0, lastSlashIndex)
            File(baseDir, dirPath).mkdirs()
        }
    }

    private fun openNonHtmlResource(items: RealmMyLibrary) {
        viewLifecycleOwner.lifecycleScope.launch {
            val matchingItems = items.resourceLocalAddress?.let {
                libraryRepository.getLibraryItemsByLocalAddress(it)
            } ?: emptyList()

            val offlineItem = matchingItems.firstOrNull { it.isResourceOffline() }
            if (offlineItem != null) {
                ResourceOpener.openFileType(requireActivity(), offlineItem, "offline", profileDbHandler)
                return@launch
            }

            when {
                items.isResourceOffline() -> ResourceOpener.openFileType(
                    requireActivity(), items, "offline", profileDbHandler
                )
                FileUtils.getFileExtension(items.resourceLocalAddress) == "mp4" -> ResourceOpener.openFileType(
                    requireActivity(), items, "online", profileDbHandler
                )
                else -> {
                    val arrayList = arrayListOf(UrlUtils.getUrl(items))
                    startDownloadWithAutoOpen(arrayList, items)
                    profileDbHandler.setResourceOpenCount(items, KEY_RESOURCE_DOWNLOAD)
                }
            }
        }
    }

    private fun installApk(items: RealmMyLibrary) {
        if (BuildConfig.LITE) return
        currentLibrary = items
        val directory = File(requireContext().getExternalFilesDir(null).toString() + "/ole" + "/" + items.id)
        if (!directory.exists()) {
            if (!directory.mkdirs()) {
                throw RuntimeException("Failed to create directory: " + directory.absolutePath)
            }
        }
        val apkFile = items.resourceLocalAddress?.let { File(directory, it) }
        if (apkFile != null) {
            if (!apkFile.exists()) {
                Utilities.toast(activity,"APK file not found")
                return
            }
        }
        val uri = apkFile?.let {
            FileProvider.getUriForFile(requireContext(), "${requireContext().packageName}.fileprovider", it)
        }
        val intent = Intent(Intent.ACTION_VIEW).apply {
            setDataAndType(uri, "application/vnd.android.package-archive")
            flags = Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_ACTIVITY_NEW_TASK
        }
        if (intent.resolveActivity(requireActivity().packageManager) != null) {
            if (hasInstallPermission(requireContext())) {
                startActivity(intent)
            } else {
                requestInstallPermission()
            }
        } else {
            Utilities.toast(activity,"No app to handle the installation")
        }
    }

    private fun requestInstallPermission() {
        if (BuildConfig.LITE) return
        val intent = Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES)
        intent.data = ("package:" + requireContext().packageName).toUri()
        installApkLauncher?.launch(intent)
    }

    private fun openFileType(items: RealmMyLibrary, videoType: String) {
        dismissProgressDialog()
        ResourceOpener.openFileType(requireActivity(), items, videoType, profileDbHandler)
    }

    private fun showResourceList(downloadedResources: List<RealmMyLibrary>) {
        val builderSingle = AlertDialog.Builder(ContextThemeWrapper(requireActivity(), R.style.CustomAlertDialog))
        builderSingle.setTitle(getString(R.string.select_resource_to_open))
        val arrayAdapter: ArrayAdapter<RealmMyLibrary?> = object : ArrayAdapter<RealmMyLibrary?>(
            requireActivity(), android.R.layout.select_dialog_item, downloadedResources
        ) {
            override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
                var view = convertView
                if (view == null) view = LayoutInflater.from(activity)
                    .inflate(android.R.layout.select_dialog_item, parent, false)
                val tv = view as TextView
                val library = getItem(position)
                tv.setCompoundDrawablesWithIntrinsicBounds(0, 0,
                    if (library?.isResourceOffline() == true) {
                        R.drawable.ic_eye
                    } else {
                        R.drawable.ic_download
                    }, 0)
                tv.setTextColor(context.getColor(R.color.daynight_textColor))
                tv.text = library?.title
                return tv
            }
        }
        builderSingle.setAdapter(arrayAdapter) { _: DialogInterface?, i: Int ->
            val library = arrayAdapter.getItem(i)
            library?.let { openResource(it) }
        }
        builderSingle.setNegativeButton(R.string.dismiss, null).show()
    }

    fun setOpenResourceButton(downloadedResources: List<RealmMyLibrary>?, btnOpen: Button) {
        if (downloadedResources.isNullOrEmpty()) {
            btnOpen.visibility = View.GONE
        } else {
            btnOpen.visibility = View.VISIBLE
            btnOpen.setOnClickListener {
                if (downloadedResources.size == 1) {
                    openResource(downloadedResources[0])
                } else {
                    showResourceList(downloadedResources)
                }
            }
        }
    }
    fun setResourceButton(resources: List<RealmMyLibrary>?, btnResources: Button) {
        if (resources.isNullOrEmpty()) {
            btnResources.visibility = View.GONE
        } else {
            btnResources.visibility = View.VISIBLE
            btnResources.text = getString(R.string.resources_size, resources.size)
            btnResources.setOnClickListener {
                if (resources.isNotEmpty()) {
                    showDownloadDialog(resources)
                }
            }
        }
    }

    open fun handleBackPressed() {
        NavigationHelper.popBackStack(parentFragmentManager)
    }

    override fun onPause() {
        super.onPause()
        dismissProgressDialog()
    }

    override fun onDestroy() {
        dismissProgressDialog()
        super.onDestroy()
    }
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/callback/OnLibraryItemSelected.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.callback

import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmTag

interface OnLibraryItemSelected {
    @JvmSuppressWildcards
    fun onSelectedListChange(list: MutableList<RealmMyLibrary?>)
    @JvmSuppressWildcards
    fun onTagClicked(realmTag: RealmTag)
}
=======
package org.ole.planet.myplanet.callback


import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmTag

interface OnLibraryItemSelected {
    @JvmSuppressWildcards
    fun onSelectedListChange(list: MutableList<RealmMyLibrary?>)
    @JvmSuppressWildcards
    fun onTagClicked(realmTag: RealmTag)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/callback/OnHomeItemClickListener.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.callback

import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmStepExam

interface OnHomeItemClickListener {
    fun openMyFragment(f: Fragment)
    fun openCallFragment(f: Fragment)
    fun openLibraryDetailFragment(library: RealmMyLibrary?)
    fun showRatingDialog(type: String?, resourceId: String?, title: String?, listener: OnRatingChangeListener?)

    fun sendSurvey(current: RealmStepExam?)
}
=======
package org.ole.planet.myplanet.callback


import androidx.fragment.app.Fragment
import org.ole.planet.myplanet.model.RealmMyLibrary
import org.ole.planet.myplanet.model.RealmStepExam

interface OnHomeItemClickListener {
    fun openMyFragment(f: Fragment)
    fun openCallFragment(f: Fragment)
    fun openLibraryDetailFragment(library: RealmMyLibrary?)
    fun showRatingDialog(type: String?, resourceId: String?, title: String?, listener: OnRatingChangeListener?)

    fun sendSurvey(current: RealmStepExam?)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/callback/OnSelectedMyPersonal.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.callback

import org.ole.planet.myplanet.model.RealmMyPersonal

interface OnSelectedMyPersonal {
    fun onUpload(personal: RealmMyPersonal?)
    fun onAddedResource()
    fun onEditPersonal(personal: RealmMyPersonal)
    fun onDeletePersonal(personal: RealmMyPersonal)
}
=======
package org.ole.planet.myplanet.callback


import org.ole.planet.myplanet.model.RealmMyPersonal

interface OnSelectedMyPersonal {
    fun onUpload(personal: RealmMyPersonal?)
    fun onAddedResource()
    fun onEditPersonal(personal: RealmMyPersonal)
    fun onDeletePersonal(personal: RealmMyPersonal)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/callback/TagClickListener.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.callback

import org.ole.planet.myplanet.model.RealmTag

interface TagClickListener {
    @JvmSuppressWildcards
    fun onTagSelected(tag: RealmTag)
    @JvmSuppressWildcards
    fun onOkClicked(list: List<RealmTag>?)
}
=======
package org.ole.planet.myplanet.callback


import org.ole.planet.myplanet.model.RealmTag

interface TagClickListener {
    @JvmSuppressWildcards
    fun onTagSelected(tag: RealmTag)
    @JvmSuppressWildcards
    fun onOkClicked(list: List<RealmTag>?)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/callback/OnCourseItemSelected.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet.callback

import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmTag

interface OnCourseItemSelected {
    @JvmSuppressWildcards
    fun onSelectedListChange(list: MutableList<RealmMyCourse?>)
    fun onTagClicked(tag: RealmTag?)
}
=======
package org.ole.planet.myplanet.callback


import org.ole.planet.myplanet.model.RealmMyCourse
import org.ole.planet.myplanet.model.RealmTag

interface OnCourseItemSelected {
    @JvmSuppressWildcards
    fun onSelectedListChange(list: MutableList<RealmMyCourse?>)
    fun onTagClicked(tag: RealmTag?)
}
>>>>>>> REPLACE



--- DIFF FOR ./app/src/main/java/org/ole/planet/myplanet/MainApplication.kt ---
<<<<<<< SEARCH
package org.ole.planet.myplanet

import android.app.Activity
import android.app.Application
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.content.res.Configuration
import android.os.Bundle
import android.os.StrictMode
import android.os.StrictMode.VmPolicy
import android.provider.Settings
import androidx.appcompat.app.AppCompatDelegate
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.PeriodicWorkRequest
import androidx.work.WorkManager
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.android.HiltAndroidApp
import java.net.HttpURLConnection
import java.net.URL
import java.util.Date
import java.util.UUID
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.backgroundDownload
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.getAllLibraryList
import org.ole.planet.myplanet.callback.TeamPageListener
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.ApiClientEntryPoint
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.di.ApplicationScopeEntryPoint
import org.ole.planet.myplanet.di.DefaultPreferences
import org.ole.planet.myplanet.di.WorkerDependenciesEntryPoint
import org.ole.planet.myplanet.model.RealmApkLog
import org.ole.planet.myplanet.service.AutoSyncWorker
import org.ole.planet.myplanet.service.NetworkMonitorWorker
import org.ole.planet.myplanet.service.StayOnlineWorker
import org.ole.planet.myplanet.service.TaskNotificationWorker
import org.ole.planet.myplanet.utilities.ANRWatchdog
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DownloadUtils.downloadAllFiles
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.NetworkUtils.isNetworkConnectedFlow
import org.ole.planet.myplanet.utilities.NetworkUtils.startListenNetworkState
import org.ole.planet.myplanet.utilities.NetworkUtils.stopListenNetworkState
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.ThemeMode
import org.ole.planet.myplanet.utilities.VersionUtils.getVersionName

@HiltAndroidApp
class MainApplication : Application(), Application.ActivityLifecycleCallbacks {

    @Inject
    lateinit var databaseService: DatabaseService

    @Inject
    @AppPreferences
    lateinit var appPreferences: SharedPreferences

    @Inject
    @DefaultPreferences
    lateinit var defaultPreferences: SharedPreferences

    companion object {
        private const val AUTO_SYNC_WORK_TAG = "autoSyncWork"
        private const val STAY_ONLINE_WORK_TAG = "stayOnlineWork"
        private const val TASK_NOTIFICATION_WORK_TAG = "taskNotificationWork"
        lateinit var context: Context
        lateinit var service: DatabaseService
        var preferences: SharedPreferences? = null
        var syncFailedCount = 0
        var isCollectionSwitchOn = false
        var showDownload = false
        var isSyncRunning = false
        var listener: TeamPageListener? = null
        val androidId: String get() {
            try {
                return Settings.Secure.getString(context.contentResolver, Settings.Secure.ANDROID_ID)
            } catch (e: Exception) {
                e.printStackTrace()
            }
            return "0"
        }
        lateinit var applicationScope: CoroutineScope
        lateinit var defaultPref: SharedPreferences

        fun createLog(type: String, error: String = "") {
            applicationScope.launch {
                val entryPoint = EntryPointAccessors.fromApplication(
                    context,
                    WorkerDependenciesEntryPoint::class.java
                )
                val userProfileDbHandler = entryPoint.userProfileDbHandler()
                val settings = context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
                try {
                    service.executeTransactionAsync { r ->
                        val log = r.createObject(RealmApkLog::class.java, "${UUID.randomUUID()}")
                        val model = userProfileDbHandler.userModel
                        log.parentCode = settings.getString("parentCode", "")
                        log.createdOn = settings.getString("planetCode", "")
                        model?.let { log.userId = it.id }
                        log.time = "${Date().time}"
                        log.page = ""
                        log.version = getVersionName(context)
                        log.type = type
                        if (error.isNotEmpty()) {
                            log.error = error
                        }
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }

        private fun applyThemeMode(themeMode: String?) {
            when (themeMode) {
                ThemeMode.LIGHT -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)
                ThemeMode.DARK -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)
                ThemeMode.FOLLOW_SYSTEM -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM)
            }
        }

        suspend fun isServerReachable(urlString: String): Boolean {
            val serverUrlMapper = ServerUrlMapper()
            val mapping = serverUrlMapper.processUrl(urlString)
            val urlsToTry = mutableListOf(urlString)
            mapping.alternativeUrl?.let { urlsToTry.add(it) }

            return try {
                if (urlString.isBlank()) return false

                val formattedUrl = if (!urlString.startsWith("http://") && !urlString.startsWith("https://")) {
                    "http://$urlString"
                } else {
                    urlString
                }

                val url = URL(formattedUrl)
                val responseCode = withContext(Dispatchers.IO) {
                    val connection = url.openConnection() as HttpURLConnection
                    try {
                        connection.requestMethod = "GET"
                        connection.connectTimeout = 5000
                        connection.readTimeout = 5000
                        connection.connect()
                        connection.responseCode
                    } finally {
                        connection.disconnect()
                    }
                }
                responseCode in 200..299
            } catch (e: Exception) {
                e.printStackTrace()
                false
            }
        }

        fun handleUncaughtException(e: Throwable) {
            e.printStackTrace()
            createLog(RealmApkLog.ERROR_TYPE_CRASH, e.stackTraceToString())

            val homeIntent = Intent(Intent.ACTION_MAIN).apply {
                addCategory(Intent.CATEGORY_HOME)
                flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK
            }
            context.startActivity(homeIntent)
        }
    }

    private var activityReferences = 0
    private var isActivityChangingConfigurations = false
    private var isFirstLaunch = true
    private lateinit var anrWatchdog: ANRWatchdog

    override fun onCreate() {
        super.onCreate()
        setupCriticalProperties()
        initApp()
        ensureApiClientInitialized()
        setupStrictMode()
        registerExceptionHandler()
        setupLifecycleCallbacks()
        configureTheme()

        applicationScope.launch {
            initializeDatabaseConnection()
            setupAnrWatchdog()
            scheduleWorkersOnStart()
            observeNetworkForDownloads()
        }
    }

    private fun initApp() {
        context = this
        applicationScope.launch(Dispatchers.Default) {
            startListenNetworkState()
        }
    }

    private fun setupCriticalProperties() {
        preferences = appPreferences
        service = databaseService
        defaultPref = defaultPreferences
        applicationScope = EntryPointAccessors.fromApplication(
            this,
            ApplicationScopeEntryPoint::class.java
        ).applicationScope()
    }

    private fun ensureApiClientInitialized() {
        EntryPointAccessors.fromApplication(
            this,
            ApiClientEntryPoint::class.java
        ).apiClient()
    }

    private suspend fun initializeDatabaseConnection() {
        withContext(Dispatchers.IO) {
            service.withRealm { }
        }
    }

    private fun setupStrictMode() {
        if (BuildConfig.DEBUG) {
            val threadPolicy = StrictMode.ThreadPolicy.Builder()
                .detectDiskReads()
                .detectDiskWrites()
                .detectNetwork()
                .penaltyLog()
                .build()
            StrictMode.setThreadPolicy(threadPolicy)
        }
        val builder = VmPolicy.Builder()
        StrictMode.setVmPolicy(builder.build())
        builder.detectFileUriExposure()
    }

    private suspend fun setupAnrWatchdog() {
        withContext(Dispatchers.Default) {
            anrWatchdog = ANRWatchdog(timeout = 5000L, listener = object : ANRWatchdog.ANRListener {
                override fun onAppNotResponding(message: String, blockedThread: Thread, duration: Long) {
                    applicationScope.launch {
                        createLog("anr", "ANR detected! Duration: ${duration}ms\n $message")
                    }
                }
            })
            anrWatchdog.start()
        }
    }

    private suspend fun scheduleWorkersOnStart() {
        withContext(Dispatchers.Default) {
            if (preferences?.getBoolean("autoSync", false) == true && preferences?.contains("autoSyncInterval") == true) {
                val syncInterval = preferences?.getInt("autoSyncInterval", 60 * 60)
                scheduleAutoSyncWork(syncInterval)
            } else {
                cancelAutoSyncWork()
            }
            scheduleStayOnlineWork()
            scheduleTaskNotificationWork()
            startNetworkMonitoring()
        }
    }

    private fun registerExceptionHandler() {
        Thread.setDefaultUncaughtExceptionHandler { _: Thread?, e: Throwable ->
            handleUncaughtException(e)
        }
    }

    private fun setupLifecycleCallbacks() {
        registerActivityLifecycleCallbacks(this)
        onAppStarted()
    }

    private fun configureTheme() {
        val savedThemeMode = getCurrentThemeMode()
        applyThemeMode(savedThemeMode)
    }

    private suspend fun observeNetworkForDownloads() {
        withContext(Dispatchers.Default) {
            isNetworkConnectedFlow.onEach { isConnected ->
                if (isConnected) {
                    val serverUrl = preferences?.getString("serverURL", "")
                    if (!serverUrl.isNullOrEmpty()) {
                        applicationScope.launch {
                            val canReachServer = withContext(Dispatchers.IO) {
                                isServerReachable(serverUrl)
                            }
                            if (canReachServer && defaultPref.getBoolean("beta_auto_download", false)) {
                                service.withRealm { realm ->
                                    backgroundDownload(
                                        downloadAllFiles(getAllLibraryList(realm)),
                                        applicationContext
                                    )
                                }
                            }
                        }
                    }
                }
            }.launchIn(applicationScope)
        }
    }

    private fun scheduleAutoSyncWork(syncInterval: Int?) {
        val autoSyncWork: PeriodicWorkRequest? = syncInterval?.let { PeriodicWorkRequest.Builder(AutoSyncWorker::class.java, it.toLong(), TimeUnit.SECONDS).build() }
        val workManager = WorkManager.getInstance(this)
        if (autoSyncWork != null) {
            workManager.enqueueUniquePeriodicWork(AUTO_SYNC_WORK_TAG, ExistingPeriodicWorkPolicy.UPDATE, autoSyncWork)
        }
    }

    private fun cancelAutoSyncWork() {
        val workManager = WorkManager.getInstance(this)
        workManager.cancelUniqueWork(AUTO_SYNC_WORK_TAG)
    }

    private fun scheduleStayOnlineWork() {
        val stayOnlineWork: PeriodicWorkRequest = PeriodicWorkRequest.Builder(StayOnlineWorker::class.java, 900, TimeUnit.SECONDS).build()
        val workManager = WorkManager.getInstance(this)
        workManager.enqueueUniquePeriodicWork(STAY_ONLINE_WORK_TAG, ExistingPeriodicWorkPolicy.UPDATE, stayOnlineWork)
    }

    private fun scheduleTaskNotificationWork() {
        val taskNotificationWork: PeriodicWorkRequest = PeriodicWorkRequest.Builder(TaskNotificationWorker::class.java, 900, TimeUnit.SECONDS).build()
        val workManager = WorkManager.getInstance(this)
        workManager.enqueueUniquePeriodicWork(TASK_NOTIFICATION_WORK_TAG, ExistingPeriodicWorkPolicy.UPDATE, taskNotificationWork)
    }

    private fun startNetworkMonitoring() {
        NetworkMonitorWorker.start(this)
    }

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(base))
    }

    override fun onConfigurationChanged(newConfig: Configuration) {
        super.onConfigurationChanged(newConfig)

        if (getCurrentThemeMode() != ThemeMode.FOLLOW_SYSTEM) return

        val isNightMode = (newConfig.uiMode and Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES
        val themeToApply = if (isNightMode) ThemeMode.DARK else ThemeMode.LIGHT

        applyThemeMode(themeToApply)
    }

    private fun getCurrentThemeMode(): String {
        val sharedPreferences = context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        return sharedPreferences.getString("theme_mode", ThemeMode.FOLLOW_SYSTEM) ?: ThemeMode.FOLLOW_SYSTEM
    }

    override fun onActivityCreated(activity: Activity, bundle: Bundle?) {}

    override fun onActivityStarted(activity: Activity) {
        if (++activityReferences == 1 && !isActivityChangingConfigurations) {
            onAppForegrounded()
        }
    }

    override fun onActivityResumed(activity: Activity) {}

    override fun onActivityPaused(activity: Activity) {}

    override fun onActivityStopped(activity: Activity) {
        isActivityChangingConfigurations = activity.isChangingConfigurations
        --activityReferences
    }

    override fun onActivitySaveInstanceState(activity: Activity, bundle: Bundle) {}

    override fun onActivityDestroyed(activity: Activity) {}

    private fun onAppForegrounded() {
        if (isFirstLaunch) {
            isFirstLaunch = false
        } else {
            applicationScope.launch {
                createLog("foreground", "")
            }
        }
    }

    private fun onAppStarted() {
        applicationScope.launch {
            createLog("new login", "")
        }
    }

    override fun onTerminate() {
        if (::anrWatchdog.isInitialized) {
            anrWatchdog.stop()
        }
        super.onTerminate()
        stopListenNetworkState()
    }
}
=======
package org.ole.planet.myplanet


import android.app.Activity
import android.app.Application
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.content.res.Configuration
import android.os.Bundle
import android.os.StrictMode
import android.os.StrictMode.VmPolicy
import android.provider.Settings
import androidx.appcompat.app.AppCompatDelegate
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.PeriodicWorkRequest
import androidx.work.WorkManager
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.android.HiltAndroidApp
import java.net.HttpURLConnection
import java.net.URL
import java.util.Date
import java.util.UUID
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.backgroundDownload
import org.ole.planet.myplanet.base.BaseResourceFragment.Companion.getAllLibraryList
import org.ole.planet.myplanet.callback.TeamPageListener
import org.ole.planet.myplanet.datamanager.DatabaseService
import org.ole.planet.myplanet.di.ApiClientEntryPoint
import org.ole.planet.myplanet.di.AppPreferences
import org.ole.planet.myplanet.di.ApplicationScopeEntryPoint
import org.ole.planet.myplanet.di.DefaultPreferences
import org.ole.planet.myplanet.di.WorkerDependenciesEntryPoint
import org.ole.planet.myplanet.model.RealmApkLog
import org.ole.planet.myplanet.service.AutoSyncWorker
import org.ole.planet.myplanet.service.NetworkMonitorWorker
import org.ole.planet.myplanet.service.StayOnlineWorker
import org.ole.planet.myplanet.service.TaskNotificationWorker
import org.ole.planet.myplanet.utilities.ANRWatchdog
import org.ole.planet.myplanet.utilities.Constants.PREFS_NAME
import org.ole.planet.myplanet.utilities.DownloadUtils.downloadAllFiles
import org.ole.planet.myplanet.utilities.LocaleHelper
import org.ole.planet.myplanet.utilities.NetworkUtils.isNetworkConnectedFlow
import org.ole.planet.myplanet.utilities.NetworkUtils.startListenNetworkState
import org.ole.planet.myplanet.utilities.NetworkUtils.stopListenNetworkState
import org.ole.planet.myplanet.utilities.ServerUrlMapper
import org.ole.planet.myplanet.utilities.ThemeMode
import org.ole.planet.myplanet.utilities.VersionUtils.getVersionName

@HiltAndroidApp
class MainApplication : Application(), Application.ActivityLifecycleCallbacks {

    @Inject
    lateinit var databaseService: DatabaseService

    @Inject
    @AppPreferences
    lateinit var appPreferences: SharedPreferences

    @Inject
    @DefaultPreferences
    lateinit var defaultPreferences: SharedPreferences

    companion object {
        private const val AUTO_SYNC_WORK_TAG = "autoSyncWork"
        private const val STAY_ONLINE_WORK_TAG = "stayOnlineWork"
        private const val TASK_NOTIFICATION_WORK_TAG = "taskNotificationWork"
        lateinit var context: Context
        lateinit var service: DatabaseService
        var preferences: SharedPreferences? = null
        var syncFailedCount = 0
        var isCollectionSwitchOn = false
        var showDownload = false
        var isSyncRunning = false
        var listener: TeamPageListener? = null
        val androidId: String get() {
            try {
                return Settings.Secure.getString(context.contentResolver, Settings.Secure.ANDROID_ID)
            } catch (e: Exception) {
                e.printStackTrace()
            }
            return "0"
        }
        lateinit var applicationScope: CoroutineScope
        lateinit var defaultPref: SharedPreferences

        fun createLog(type: String, error: String = "") {
            applicationScope.launch {
                val entryPoint = EntryPointAccessors.fromApplication(
                    context,
                    WorkerDependenciesEntryPoint::class.java
                )
                val userProfileDbHandler = entryPoint.userProfileDbHandler()
                val settings = context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
                try {
                    service.executeTransactionAsync { r ->
                        val log = r.createObject(RealmApkLog::class.java, "${UUID.randomUUID()}")
                        val model = userProfileDbHandler.userModel
                        log.parentCode = settings.getString("parentCode", "")
                        log.createdOn = settings.getString("planetCode", "")
                        model?.let { log.userId = it.id }
                        log.time = "${Date().time}"
                        log.page = ""
                        log.version = getVersionName(context)
                        log.type = type
                        if (error.isNotEmpty()) {
                            log.error = error
                        }
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }

        private fun applyThemeMode(themeMode: String?) {
            when (themeMode) {
                ThemeMode.LIGHT -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)
                ThemeMode.DARK -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)
                ThemeMode.FOLLOW_SYSTEM -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM)
            }
        }

        suspend fun isServerReachable(urlString: String): Boolean {
            val serverUrlMapper = ServerUrlMapper()
            val mapping = serverUrlMapper.processUrl(urlString)
            val urlsToTry = mutableListOf(urlString)
            mapping.alternativeUrl?.let { urlsToTry.add(it) }

            return try {
                if (urlString.isBlank()) return false

                val formattedUrl = if (!urlString.startsWith("http://") && !urlString.startsWith("https://")) {
                    "http://$urlString"
                } else {
                    urlString
                }

                val url = URL(formattedUrl)
                val responseCode = withContext(Dispatchers.IO) {
                    val connection = url.openConnection() as HttpURLConnection
                    try {
                        connection.requestMethod = "GET"
                        connection.connectTimeout = 5000
                        connection.readTimeout = 5000
                        connection.connect()
                        connection.responseCode
                    } finally {
                        connection.disconnect()
                    }
                }
                responseCode in 200..299
            } catch (e: Exception) {
                e.printStackTrace()
                false
            }
        }

        fun handleUncaughtException(e: Throwable) {
            e.printStackTrace()
            createLog(RealmApkLog.ERROR_TYPE_CRASH, e.stackTraceToString())

            val homeIntent = Intent(Intent.ACTION_MAIN).apply {
                addCategory(Intent.CATEGORY_HOME)
                flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK
            }
            context.startActivity(homeIntent)
        }
    }

    private var activityReferences = 0
    private var isActivityChangingConfigurations = false
    private var isFirstLaunch = true
    private lateinit var anrWatchdog: ANRWatchdog

    override fun onCreate() {
        super.onCreate()
        setupCriticalProperties()
        initApp()
        ensureApiClientInitialized()
        setupStrictMode()
        registerExceptionHandler()
        setupLifecycleCallbacks()
        configureTheme()

        applicationScope.launch {
            initializeDatabaseConnection()
            setupAnrWatchdog()
            scheduleWorkersOnStart()
            observeNetworkForDownloads()
        }
    }

    private fun initApp() {
        context = this
        applicationScope.launch(Dispatchers.Default) {
            startListenNetworkState()
        }
    }

    private fun setupCriticalProperties() {
        preferences = appPreferences
        service = databaseService
        defaultPref = defaultPreferences
        applicationScope = EntryPointAccessors.fromApplication(
            this,
            ApplicationScopeEntryPoint::class.java
        ).applicationScope()
    }

    private fun ensureApiClientInitialized() {
        EntryPointAccessors.fromApplication(
            this,
            ApiClientEntryPoint::class.java
        ).apiClient()
    }

    private suspend fun initializeDatabaseConnection() {
        withContext(Dispatchers.IO) {
            service.withRealm { }
        }
    }

    private fun setupStrictMode() {
        if (BuildConfig.DEBUG) {
            val threadPolicy = StrictMode.ThreadPolicy.Builder()
                .detectDiskReads()
                .detectDiskWrites()
                .detectNetwork()
                .penaltyLog()
                .build()
            StrictMode.setThreadPolicy(threadPolicy)
        }
        val builder = VmPolicy.Builder()
        StrictMode.setVmPolicy(builder.build())
        builder.detectFileUriExposure()
    }

    private suspend fun setupAnrWatchdog() {
        withContext(Dispatchers.Default) {
            anrWatchdog = ANRWatchdog(timeout = 5000L, listener = object : ANRWatchdog.ANRListener {
                override fun onAppNotResponding(message: String, blockedThread: Thread, duration: Long) {
                    applicationScope.launch {
                        createLog("anr", "ANR detected! Duration: ${duration}ms\n $message")
                    }
                }
            })
            anrWatchdog.start()
        }
    }

    private suspend fun scheduleWorkersOnStart() {
        withContext(Dispatchers.Default) {
            if (preferences?.getBoolean("autoSync", false) == true && preferences?.contains("autoSyncInterval") == true) {
                val syncInterval = preferences?.getInt("autoSyncInterval", 60 * 60)
                scheduleAutoSyncWork(syncInterval)
            } else {
                cancelAutoSyncWork()
            }
            scheduleStayOnlineWork()
            scheduleTaskNotificationWork()
            startNetworkMonitoring()
        }
    }

    private fun registerExceptionHandler() {
        Thread.setDefaultUncaughtExceptionHandler { _: Thread?, e: Throwable ->
            handleUncaughtException(e)
        }
    }

    private fun setupLifecycleCallbacks() {
        registerActivityLifecycleCallbacks(this)
        onAppStarted()
    }

    private fun configureTheme() {
        val savedThemeMode = getCurrentThemeMode()
        applyThemeMode(savedThemeMode)
    }

    private suspend fun observeNetworkForDownloads() {
        withContext(Dispatchers.Default) {
            isNetworkConnectedFlow.onEach { isConnected ->
                if (isConnected) {
                    val serverUrl = preferences?.getString("serverURL", "")
                    if (!serverUrl.isNullOrEmpty()) {
                        applicationScope.launch {
                            val canReachServer = withContext(Dispatchers.IO) {
                                isServerReachable(serverUrl)
                            }
                            if (canReachServer && defaultPref.getBoolean("beta_auto_download", false)) {
                                service.withRealm { realm ->
                                    backgroundDownload(
                                        downloadAllFiles(getAllLibraryList(realm)),
                                        applicationContext
                                    )
                                }
                            }
                        }
                    }
                }
            }.launchIn(applicationScope)
        }
    }

    private fun scheduleAutoSyncWork(syncInterval: Int?) {
        val autoSyncWork: PeriodicWorkRequest? = syncInterval?.let { PeriodicWorkRequest.Builder(AutoSyncWorker::class.java, it.toLong(), TimeUnit.SECONDS).build() }
        val workManager = WorkManager.getInstance(this)
        if (autoSyncWork != null) {
            workManager.enqueueUniquePeriodicWork(AUTO_SYNC_WORK_TAG, ExistingPeriodicWorkPolicy.UPDATE, autoSyncWork)
        }
    }

    private fun cancelAutoSyncWork() {
        val workManager = WorkManager.getInstance(this)
        workManager.cancelUniqueWork(AUTO_SYNC_WORK_TAG)
    }

    private fun scheduleStayOnlineWork() {
        val stayOnlineWork: PeriodicWorkRequest = PeriodicWorkRequest.Builder(StayOnlineWorker::class.java, 900, TimeUnit.SECONDS).build()
        val workManager = WorkManager.getInstance(this)
        workManager.enqueueUniquePeriodicWork(STAY_ONLINE_WORK_TAG, ExistingPeriodicWorkPolicy.UPDATE, stayOnlineWork)
    }

    private fun scheduleTaskNotificationWork() {
        val taskNotificationWork: PeriodicWorkRequest = PeriodicWorkRequest.Builder(TaskNotificationWorker::class.java, 900, TimeUnit.SECONDS).build()
        val workManager = WorkManager.getInstance(this)
        workManager.enqueueUniquePeriodicWork(TASK_NOTIFICATION_WORK_TAG, ExistingPeriodicWorkPolicy.UPDATE, taskNotificationWork)
    }

    private fun startNetworkMonitoring() {
        NetworkMonitorWorker.start(this)
    }

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(LocaleHelper.onAttach(base))
    }

    override fun onConfigurationChanged(newConfig: Configuration) {
        super.onConfigurationChanged(newConfig)

        if (getCurrentThemeMode() != ThemeMode.FOLLOW_SYSTEM) return

        val isNightMode = (newConfig.uiMode and Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES
        val themeToApply = if (isNightMode) ThemeMode.DARK else ThemeMode.LIGHT

        applyThemeMode(themeToApply)
    }

    private fun getCurrentThemeMode(): String {
        val sharedPreferences = context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE)
        return sharedPreferences.getString("theme_mode", ThemeMode.FOLLOW_SYSTEM) ?: ThemeMode.FOLLOW_SYSTEM
    }

    override fun onActivityCreated(activity: Activity, bundle: Bundle?) {}

    override fun onActivityStarted(activity: Activity) {
        if (++activityReferences == 1 && !isActivityChangingConfigurations) {
            onAppForegrounded()
        }
    }

    override fun onActivityResumed(activity: Activity) {}

    override fun onActivityPaused(activity: Activity) {}

    override fun onActivityStopped(activity: Activity) {
        isActivityChangingConfigurations = activity.isChangingConfigurations
        --activityReferences
    }

    override fun onActivitySaveInstanceState(activity: Activity, bundle: Bundle) {}

    override fun onActivityDestroyed(activity: Activity) {}

    private fun onAppForegrounded() {
        if (isFirstLaunch) {
            isFirstLaunch = false
        } else {
            applicationScope.launch {
                createLog("foreground", "")
            }
        }
    }

    private fun onAppStarted() {
        applicationScope.launch {
            createLog("new login", "")
        }
    }

    override fun onTerminate() {
        if (::anrWatchdog.isInitialized) {
            anrWatchdog.stop()
        }
        super.onTerminate()
        stopListenNetworkState()
    }
}
>>>>>>> REPLACE
